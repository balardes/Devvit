/**
 * #datetime.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../typeRegistry.js';
import { Duration } from '../protobuf/duration.js';
function createBaseDateTime() {
    return {
        year: 0,
        month: 0,
        day: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        nanos: 0,
        utcOffset: undefined,
        timeZone: undefined,
    };
}
export const DateTime = {
    $type: "google.type.DateTime",
    encode(message, writer = _m0.Writer.create()) {
        if (message.year !== 0) {
            writer.uint32(8).int32(message.year);
        }
        if (message.month !== 0) {
            writer.uint32(16).int32(message.month);
        }
        if (message.day !== 0) {
            writer.uint32(24).int32(message.day);
        }
        if (message.hours !== 0) {
            writer.uint32(32).int32(message.hours);
        }
        if (message.minutes !== 0) {
            writer.uint32(40).int32(message.minutes);
        }
        if (message.seconds !== 0) {
            writer.uint32(48).int32(message.seconds);
        }
        if (message.nanos !== 0) {
            writer.uint32(56).int32(message.nanos);
        }
        if (message.utcOffset !== undefined) {
            Duration.encode(message.utcOffset, writer.uint32(66).fork()).ldelim();
        }
        if (message.timeZone !== undefined) {
            TimeZone.encode(message.timeZone, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDateTime();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.year = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.month = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.day = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.hours = reader.int32();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.minutes = reader.int32();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.seconds = reader.int32();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.nanos = reader.int32();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.utcOffset = Duration.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.timeZone = TimeZone.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            year: isSet(object.year) ? globalThis.Number(object.year) : 0,
            month: isSet(object.month) ? globalThis.Number(object.month) : 0,
            day: isSet(object.day) ? globalThis.Number(object.day) : 0,
            hours: isSet(object.hours) ? globalThis.Number(object.hours) : 0,
            minutes: isSet(object.minutes) ? globalThis.Number(object.minutes) : 0,
            seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
            nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
            utcOffset: isSet(object.utcOffset) ? Duration.fromJSON(object.utcOffset) : undefined,
            timeZone: isSet(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.year !== 0) {
            obj.year = Math.round(message.year);
        }
        if (message.month !== 0) {
            obj.month = Math.round(message.month);
        }
        if (message.day !== 0) {
            obj.day = Math.round(message.day);
        }
        if (message.hours !== 0) {
            obj.hours = Math.round(message.hours);
        }
        if (message.minutes !== 0) {
            obj.minutes = Math.round(message.minutes);
        }
        if (message.seconds !== 0) {
            obj.seconds = Math.round(message.seconds);
        }
        if (message.nanos !== 0) {
            obj.nanos = Math.round(message.nanos);
        }
        if (message.utcOffset !== undefined) {
            obj.utcOffset = Duration.toJSON(message.utcOffset);
        }
        if (message.timeZone !== undefined) {
            obj.timeZone = TimeZone.toJSON(message.timeZone);
        }
        return obj;
    },
    create(base) {
        return DateTime.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDateTime();
        message.year = object.year ?? 0;
        message.month = object.month ?? 0;
        message.day = object.day ?? 0;
        message.hours = object.hours ?? 0;
        message.minutes = object.minutes ?? 0;
        message.seconds = object.seconds ?? 0;
        message.nanos = object.nanos ?? 0;
        message.utcOffset = (object.utcOffset !== undefined && object.utcOffset !== null)
            ? Duration.fromPartial(object.utcOffset)
            : undefined;
        message.timeZone = (object.timeZone !== undefined && object.timeZone !== null)
            ? TimeZone.fromPartial(object.timeZone)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(DateTime.$type, DateTime);
function createBaseTimeZone() {
    return { id: "", version: "" };
}
export const TimeZone = {
    $type: "google.type.TimeZone",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimeZone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        return obj;
    },
    create(base) {
        return TimeZone.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTimeZone();
        message.id = object.id ?? "";
        message.version = object.version ?? "";
        return message;
    },
};
messageTypeRegistry.set(TimeZone.$type, TimeZone);
function isSet(value) {
    return value !== null && value !== undefined;
}
