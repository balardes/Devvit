/**
 * #step.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Comment } from '../../../reddit/comment.js';
import { Post } from '../../../reddit/post.js';
import { User } from '../../../reddit/user.js';
function createBaseStepDescription() {
    return { actor: "", config: undefined };
}
export const StepDescription = {
    $type: "devvit.actor.automation.v1alpha.StepDescription",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        if (message.config !== undefined) {
            Struct.encode(Struct.wrap(message.config), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.actor = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? globalThis.String(object.actor) : "",
            config: isObject(object.config) ? object.config : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actor !== "") {
            obj.actor = message.actor;
        }
        if (message.config !== undefined) {
            obj.config = message.config;
        }
        return obj;
    },
    create(base) {
        return StepDescription.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepDescription();
        message.actor = object.actor ?? "";
        message.config = object.config ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(StepDescription.$type, StepDescription);
function createBaseStepInput() {
    return { config: undefined, prev: undefined };
}
export const StepInput = {
    $type: "devvit.actor.automation.v1alpha.StepInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.config !== undefined) {
            Struct.encode(Struct.wrap(message.config), writer.uint32(10).fork()).ldelim();
        }
        if (message.prev !== undefined) {
            Struct.encode(Struct.wrap(message.prev), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.prev = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            config: isObject(object.config) ? object.config : undefined,
            prev: isObject(object.prev) ? object.prev : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.config !== undefined) {
            obj.config = message.config;
        }
        if (message.prev !== undefined) {
            obj.prev = message.prev;
        }
        return obj;
    },
    create(base) {
        return StepInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepInput();
        message.config = object.config ?? undefined;
        message.prev = object.prev ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(StepInput.$type, StepInput);
function createBaseStepCommentInput() {
    return { input: undefined, comment: undefined };
}
export const StepCommentInput = {
    $type: "devvit.actor.automation.v1alpha.StepCommentInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.input !== undefined) {
            StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
        }
        if (message.comment !== undefined) {
            Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepCommentInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.input = StepInput.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.comment = Comment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            input: isSet(object.input) ? StepInput.fromJSON(object.input) : undefined,
            comment: isSet(object.comment) ? Comment.fromJSON(object.comment) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.input !== undefined) {
            obj.input = StepInput.toJSON(message.input);
        }
        if (message.comment !== undefined) {
            obj.comment = Comment.toJSON(message.comment);
        }
        return obj;
    },
    create(base) {
        return StepCommentInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepCommentInput();
        message.input = (object.input !== undefined && object.input !== null)
            ? StepInput.fromPartial(object.input)
            : undefined;
        message.comment = (object.comment !== undefined && object.comment !== null)
            ? Comment.fromPartial(object.comment)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(StepCommentInput.$type, StepCommentInput);
function createBaseStepPostInput() {
    return { input: undefined, post: undefined };
}
export const StepPostInput = {
    $type: "devvit.actor.automation.v1alpha.StepPostInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.input !== undefined) {
            StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
        }
        if (message.post !== undefined) {
            Post.encode(message.post, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepPostInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.input = StepInput.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.post = Post.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            input: isSet(object.input) ? StepInput.fromJSON(object.input) : undefined,
            post: isSet(object.post) ? Post.fromJSON(object.post) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.input !== undefined) {
            obj.input = StepInput.toJSON(message.input);
        }
        if (message.post !== undefined) {
            obj.post = Post.toJSON(message.post);
        }
        return obj;
    },
    create(base) {
        return StepPostInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepPostInput();
        message.input = (object.input !== undefined && object.input !== null)
            ? StepInput.fromPartial(object.input)
            : undefined;
        message.post = (object.post !== undefined && object.post !== null) ? Post.fromPartial(object.post) : undefined;
        return message;
    },
};
messageTypeRegistry.set(StepPostInput.$type, StepPostInput);
function createBaseStepUserInput() {
    return { input: undefined, user: undefined };
}
export const StepUserInput = {
    $type: "devvit.actor.automation.v1alpha.StepUserInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.input !== undefined) {
            StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
        }
        if (message.user !== undefined) {
            User.encode(message.user, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepUserInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.input = StepInput.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.user = User.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            input: isSet(object.input) ? StepInput.fromJSON(object.input) : undefined,
            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.input !== undefined) {
            obj.input = StepInput.toJSON(message.input);
        }
        if (message.user !== undefined) {
            obj.user = User.toJSON(message.user);
        }
        return obj;
    },
    create(base) {
        return StepUserInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepUserInput();
        message.input = (object.input !== undefined && object.input !== null)
            ? StepInput.fromPartial(object.input)
            : undefined;
        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
        return message;
    },
};
messageTypeRegistry.set(StepUserInput.$type, StepUserInput);
function createBaseStepResult() {
    return { output: undefined, stop: false };
}
export const StepResult = {
    $type: "devvit.actor.automation.v1alpha.StepResult",
    encode(message, writer = _m0.Writer.create()) {
        if (message.output !== undefined) {
            Struct.encode(Struct.wrap(message.output), writer.uint32(10).fork()).ldelim();
        }
        if (message.stop !== false) {
            writer.uint32(16).bool(message.stop);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.output = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.stop = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            output: isObject(object.output) ? object.output : undefined,
            stop: isSet(object.stop) ? globalThis.Boolean(object.stop) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.output !== undefined) {
            obj.output = message.output;
        }
        if (message.stop !== false) {
            obj.stop = message.stop;
        }
        return obj;
    },
    create(base) {
        return StepResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepResult();
        message.output = object.output ?? undefined;
        message.stop = object.stop ?? false;
        return message;
    },
};
messageTypeRegistry.set(StepResult.$type, StepResult);
function createBaseStepReport() {
    return { actor: "", message: "", duration: 0, success: false, data: undefined };
}
export const StepReport = {
    $type: "devvit.actor.automation.v1alpha.StepReport",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.duration !== 0) {
            writer.uint32(29).float(message.duration);
        }
        if (message.success !== false) {
            writer.uint32(32).bool(message.success);
        }
        if (message.data !== undefined) {
            StepResult.encode(message.data, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepReport();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.actor = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.duration = reader.float();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.data = StepResult.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? globalThis.String(object.actor) : "",
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            data: isSet(object.data) ? StepResult.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actor !== "") {
            obj.actor = message.actor;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.duration !== 0) {
            obj.duration = message.duration;
        }
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.data !== undefined) {
            obj.data = StepResult.toJSON(message.data);
        }
        return obj;
    },
    create(base) {
        return StepReport.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepReport();
        message.actor = object.actor ?? "";
        message.message = object.message ?? "";
        message.duration = object.duration ?? 0;
        message.success = object.success ?? false;
        message.data = (object.data !== undefined && object.data !== null)
            ? StepResult.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(StepReport.$type, StepReport);
export const CommentStepServiceName = "devvit.actor.automation.v1alpha.CommentStep";
export class CommentStepClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || CommentStepServiceName;
        this.rpc = rpc;
        this.Invoke = this.Invoke.bind(this);
    }
    Invoke(request, metadata) {
        const data = StepCommentInput.encode(request).finish();
        const promise = this.rpc.request(this.service, "Invoke", data, metadata);
        return promise.then((data) => StepResult.decode(_m0.Reader.create(data)));
    }
}
export const CommentStepDefinition = {
    name: "CommentStep",
    fullName: "devvit.actor.automation.v1alpha.CommentStep",
    methods: {
        invoke: {
            name: "Invoke",
            requestType: StepCommentInput,
            requestStream: false,
            responseType: StepResult,
            responseStream: false,
            options: {},
        },
    },
};
export const PostStepServiceName = "devvit.actor.automation.v1alpha.PostStep";
export class PostStepClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || PostStepServiceName;
        this.rpc = rpc;
        this.Invoke = this.Invoke.bind(this);
    }
    Invoke(request, metadata) {
        const data = StepPostInput.encode(request).finish();
        const promise = this.rpc.request(this.service, "Invoke", data, metadata);
        return promise.then((data) => StepResult.decode(_m0.Reader.create(data)));
    }
}
export const PostStepDefinition = {
    name: "PostStep",
    fullName: "devvit.actor.automation.v1alpha.PostStep",
    methods: {
        invoke: {
            name: "Invoke",
            requestType: StepPostInput,
            requestStream: false,
            responseType: StepResult,
            responseStream: false,
            options: {},
        },
    },
};
export const UserStepServiceName = "devvit.actor.automation.v1alpha.UserStep";
export class UserStepClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || UserStepServiceName;
        this.rpc = rpc;
        this.Invoke = this.Invoke.bind(this);
    }
    Invoke(request, metadata) {
        const data = StepUserInput.encode(request).finish();
        const promise = this.rpc.request(this.service, "Invoke", data, metadata);
        return promise.then((data) => StepResult.decode(_m0.Reader.create(data)));
    }
}
export const UserStepDefinition = {
    name: "UserStep",
    fullName: "devvit.actor.automation.v1alpha.UserStep",
    methods: {
        invoke: {
            name: "Invoke",
            requestType: StepUserInput,
            requestStream: false,
            responseType: StepResult,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
