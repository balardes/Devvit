/**
 * #automation.ts
 *
 * @packageDocumentation
 */
import _m0 from 'protobufjs/minimal.js';
import { Metadata } from "../../../../../lib/Types.js";
import { Comment } from '../../../reddit/comment.js';
import { Post } from '../../../reddit/post.js';
import { Subreddit } from '../../../reddit/subreddit.js';
import { User } from '../../../reddit/user.js';
import { StepDescription, StepReport } from './step.js';
import { Trigger } from './trigger.js';
/** The status of an automation */
export declare enum AutomationStatus {
    /** INSTALLED - Installed, but not actively executing on a trigger */
    INSTALLED = 0,
    /** ENABLED - Installed and executing on a trigger */
    ENABLED = 1,
    /** DISABLED - Disabled by admins, does not run and cannot be re-enabled without admin approval. This is used if an automation is causing problems or is in violation of our policies. */
    DISABLED = 2,
    UNRECOGNIZED = -1
}
export declare function automationStatusFromJSON(object: any): AutomationStatus;
export declare function automationStatusToJSON(object: AutomationStatus): number;
/** Whether or not automation is sharable */
export declare enum AutomationVisibility {
    /** PRIVATE - Only visible to mods of the installed subreddit */
    PRIVATE = 0,
    /** PUBLIC - Published for sharing */
    PUBLIC = 1,
    UNRECOGNIZED = -1
}
export declare function automationVisibilityFromJSON(object: any): AutomationVisibility;
export declare function automationVisibilityToJSON(object: AutomationVisibility): number;
/** A series of actions to invoke upon a trigger */
export interface Automation {
    /** uuid of the automation, this will only be set when registered, when sharing this will be empty */
    id: string;
    /** Human readable name that will show up on the automation list */
    name: string;
    /** A quick description of the automation. This shows up in the automation list */
    description: string;
    /** If the automation is currently enabled or not. This will be empty during sharing */
    status: AutomationStatus;
    /** A flag for tracking if the automation is sharable */
    visibility: AutomationVisibility;
    /** The trigger that kicks off this automation */
    trigger?: Trigger | undefined;
    /** A list of steps to execute in order */
    steps: StepDescription[];
}
/** The results on an automation run */
export interface AutomationResult {
    /** Id that came from the AutomationInvocation */
    id: string;
    /** Reports from each actor that was invoked */
    steps: StepReport[];
}
/** An invocation of an automation */
export interface AutomationInvocation {
    /** Uuid for this automation run */
    id: string;
    /** Automation object */
    automation?: Automation | undefined;
    comment?: Comment | undefined;
    post?: Post | undefined;
    user?: User | undefined;
    subreddit?: Subreddit | undefined;
}
export declare const Automation: {
    $type: "devvit.actor.automation.v1alpha.Automation";
    encode(message: Automation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Automation;
    fromJSON(object: any): Automation;
    toJSON(message: Automation): unknown;
    create(base?: DeepPartial<Automation>): Automation;
    fromPartial(object: DeepPartial<Automation>): Automation;
};
export declare const AutomationResult: {
    $type: "devvit.actor.automation.v1alpha.AutomationResult";
    encode(message: AutomationResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AutomationResult;
    fromJSON(object: any): AutomationResult;
    toJSON(message: AutomationResult): unknown;
    create(base?: DeepPartial<AutomationResult>): AutomationResult;
    fromPartial(object: DeepPartial<AutomationResult>): AutomationResult;
};
export declare const AutomationInvocation: {
    $type: "devvit.actor.automation.v1alpha.AutomationInvocation";
    encode(message: AutomationInvocation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AutomationInvocation;
    fromJSON(object: any): AutomationInvocation;
    toJSON(message: AutomationInvocation): unknown;
    create(base?: DeepPartial<AutomationInvocation>): AutomationInvocation;
    fromPartial(object: DeepPartial<AutomationInvocation>): AutomationInvocation;
};
/** An actor type for the workflow engine itself. */
export interface AutomationEngine {
    /** Evaluates a workflow by invoking defined actor steps and gathering results */
    Evaluate(request: AutomationInvocation, metadata?: Metadata): Promise<AutomationResult>;
}
export declare const AutomationEngineServiceName = "devvit.actor.automation.v1alpha.AutomationEngine";
export declare class AutomationEngineClientImpl implements AutomationEngine {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Evaluate(request: AutomationInvocation, metadata?: Metadata): Promise<AutomationResult>;
}
/** An actor type for the workflow engine itself. */
export type AutomationEngineDefinition = typeof AutomationEngineDefinition;
export declare const AutomationEngineDefinition: {
    readonly name: "AutomationEngine";
    readonly fullName: "devvit.actor.automation.v1alpha.AutomationEngine";
    readonly methods: {
        /** Evaluates a workflow by invoking defined actor steps and gathering results */
        readonly evaluate: {
            readonly name: "Evaluate";
            readonly requestType: {
                $type: "devvit.actor.automation.v1alpha.AutomationInvocation";
                encode(message: AutomationInvocation, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AutomationInvocation;
                fromJSON(object: any): AutomationInvocation;
                toJSON(message: AutomationInvocation): unknown;
                create(base?: DeepPartial<AutomationInvocation>): AutomationInvocation;
                fromPartial(object: DeepPartial<AutomationInvocation>): AutomationInvocation;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.AutomationResult";
                encode(message: AutomationResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AutomationResult;
                fromJSON(object: any): AutomationResult;
                toJSON(message: AutomationResult): unknown;
                create(base?: DeepPartial<AutomationResult>): AutomationResult;
                fromPartial(object: DeepPartial<AutomationResult>): AutomationResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
interface Rpc {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=automation.d.ts.map