/**
 * #send_event.ts
 *
 * @packageDocumentation
 */
import _m0 from 'protobufjs/minimal.js';
import { UIEvent } from '../../events/v1alpha/event.js';
/**
 * This is a low level effect that allows the client or server to send events
 * directly, typically to the other runtime.  It's not intended to be used by
 * app code directly, but rather by hooks that start to bring concurrency features
 * into the platform.
 *
 * An example might be a useFetchHook.  An app developer would use the hook to
 * fetch a remote api, making the request from the server runtime, but without
 * blocking the client runtime.  The lifecycle would be something like:
 *
 *    const {data, loading, error} = useFetch("https://api.example.com");
 *
 * The useFetch hook on the client runtime would emit a
 * SendEventEffect(AsyncRequest({id: "hook-id-xyz"})).  When this event hits the client
 * runtime, it would instantly circuit-break, causing the runtime to send the event to the
 * server runtime.  The server runtime would then look up the hook by id, actually make the
 * request, and then emit a SendEventEffect(AsyncResponse(id: "hook-id-xyz", data: "..."), Target.CLIENT)
 * which would get routed back into the client.
 *
 * This request lifecycle would be orthogonal to the normal event lifecycle, and therefore you
 * couldn't/wouldn't do any setStates inside of the hook.  But the benefit would be that
 * there would be no state conflicts, so the async request/response could be handled concurrently.
 */
export interface SendEventEffect {
    event?: UIEvent | undefined;
    /**
     * If true, the event will be sent to the front of the queue.  The reason to do this is
     * for event replay in e.g. circuit breaking.
     */
    jumpsQueue?: boolean | undefined;
}
export declare const SendEventEffect: {
    $type: "devvit.ui.effects.v1alpha.SendEventEffect";
    encode(message: SendEventEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SendEventEffect;
    fromJSON(object: any): SendEventEffect;
    toJSON(message: SendEventEffect): unknown;
    create(base?: DeepPartial<SendEventEffect>): SendEventEffect;
    fromPartial(object: DeepPartial<SendEventEffect>): SendEventEffect;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=send_event.d.ts.map