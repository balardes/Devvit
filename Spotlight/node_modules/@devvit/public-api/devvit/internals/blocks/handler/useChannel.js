var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChannelHook_context, _ChannelHook_invalidate, _ChannelHook_opts;
import { RealtimeSubscriptionStatus } from '@devvit/protos';
import { Header } from '@devvit/shared-types/Header.js';
import { ChannelStatus } from '../../../../types/realtime.js';
import { registerHook } from './BlocksHandler.js';
class ChannelHook {
    constructor(opts, params) {
        _ChannelHook_context.set(this, void 0);
        /** Record state in BlocksHandler. */
        _ChannelHook_invalidate.set(this, void 0);
        _ChannelHook_opts.set(this, void 0);
        __classPrivateFieldSet(this, _ChannelHook_context, params.context, "f");
        __classPrivateFieldSet(this, _ChannelHook_opts, opts, "f");
        __classPrivateFieldSet(this, _ChannelHook_invalidate, params.invalidate, "f");
        const appID = params.context.meta[Header.App]?.values[0];
        if (!appID)
            throw Error('useChannel() missing app ID metadata');
        const installID = params.context.meta[Header.Installation]?.values[0];
        if (!installID)
            throw Error('useChannel() missing install ID from metadata');
        this.state = {
            channel: `${appID}:${installID}:${opts.name}`,
            connected: false,
            subscribed: false,
        };
    }
    async onUIEvent(ev) {
        const realtime = ev.realtimeEvent;
        if (!realtime || !this.state.subscribed)
            return;
        switch (realtime.status) {
            case RealtimeSubscriptionStatus.REALTIME_SUBSCRIBED:
                this.state.connected = true;
                __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
                await __classPrivateFieldGet(this, _ChannelHook_opts, "f").onSubscribed?.();
                break;
            case RealtimeSubscriptionStatus.REALTIME_UNSUBSCRIBED:
                this.state.connected = false;
                __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
                await __classPrivateFieldGet(this, _ChannelHook_opts, "f").onUnsubscribed?.();
                break;
            default:
                // to-do: define a RealtimeSubscriptionStatus.MESSAGE. this could have
                //        been a oneOf but the current approach allows for status + data
                //        and this default case will break if another new type is added.
                __classPrivateFieldGet(this, _ChannelHook_opts, "f").onMessage(realtime.event?.data ?? {});
                break;
        }
    }
    async send(data) {
        if (!this.state.subscribed || !this.state.connected)
            throw Error(`send failed; ${this.state.channel} channel not connected`);
        await __classPrivateFieldGet(this, _ChannelHook_context, "f").devvitContext.realtime.send(this.state.channel, data);
    }
    get status() {
        if (this.state.subscribed && this.state.connected)
            return ChannelStatus.Connected;
        else if (this.state.subscribed && !this.state.connected)
            return ChannelStatus.Connecting;
        else if (!this.state.subscribed && this.state.connected)
            return ChannelStatus.Disconnecting;
        return ChannelStatus.Disconnected;
    }
    subscribe() {
        if (this.state.subscribed)
            return;
        this.state.subscribed = true;
        __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
    }
    unsubscribe() {
        if (!this.state.subscribed)
            return;
        this.state.subscribed = false;
        __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
    }
}
_ChannelHook_context = new WeakMap(), _ChannelHook_invalidate = new WeakMap(), _ChannelHook_opts = new WeakMap();
export function useChannel(opts) {
    return registerHook({ namespace: 'useChannel' }, (params) => {
        return new ChannelHook(opts, params);
    });
}
