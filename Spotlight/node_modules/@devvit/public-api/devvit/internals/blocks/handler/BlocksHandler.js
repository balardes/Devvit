var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _BlocksHandler_instances, _BlocksHandler_root, _BlocksHandler_contextBuilder, _BlocksHandler_blocksTransformer, _BlocksHandler_debug_get, _BlocksHandler_loadHooks, _BlocksHandler_handleAsyncQueues, _BlocksHandler_attemptHook, _BlocksHandler_handleMainQueue, _BlocksHandler_renderRoot, _BlocksHandler_render, _BlocksHandler_renderList, _BlocksHandler_renderElement, _BlocksHandler_reifyProps;
import isEqual from 'lodash.isequal';
import { BlocksTransformer } from '../BlocksTransformer.js';
import { ContextBuilder } from './ContextBuilder.js';
import { RenderContext } from './RenderContext.js';
import { RenderInterruptError } from './types.js';
/**
 * This can be a global/singleton because render is synchronous.
 *
 * If you want to use this from somewhere else, please consider using one of the
 * functions like isRendering or registerHook, and then try to add additional
 * functions here if needed.  Don't use this directly.
 */
export let _activeRenderContext = null;
export function useEffectEmitter() {
    if (!_activeRenderContext) {
        throw new Error('Hooks can only be declared at the top of a component.');
    }
    return _activeRenderContext;
}
export function isRendering() {
    return _activeRenderContext !== null;
}
function _structuredClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * This is the recommended low-level interface for creating hooks like useState or useAsync.
 *
 * Practically, this initializes your hook if it doesn't already exist, and makes sure
 * that its state gets all sync'd up.
 *
 * @param HookSegment -- A name for this hook.  This is used to dedupe hooks.
 * @param initializer
 *    factory for building this hook
 * @returns
 */
export function registerHook(options, initializer) {
    if (!_activeRenderContext) {
        throw new Error("Hooks can only be declared at the top of a component.  You cannot declare hooks outside\
    of components or inside of event handlers.  It's almost always a mistake to declare hooks inside of loops or\
    conditionals.");
    }
    const hookId = _activeRenderContext.nextHookId(options);
    const context = _activeRenderContext;
    const params = {
        hookId,
        invalidate: () => {
            context._changed[hookId] = true;
            context._state[hookId] = context?._hooks[hookId]?.state;
        },
        context: _activeRenderContext,
    };
    const fromNull = _activeRenderContext._state[hookId] === undefined;
    _activeRenderContext._hooks[hookId] = _activeRenderContext._hooks[hookId] ?? initializer(params);
    const hook = _activeRenderContext._hooks[hookId];
    if (_activeRenderContext._state[hookId] !== undefined) {
        hook.state = _activeRenderContext._state[hookId];
    }
    hook.onStateLoaded?.();
    if (fromNull && hook.state !== undefined && hook.state !== null) {
        params.invalidate();
    }
    return hook;
}
export let _latestBlocksHandler = null;
/**
 * Replacing BlocksReconciler, the model is now less of a "reconciliation", and more
 * of a handling a request/response lifecycle.
 *
 */
export class BlocksHandler {
    constructor(root) {
        _BlocksHandler_instances.add(this);
        _BlocksHandler_root.set(this, void 0);
        _BlocksHandler_contextBuilder.set(this, new ContextBuilder());
        _BlocksHandler_blocksTransformer.set(this, new BlocksTransformer(() => this._latestRenderContext?.devvitContext?.assets));
        this._latestRenderContext = null;
        if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
            console.debug('[blocks] BlocksHandler v1');
        __classPrivateFieldSet(this, _BlocksHandler_root, root, "f");
        _latestBlocksHandler = this;
    }
    async handle(request, metadata) {
        const context = new RenderContext(request, metadata);
        const devvitContext = __classPrivateFieldGet(this, _BlocksHandler_contextBuilder, "f").buildContext(context, request, metadata);
        context.devvitContext = devvitContext;
        let blocks;
        /**
         * Events on the main queue must be handled in order, so that state is updated in the correct order.  Events
         * on other queues can be handled in parallel, because they only emit effects.
         *
         * There is an optimization here to process SendEventEffects locally, instead of letting them bubble up to the
         * platform.  This prevents a round trip to the platform for every event.
         *
         * This also means we need to respect execution queues here, and not just in the platform.
         */
        const eventsToProcess = request.events;
        const noEvents = !request.events?.length;
        const isMainQueue = noEvents || eventsToProcess.some((e) => !e.async);
        const isBlockingSSR = eventsToProcess.some((e) => e.blocking);
        let changed;
        let progress;
        let remaining = [...eventsToProcess];
        if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
            console.debug('[blocks] starting processing events');
        while (eventsToProcess.length > 0) {
            if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
                console.debug('[blocks] processing events loop iteration', eventsToProcess.length);
            /**
             * A concurrently executable batch is a set of events that can be executed in parallel.  This either one main queue event,
             * or any number of other queue events.
             */
            const batch = [];
            if (!eventsToProcess[0].async) {
                batch.push(eventsToProcess.shift());
            }
            else {
                while (eventsToProcess[0]?.async) {
                    batch.push(eventsToProcess.shift());
                }
            }
            if (!batch.length)
                throw Error('batch must have at least one event');
            try {
                if (batch[0].async) {
                    const stateCopy = _structuredClone(context._state);
                    await __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_handleAsyncQueues).call(this, context, ...batch);
                    // enforce that state updates are only allowed on the main queue.
                    context._state = stateCopy;
                }
                else {
                    await __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_handleMainQueue).call(this, context, ...batch);
                }
            }
            catch (e) {
                if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
                    console.debug('[blocks] caught in handler', e);
                /**
                 * If we have a progress, we can recover from an error by rolling back to the last progress, and then letting the
                 * remaining events be reprocessed.
                 */
                if (progress) {
                    context._state = progress._state;
                    context._changed = changed;
                    context._effects = progress._effects;
                    const requeueable = remaining.map((e) => {
                        const requeueEvent = { ...e };
                        requeueEvent.retry = true;
                        return requeueEvent;
                    });
                    context.addToRequeueEvents(...requeueable);
                    break;
                }
                else {
                    throw e;
                }
            }
            if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
                console.debug('[blocks] remaining events', context._requeueEvents);
            const remainingRequeueEvents = [];
            for (const event of context._requeueEvents) {
                if (!isMainQueue && !event.async) {
                    if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
                        console.debug('[blocks] NOT reprocessing event in BlocksHandler, sync mismatch A', event);
                    // We're async, this is a main qrueue event.  We need to send it back to the platform to let
                    // the platform synchronize it.
                    remainingRequeueEvents.push(event);
                    continue;
                }
                if (isMainQueue && event.async && !isBlockingSSR) {
                    if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
                        console.debug('[blocks] NOT reprocessing event in BlocksHandler, sync mismatch B', event);
                    // We're main queue, and this is an async event.  We're not in SSR mode, so let's prioritize
                    // returning control quickly to the platform so we don't block event loops.
                    remainingRequeueEvents.push(event);
                    continue;
                }
                if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
                    console.debug('[blocks] reprocessing event in BlocksHandler', event);
                eventsToProcess.push(event);
            }
            context._requeueEvents = remainingRequeueEvents; //
            /**
             * If we're going back through this again, we need to capture the progress, and the remaining events.
             */
            if (eventsToProcess.length > 0) {
                changed = { ...context._changed };
                progress = {
                    _state: _structuredClone(context._state),
                    _effects: { ...context._effects },
                };
                remaining = [...eventsToProcess];
            }
        } // End of while loop
        if (isMainQueue) {
            const stateCopy = _structuredClone(context._state);
            const eventsCopy = [...context._requeueEvents];
            const effectsCopy = { ...context._effects };
            // Rendering only happens on the main queue.
            const tags = __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderRoot).call(this, __classPrivateFieldGet(this, _BlocksHandler_root, "f"), context._rootProps ?? {}, context);
            /**
             * It's technically ok for renderRoot to mutate, but that's only in the context of loadHooks.  This render should
             * be idempotent, so we're going to enforce that it doesn't mutate state.
             *
             * TODO: hide this behind a flag, because it's possibly expensive.
             */
            if (!isEqual(context._state, stateCopy)) {
                console.error('[blocks] State was mutated during rendering', context._state, stateCopy);
            }
            if (!isEqual(context._requeueEvents, eventsCopy)) {
                console.error('[blocks] Events were mutated during rendering', context._requeueEvents, eventsCopy);
            }
            if (!isEqual(context._effects, effectsCopy)) {
                console.error('[blocks] Effects were mutated during rendering', context._effects, effectsCopy);
            }
            if (tags) {
                blocks = __classPrivateFieldGet(this, _BlocksHandler_blocksTransformer, "f").createBlocksElementOrThrow(tags);
                blocks = __classPrivateFieldGet(this, _BlocksHandler_blocksTransformer, "f").ensureRootBlock(blocks);
            }
        }
        return {
            state: context._changedState,
            effects: context.effects,
            blocks,
            events: context._requeueEvents,
        };
    }
}
_BlocksHandler_root = new WeakMap(), _BlocksHandler_contextBuilder = new WeakMap(), _BlocksHandler_blocksTransformer = new WeakMap(), _BlocksHandler_instances = new WeakSet(), _BlocksHandler_debug_get = function _BlocksHandler_debug_get() {
    return !!this._latestRenderContext?.devvitContext.debug.blocks;
}, _BlocksHandler_loadHooks = function _BlocksHandler_loadHooks(context, ..._events) {
    // TBD: partial rendering
    context._hooks = {};
    __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderRoot).call(this, __classPrivateFieldGet(this, _BlocksHandler_root, "f"), context.request.props ?? {}, context);
}, _BlocksHandler_handleAsyncQueues = 
/**
 * These can all run in parallel, because they only emit effects
 */
async function _BlocksHandler_handleAsyncQueues(context, ...batch) {
    __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_loadHooks).call(this, context, ...batch);
    await Promise.all(batch.map(async (event) => {
        if (!event.async) {
            throw new Error("You can't mix main and other queues in one batch.  This is likely a platform bug.  Please file an issue in the Discord for someone to help! https://discord.com/channels/1050224141732687912/1115441897079574620");
        }
        await __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_attemptHook).call(this, context, event);
    }));
}, _BlocksHandler_attemptHook = async function _BlocksHandler_attemptHook(context, event) {
    const hook = context._hooks[event.hook];
    if (hook?.onUIEvent) {
        try {
            await hook.onUIEvent(event, context);
        }
        catch (e) {
            console.error('Error in event handler', e);
            throw e;
        }
    }
    else {
        await context.handleUndeliveredEvent(event);
    }
}, _BlocksHandler_handleMainQueue = async function _BlocksHandler_handleMainQueue(context, ...batch) {
    // We need to handle events in order, so that the state is updated in the correct order.
    for (const event of batch) {
        if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
            console.log('[blocks] handling main queue event', event);
        if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
            console.log('[blocks] before', context._state);
        __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_loadHooks).call(this, context, event);
        await __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_attemptHook).call(this, context, event);
        if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
            console.log('[blocks] after', context._state);
    }
    // TODO: Decide whether this is excessive.  It doesn't hurt anything besides performance.
    __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_loadHooks).call(this, context);
}, _BlocksHandler_renderRoot = function _BlocksHandler_renderRoot(component, props, context) {
    if (__classPrivateFieldGet(this, _BlocksHandler_instances, "a", _BlocksHandler_debug_get))
        console.debug('[blocks] renderRoot');
    context._generated = {};
    _activeRenderContext = context;
    this._latestRenderContext = context;
    try {
        const roots = __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_render).call(this, component, props, context);
        if (roots.length !== 1) {
            throw new Error('only one root');
        }
        const root = roots[0];
        if (typeof root === 'string') {
            throw new Error('There must be a root tag.  Try wrapping your app in a <text></text>, <vstack> or other tag.');
        }
        return root;
    }
    catch (e) {
        if (e instanceof RenderInterruptError) {
            return undefined;
        }
        else {
            throw e;
        }
    }
    finally {
        _activeRenderContext = null;
    }
}, _BlocksHandler_render = function _BlocksHandler_render(component, props, context) {
    context.push({ namespace: component.name, ...props });
    try {
        const element = component(props, context.devvitContext);
        return __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderElement).call(this, element, context);
    }
    finally {
        context.pop();
    }
}, _BlocksHandler_renderList = function _BlocksHandler_renderList(list, context) {
    list = list.flat(Infinity);
    return list.flatMap((e, i) => {
        if (e && typeof e === 'object' && 'props' in e) {
            if (!e.props?.key) {
                e.props = e.props ?? {};
                e.props.key = `${i}`;
            }
        }
        return __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderElement).call(this, e, context);
    });
}, _BlocksHandler_renderElement = function _BlocksHandler_renderElement(element, context) {
    if (Array.isArray(element)) {
        return __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderList).call(this, element, context);
    }
    else if (isBlockElement(element)) {
        if (element.type === undefined) {
            return __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderList).call(this, element.children, context);
        }
        else if (typeof element.type === 'function') {
            const propsWithChildren = { ...element.props, children: element.children };
            return __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_render).call(this, element.type, propsWithChildren, context);
        }
        else {
            context.push({ namespace: element.type, ...element.props });
            const reifiedChildren = __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_renderList).call(this, element.children, context);
            const reifiedProps = __classPrivateFieldGet(this, _BlocksHandler_instances, "m", _BlocksHandler_reifyProps).call(this, element.props ?? {});
            context.pop();
            return [{ type: element.type, children: reifiedChildren, props: reifiedProps }];
        }
    }
    else {
        return [(element ?? '').toString()];
    }
}, _BlocksHandler_reifyProps = function _BlocksHandler_reifyProps(props) {
    const reifiedProps = {};
    for (const key in props) {
        if (typeof props[key] === 'function') {
            const hook = registerHook({
                namespace: key,
                key: false,
            }, ({ hookId }) => ({ hookId, state: null, onUIEvent: props[key] }));
            reifiedProps[key] = hook.hookId;
            if ('captureHookRef' in props[key]) {
                props[key].captureHookRef();
            }
        }
        else {
            // push value through the JSON parser to filter incompatible types
            const value = JSON.parse(JSON.stringify(props[key]));
            if (value !== undefined && value !== null) {
                reifiedProps[key] = value;
            }
        }
    }
    return reifiedProps;
};
function isBlockElement(e) {
    return typeof e === 'object' && e != null && 'type' in e;
}
