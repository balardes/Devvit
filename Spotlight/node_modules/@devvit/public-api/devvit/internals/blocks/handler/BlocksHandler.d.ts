import { type Metadata, type UIRequest, type UIResponse } from '@devvit/protos';
import type { EffectEmitter } from '../EffectEmitter.js';
import { RenderContext } from './RenderContext.js';
import type { Hook, HookParams, HookSegment } from './types.js';
/**
 * This can be a global/singleton because render is synchronous.
 *
 * If you want to use this from somewhere else, please consider using one of the
 * functions like isRendering or registerHook, and then try to add additional
 * functions here if needed.  Don't use this directly.
 */
export declare let _activeRenderContext: RenderContext | null;
export declare function useEffectEmitter(): EffectEmitter;
export declare function isRendering(): boolean;
/**
 * This is the recommended low-level interface for creating hooks like useState or useAsync.
 *
 * Practically, this initializes your hook if it doesn't already exist, and makes sure
 * that its state gets all sync'd up.
 *
 * @param HookSegment -- A name for this hook.  This is used to dedupe hooks.
 * @param initializer
 *    factory for building this hook
 * @returns
 */
export declare function registerHook<H extends Hook>(options: HookSegment, initializer: (p: HookParams) => H): H;
export declare let _latestBlocksHandler: BlocksHandler | null;
/**
 * Replacing BlocksReconciler, the model is now less of a "reconciliation", and more
 * of a handling a request/response lifecycle.
 *
 */
export declare class BlocksHandler {
    #private;
    _latestRenderContext: RenderContext | null;
    constructor(root: JSX.ComponentFunction);
    handle(request: UIRequest, metadata: Metadata): Promise<UIResponse>;
}
//# sourceMappingURL=BlocksHandler.d.ts.map