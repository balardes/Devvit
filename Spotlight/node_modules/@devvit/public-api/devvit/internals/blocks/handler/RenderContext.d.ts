import type { Effect, Metadata, UIEvent, UIRequest } from '@devvit/protos';
import type { Devvit } from '../../../Devvit.js';
import type { EffectEmitter } from '../EffectEmitter.js';
import type { BlocksState, EventHandler, Hook, HookRef, HookSegment } from './types.js';
/**
 * The RenderContext is a class that holds the state of the rendering process.
 *
 * There are many properties that start with an underscore, which is a convention we use to
 * indicate that they are private and should not be accessed directly.  They are used internally
 * in tests and in the implementation of the BlocksHandler.
 *
 * DO your best to avoid adding new properties to this class to support new features.  It will be tempting
 * to add special cases for new features, but we should strive to work within the existing framework.
 */
export declare class RenderContext implements EffectEmitter {
    #private;
    readonly request: Readonly<UIRequest>;
    readonly meta: Readonly<Metadata>;
    _segments: (HookSegment & {
        next: number;
    })[];
    _hooks: {
        [key: string]: Hook;
    };
    _prevHookId: string;
    _effects: {
        [key: string]: Effect;
    };
    _changed: {
        [hookID: string]: true;
    };
    /** Events that will re-enter the dispatcher queue */
    _requeueEvents: UIEvent[];
    _rootProps: {
        [key: string]: any;
    };
    _generated: {
        [key: string]: boolean;
    };
    static _staticUndeliveredHandlers: {
        [key: string]: EventHandler;
    };
    _undeliveredHandlers: {
        [key: string]: EventHandler;
    };
    _devvitContext?: Devvit.Context;
    get devvitContext(): Devvit.Context;
    set devvitContext(context: Devvit.Context);
    constructor(request: UIRequest, meta: Metadata);
    /** The state delta new to this render. */
    get _changedState(): BlocksState;
    /** The complete render state. */
    get _state(): BlocksState;
    /** Replacing state resets the delta for the next render. */
    set _state(state: BlocksState);
    push(options: HookSegment): void;
    pop(): void;
    addUndeliveredEventHandler(id: string, handler: EventHandler): void;
    addGlobalUndeliveredEventHandler(id: string, handler: EventHandler): void;
    getHook(ref: HookRef): Hook;
    static addGlobalUndeliveredEventHandler(id: string, handler: EventHandler): void;
    handleUndeliveredEvent(ev: UIEvent): Promise<Effect[] | void>;
    emitEffect(dedupeKey: string, effect: Effect): void;
    /**
     * Adds event that will re-enter the dispatcher queue.
     */
    addToRequeueEvents(...events: UIEvent[]): void;
    get effects(): Effect[];
    nextHookId(options: HookSegment): string;
}
//# sourceMappingURL=RenderContext.d.ts.map