var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RenderContext_state;
/**
 * The RenderContext is a class that holds the state of the rendering process.
 *
 * There are many properties that start with an underscore, which is a convention we use to
 * indicate that they are private and should not be accessed directly.  They are used internally
 * in tests and in the implementation of the BlocksHandler.
 *
 * DO your best to avoid adding new properties to this class to support new features.  It will be tempting
 * to add special cases for new features, but we should strive to work within the existing framework.
 */
export class RenderContext {
    get devvitContext() {
        if (!this._devvitContext) {
            throw new Error('Devvit context not available');
        }
        return this._devvitContext;
    }
    set devvitContext(context) {
        this._devvitContext = context;
    }
    constructor(request, meta) {
        _RenderContext_state.set(this, void 0);
        this._segments = [];
        this._hooks = {};
        this._prevHookId = '';
        this._effects = {};
        this._changed = {};
        /** Events that will re-enter the dispatcher queue */
        this._requeueEvents = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._rootProps = {};
        this._generated = {};
        this._undeliveredHandlers = {};
        this.request = request;
        this.meta = meta;
        __classPrivateFieldSet(this, _RenderContext_state, request.state ?? {}, "f");
        this._rootProps = request.props ?? {};
    }
    /** The state delta new to this render. */
    get _changedState() {
        const changed = {};
        for (const key in this._changed)
            changed[key] = this._state[key];
        return changed;
    }
    /** The complete render state. */
    get _state() {
        return __classPrivateFieldGet(this, _RenderContext_state, "f");
    }
    /** Replacing state resets the delta for the next render. */
    set _state(state) {
        this._changed = {};
        __classPrivateFieldSet(this, _RenderContext_state, state, "f");
    }
    push(options) {
        this._segments.push({ ...options, next: 0 });
    }
    pop() {
        this._segments.pop();
    }
    addUndeliveredEventHandler(id, handler) {
        this._undeliveredHandlers[id] = handler;
    }
    addGlobalUndeliveredEventHandler(id, handler) {
        RenderContext.addGlobalUndeliveredEventHandler(id, handler);
    }
    getHook(ref) {
        return this._hooks[ref.id];
    }
    static addGlobalUndeliveredEventHandler(id, handler) {
        RenderContext._staticUndeliveredHandlers[id] = handler;
    }
    async handleUndeliveredEvent(ev) {
        const allHandlers = {
            ...RenderContext._staticUndeliveredHandlers,
            ...this._undeliveredHandlers,
        };
        for (const [_, handler] of Object.entries(allHandlers)) {
            await handler(ev, this);
        }
    }
    emitEffect(dedupeKey, effect) {
        this._effects[dedupeKey] = effect;
    }
    /**
     * Adds event that will re-enter the dispatcher queue.
     */
    addToRequeueEvents(...events) {
        if (this._devvitContext?.debug.blocks)
            console.debug('[blocks] requeueing events', events);
        const grouped = events.reduce((acc, event) => {
            if (event.retry) {
                acc.retry.push(event);
            }
            else {
                acc.normal.push(event);
            }
            return acc;
        }, { retry: [], normal: [] });
        // We need to maintain the order of the events, so we need to add the retry events first
        this._requeueEvents = [...grouped.retry, ...this._requeueEvents, ...grouped.normal];
    }
    get effects() {
        return Object.values(this._effects);
    }
    nextHookId(options) {
        if (options.key === undefined) {
            options.key = this._segments[this._segments.length - 1].next++ + '';
        }
        this.push(options);
        try {
            const builder = [];
            /**
             * We need to build the hook id from the segments in reverse order, because an explicit id
             * overrrides parent path info.
             */
            for (let i = this._segments.length - 1; i >= 0; i--) {
                const segment = this._segments[i];
                if (segment.id) {
                    builder.unshift(segment.id);
                    break;
                }
                const tag = [];
                if (segment.namespace) {
                    tag.push(segment.namespace);
                }
                if (segment.key !== undefined && segment.key !== false) {
                    tag.push(segment.key);
                }
                builder.unshift(tag.join('-'));
            }
            const id = builder.join('.');
            if (this._generated[id] && !options.shared) {
                throw new Error(`Hook id ${id} already used, cannot register another hook with the same id`);
            }
            this._generated[id] = true;
            this._prevHookId = id;
            return id;
        }
        finally {
            this.pop();
        }
    }
}
_RenderContext_state = new WeakMap();
RenderContext._staticUndeliveredHandlers = {};
