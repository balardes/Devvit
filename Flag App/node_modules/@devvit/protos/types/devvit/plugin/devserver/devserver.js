/**
 * #devserver.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { map } from "rxjs/operators";
import { Empty } from '../../../google/protobuf/empty.js';
import { Timestamp } from '../../../google/protobuf/timestamp.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { LinkedBundle } from '../../runtime/bundle.js';
import { CompileLog } from '../buildpack/buildpack_common.js';
import { File, FileSystem } from '../buildpack/filesystem.js';
import { TestCasesList } from './testcases.js';
function createBaseProjectListRequest() {
    return { projectRootDirectory: "" };
}
export const ProjectListRequest = {
    $type: "devvit.plugin.devserver.ProjectListRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.projectRootDirectory !== "") {
            writer.uint32(10).string(message.projectRootDirectory);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectListRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.projectRootDirectory = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            projectRootDirectory: isSet(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.projectRootDirectory !== "") {
            obj.projectRootDirectory = message.projectRootDirectory;
        }
        return obj;
    },
    create(base) {
        return ProjectListRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectListRequest();
        message.projectRootDirectory = object.projectRootDirectory ?? "";
        return message;
    },
};
messageTypeRegistry.set(ProjectListRequest.$type, ProjectListRequest);
function createBaseProjectBuildProblems() {
    return { warnings: [], errors: [] };
}
export const ProjectBuildProblems = {
    $type: "devvit.plugin.devserver.ProjectBuildProblems",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.warnings) {
            CompileLog.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.errors) {
            CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectBuildProblems();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.warnings.push(CompileLog.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.errors.push(CompileLog.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            warnings: globalThis.Array.isArray(object?.warnings)
                ? object.warnings.map((e) => CompileLog.fromJSON(e))
                : [],
            errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.warnings?.length) {
            obj.warnings = message.warnings.map((e) => CompileLog.toJSON(e));
        }
        if (message.errors?.length) {
            obj.errors = message.errors.map((e) => CompileLog.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ProjectBuildProblems.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectBuildProblems();
        message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
        message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(ProjectBuildProblems.$type, ProjectBuildProblems);
function createBaseProjectListingResponse() {
    return { projectRootDirectory: "", projectFileSystem: undefined, buildProblems: {} };
}
export const ProjectListingResponse = {
    $type: "devvit.plugin.devserver.ProjectListingResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.projectRootDirectory !== "") {
            writer.uint32(10).string(message.projectRootDirectory);
        }
        if (message.projectFileSystem !== undefined) {
            FileSystem.encode(message.projectFileSystem, writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.buildProblems).forEach(([key, value]) => {
            ProjectListingResponse_BuildProblemsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectListingResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.projectRootDirectory = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.projectFileSystem = FileSystem.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = ProjectListingResponse_BuildProblemsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.buildProblems[entry3.key] = entry3.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            projectRootDirectory: isSet(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : "",
            projectFileSystem: isSet(object.projectFileSystem) ? FileSystem.fromJSON(object.projectFileSystem) : undefined,
            buildProblems: isObject(object.buildProblems)
                ? Object.entries(object.buildProblems).reduce((acc, [key, value]) => {
                    acc[key] = ProjectBuildProblems.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.projectRootDirectory !== "") {
            obj.projectRootDirectory = message.projectRootDirectory;
        }
        if (message.projectFileSystem !== undefined) {
            obj.projectFileSystem = FileSystem.toJSON(message.projectFileSystem);
        }
        if (message.buildProblems) {
            const entries = Object.entries(message.buildProblems);
            if (entries.length > 0) {
                obj.buildProblems = {};
                entries.forEach(([k, v]) => {
                    obj.buildProblems[k] = ProjectBuildProblems.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ProjectListingResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectListingResponse();
        message.projectRootDirectory = object.projectRootDirectory ?? "";
        message.projectFileSystem = (object.projectFileSystem !== undefined && object.projectFileSystem !== null)
            ? FileSystem.fromPartial(object.projectFileSystem)
            : undefined;
        message.buildProblems = Object.entries(object.buildProblems ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ProjectBuildProblems.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(ProjectListingResponse.$type, ProjectListingResponse);
function createBaseProjectListingResponse_BuildProblemsEntry() {
    return { key: "", value: undefined };
}
export const ProjectListingResponse_BuildProblemsEntry = {
    $type: "devvit.plugin.devserver.ProjectListingResponse.BuildProblemsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ProjectBuildProblems.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectListingResponse_BuildProblemsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ProjectBuildProblems.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ProjectBuildProblems.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ProjectBuildProblems.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ProjectListingResponse_BuildProblemsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectListingResponse_BuildProblemsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ProjectBuildProblems.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ProjectListingResponse_BuildProblemsEntry.$type, ProjectListingResponse_BuildProblemsEntry);
function createBaseProjectUpdatesRequest() {
    return { projectRootDirectory: "" };
}
export const ProjectUpdatesRequest = {
    $type: "devvit.plugin.devserver.ProjectUpdatesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.projectRootDirectory !== "") {
            writer.uint32(10).string(message.projectRootDirectory);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectUpdatesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.projectRootDirectory = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            projectRootDirectory: isSet(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.projectRootDirectory !== "") {
            obj.projectRootDirectory = message.projectRootDirectory;
        }
        return obj;
    },
    create(base) {
        return ProjectUpdatesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectUpdatesRequest();
        message.projectRootDirectory = object.projectRootDirectory ?? "";
        return message;
    },
};
messageTypeRegistry.set(ProjectUpdatesRequest.$type, ProjectUpdatesRequest);
function createBaseProjectUpdateResponse() {
    return { projectRootDirectory: "", file: undefined, linkedBundle: undefined, actorPath: "", buildProblems: {} };
}
export const ProjectUpdateResponse = {
    $type: "devvit.plugin.devserver.ProjectUpdateResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.projectRootDirectory !== "") {
            writer.uint32(10).string(message.projectRootDirectory);
        }
        if (message.file !== undefined) {
            File.encode(message.file, writer.uint32(18).fork()).ldelim();
        }
        if (message.linkedBundle !== undefined) {
            LinkedBundle.encode(message.linkedBundle, writer.uint32(26).fork()).ldelim();
        }
        if (message.actorPath !== "") {
            writer.uint32(34).string(message.actorPath);
        }
        Object.entries(message.buildProblems).forEach(([key, value]) => {
            ProjectUpdateResponse_BuildProblemsEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectUpdateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.projectRootDirectory = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.file = File.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.linkedBundle = LinkedBundle.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.actorPath = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    const entry5 = ProjectUpdateResponse_BuildProblemsEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.buildProblems[entry5.key] = entry5.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            projectRootDirectory: isSet(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : "",
            file: isSet(object.file) ? File.fromJSON(object.file) : undefined,
            linkedBundle: isSet(object.linkedBundle) ? LinkedBundle.fromJSON(object.linkedBundle) : undefined,
            actorPath: isSet(object.actorPath) ? globalThis.String(object.actorPath) : "",
            buildProblems: isObject(object.buildProblems)
                ? Object.entries(object.buildProblems).reduce((acc, [key, value]) => {
                    acc[key] = ProjectBuildProblems.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.projectRootDirectory !== "") {
            obj.projectRootDirectory = message.projectRootDirectory;
        }
        if (message.file !== undefined) {
            obj.file = File.toJSON(message.file);
        }
        if (message.linkedBundle !== undefined) {
            obj.linkedBundle = LinkedBundle.toJSON(message.linkedBundle);
        }
        if (message.actorPath !== "") {
            obj.actorPath = message.actorPath;
        }
        if (message.buildProblems) {
            const entries = Object.entries(message.buildProblems);
            if (entries.length > 0) {
                obj.buildProblems = {};
                entries.forEach(([k, v]) => {
                    obj.buildProblems[k] = ProjectBuildProblems.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ProjectUpdateResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectUpdateResponse();
        message.projectRootDirectory = object.projectRootDirectory ?? "";
        message.file = (object.file !== undefined && object.file !== null) ? File.fromPartial(object.file) : undefined;
        message.linkedBundle = (object.linkedBundle !== undefined && object.linkedBundle !== null)
            ? LinkedBundle.fromPartial(object.linkedBundle)
            : undefined;
        message.actorPath = object.actorPath ?? "";
        message.buildProblems = Object.entries(object.buildProblems ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ProjectBuildProblems.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(ProjectUpdateResponse.$type, ProjectUpdateResponse);
function createBaseProjectUpdateResponse_BuildProblemsEntry() {
    return { key: "", value: undefined };
}
export const ProjectUpdateResponse_BuildProblemsEntry = {
    $type: "devvit.plugin.devserver.ProjectUpdateResponse.BuildProblemsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ProjectBuildProblems.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProjectUpdateResponse_BuildProblemsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ProjectBuildProblems.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ProjectBuildProblems.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ProjectBuildProblems.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ProjectUpdateResponse_BuildProblemsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProjectUpdateResponse_BuildProblemsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ProjectBuildProblems.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ProjectUpdateResponse_BuildProblemsEntry.$type, ProjectUpdateResponse_BuildProblemsEntry);
function createBaseTestCasesRequest() {
    return { actorName: "" };
}
export const TestCasesRequest = {
    $type: "devvit.plugin.devserver.TestCasesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actorName !== "") {
            writer.uint32(10).string(message.actorName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestCasesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.actorName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { actorName: isSet(object.actorName) ? globalThis.String(object.actorName) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.actorName !== "") {
            obj.actorName = message.actorName;
        }
        return obj;
    },
    create(base) {
        return TestCasesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTestCasesRequest();
        message.actorName = object.actorName ?? "";
        return message;
    },
};
messageTypeRegistry.set(TestCasesRequest.$type, TestCasesRequest);
function createBaseAuthenticationRequest() {
    return {};
}
export const AuthenticationRequest = {
    $type: "devvit.plugin.devserver.AuthenticationRequest",
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthenticationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return AuthenticationRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseAuthenticationRequest();
        return message;
    },
};
messageTypeRegistry.set(AuthenticationRequest.$type, AuthenticationRequest);
function createBaseAuthenticationResponse() {
    return { storedToken: undefined };
}
export const AuthenticationResponse = {
    $type: "devvit.plugin.devserver.AuthenticationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.storedToken !== undefined) {
            StoredToken.encode(message.storedToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthenticationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.storedToken = StoredToken.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { storedToken: isSet(object.storedToken) ? StoredToken.fromJSON(object.storedToken) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.storedToken !== undefined) {
            obj.storedToken = StoredToken.toJSON(message.storedToken);
        }
        return obj;
    },
    create(base) {
        return AuthenticationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuthenticationResponse();
        message.storedToken = (object.storedToken !== undefined && object.storedToken !== null)
            ? StoredToken.fromPartial(object.storedToken)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(AuthenticationResponse.$type, AuthenticationResponse);
function createBaseValidationRequest() {
    return {};
}
export const ValidationRequest = {
    $type: "devvit.plugin.devserver.ValidationRequest",
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return ValidationRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseValidationRequest();
        return message;
    },
};
messageTypeRegistry.set(ValidationRequest.$type, ValidationRequest);
function createBaseStoredToken() {
    return { refreshToken: "", accessToken: "", expiresAt: undefined, scope: "", tokenType: "" };
}
export const StoredToken = {
    $type: "devvit.plugin.devserver.StoredToken",
    encode(message, writer = _m0.Writer.create()) {
        if (message.refreshToken !== "") {
            writer.uint32(10).string(message.refreshToken);
        }
        if (message.accessToken !== "") {
            writer.uint32(18).string(message.accessToken);
        }
        if (message.expiresAt !== undefined) {
            Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        if (message.tokenType !== "") {
            writer.uint32(42).string(message.tokenType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStoredToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.refreshToken = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.accessToken = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.scope = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.tokenType = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
            accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
            expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
            scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
            tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.refreshToken !== "") {
            obj.refreshToken = message.refreshToken;
        }
        if (message.accessToken !== "") {
            obj.accessToken = message.accessToken;
        }
        if (message.expiresAt !== undefined) {
            obj.expiresAt = message.expiresAt.toISOString();
        }
        if (message.scope !== "") {
            obj.scope = message.scope;
        }
        if (message.tokenType !== "") {
            obj.tokenType = message.tokenType;
        }
        return obj;
    },
    create(base) {
        return StoredToken.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStoredToken();
        message.refreshToken = object.refreshToken ?? "";
        message.accessToken = object.accessToken ?? "";
        message.expiresAt = object.expiresAt ?? undefined;
        message.scope = object.scope ?? "";
        message.tokenType = object.tokenType ?? "";
        return message;
    },
};
messageTypeRegistry.set(StoredToken.$type, StoredToken);
export const DevServerServiceName = "devvit.plugin.devserver.DevServer";
export class DevServerClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || DevServerServiceName;
        this.rpc = rpc;
        this.ListProject = this.ListProject.bind(this);
        this.NotifyBundleUpdates = this.NotifyBundleUpdates.bind(this);
        this.GetTestCases = this.GetTestCases.bind(this);
        this.UpdateTestCases = this.UpdateTestCases.bind(this);
    }
    ListProject(request, metadata) {
        const data = ProjectListRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ListProject", data, metadata);
        return promise.then((data) => ProjectListingResponse.decode(_m0.Reader.create(data)));
    }
    NotifyBundleUpdates(request, metadata) {
        const data = ProjectUpdatesRequest.encode(request).finish();
        const result = this.rpc.serverStreamingRequest(this.service, "NotifyBundleUpdates", data, metadata);
        return result.pipe(map((data) => ProjectUpdateResponse.decode(_m0.Reader.create(data))));
    }
    GetTestCases(request, metadata) {
        const data = TestCasesRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetTestCases", data, metadata);
        return promise.then((data) => TestCasesList.decode(_m0.Reader.create(data)));
    }
    UpdateTestCases(request, metadata) {
        const data = TestCasesList.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateTestCases", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
}
export const DevServerDefinition = {
    name: "DevServer",
    fullName: "devvit.plugin.devserver.DevServer",
    methods: {
        /**
         * Used when the client connects initially to populate the sidebar.
         * This could be updated to take in target project root directory
         * if we support one server powering multiple projects
         */
        listProject: {
            name: "ListProject",
            requestType: ProjectListRequest,
            requestStream: false,
            responseType: ProjectListingResponse,
            responseStream: false,
            options: {},
        },
        /** For now the webUI will request linked bundles over http request caching */
        notifyBundleUpdates: {
            name: "NotifyBundleUpdates",
            requestType: ProjectUpdatesRequest,
            requestStream: false,
            responseType: ProjectUpdateResponse,
            responseStream: true,
            options: {},
        },
        /** Get the list of test cases saved with a given actor */
        getTestCases: {
            name: "GetTestCases",
            requestType: TestCasesRequest,
            requestStream: false,
            responseType: TestCasesList,
            responseStream: false,
            options: {},
        },
        /** Update the list of test cases saved with a given actor */
        updateTestCases: {
            name: "UpdateTestCases",
            requestType: TestCasesList,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
    },
};
export const OAuthProviderServiceName = "devvit.plugin.devserver.OAuthProvider";
export class OAuthProviderClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || OAuthProviderServiceName;
        this.rpc = rpc;
        this.Authenticate = this.Authenticate.bind(this);
        this.Validate = this.Validate.bind(this);
        this.NotifyAuthenticationUpdates = this.NotifyAuthenticationUpdates.bind(this);
        this.Logout = this.Logout.bind(this);
    }
    Authenticate(request, metadata) {
        const data = AuthenticationRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Authenticate", data, metadata);
        return promise.then((data) => AuthenticationResponse.decode(_m0.Reader.create(data)));
    }
    Validate(request, metadata) {
        const data = ValidationRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Validate", data, metadata);
        return promise.then((data) => AuthenticationResponse.decode(_m0.Reader.create(data)));
    }
    NotifyAuthenticationUpdates(request, metadata) {
        const data = Empty.encode(request).finish();
        const result = this.rpc.serverStreamingRequest(this.service, "NotifyAuthenticationUpdates", data, metadata);
        return result.pipe(map((data) => AuthenticationResponse.decode(_m0.Reader.create(data))));
    }
    Logout(request, metadata) {
        const data = Empty.encode(request).finish();
        const promise = this.rpc.request(this.service, "Logout", data, metadata);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
}
export const OAuthProviderDefinition = {
    name: "OAuthProvider",
    fullName: "devvit.plugin.devserver.OAuthProvider",
    methods: {
        authenticate: {
            name: "Authenticate",
            requestType: AuthenticationRequest,
            requestStream: false,
            responseType: AuthenticationResponse,
            responseStream: false,
            options: {},
        },
        validate: {
            name: "Validate",
            requestType: ValidationRequest,
            requestStream: false,
            responseType: AuthenticationResponse,
            responseStream: false,
            options: {},
        },
        notifyAuthenticationUpdates: {
            name: "NotifyAuthenticationUpdates",
            requestType: Empty,
            requestStream: false,
            responseType: AuthenticationResponse,
            responseStream: true,
            options: {},
        },
        logout: {
            name: "Logout",
            requestType: Empty,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
