/**
 * #postcollections_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Timestamp } from '../../../../google/protobuf/timestamp.js';
import { BoolValue, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseCollectionRequest() {
    return { collectionId: undefined, includeLinks: undefined };
}
export const CollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.CollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.includeLinks !== undefined) {
            BoolValue.encode({ value: message.includeLinks }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.includeLinks = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            includeLinks: isSet(object.includeLinks) ? Boolean(object.includeLinks) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.includeLinks !== undefined) {
            obj.includeLinks = message.includeLinks;
        }
        return obj;
    },
    create(base) {
        return CollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.includeLinks = object.includeLinks ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(CollectionRequest.$type, CollectionRequest);
function createBaseCreateCollectionRequest() {
    return { title: undefined, srFullname: undefined, description: undefined, displayLayout: undefined };
}
export const CreateCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.CreateCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
        }
        if (message.srFullname !== undefined) {
            StringValue.encode({ value: message.srFullname }, writer.uint32(18).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
        }
        if (message.displayLayout !== undefined) {
            StringValue.encode({ value: message.displayLayout }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.srFullname = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? String(object.title) : undefined,
            srFullname: isSet(object.srFullname) ? String(object.srFullname) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            displayLayout: isSet(object.displayLayout) ? String(object.displayLayout) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        if (message.srFullname !== undefined) {
            obj.srFullname = message.srFullname;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.displayLayout !== undefined) {
            obj.displayLayout = message.displayLayout;
        }
        return obj;
    },
    create(base) {
        return CreateCollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateCollectionRequest();
        message.title = object.title ?? undefined;
        message.srFullname = object.srFullname ?? undefined;
        message.description = object.description ?? undefined;
        message.displayLayout = object.displayLayout ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateCollectionRequest.$type, CreateCollectionRequest);
function createBaseAddPostToCollectionRequest() {
    return { collectionId: undefined, linkFullname: undefined };
}
export const AddPostToCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.AddPostToCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkFullname !== undefined) {
            StringValue.encode({ value: message.linkFullname }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddPostToCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.linkFullname = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            linkFullname: isSet(object.linkFullname) ? String(object.linkFullname) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.linkFullname !== undefined) {
            obj.linkFullname = message.linkFullname;
        }
        return obj;
    },
    create(base) {
        return AddPostToCollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddPostToCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.linkFullname = object.linkFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(AddPostToCollectionRequest.$type, AddPostToCollectionRequest);
function createBaseDeleteCollectionRequest() {
    return { collectionId: undefined };
}
export const DeleteCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.DeleteCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        return obj;
    },
    create(base) {
        return DeleteCollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(DeleteCollectionRequest.$type, DeleteCollectionRequest);
function createBaseFollowCollectionRequest() {
    return { collectionId: undefined, follow: undefined };
}
export const FollowCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.FollowCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.follow !== undefined) {
            BoolValue.encode({ value: message.follow }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFollowCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.follow = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            follow: isSet(object.follow) ? Boolean(object.follow) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.follow !== undefined) {
            obj.follow = message.follow;
        }
        return obj;
    },
    create(base) {
        return FollowCollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFollowCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.follow = object.follow ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FollowCollectionRequest.$type, FollowCollectionRequest);
function createBaseRemovePostInCollectionRequest() {
    return { collectionId: undefined, linkFullname: undefined };
}
export const RemovePostInCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.RemovePostInCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkFullname !== undefined) {
            StringValue.encode({ value: message.linkFullname }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemovePostInCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.linkFullname = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            linkFullname: isSet(object.linkFullname) ? String(object.linkFullname) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.linkFullname !== undefined) {
            obj.linkFullname = message.linkFullname;
        }
        return obj;
    },
    create(base) {
        return RemovePostInCollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRemovePostInCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.linkFullname = object.linkFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(RemovePostInCollectionRequest.$type, RemovePostInCollectionRequest);
function createBaseReorderCollectionRequest() {
    return { collectionId: undefined, linkIds: undefined };
}
export const ReorderCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.ReorderCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkIds !== undefined) {
            StringValue.encode({ value: message.linkIds }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReorderCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.linkIds = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            linkIds: isSet(object.linkIds) ? String(object.linkIds) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.linkIds !== undefined) {
            obj.linkIds = message.linkIds;
        }
        return obj;
    },
    create(base) {
        return ReorderCollectionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseReorderCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.linkIds = object.linkIds ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ReorderCollectionRequest.$type, ReorderCollectionRequest);
function createBaseSubredditCollectionsRequest() {
    return { srFullname: undefined };
}
export const SubredditCollectionsRequest = {
    $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.srFullname !== undefined) {
            StringValue.encode({ value: message.srFullname }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditCollectionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.srFullname = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { srFullname: isSet(object.srFullname) ? String(object.srFullname) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.srFullname !== undefined) {
            obj.srFullname = message.srFullname;
        }
        return obj;
    },
    create(base) {
        return SubredditCollectionsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubredditCollectionsRequest();
        message.srFullname = object.srFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubredditCollectionsRequest.$type, SubredditCollectionsRequest);
function createBaseUpdateCollectionDescriptionRequest() {
    return { collectionId: undefined, description: undefined };
}
export const UpdateCollectionDescriptionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDescriptionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCollectionDescriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return UpdateCollectionDescriptionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateCollectionDescriptionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UpdateCollectionDescriptionRequest.$type, UpdateCollectionDescriptionRequest);
function createBaseUpdateCollectionTitleRequest() {
    return { collectionId: undefined, title: undefined };
}
export const UpdateCollectionTitleRequest = {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionTitleRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCollectionTitleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        return obj;
    },
    create(base) {
        return UpdateCollectionTitleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateCollectionTitleRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UpdateCollectionTitleRequest.$type, UpdateCollectionTitleRequest);
function createBaseUpdateCollectionDisplayLayoutRequest() {
    return { collectionId: undefined, displayLayout: undefined };
}
export const UpdateCollectionDisplayLayoutRequest = {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDisplayLayoutRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.displayLayout !== undefined) {
            StringValue.encode({ value: message.displayLayout }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCollectionDisplayLayoutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            displayLayout: isSet(object.displayLayout) ? String(object.displayLayout) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.displayLayout !== undefined) {
            obj.displayLayout = message.displayLayout;
        }
        return obj;
    },
    create(base) {
        return UpdateCollectionDisplayLayoutRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateCollectionDisplayLayoutRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.displayLayout = object.displayLayout ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UpdateCollectionDisplayLayoutRequest.$type, UpdateCollectionDisplayLayoutRequest);
function createBaseCollectionResponse() {
    return {
        collectionId: undefined,
        subredditId: undefined,
        title: undefined,
        description: undefined,
        authorId: undefined,
        authorName: undefined,
        permalink: undefined,
        linkIds: [],
        primaryLinkId: undefined,
        displayLayout: undefined,
        createdAtUtc: undefined,
        lastUpdateUtc: undefined,
    };
}
export const CollectionResponse = {
    $type: "devvit.plugin.redditapi.postcollections.CollectionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
        }
        if (message.authorId !== undefined) {
            StringValue.encode({ value: message.authorId }, writer.uint32(42).fork()).ldelim();
        }
        if (message.authorName !== undefined) {
            StringValue.encode({ value: message.authorName }, writer.uint32(50).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.linkIds) {
            StringValue.encode({ value: v }, writer.uint32(66).fork()).ldelim();
        }
        if (message.primaryLinkId !== undefined) {
            StringValue.encode({ value: message.primaryLinkId }, writer.uint32(74).fork()).ldelim();
        }
        if (message.displayLayout !== undefined) {
            StringValue.encode({ value: message.displayLayout }, writer.uint32(82).fork()).ldelim();
        }
        if (message.createdAtUtc !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAtUtc), writer.uint32(90).fork()).ldelim();
        }
        if (message.lastUpdateUtc !== undefined) {
            Timestamp.encode(toTimestamp(message.lastUpdateUtc), writer.uint32(98).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCollectionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.authorId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.authorName = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.linkIds.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.primaryLinkId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.createdAtUtc = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.lastUpdateUtc = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            authorId: isSet(object.authorId) ? String(object.authorId) : undefined,
            authorName: isSet(object.authorName) ? String(object.authorName) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            linkIds: globalThis.Array.isArray(object?.linkIds) ? object.linkIds.map((e) => String(e)) : [],
            primaryLinkId: isSet(object.primaryLinkId) ? String(object.primaryLinkId) : undefined,
            displayLayout: isSet(object.displayLayout) ? String(object.displayLayout) : undefined,
            createdAtUtc: isSet(object.createdAtUtc) ? fromJsonTimestamp(object.createdAtUtc) : undefined,
            lastUpdateUtc: isSet(object.lastUpdateUtc) ? fromJsonTimestamp(object.lastUpdateUtc) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collectionId !== undefined) {
            obj.collectionId = message.collectionId;
        }
        if (message.subredditId !== undefined) {
            obj.subredditId = message.subredditId;
        }
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.authorId !== undefined) {
            obj.authorId = message.authorId;
        }
        if (message.authorName !== undefined) {
            obj.authorName = message.authorName;
        }
        if (message.permalink !== undefined) {
            obj.permalink = message.permalink;
        }
        if (message.linkIds?.length) {
            obj.linkIds = message.linkIds;
        }
        if (message.primaryLinkId !== undefined) {
            obj.primaryLinkId = message.primaryLinkId;
        }
        if (message.displayLayout !== undefined) {
            obj.displayLayout = message.displayLayout;
        }
        if (message.createdAtUtc !== undefined) {
            obj.createdAtUtc = message.createdAtUtc.toISOString();
        }
        if (message.lastUpdateUtc !== undefined) {
            obj.lastUpdateUtc = message.lastUpdateUtc.toISOString();
        }
        return obj;
    },
    create(base) {
        return CollectionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCollectionResponse();
        message.collectionId = object.collectionId ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.title = object.title ?? undefined;
        message.description = object.description ?? undefined;
        message.authorId = object.authorId ?? undefined;
        message.authorName = object.authorName ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.linkIds = object.linkIds?.map((e) => e) || [];
        message.primaryLinkId = object.primaryLinkId ?? undefined;
        message.displayLayout = object.displayLayout ?? undefined;
        message.createdAtUtc = object.createdAtUtc ?? undefined;
        message.lastUpdateUtc = object.lastUpdateUtc ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(CollectionResponse.$type, CollectionResponse);
function createBaseSubredditCollectionsResponse() {
    return { collections: [] };
}
export const SubredditCollectionsResponse = {
    $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.collections) {
            CollectionResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditCollectionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.collections.push(CollectionResponse.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            collections: globalThis.Array.isArray(object?.collections)
                ? object.collections.map((e) => CollectionResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collections?.length) {
            obj.collections = message.collections.map((e) => CollectionResponse.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return SubredditCollectionsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubredditCollectionsResponse();
        message.collections = object.collections?.map((e) => CollectionResponse.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(SubredditCollectionsResponse.$type, SubredditCollectionsResponse);
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
