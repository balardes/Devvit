"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer4;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer4.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer4.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function Buffer4(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer4.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer4.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer4.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer4, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer4.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer4.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer4.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike2(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike2(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer4.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike2(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike2(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer4.alloc(+length);
    }
    Buffer4.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer4.prototype;
    };
    Buffer4.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer4.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer4.from(b, b.offset, b.byteLength);
      if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer4.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer4.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer4.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer4.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer4.isBuffer(buf))
              buf = Buffer4.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer4.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer4.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer4.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer4.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer4.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
    Buffer4.prototype.equals = function equals(b) {
      if (!Buffer4.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer4.compare(this, b) === 0;
    };
    Buffer4.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
    }
    Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer4.from(target, target.offset, target.byteLength);
      }
      if (!Buffer4.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
      }
      if (Buffer4.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer4.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer4.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer4.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer4.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer4.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer4.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject36(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet142(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer4 = util.inquire("buffer").Buffer;
        return Buffer4.prototype.utf8Write ? Buffer4 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer4 = util.Buffer;
      if (!Buffer4) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer4.from !== Uint8Array.from && Buffer4.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer4(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer4.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer4(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/long/src/long.js
var require_long = __commonJS({
  "../../node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long17;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long17(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long17.prototype.__isLong__;
    Object.defineProperty(Long17.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long17.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long17.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long17.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long17(lowBits, highBits, unsigned);
    }
    Long17.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long17.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long17.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long17.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long17.UZERO = UZERO;
    var ONE = fromInt(1);
    Long17.ONE = ONE;
    var UONE = fromInt(1, true);
    Long17.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long17.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long17.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long17.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long17.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long17.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long17.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long17.fromBytesLE(bytes, unsigned) : Long17.fromBytesBE(bytes, unsigned);
    };
    Long17.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long17(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long17.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long17(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var AS = hasAbortController ? AbortSignal : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e = { type, target: this };
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache2);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache2;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache2;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache2 = class _LRUCache {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          noDeleteOnFetchRejection
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl) => {
          this.starts[index] = ttl !== 0 ? perf.now() : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => this.calculatedSize -= this.sizes[index];
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, v, k, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, v, k, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes()) {
          const key = this.keyList[i];
          const value = this.valList[i];
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, v, k, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, v, k, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          return this.valList[index];
        }
      }
      backgroundFetch(k, index, options) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options
        };
        const cb = (v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, { allowStale, updateAgeOnGet });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              this.delete(k);
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache2;
  }
});

// src/lib/getRandomValues.polyfill.ts
if (globalThis.crypto?.getRandomValues == null) {
  let getRandomValues2;
  if (typeof require === "function") {
    const nodeCrypto = require("crypto");
    getRandomValues2 = (array) => {
      if (!isTypedArray(array) || array instanceof BigInt64Array || array instanceof BigUint64Array)
        throw Error("Expected number TypedArray.");
      array.set(nodeCrypto.pseudoRandomBytes(array.length));
      return array;
    };
  } else {
    getRandomValues2 = (array) => {
      if (!isTypedArray(array) || array instanceof BigInt64Array || array instanceof BigUint64Array)
        throw Error("Expected number TypedArray.");
      array.set(array.map(() => Math.floor(Math.random() * 256)));
      return array;
    };
  }
  if (globalThis.crypto == null) {
    globalThis.crypto = {};
  }
  globalThis.crypto.getRandomValues = getRandomValues2;
}
function isTypedArray(val) {
  return ArrayBuffer.isView(val) && !(val instanceof DataView);
}

// src/lib/Buffer.polyfill.ts
var import_buffer = __toESM(require_buffer(), 1);
globalThis.Buffer ?? (globalThis.Buffer = import_buffer.Buffer);

// ../protos/dist/types/typeRegistry.js
var messageTypeRegistry = /* @__PURE__ */ new Map();

// ../protos/dist/types/devvit/uuid.js
var import_minimal = __toESM(require_minimal2(), 1);
function createBaseUUID() {
  return { id: "" };
}
var UUID = {
  $type: "devvit.UUID",
  encode(message, writer = import_minimal.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUUID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return UUID.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUUID();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(UUID.$type, UUID);
function isSet(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/type/datetime.js
var import_minimal3 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/google/protobuf/duration.js
var import_long = __toESM(require_long(), 1);
var import_minimal2 = __toESM(require_minimal2(), 1);
function createBaseDuration() {
  return { seconds: 0, nanos: 0 };
}
var Duration = {
  $type: "google.protobuf.Duration",
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.seconds = longToNumber(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.nanos = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet2(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanos: isSet2(object.nanos) ? globalThis.Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },
  create(base) {
    return Duration.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDuration();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Duration.$type, Duration);
function longToNumber(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal2.default.util.Long !== import_long.default) {
  import_minimal2.default.util.Long = import_long.default;
  import_minimal2.default.configure();
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/type/datetime.js
function createBaseDateTime() {
  return {
    year: 0,
    month: 0,
    day: 0,
    hours: 0,
    minutes: 0,
    seconds: 0,
    nanos: 0,
    utcOffset: void 0,
    timeZone: void 0
  };
}
var DateTime = {
  $type: "google.type.DateTime",
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.year !== 0) {
      writer.uint32(8).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(16).int32(message.month);
    }
    if (message.day !== 0) {
      writer.uint32(24).int32(message.day);
    }
    if (message.hours !== 0) {
      writer.uint32(32).int32(message.hours);
    }
    if (message.minutes !== 0) {
      writer.uint32(40).int32(message.minutes);
    }
    if (message.seconds !== 0) {
      writer.uint32(48).int32(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(56).int32(message.nanos);
    }
    if (message.utcOffset !== void 0) {
      Duration.encode(message.utcOffset, writer.uint32(66).fork()).ldelim();
    }
    if (message.timeZone !== void 0) {
      TimeZone.encode(message.timeZone, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDateTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.year = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.month = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.day = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.hours = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.minutes = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.seconds = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.nanos = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.utcOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.timeZone = TimeZone.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      year: isSet3(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet3(object.month) ? globalThis.Number(object.month) : 0,
      day: isSet3(object.day) ? globalThis.Number(object.day) : 0,
      hours: isSet3(object.hours) ? globalThis.Number(object.hours) : 0,
      minutes: isSet3(object.minutes) ? globalThis.Number(object.minutes) : 0,
      seconds: isSet3(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanos: isSet3(object.nanos) ? globalThis.Number(object.nanos) : 0,
      utcOffset: isSet3(object.utcOffset) ? Duration.fromJSON(object.utcOffset) : void 0,
      timeZone: isSet3(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.day !== 0) {
      obj.day = Math.round(message.day);
    }
    if (message.hours !== 0) {
      obj.hours = Math.round(message.hours);
    }
    if (message.minutes !== 0) {
      obj.minutes = Math.round(message.minutes);
    }
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    if (message.utcOffset !== void 0) {
      obj.utcOffset = Duration.toJSON(message.utcOffset);
    }
    if (message.timeZone !== void 0) {
      obj.timeZone = TimeZone.toJSON(message.timeZone);
    }
    return obj;
  },
  create(base) {
    return DateTime.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDateTime();
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.day = object.day ?? 0;
    message.hours = object.hours ?? 0;
    message.minutes = object.minutes ?? 0;
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    message.utcOffset = object.utcOffset !== void 0 && object.utcOffset !== null ? Duration.fromPartial(object.utcOffset) : void 0;
    message.timeZone = object.timeZone !== void 0 && object.timeZone !== null ? TimeZone.fromPartial(object.timeZone) : void 0;
    return message;
  }
};
messageTypeRegistry.set(DateTime.$type, DateTime);
function createBaseTimeZone() {
  return { id: "", version: "" };
}
var TimeZone = {
  $type: "google.type.TimeZone",
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimeZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet3(object.id) ? globalThis.String(object.id) : "",
      version: isSet3(object.version) ? globalThis.String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },
  create(base) {
    return TimeZone.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTimeZone();
    message.id = object.id ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set(TimeZone.$type, TimeZone);
function isSet3(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/wrappers.js
var import_long2 = __toESM(require_long(), 1);
var import_minimal4 = __toESM(require_minimal2(), 1);
function createBaseDoubleValue() {
  return { value: 0 };
}
var DoubleValue = {
  $type: "google.protobuf.DoubleValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDoubleValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }
          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return DoubleValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDoubleValue();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(DoubleValue.$type, DoubleValue);
function createBaseFloatValue() {
  return { value: 0 };
}
var FloatValue = {
  $type: "google.protobuf.FloatValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFloatValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }
          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FloatValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFloatValue();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FloatValue.$type, FloatValue);
function createBaseInt64Value() {
  return { value: 0 };
}
var Int64Value = {
  $type: "google.protobuf.Int64Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int64(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInt64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = longToNumber2(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },
  create(base) {
    return Int64Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInt64Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Int64Value.$type, Int64Value);
function createBaseUInt64Value() {
  return { value: 0 };
}
var UInt64Value = {
  $type: "google.protobuf.UInt64Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUInt64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = longToNumber2(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },
  create(base) {
    return UInt64Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUInt64Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(UInt64Value.$type, UInt64Value);
function createBaseInt32Value() {
  return { value: 0 };
}
var Int32Value = {
  $type: "google.protobuf.Int32Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInt32Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },
  create(base) {
    return Int32Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInt32Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Int32Value.$type, Int32Value);
function createBaseUInt32Value() {
  return { value: 0 };
}
var UInt32Value = {
  $type: "google.protobuf.UInt32Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUInt32Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },
  create(base) {
    return UInt32Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUInt32Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(UInt32Value.$type, UInt32Value);
function createBaseBoolValue() {
  return { value: false };
}
var BoolValue = {
  $type: "google.protobuf.BoolValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.Boolean(object.value) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return BoolValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBoolValue();
    message.value = object.value ?? false;
    return message;
  }
};
messageTypeRegistry.set(BoolValue.$type, BoolValue);
function createBaseStringValue() {
  return { value: "" };
}
var StringValue = {
  $type: "google.protobuf.StringValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? globalThis.String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return StringValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStringValue();
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(StringValue.$type, StringValue);
function createBaseBytesValue() {
  return { value: new Uint8Array(0) };
}
var BytesValue = {
  $type: "google.protobuf.BytesValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBytesValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet4(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
  },
  toJSON(message) {
    const obj = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },
  create(base) {
    return BytesValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBytesValue();
    message.value = object.value ?? new Uint8Array(0);
    return message;
  }
};
messageTypeRegistry.set(BytesValue.$type, BytesValue);
function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function longToNumber2(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal4.default.util.Long !== import_long2.default) {
  import_minimal4.default.util.Long = import_long2.default;
  import_minimal4.default.configure();
}
function isSet4(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/timestamp.js
var import_long3 = __toESM(require_long(), 1);
var import_minimal5 = __toESM(require_minimal2(), 1);
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
var Timestamp = {
  $type: "google.protobuf.Timestamp",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.seconds = longToNumber3(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.nanos = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet5(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanos: isSet5(object.nanos) ? globalThis.Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },
  create(base) {
    return Timestamp.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTimestamp();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Timestamp.$type, Timestamp);
function longToNumber3(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal5.default.util.Long !== import_long3.default) {
  import_minimal5.default.util.Long = import_long3.default;
  import_minimal5.default.configure();
}
function isSet5(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/struct.js
var import_minimal6 = __toESM(require_minimal2(), 1);
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
  NullValue2[NullValue2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NullValue || (NullValue = {}));
function nullValueFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return NullValue.NULL_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NullValue.UNRECOGNIZED;
  }
}
function nullValueToJSON(object) {
  switch (object) {
    case NullValue.NULL_VALUE:
      return 0;
    case NullValue.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseStruct() {
  return { fields: {} };
}
var Struct = {
  $type: "google.protobuf.Struct",
  encode(message, writer = import_minimal6.default.Writer.create()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        Struct_FieldsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
      }
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: isObject(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return Struct.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStruct();
    message.fields = Object.entries(object.fields ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  },
  wrap(object) {
    const struct = createBaseStruct();
    if (object !== void 0) {
      for (const key of Object.keys(object)) {
        struct.fields[key] = object[key];
      }
    }
    return struct;
  },
  unwrap(message) {
    const object = {};
    if (message.fields) {
      for (const key of Object.keys(message.fields)) {
        object[key] = message.fields[key];
      }
    }
    return object;
  }
};
messageTypeRegistry.set(Struct.$type, Struct);
function createBaseStruct_FieldsEntry() {
  return { key: "", value: void 0 };
}
var Struct_FieldsEntry = {
  $type: "google.protobuf.Struct.FieldsEntry",
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet6(object.key) ? globalThis.String(object.key) : "",
      value: isSet6(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Struct_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStruct_FieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Struct_FieldsEntry.$type, Struct_FieldsEntry);
function createBaseValue() {
  return {
    nullValue: void 0,
    numberValue: void 0,
    stringValue: void 0,
    boolValue: void 0,
    structValue: void 0,
    listValue: void 0
  };
}
var Value = {
  $type: "google.protobuf.Value",
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.nullValue !== void 0) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).ldelim();
    }
    if (message.listValue !== void 0) {
      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.nullValue = reader.int32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.numberValue = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      nullValue: isSet6(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
      numberValue: isSet6(object.numberValue) ? globalThis.Number(object.numberValue) : void 0,
      stringValue: isSet6(object.stringValue) ? globalThis.String(object.stringValue) : void 0,
      boolValue: isSet6(object.boolValue) ? globalThis.Boolean(object.boolValue) : void 0,
      structValue: isObject(object.structValue) ? object.structValue : void 0,
      listValue: globalThis.Array.isArray(object.listValue) ? [...object.listValue] : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.nullValue !== void 0) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      obj.numberValue = message.numberValue;
    }
    if (message.stringValue !== void 0) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== void 0) {
      obj.boolValue = message.boolValue;
    }
    if (message.structValue !== void 0) {
      obj.structValue = message.structValue;
    }
    if (message.listValue !== void 0) {
      obj.listValue = message.listValue;
    }
    return obj;
  },
  create(base) {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValue();
    message.nullValue = object.nullValue ?? void 0;
    message.numberValue = object.numberValue ?? void 0;
    message.stringValue = object.stringValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    message.structValue = object.structValue ?? void 0;
    message.listValue = object.listValue ?? void 0;
    return message;
  },
  wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = NullValue.NULL_VALUE;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (globalThis.Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new globalThis.Error("Unsupported any value type: " + typeof value);
    }
    return result;
  },
  unwrap(message) {
    if (message.stringValue !== void 0) {
      return message.stringValue;
    } else if (message?.numberValue !== void 0) {
      return message.numberValue;
    } else if (message?.boolValue !== void 0) {
      return message.boolValue;
    } else if (message?.structValue !== void 0) {
      return message.structValue;
    } else if (message?.listValue !== void 0) {
      return message.listValue;
    } else if (message?.nullValue !== void 0) {
      return null;
    }
    return void 0;
  }
};
messageTypeRegistry.set(Value.$type, Value);
function createBaseListValue() {
  return { values: [] };
}
var ListValue = {
  $type: "google.protobuf.ListValue",
  encode(message, writer = import_minimal6.default.Writer.create()) {
    for (const v of message.values) {
      Value.encode(Value.wrap(v), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { values: globalThis.Array.isArray(object?.values) ? [...object.values] : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return ListValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
  wrap(array) {
    const result = createBaseListValue();
    result.values = array ?? [];
    return result;
  },
  unwrap(message) {
    if (message?.hasOwnProperty("values") && globalThis.Array.isArray(message.values)) {
      return message.values;
    } else {
      return message;
    }
  }
};
messageTypeRegistry.set(ListValue.$type, ListValue);
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet6(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/empty.js
var import_minimal7 = __toESM(require_minimal2(), 1);
function createBaseEmpty() {
  return {};
}
var Empty = {
  $type: "google.protobuf.Empty",
  encode(_, writer = import_minimal7.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : import_minimal7.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseEmpty();
    return message;
  }
};
messageTypeRegistry.set(Empty.$type, Empty);

// ../protos/dist/types/google/protobuf/descriptor.js
var import_long4 = __toESM(require_long(), 1);
var import_minimal8 = __toESM(require_minimal2(), 1);
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_INT64"] = 3] = "TYPE_INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_INT32"] = 5] = "TYPE_INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_STRING"] = 9] = "TYPE_STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
function fieldDescriptorProto_TypeFromJSON(object) {
  switch (object) {
    case 1:
    case "TYPE_DOUBLE":
      return FieldDescriptorProto_Type.TYPE_DOUBLE;
    case 2:
    case "TYPE_FLOAT":
      return FieldDescriptorProto_Type.TYPE_FLOAT;
    case 3:
    case "TYPE_INT64":
      return FieldDescriptorProto_Type.TYPE_INT64;
    case 4:
    case "TYPE_UINT64":
      return FieldDescriptorProto_Type.TYPE_UINT64;
    case 5:
    case "TYPE_INT32":
      return FieldDescriptorProto_Type.TYPE_INT32;
    case 6:
    case "TYPE_FIXED64":
      return FieldDescriptorProto_Type.TYPE_FIXED64;
    case 7:
    case "TYPE_FIXED32":
      return FieldDescriptorProto_Type.TYPE_FIXED32;
    case 8:
    case "TYPE_BOOL":
      return FieldDescriptorProto_Type.TYPE_BOOL;
    case 9:
    case "TYPE_STRING":
      return FieldDescriptorProto_Type.TYPE_STRING;
    case 10:
    case "TYPE_GROUP":
      return FieldDescriptorProto_Type.TYPE_GROUP;
    case 11:
    case "TYPE_MESSAGE":
      return FieldDescriptorProto_Type.TYPE_MESSAGE;
    case 12:
    case "TYPE_BYTES":
      return FieldDescriptorProto_Type.TYPE_BYTES;
    case 13:
    case "TYPE_UINT32":
      return FieldDescriptorProto_Type.TYPE_UINT32;
    case 14:
    case "TYPE_ENUM":
      return FieldDescriptorProto_Type.TYPE_ENUM;
    case 15:
    case "TYPE_SFIXED32":
      return FieldDescriptorProto_Type.TYPE_SFIXED32;
    case 16:
    case "TYPE_SFIXED64":
      return FieldDescriptorProto_Type.TYPE_SFIXED64;
    case 17:
    case "TYPE_SINT32":
      return FieldDescriptorProto_Type.TYPE_SINT32;
    case 18:
    case "TYPE_SINT64":
      return FieldDescriptorProto_Type.TYPE_SINT64;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldDescriptorProto_Type.UNRECOGNIZED;
  }
}
function fieldDescriptorProto_TypeToJSON(object) {
  switch (object) {
    case FieldDescriptorProto_Type.TYPE_DOUBLE:
      return 1;
    case FieldDescriptorProto_Type.TYPE_FLOAT:
      return 2;
    case FieldDescriptorProto_Type.TYPE_INT64:
      return 3;
    case FieldDescriptorProto_Type.TYPE_UINT64:
      return 4;
    case FieldDescriptorProto_Type.TYPE_INT32:
      return 5;
    case FieldDescriptorProto_Type.TYPE_FIXED64:
      return 6;
    case FieldDescriptorProto_Type.TYPE_FIXED32:
      return 7;
    case FieldDescriptorProto_Type.TYPE_BOOL:
      return 8;
    case FieldDescriptorProto_Type.TYPE_STRING:
      return 9;
    case FieldDescriptorProto_Type.TYPE_GROUP:
      return 10;
    case FieldDescriptorProto_Type.TYPE_MESSAGE:
      return 11;
    case FieldDescriptorProto_Type.TYPE_BYTES:
      return 12;
    case FieldDescriptorProto_Type.TYPE_UINT32:
      return 13;
    case FieldDescriptorProto_Type.TYPE_ENUM:
      return 14;
    case FieldDescriptorProto_Type.TYPE_SFIXED32:
      return 15;
    case FieldDescriptorProto_Type.TYPE_SFIXED64:
      return 16;
    case FieldDescriptorProto_Type.TYPE_SINT32:
      return 17;
    case FieldDescriptorProto_Type.TYPE_SINT64:
      return 18;
    case FieldDescriptorProto_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_OPTIONAL"] = 1] = "LABEL_OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_REQUIRED"] = 2] = "LABEL_REQUIRED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_REPEATED"] = 3] = "LABEL_REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
function fieldDescriptorProto_LabelFromJSON(object) {
  switch (object) {
    case 1:
    case "LABEL_OPTIONAL":
      return FieldDescriptorProto_Label.LABEL_OPTIONAL;
    case 2:
    case "LABEL_REQUIRED":
      return FieldDescriptorProto_Label.LABEL_REQUIRED;
    case 3:
    case "LABEL_REPEATED":
      return FieldDescriptorProto_Label.LABEL_REPEATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldDescriptorProto_Label.UNRECOGNIZED;
  }
}
function fieldDescriptorProto_LabelToJSON(object) {
  switch (object) {
    case FieldDescriptorProto_Label.LABEL_OPTIONAL:
      return 1;
    case FieldDescriptorProto_Label.LABEL_REQUIRED:
      return 2;
    case FieldDescriptorProto_Label.LABEL_REPEATED:
      return 3;
    case FieldDescriptorProto_Label.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
function fileOptions_OptimizeModeFromJSON(object) {
  switch (object) {
    case 1:
    case "SPEED":
      return FileOptions_OptimizeMode.SPEED;
    case 2:
    case "CODE_SIZE":
      return FileOptions_OptimizeMode.CODE_SIZE;
    case 3:
    case "LITE_RUNTIME":
      return FileOptions_OptimizeMode.LITE_RUNTIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileOptions_OptimizeMode.UNRECOGNIZED;
  }
}
function fileOptions_OptimizeModeToJSON(object) {
  switch (object) {
    case FileOptions_OptimizeMode.SPEED:
      return 1;
    case FileOptions_OptimizeMode.CODE_SIZE:
      return 2;
    case FileOptions_OptimizeMode.LITE_RUNTIME:
      return 3;
    case FileOptions_OptimizeMode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
  FieldOptions_CType2[FieldOptions_CType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_CType || (FieldOptions_CType = {}));
function fieldOptions_CTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return FieldOptions_CType.STRING;
    case 1:
    case "CORD":
      return FieldOptions_CType.CORD;
    case 2:
    case "STRING_PIECE":
      return FieldOptions_CType.STRING_PIECE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_CType.UNRECOGNIZED;
  }
}
function fieldOptions_CTypeToJSON(object) {
  switch (object) {
    case FieldOptions_CType.STRING:
      return 0;
    case FieldOptions_CType.CORD:
      return 1;
    case FieldOptions_CType.STRING_PIECE:
      return 2;
    case FieldOptions_CType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
  FieldOptions_JSType2[FieldOptions_JSType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_JSType || (FieldOptions_JSType = {}));
function fieldOptions_JSTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "JS_NORMAL":
      return FieldOptions_JSType.JS_NORMAL;
    case 1:
    case "JS_STRING":
      return FieldOptions_JSType.JS_STRING;
    case 2:
    case "JS_NUMBER":
      return FieldOptions_JSType.JS_NUMBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_JSType.UNRECOGNIZED;
  }
}
function fieldOptions_JSTypeToJSON(object) {
  switch (object) {
    case FieldOptions_JSType.JS_NORMAL:
      return 0;
    case FieldOptions_JSType.JS_STRING:
      return 1;
    case FieldOptions_JSType.JS_NUMBER:
      return 2;
    case FieldOptions_JSType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
function fieldOptions_OptionRetentionFromJSON(object) {
  switch (object) {
    case 0:
    case "RETENTION_UNKNOWN":
      return FieldOptions_OptionRetention.RETENTION_UNKNOWN;
    case 1:
    case "RETENTION_RUNTIME":
      return FieldOptions_OptionRetention.RETENTION_RUNTIME;
    case 2:
    case "RETENTION_SOURCE":
      return FieldOptions_OptionRetention.RETENTION_SOURCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_OptionRetention.UNRECOGNIZED;
  }
}
function fieldOptions_OptionRetentionToJSON(object) {
  switch (object) {
    case FieldOptions_OptionRetention.RETENTION_UNKNOWN:
      return 0;
    case FieldOptions_OptionRetention.RETENTION_RUNTIME:
      return 1;
    case FieldOptions_OptionRetention.RETENTION_SOURCE:
      return 2;
    case FieldOptions_OptionRetention.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
function fieldOptions_OptionTargetTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "TARGET_TYPE_UNKNOWN":
      return FieldOptions_OptionTargetType.TARGET_TYPE_UNKNOWN;
    case 1:
    case "TARGET_TYPE_FILE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_FILE;
    case 2:
    case "TARGET_TYPE_EXTENSION_RANGE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_EXTENSION_RANGE;
    case 3:
    case "TARGET_TYPE_MESSAGE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_MESSAGE;
    case 4:
    case "TARGET_TYPE_FIELD":
      return FieldOptions_OptionTargetType.TARGET_TYPE_FIELD;
    case 5:
    case "TARGET_TYPE_ONEOF":
      return FieldOptions_OptionTargetType.TARGET_TYPE_ONEOF;
    case 6:
    case "TARGET_TYPE_ENUM":
      return FieldOptions_OptionTargetType.TARGET_TYPE_ENUM;
    case 7:
    case "TARGET_TYPE_ENUM_ENTRY":
      return FieldOptions_OptionTargetType.TARGET_TYPE_ENUM_ENTRY;
    case 8:
    case "TARGET_TYPE_SERVICE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_SERVICE;
    case 9:
    case "TARGET_TYPE_METHOD":
      return FieldOptions_OptionTargetType.TARGET_TYPE_METHOD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_OptionTargetType.UNRECOGNIZED;
  }
}
function fieldOptions_OptionTargetTypeToJSON(object) {
  switch (object) {
    case FieldOptions_OptionTargetType.TARGET_TYPE_UNKNOWN:
      return 0;
    case FieldOptions_OptionTargetType.TARGET_TYPE_FILE:
      return 1;
    case FieldOptions_OptionTargetType.TARGET_TYPE_EXTENSION_RANGE:
      return 2;
    case FieldOptions_OptionTargetType.TARGET_TYPE_MESSAGE:
      return 3;
    case FieldOptions_OptionTargetType.TARGET_TYPE_FIELD:
      return 4;
    case FieldOptions_OptionTargetType.TARGET_TYPE_ONEOF:
      return 5;
    case FieldOptions_OptionTargetType.TARGET_TYPE_ENUM:
      return 6;
    case FieldOptions_OptionTargetType.TARGET_TYPE_ENUM_ENTRY:
      return 7;
    case FieldOptions_OptionTargetType.TARGET_TYPE_SERVICE:
      return 8;
    case FieldOptions_OptionTargetType.TARGET_TYPE_METHOD:
      return 9;
    case FieldOptions_OptionTargetType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
function methodOptions_IdempotencyLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "IDEMPOTENCY_UNKNOWN":
      return MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN;
    case 1:
    case "NO_SIDE_EFFECTS":
      return MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;
    case 2:
    case "IDEMPOTENT":
      return MethodOptions_IdempotencyLevel.IDEMPOTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MethodOptions_IdempotencyLevel.UNRECOGNIZED;
  }
}
function methodOptions_IdempotencyLevelToJSON(object) {
  switch (object) {
    case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:
      return 0;
    case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:
      return 1;
    case MethodOptions_IdempotencyLevel.IDEMPOTENT:
      return 2;
    case MethodOptions_IdempotencyLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
function generatedCodeInfo_Annotation_SemanticFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return GeneratedCodeInfo_Annotation_Semantic.NONE;
    case 1:
    case "SET":
      return GeneratedCodeInfo_Annotation_Semantic.SET;
    case 2:
    case "ALIAS":
      return GeneratedCodeInfo_Annotation_Semantic.ALIAS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GeneratedCodeInfo_Annotation_Semantic.UNRECOGNIZED;
  }
}
function generatedCodeInfo_Annotation_SemanticToJSON(object) {
  switch (object) {
    case GeneratedCodeInfo_Annotation_Semantic.NONE:
      return 0;
    case GeneratedCodeInfo_Annotation_Semantic.SET:
      return 1;
    case GeneratedCodeInfo_Annotation_Semantic.ALIAS:
      return 2;
    case GeneratedCodeInfo_Annotation_Semantic.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseFileDescriptorSet() {
  return { file: [] };
}
var FileDescriptorSet = {
  $type: "google.protobuf.FileDescriptorSet",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    for (const v of message.file) {
      FileDescriptorProto.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.file.push(FileDescriptorProto.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      file: globalThis.Array.isArray(object?.file) ? object.file.map((e) => FileDescriptorProto.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.file?.length) {
      obj.file = message.file.map((e) => FileDescriptorProto.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FileDescriptorSet.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFileDescriptorSet();
    message.file = object.file?.map((e) => FileDescriptorProto.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FileDescriptorSet.$type, FileDescriptorSet);
function createBaseFileDescriptorProto() {
  return {
    name: "",
    package: "",
    dependency: [],
    publicDependency: [],
    weakDependency: [],
    messageType: [],
    enumType: [],
    service: [],
    extension: [],
    options: void 0,
    sourceCodeInfo: void 0,
    syntax: "",
    edition: ""
  };
}
var FileDescriptorProto = {
  $type: "google.protobuf.FileDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.package !== void 0 && message.package !== "") {
      writer.uint32(18).string(message.package);
    }
    for (const v of message.dependency) {
      writer.uint32(26).string(v);
    }
    writer.uint32(82).fork();
    for (const v of message.publicDependency) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(90).fork();
    for (const v of message.weakDependency) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.messageType) {
      DescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.enumType) {
      EnumDescriptorProto.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.service) {
      ServiceDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.extension) {
      FieldDescriptorProto.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.options !== void 0) {
      FileOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    if (message.sourceCodeInfo !== void 0) {
      SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.syntax !== void 0 && message.syntax !== "") {
      writer.uint32(98).string(message.syntax);
    }
    if (message.edition !== void 0 && message.edition !== "") {
      writer.uint32(106).string(message.edition);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.package = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.dependency.push(reader.string());
          continue;
        case 10:
          if (tag === 80) {
            message.publicDependency.push(reader.int32());
            continue;
          }
          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.publicDependency.push(reader.int32());
            }
            continue;
          }
          break;
        case 11:
          if (tag === 88) {
            message.weakDependency.push(reader.int32());
            continue;
          }
          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weakDependency.push(reader.int32());
            }
            continue;
          }
          break;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.messageType.push(DescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.service.push(ServiceDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.options = FileOptions.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.sourceCodeInfo = SourceCodeInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.syntax = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.edition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      package: isSet7(object.package) ? globalThis.String(object.package) : "",
      dependency: globalThis.Array.isArray(object?.dependency) ? object.dependency.map((e) => globalThis.String(e)) : [],
      publicDependency: globalThis.Array.isArray(object?.publicDependency) ? object.publicDependency.map((e) => globalThis.Number(e)) : [],
      weakDependency: globalThis.Array.isArray(object?.weakDependency) ? object.weakDependency.map((e) => globalThis.Number(e)) : [],
      messageType: globalThis.Array.isArray(object?.messageType) ? object.messageType.map((e) => DescriptorProto.fromJSON(e)) : [],
      enumType: globalThis.Array.isArray(object?.enumType) ? object.enumType.map((e) => EnumDescriptorProto.fromJSON(e)) : [],
      service: globalThis.Array.isArray(object?.service) ? object.service.map((e) => ServiceDescriptorProto.fromJSON(e)) : [],
      extension: globalThis.Array.isArray(object?.extension) ? object.extension.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      options: isSet7(object.options) ? FileOptions.fromJSON(object.options) : void 0,
      sourceCodeInfo: isSet7(object.sourceCodeInfo) ? SourceCodeInfo.fromJSON(object.sourceCodeInfo) : void 0,
      syntax: isSet7(object.syntax) ? globalThis.String(object.syntax) : "",
      edition: isSet7(object.edition) ? globalThis.String(object.edition) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.package !== void 0 && message.package !== "") {
      obj.package = message.package;
    }
    if (message.dependency?.length) {
      obj.dependency = message.dependency;
    }
    if (message.publicDependency?.length) {
      obj.publicDependency = message.publicDependency.map((e) => Math.round(e));
    }
    if (message.weakDependency?.length) {
      obj.weakDependency = message.weakDependency.map((e) => Math.round(e));
    }
    if (message.messageType?.length) {
      obj.messageType = message.messageType.map((e) => DescriptorProto.toJSON(e));
    }
    if (message.enumType?.length) {
      obj.enumType = message.enumType.map((e) => EnumDescriptorProto.toJSON(e));
    }
    if (message.service?.length) {
      obj.service = message.service.map((e) => ServiceDescriptorProto.toJSON(e));
    }
    if (message.extension?.length) {
      obj.extension = message.extension.map((e) => FieldDescriptorProto.toJSON(e));
    }
    if (message.options !== void 0) {
      obj.options = FileOptions.toJSON(message.options);
    }
    if (message.sourceCodeInfo !== void 0) {
      obj.sourceCodeInfo = SourceCodeInfo.toJSON(message.sourceCodeInfo);
    }
    if (message.syntax !== void 0 && message.syntax !== "") {
      obj.syntax = message.syntax;
    }
    if (message.edition !== void 0 && message.edition !== "") {
      obj.edition = message.edition;
    }
    return obj;
  },
  create(base) {
    return FileDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFileDescriptorProto();
    message.name = object.name ?? "";
    message.package = object.package ?? "";
    message.dependency = object.dependency?.map((e) => e) || [];
    message.publicDependency = object.publicDependency?.map((e) => e) || [];
    message.weakDependency = object.weakDependency?.map((e) => e) || [];
    message.messageType = object.messageType?.map((e) => DescriptorProto.fromPartial(e)) || [];
    message.enumType = object.enumType?.map((e) => EnumDescriptorProto.fromPartial(e)) || [];
    message.service = object.service?.map((e) => ServiceDescriptorProto.fromPartial(e)) || [];
    message.extension = object.extension?.map((e) => FieldDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? FileOptions.fromPartial(object.options) : void 0;
    message.sourceCodeInfo = object.sourceCodeInfo !== void 0 && object.sourceCodeInfo !== null ? SourceCodeInfo.fromPartial(object.sourceCodeInfo) : void 0;
    message.syntax = object.syntax ?? "";
    message.edition = object.edition ?? "";
    return message;
  }
};
messageTypeRegistry.set(FileDescriptorProto.$type, FileDescriptorProto);
function createBaseDescriptorProto() {
  return {
    name: "",
    field: [],
    extension: [],
    nestedType: [],
    enumType: [],
    extensionRange: [],
    oneofDecl: [],
    options: void 0,
    reservedRange: [],
    reservedName: []
  };
}
var DescriptorProto = {
  $type: "google.protobuf.DescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.field) {
      FieldDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.extension) {
      FieldDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.nestedType) {
      DescriptorProto.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.enumType) {
      EnumDescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.extensionRange) {
      DescriptorProto_ExtensionRange.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.oneofDecl) {
      OneofDescriptorProto.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.options !== void 0) {
      MessageOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.reservedRange) {
      DescriptorProto_ReservedRange.encode(v, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.reservedName) {
      writer.uint32(82).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.field.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.nestedType.push(DescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.extensionRange.push(DescriptorProto_ExtensionRange.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.oneofDecl.push(OneofDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.options = MessageOptions.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.reservedRange.push(DescriptorProto_ReservedRange.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.reservedName.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      field: globalThis.Array.isArray(object?.field) ? object.field.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      extension: globalThis.Array.isArray(object?.extension) ? object.extension.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      nestedType: globalThis.Array.isArray(object?.nestedType) ? object.nestedType.map((e) => DescriptorProto.fromJSON(e)) : [],
      enumType: globalThis.Array.isArray(object?.enumType) ? object.enumType.map((e) => EnumDescriptorProto.fromJSON(e)) : [],
      extensionRange: globalThis.Array.isArray(object?.extensionRange) ? object.extensionRange.map((e) => DescriptorProto_ExtensionRange.fromJSON(e)) : [],
      oneofDecl: globalThis.Array.isArray(object?.oneofDecl) ? object.oneofDecl.map((e) => OneofDescriptorProto.fromJSON(e)) : [],
      options: isSet7(object.options) ? MessageOptions.fromJSON(object.options) : void 0,
      reservedRange: globalThis.Array.isArray(object?.reservedRange) ? object.reservedRange.map((e) => DescriptorProto_ReservedRange.fromJSON(e)) : [],
      reservedName: globalThis.Array.isArray(object?.reservedName) ? object.reservedName.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.field?.length) {
      obj.field = message.field.map((e) => FieldDescriptorProto.toJSON(e));
    }
    if (message.extension?.length) {
      obj.extension = message.extension.map((e) => FieldDescriptorProto.toJSON(e));
    }
    if (message.nestedType?.length) {
      obj.nestedType = message.nestedType.map((e) => DescriptorProto.toJSON(e));
    }
    if (message.enumType?.length) {
      obj.enumType = message.enumType.map((e) => EnumDescriptorProto.toJSON(e));
    }
    if (message.extensionRange?.length) {
      obj.extensionRange = message.extensionRange.map((e) => DescriptorProto_ExtensionRange.toJSON(e));
    }
    if (message.oneofDecl?.length) {
      obj.oneofDecl = message.oneofDecl.map((e) => OneofDescriptorProto.toJSON(e));
    }
    if (message.options !== void 0) {
      obj.options = MessageOptions.toJSON(message.options);
    }
    if (message.reservedRange?.length) {
      obj.reservedRange = message.reservedRange.map((e) => DescriptorProto_ReservedRange.toJSON(e));
    }
    if (message.reservedName?.length) {
      obj.reservedName = message.reservedName;
    }
    return obj;
  },
  create(base) {
    return DescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDescriptorProto();
    message.name = object.name ?? "";
    message.field = object.field?.map((e) => FieldDescriptorProto.fromPartial(e)) || [];
    message.extension = object.extension?.map((e) => FieldDescriptorProto.fromPartial(e)) || [];
    message.nestedType = object.nestedType?.map((e) => DescriptorProto.fromPartial(e)) || [];
    message.enumType = object.enumType?.map((e) => EnumDescriptorProto.fromPartial(e)) || [];
    message.extensionRange = object.extensionRange?.map((e) => DescriptorProto_ExtensionRange.fromPartial(e)) || [];
    message.oneofDecl = object.oneofDecl?.map((e) => OneofDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? MessageOptions.fromPartial(object.options) : void 0;
    message.reservedRange = object.reservedRange?.map((e) => DescriptorProto_ReservedRange.fromPartial(e)) || [];
    message.reservedName = object.reservedName?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(DescriptorProto.$type, DescriptorProto);
function createBaseDescriptorProto_ExtensionRange() {
  return { start: 0, end: 0, options: void 0 };
}
var DescriptorProto_ExtensionRange = {
  $type: "google.protobuf.DescriptorProto.ExtensionRange",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.start !== void 0 && message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== void 0 && message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.options !== void 0) {
      ExtensionRangeOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto_ExtensionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.end = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.options = ExtensionRangeOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet7(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet7(object.end) ? globalThis.Number(object.end) : 0,
      options: isSet7(object.options) ? ExtensionRangeOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.start !== void 0 && message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== void 0 && message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.options !== void 0) {
      obj.options = ExtensionRangeOptions.toJSON(message.options);
    }
    return obj;
  },
  create(base) {
    return DescriptorProto_ExtensionRange.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDescriptorProto_ExtensionRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.options = object.options !== void 0 && object.options !== null ? ExtensionRangeOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set(DescriptorProto_ExtensionRange.$type, DescriptorProto_ExtensionRange);
function createBaseDescriptorProto_ReservedRange() {
  return { start: 0, end: 0 };
}
var DescriptorProto_ReservedRange = {
  $type: "google.protobuf.DescriptorProto.ReservedRange",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.start !== void 0 && message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== void 0 && message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto_ReservedRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.end = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet7(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet7(object.end) ? globalThis.Number(object.end) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.start !== void 0 && message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== void 0 && message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },
  create(base) {
    return DescriptorProto_ReservedRange.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDescriptorProto_ReservedRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  }
};
messageTypeRegistry.set(DescriptorProto_ReservedRange.$type, DescriptorProto_ReservedRange);
function createBaseExtensionRangeOptions() {
  return { uninterpretedOption: [] };
}
var ExtensionRangeOptions = {
  $type: "google.protobuf.ExtensionRangeOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionRangeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ExtensionRangeOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseExtensionRangeOptions();
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ExtensionRangeOptions.$type, ExtensionRangeOptions);
function createBaseFieldDescriptorProto() {
  return {
    name: "",
    number: 0,
    label: 1,
    type: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    options: void 0,
    proto3Optional: false
  };
}
var FieldDescriptorProto = {
  $type: "google.protobuf.FieldDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== void 0 && message.number !== 0) {
      writer.uint32(24).int32(message.number);
    }
    if (message.label !== void 0 && message.label !== 1) {
      writer.uint32(32).int32(message.label);
    }
    if (message.type !== void 0 && message.type !== 1) {
      writer.uint32(40).int32(message.type);
    }
    if (message.typeName !== void 0 && message.typeName !== "") {
      writer.uint32(50).string(message.typeName);
    }
    if (message.extendee !== void 0 && message.extendee !== "") {
      writer.uint32(18).string(message.extendee);
    }
    if (message.defaultValue !== void 0 && message.defaultValue !== "") {
      writer.uint32(58).string(message.defaultValue);
    }
    if (message.oneofIndex !== void 0 && message.oneofIndex !== 0) {
      writer.uint32(72).int32(message.oneofIndex);
    }
    if (message.jsonName !== void 0 && message.jsonName !== "") {
      writer.uint32(82).string(message.jsonName);
    }
    if (message.options !== void 0) {
      FieldOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    if (message.proto3Optional !== void 0 && message.proto3Optional !== false) {
      writer.uint32(136).bool(message.proto3Optional);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.number = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.label = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.typeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.extendee = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.defaultValue = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.oneofIndex = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.jsonName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.options = FieldOptions.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }
          message.proto3Optional = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      number: isSet7(object.number) ? globalThis.Number(object.number) : 0,
      label: isSet7(object.label) ? fieldDescriptorProto_LabelFromJSON(object.label) : 1,
      type: isSet7(object.type) ? fieldDescriptorProto_TypeFromJSON(object.type) : 1,
      typeName: isSet7(object.typeName) ? globalThis.String(object.typeName) : "",
      extendee: isSet7(object.extendee) ? globalThis.String(object.extendee) : "",
      defaultValue: isSet7(object.defaultValue) ? globalThis.String(object.defaultValue) : "",
      oneofIndex: isSet7(object.oneofIndex) ? globalThis.Number(object.oneofIndex) : 0,
      jsonName: isSet7(object.jsonName) ? globalThis.String(object.jsonName) : "",
      options: isSet7(object.options) ? FieldOptions.fromJSON(object.options) : void 0,
      proto3Optional: isSet7(object.proto3Optional) ? globalThis.Boolean(object.proto3Optional) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.number !== void 0 && message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.label !== void 0 && message.label !== 1) {
      obj.label = fieldDescriptorProto_LabelToJSON(message.label);
    }
    if (message.type !== void 0 && message.type !== 1) {
      obj.type = fieldDescriptorProto_TypeToJSON(message.type);
    }
    if (message.typeName !== void 0 && message.typeName !== "") {
      obj.typeName = message.typeName;
    }
    if (message.extendee !== void 0 && message.extendee !== "") {
      obj.extendee = message.extendee;
    }
    if (message.defaultValue !== void 0 && message.defaultValue !== "") {
      obj.defaultValue = message.defaultValue;
    }
    if (message.oneofIndex !== void 0 && message.oneofIndex !== 0) {
      obj.oneofIndex = Math.round(message.oneofIndex);
    }
    if (message.jsonName !== void 0 && message.jsonName !== "") {
      obj.jsonName = message.jsonName;
    }
    if (message.options !== void 0) {
      obj.options = FieldOptions.toJSON(message.options);
    }
    if (message.proto3Optional !== void 0 && message.proto3Optional !== false) {
      obj.proto3Optional = message.proto3Optional;
    }
    return obj;
  },
  create(base) {
    return FieldDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldDescriptorProto();
    message.name = object.name ?? "";
    message.number = object.number ?? 0;
    message.label = object.label ?? 1;
    message.type = object.type ?? 1;
    message.typeName = object.typeName ?? "";
    message.extendee = object.extendee ?? "";
    message.defaultValue = object.defaultValue ?? "";
    message.oneofIndex = object.oneofIndex ?? 0;
    message.jsonName = object.jsonName ?? "";
    message.options = object.options !== void 0 && object.options !== null ? FieldOptions.fromPartial(object.options) : void 0;
    message.proto3Optional = object.proto3Optional ?? false;
    return message;
  }
};
messageTypeRegistry.set(FieldDescriptorProto.$type, FieldDescriptorProto);
function createBaseOneofDescriptorProto() {
  return { name: "", options: void 0 };
}
var OneofDescriptorProto = {
  $type: "google.protobuf.OneofDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.options !== void 0) {
      OneofOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOneofDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.options = OneofOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      options: isSet7(object.options) ? OneofOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.options !== void 0) {
      obj.options = OneofOptions.toJSON(message.options);
    }
    return obj;
  },
  create(base) {
    return OneofDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOneofDescriptorProto();
    message.name = object.name ?? "";
    message.options = object.options !== void 0 && object.options !== null ? OneofOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set(OneofDescriptorProto.$type, OneofDescriptorProto);
function createBaseEnumDescriptorProto() {
  return { name: "", value: [], options: void 0, reservedRange: [], reservedName: [] };
}
var EnumDescriptorProto = {
  $type: "google.protobuf.EnumDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.value) {
      EnumValueDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== void 0) {
      EnumOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.reservedRange) {
      EnumDescriptorProto_EnumReservedRange.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.reservedName) {
      writer.uint32(42).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value.push(EnumValueDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.options = EnumOptions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.reservedName.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e) => EnumValueDescriptorProto.fromJSON(e)) : [],
      options: isSet7(object.options) ? EnumOptions.fromJSON(object.options) : void 0,
      reservedRange: globalThis.Array.isArray(object?.reservedRange) ? object.reservedRange.map((e) => EnumDescriptorProto_EnumReservedRange.fromJSON(e)) : [],
      reservedName: globalThis.Array.isArray(object?.reservedName) ? object.reservedName.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value?.length) {
      obj.value = message.value.map((e) => EnumValueDescriptorProto.toJSON(e));
    }
    if (message.options !== void 0) {
      obj.options = EnumOptions.toJSON(message.options);
    }
    if (message.reservedRange?.length) {
      obj.reservedRange = message.reservedRange.map((e) => EnumDescriptorProto_EnumReservedRange.toJSON(e));
    }
    if (message.reservedName?.length) {
      obj.reservedName = message.reservedName;
    }
    return obj;
  },
  create(base) {
    return EnumDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnumDescriptorProto();
    message.name = object.name ?? "";
    message.value = object.value?.map((e) => EnumValueDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? EnumOptions.fromPartial(object.options) : void 0;
    message.reservedRange = object.reservedRange?.map((e) => EnumDescriptorProto_EnumReservedRange.fromPartial(e)) || [];
    message.reservedName = object.reservedName?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(EnumDescriptorProto.$type, EnumDescriptorProto);
function createBaseEnumDescriptorProto_EnumReservedRange() {
  return { start: 0, end: 0 };
}
var EnumDescriptorProto_EnumReservedRange = {
  $type: "google.protobuf.EnumDescriptorProto.EnumReservedRange",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.start !== void 0 && message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== void 0 && message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumDescriptorProto_EnumReservedRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.end = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet7(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet7(object.end) ? globalThis.Number(object.end) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.start !== void 0 && message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== void 0 && message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },
  create(base) {
    return EnumDescriptorProto_EnumReservedRange.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnumDescriptorProto_EnumReservedRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  }
};
messageTypeRegistry.set(EnumDescriptorProto_EnumReservedRange.$type, EnumDescriptorProto_EnumReservedRange);
function createBaseEnumValueDescriptorProto() {
  return { name: "", number: 0, options: void 0 };
}
var EnumValueDescriptorProto = {
  $type: "google.protobuf.EnumValueDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== void 0 && message.number !== 0) {
      writer.uint32(16).int32(message.number);
    }
    if (message.options !== void 0) {
      EnumValueOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumValueDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.number = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.options = EnumValueOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      number: isSet7(object.number) ? globalThis.Number(object.number) : 0,
      options: isSet7(object.options) ? EnumValueOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.number !== void 0 && message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.options !== void 0) {
      obj.options = EnumValueOptions.toJSON(message.options);
    }
    return obj;
  },
  create(base) {
    return EnumValueDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnumValueDescriptorProto();
    message.name = object.name ?? "";
    message.number = object.number ?? 0;
    message.options = object.options !== void 0 && object.options !== null ? EnumValueOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set(EnumValueDescriptorProto.$type, EnumValueDescriptorProto);
function createBaseServiceDescriptorProto() {
  return { name: "", method: [], options: void 0 };
}
var ServiceDescriptorProto = {
  $type: "google.protobuf.ServiceDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.method) {
      MethodDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== void 0) {
      ServiceOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseServiceDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.method.push(MethodDescriptorProto.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.options = ServiceOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      method: globalThis.Array.isArray(object?.method) ? object.method.map((e) => MethodDescriptorProto.fromJSON(e)) : [],
      options: isSet7(object.options) ? ServiceOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.method?.length) {
      obj.method = message.method.map((e) => MethodDescriptorProto.toJSON(e));
    }
    if (message.options !== void 0) {
      obj.options = ServiceOptions.toJSON(message.options);
    }
    return obj;
  },
  create(base) {
    return ServiceDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseServiceDescriptorProto();
    message.name = object.name ?? "";
    message.method = object.method?.map((e) => MethodDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? ServiceOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ServiceDescriptorProto.$type, ServiceDescriptorProto);
function createBaseMethodDescriptorProto() {
  return {
    name: "",
    inputType: "",
    outputType: "",
    options: void 0,
    clientStreaming: false,
    serverStreaming: false
  };
}
var MethodDescriptorProto = {
  $type: "google.protobuf.MethodDescriptorProto",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.name !== void 0 && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.inputType !== void 0 && message.inputType !== "") {
      writer.uint32(18).string(message.inputType);
    }
    if (message.outputType !== void 0 && message.outputType !== "") {
      writer.uint32(26).string(message.outputType);
    }
    if (message.options !== void 0) {
      MethodOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    if (message.clientStreaming !== void 0 && message.clientStreaming !== false) {
      writer.uint32(40).bool(message.clientStreaming);
    }
    if (message.serverStreaming !== void 0 && message.serverStreaming !== false) {
      writer.uint32(48).bool(message.serverStreaming);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.inputType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.outputType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.options = MethodOptions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.clientStreaming = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.serverStreaming = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet7(object.name) ? globalThis.String(object.name) : "",
      inputType: isSet7(object.inputType) ? globalThis.String(object.inputType) : "",
      outputType: isSet7(object.outputType) ? globalThis.String(object.outputType) : "",
      options: isSet7(object.options) ? MethodOptions.fromJSON(object.options) : void 0,
      clientStreaming: isSet7(object.clientStreaming) ? globalThis.Boolean(object.clientStreaming) : false,
      serverStreaming: isSet7(object.serverStreaming) ? globalThis.Boolean(object.serverStreaming) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0 && message.name !== "") {
      obj.name = message.name;
    }
    if (message.inputType !== void 0 && message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    if (message.outputType !== void 0 && message.outputType !== "") {
      obj.outputType = message.outputType;
    }
    if (message.options !== void 0) {
      obj.options = MethodOptions.toJSON(message.options);
    }
    if (message.clientStreaming !== void 0 && message.clientStreaming !== false) {
      obj.clientStreaming = message.clientStreaming;
    }
    if (message.serverStreaming !== void 0 && message.serverStreaming !== false) {
      obj.serverStreaming = message.serverStreaming;
    }
    return obj;
  },
  create(base) {
    return MethodDescriptorProto.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMethodDescriptorProto();
    message.name = object.name ?? "";
    message.inputType = object.inputType ?? "";
    message.outputType = object.outputType ?? "";
    message.options = object.options !== void 0 && object.options !== null ? MethodOptions.fromPartial(object.options) : void 0;
    message.clientStreaming = object.clientStreaming ?? false;
    message.serverStreaming = object.serverStreaming ?? false;
    return message;
  }
};
messageTypeRegistry.set(MethodDescriptorProto.$type, MethodDescriptorProto);
function createBaseFileOptions() {
  return {
    javaPackage: "",
    javaOuterClassname: "",
    javaMultipleFiles: false,
    javaGenerateEqualsAndHash: false,
    javaStringCheckUtf8: false,
    optimizeFor: 1,
    goPackage: "",
    ccGenericServices: false,
    javaGenericServices: false,
    pyGenericServices: false,
    phpGenericServices: false,
    deprecated: false,
    ccEnableArenas: true,
    objcClassPrefix: "",
    csharpNamespace: "",
    swiftPrefix: "",
    phpClassPrefix: "",
    phpNamespace: "",
    phpMetadataNamespace: "",
    rubyPackage: "",
    uninterpretedOption: []
  };
}
var FileOptions = {
  $type: "google.protobuf.FileOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.javaPackage !== void 0 && message.javaPackage !== "") {
      writer.uint32(10).string(message.javaPackage);
    }
    if (message.javaOuterClassname !== void 0 && message.javaOuterClassname !== "") {
      writer.uint32(66).string(message.javaOuterClassname);
    }
    if (message.javaMultipleFiles !== void 0 && message.javaMultipleFiles !== false) {
      writer.uint32(80).bool(message.javaMultipleFiles);
    }
    if (message.javaGenerateEqualsAndHash !== void 0 && message.javaGenerateEqualsAndHash !== false) {
      writer.uint32(160).bool(message.javaGenerateEqualsAndHash);
    }
    if (message.javaStringCheckUtf8 !== void 0 && message.javaStringCheckUtf8 !== false) {
      writer.uint32(216).bool(message.javaStringCheckUtf8);
    }
    if (message.optimizeFor !== void 0 && message.optimizeFor !== 1) {
      writer.uint32(72).int32(message.optimizeFor);
    }
    if (message.goPackage !== void 0 && message.goPackage !== "") {
      writer.uint32(90).string(message.goPackage);
    }
    if (message.ccGenericServices !== void 0 && message.ccGenericServices !== false) {
      writer.uint32(128).bool(message.ccGenericServices);
    }
    if (message.javaGenericServices !== void 0 && message.javaGenericServices !== false) {
      writer.uint32(136).bool(message.javaGenericServices);
    }
    if (message.pyGenericServices !== void 0 && message.pyGenericServices !== false) {
      writer.uint32(144).bool(message.pyGenericServices);
    }
    if (message.phpGenericServices !== void 0 && message.phpGenericServices !== false) {
      writer.uint32(336).bool(message.phpGenericServices);
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(184).bool(message.deprecated);
    }
    if (message.ccEnableArenas !== void 0 && message.ccEnableArenas !== true) {
      writer.uint32(248).bool(message.ccEnableArenas);
    }
    if (message.objcClassPrefix !== void 0 && message.objcClassPrefix !== "") {
      writer.uint32(290).string(message.objcClassPrefix);
    }
    if (message.csharpNamespace !== void 0 && message.csharpNamespace !== "") {
      writer.uint32(298).string(message.csharpNamespace);
    }
    if (message.swiftPrefix !== void 0 && message.swiftPrefix !== "") {
      writer.uint32(314).string(message.swiftPrefix);
    }
    if (message.phpClassPrefix !== void 0 && message.phpClassPrefix !== "") {
      writer.uint32(322).string(message.phpClassPrefix);
    }
    if (message.phpNamespace !== void 0 && message.phpNamespace !== "") {
      writer.uint32(330).string(message.phpNamespace);
    }
    if (message.phpMetadataNamespace !== void 0 && message.phpMetadataNamespace !== "") {
      writer.uint32(354).string(message.phpMetadataNamespace);
    }
    if (message.rubyPackage !== void 0 && message.rubyPackage !== "") {
      writer.uint32(362).string(message.rubyPackage);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.javaPackage = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.javaOuterClassname = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.javaMultipleFiles = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }
          message.javaGenerateEqualsAndHash = reader.bool();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }
          message.javaStringCheckUtf8 = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.optimizeFor = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.goPackage = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }
          message.ccGenericServices = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }
          message.javaGenericServices = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }
          message.pyGenericServices = reader.bool();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }
          message.phpGenericServices = reader.bool();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }
          message.ccEnableArenas = reader.bool();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.objcClassPrefix = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.csharpNamespace = reader.string();
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.swiftPrefix = reader.string();
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.phpClassPrefix = reader.string();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.phpNamespace = reader.string();
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.phpMetadataNamespace = reader.string();
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.rubyPackage = reader.string();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      javaPackage: isSet7(object.javaPackage) ? globalThis.String(object.javaPackage) : "",
      javaOuterClassname: isSet7(object.javaOuterClassname) ? globalThis.String(object.javaOuterClassname) : "",
      javaMultipleFiles: isSet7(object.javaMultipleFiles) ? globalThis.Boolean(object.javaMultipleFiles) : false,
      javaGenerateEqualsAndHash: isSet7(object.javaGenerateEqualsAndHash) ? globalThis.Boolean(object.javaGenerateEqualsAndHash) : false,
      javaStringCheckUtf8: isSet7(object.javaStringCheckUtf8) ? globalThis.Boolean(object.javaStringCheckUtf8) : false,
      optimizeFor: isSet7(object.optimizeFor) ? fileOptions_OptimizeModeFromJSON(object.optimizeFor) : 1,
      goPackage: isSet7(object.goPackage) ? globalThis.String(object.goPackage) : "",
      ccGenericServices: isSet7(object.ccGenericServices) ? globalThis.Boolean(object.ccGenericServices) : false,
      javaGenericServices: isSet7(object.javaGenericServices) ? globalThis.Boolean(object.javaGenericServices) : false,
      pyGenericServices: isSet7(object.pyGenericServices) ? globalThis.Boolean(object.pyGenericServices) : false,
      phpGenericServices: isSet7(object.phpGenericServices) ? globalThis.Boolean(object.phpGenericServices) : false,
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      ccEnableArenas: isSet7(object.ccEnableArenas) ? globalThis.Boolean(object.ccEnableArenas) : true,
      objcClassPrefix: isSet7(object.objcClassPrefix) ? globalThis.String(object.objcClassPrefix) : "",
      csharpNamespace: isSet7(object.csharpNamespace) ? globalThis.String(object.csharpNamespace) : "",
      swiftPrefix: isSet7(object.swiftPrefix) ? globalThis.String(object.swiftPrefix) : "",
      phpClassPrefix: isSet7(object.phpClassPrefix) ? globalThis.String(object.phpClassPrefix) : "",
      phpNamespace: isSet7(object.phpNamespace) ? globalThis.String(object.phpNamespace) : "",
      phpMetadataNamespace: isSet7(object.phpMetadataNamespace) ? globalThis.String(object.phpMetadataNamespace) : "",
      rubyPackage: isSet7(object.rubyPackage) ? globalThis.String(object.rubyPackage) : "",
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.javaPackage !== void 0 && message.javaPackage !== "") {
      obj.javaPackage = message.javaPackage;
    }
    if (message.javaOuterClassname !== void 0 && message.javaOuterClassname !== "") {
      obj.javaOuterClassname = message.javaOuterClassname;
    }
    if (message.javaMultipleFiles !== void 0 && message.javaMultipleFiles !== false) {
      obj.javaMultipleFiles = message.javaMultipleFiles;
    }
    if (message.javaGenerateEqualsAndHash !== void 0 && message.javaGenerateEqualsAndHash !== false) {
      obj.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
    }
    if (message.javaStringCheckUtf8 !== void 0 && message.javaStringCheckUtf8 !== false) {
      obj.javaStringCheckUtf8 = message.javaStringCheckUtf8;
    }
    if (message.optimizeFor !== void 0 && message.optimizeFor !== 1) {
      obj.optimizeFor = fileOptions_OptimizeModeToJSON(message.optimizeFor);
    }
    if (message.goPackage !== void 0 && message.goPackage !== "") {
      obj.goPackage = message.goPackage;
    }
    if (message.ccGenericServices !== void 0 && message.ccGenericServices !== false) {
      obj.ccGenericServices = message.ccGenericServices;
    }
    if (message.javaGenericServices !== void 0 && message.javaGenericServices !== false) {
      obj.javaGenericServices = message.javaGenericServices;
    }
    if (message.pyGenericServices !== void 0 && message.pyGenericServices !== false) {
      obj.pyGenericServices = message.pyGenericServices;
    }
    if (message.phpGenericServices !== void 0 && message.phpGenericServices !== false) {
      obj.phpGenericServices = message.phpGenericServices;
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.ccEnableArenas !== void 0 && message.ccEnableArenas !== true) {
      obj.ccEnableArenas = message.ccEnableArenas;
    }
    if (message.objcClassPrefix !== void 0 && message.objcClassPrefix !== "") {
      obj.objcClassPrefix = message.objcClassPrefix;
    }
    if (message.csharpNamespace !== void 0 && message.csharpNamespace !== "") {
      obj.csharpNamespace = message.csharpNamespace;
    }
    if (message.swiftPrefix !== void 0 && message.swiftPrefix !== "") {
      obj.swiftPrefix = message.swiftPrefix;
    }
    if (message.phpClassPrefix !== void 0 && message.phpClassPrefix !== "") {
      obj.phpClassPrefix = message.phpClassPrefix;
    }
    if (message.phpNamespace !== void 0 && message.phpNamespace !== "") {
      obj.phpNamespace = message.phpNamespace;
    }
    if (message.phpMetadataNamespace !== void 0 && message.phpMetadataNamespace !== "") {
      obj.phpMetadataNamespace = message.phpMetadataNamespace;
    }
    if (message.rubyPackage !== void 0 && message.rubyPackage !== "") {
      obj.rubyPackage = message.rubyPackage;
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FileOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFileOptions();
    message.javaPackage = object.javaPackage ?? "";
    message.javaOuterClassname = object.javaOuterClassname ?? "";
    message.javaMultipleFiles = object.javaMultipleFiles ?? false;
    message.javaGenerateEqualsAndHash = object.javaGenerateEqualsAndHash ?? false;
    message.javaStringCheckUtf8 = object.javaStringCheckUtf8 ?? false;
    message.optimizeFor = object.optimizeFor ?? 1;
    message.goPackage = object.goPackage ?? "";
    message.ccGenericServices = object.ccGenericServices ?? false;
    message.javaGenericServices = object.javaGenericServices ?? false;
    message.pyGenericServices = object.pyGenericServices ?? false;
    message.phpGenericServices = object.phpGenericServices ?? false;
    message.deprecated = object.deprecated ?? false;
    message.ccEnableArenas = object.ccEnableArenas ?? true;
    message.objcClassPrefix = object.objcClassPrefix ?? "";
    message.csharpNamespace = object.csharpNamespace ?? "";
    message.swiftPrefix = object.swiftPrefix ?? "";
    message.phpClassPrefix = object.phpClassPrefix ?? "";
    message.phpNamespace = object.phpNamespace ?? "";
    message.phpMetadataNamespace = object.phpMetadataNamespace ?? "";
    message.rubyPackage = object.rubyPackage ?? "";
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FileOptions.$type, FileOptions);
function createBaseMessageOptions() {
  return {
    messageSetWireFormat: false,
    noStandardDescriptorAccessor: false,
    deprecated: false,
    mapEntry: false,
    deprecatedLegacyJsonFieldConflicts: false,
    uninterpretedOption: []
  };
}
var MessageOptions = {
  $type: "google.protobuf.MessageOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.messageSetWireFormat !== void 0 && message.messageSetWireFormat !== false) {
      writer.uint32(8).bool(message.messageSetWireFormat);
    }
    if (message.noStandardDescriptorAccessor !== void 0 && message.noStandardDescriptorAccessor !== false) {
      writer.uint32(16).bool(message.noStandardDescriptorAccessor);
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.mapEntry !== void 0 && message.mapEntry !== false) {
      writer.uint32(56).bool(message.mapEntry);
    }
    if (message.deprecatedLegacyJsonFieldConflicts !== void 0 && message.deprecatedLegacyJsonFieldConflicts !== false) {
      writer.uint32(88).bool(message.deprecatedLegacyJsonFieldConflicts);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.messageSetWireFormat = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.noStandardDescriptorAccessor = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.mapEntry = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.deprecatedLegacyJsonFieldConflicts = reader.bool();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messageSetWireFormat: isSet7(object.messageSetWireFormat) ? globalThis.Boolean(object.messageSetWireFormat) : false,
      noStandardDescriptorAccessor: isSet7(object.noStandardDescriptorAccessor) ? globalThis.Boolean(object.noStandardDescriptorAccessor) : false,
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      mapEntry: isSet7(object.mapEntry) ? globalThis.Boolean(object.mapEntry) : false,
      deprecatedLegacyJsonFieldConflicts: isSet7(object.deprecatedLegacyJsonFieldConflicts) ? globalThis.Boolean(object.deprecatedLegacyJsonFieldConflicts) : false,
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messageSetWireFormat !== void 0 && message.messageSetWireFormat !== false) {
      obj.messageSetWireFormat = message.messageSetWireFormat;
    }
    if (message.noStandardDescriptorAccessor !== void 0 && message.noStandardDescriptorAccessor !== false) {
      obj.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.mapEntry !== void 0 && message.mapEntry !== false) {
      obj.mapEntry = message.mapEntry;
    }
    if (message.deprecatedLegacyJsonFieldConflicts !== void 0 && message.deprecatedLegacyJsonFieldConflicts !== false) {
      obj.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts;
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MessageOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageOptions();
    message.messageSetWireFormat = object.messageSetWireFormat ?? false;
    message.noStandardDescriptorAccessor = object.noStandardDescriptorAccessor ?? false;
    message.deprecated = object.deprecated ?? false;
    message.mapEntry = object.mapEntry ?? false;
    message.deprecatedLegacyJsonFieldConflicts = object.deprecatedLegacyJsonFieldConflicts ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(MessageOptions.$type, MessageOptions);
function createBaseFieldOptions() {
  return {
    ctype: 0,
    packed: false,
    jstype: 0,
    lazy: false,
    unverifiedLazy: false,
    deprecated: false,
    weak: false,
    debugRedact: false,
    retention: 0,
    target: 0,
    uninterpretedOption: []
  };
}
var FieldOptions = {
  $type: "google.protobuf.FieldOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.ctype !== void 0 && message.ctype !== 0) {
      writer.uint32(8).int32(message.ctype);
    }
    if (message.packed !== void 0 && message.packed !== false) {
      writer.uint32(16).bool(message.packed);
    }
    if (message.jstype !== void 0 && message.jstype !== 0) {
      writer.uint32(48).int32(message.jstype);
    }
    if (message.lazy !== void 0 && message.lazy !== false) {
      writer.uint32(40).bool(message.lazy);
    }
    if (message.unverifiedLazy !== void 0 && message.unverifiedLazy !== false) {
      writer.uint32(120).bool(message.unverifiedLazy);
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.weak !== void 0 && message.weak !== false) {
      writer.uint32(80).bool(message.weak);
    }
    if (message.debugRedact !== void 0 && message.debugRedact !== false) {
      writer.uint32(128).bool(message.debugRedact);
    }
    if (message.retention !== void 0 && message.retention !== 0) {
      writer.uint32(136).int32(message.retention);
    }
    if (message.target !== void 0 && message.target !== 0) {
      writer.uint32(144).int32(message.target);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.ctype = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.packed = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.jstype = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.lazy = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }
          message.unverifiedLazy = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.weak = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }
          message.debugRedact = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }
          message.retention = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }
          message.target = reader.int32();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ctype: isSet7(object.ctype) ? fieldOptions_CTypeFromJSON(object.ctype) : 0,
      packed: isSet7(object.packed) ? globalThis.Boolean(object.packed) : false,
      jstype: isSet7(object.jstype) ? fieldOptions_JSTypeFromJSON(object.jstype) : 0,
      lazy: isSet7(object.lazy) ? globalThis.Boolean(object.lazy) : false,
      unverifiedLazy: isSet7(object.unverifiedLazy) ? globalThis.Boolean(object.unverifiedLazy) : false,
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      weak: isSet7(object.weak) ? globalThis.Boolean(object.weak) : false,
      debugRedact: isSet7(object.debugRedact) ? globalThis.Boolean(object.debugRedact) : false,
      retention: isSet7(object.retention) ? fieldOptions_OptionRetentionFromJSON(object.retention) : 0,
      target: isSet7(object.target) ? fieldOptions_OptionTargetTypeFromJSON(object.target) : 0,
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ctype !== void 0 && message.ctype !== 0) {
      obj.ctype = fieldOptions_CTypeToJSON(message.ctype);
    }
    if (message.packed !== void 0 && message.packed !== false) {
      obj.packed = message.packed;
    }
    if (message.jstype !== void 0 && message.jstype !== 0) {
      obj.jstype = fieldOptions_JSTypeToJSON(message.jstype);
    }
    if (message.lazy !== void 0 && message.lazy !== false) {
      obj.lazy = message.lazy;
    }
    if (message.unverifiedLazy !== void 0 && message.unverifiedLazy !== false) {
      obj.unverifiedLazy = message.unverifiedLazy;
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.weak !== void 0 && message.weak !== false) {
      obj.weak = message.weak;
    }
    if (message.debugRedact !== void 0 && message.debugRedact !== false) {
      obj.debugRedact = message.debugRedact;
    }
    if (message.retention !== void 0 && message.retention !== 0) {
      obj.retention = fieldOptions_OptionRetentionToJSON(message.retention);
    }
    if (message.target !== void 0 && message.target !== 0) {
      obj.target = fieldOptions_OptionTargetTypeToJSON(message.target);
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FieldOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldOptions();
    message.ctype = object.ctype ?? 0;
    message.packed = object.packed ?? false;
    message.jstype = object.jstype ?? 0;
    message.lazy = object.lazy ?? false;
    message.unverifiedLazy = object.unverifiedLazy ?? false;
    message.deprecated = object.deprecated ?? false;
    message.weak = object.weak ?? false;
    message.debugRedact = object.debugRedact ?? false;
    message.retention = object.retention ?? 0;
    message.target = object.target ?? 0;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FieldOptions.$type, FieldOptions);
function createBaseOneofOptions() {
  return { uninterpretedOption: [] };
}
var OneofOptions = {
  $type: "google.protobuf.OneofOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOneofOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return OneofOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOneofOptions();
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(OneofOptions.$type, OneofOptions);
function createBaseEnumOptions() {
  return { allowAlias: false, deprecated: false, deprecatedLegacyJsonFieldConflicts: false, uninterpretedOption: [] };
}
var EnumOptions = {
  $type: "google.protobuf.EnumOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.allowAlias !== void 0 && message.allowAlias !== false) {
      writer.uint32(16).bool(message.allowAlias);
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.deprecatedLegacyJsonFieldConflicts !== void 0 && message.deprecatedLegacyJsonFieldConflicts !== false) {
      writer.uint32(48).bool(message.deprecatedLegacyJsonFieldConflicts);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }
          message.allowAlias = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.deprecatedLegacyJsonFieldConflicts = reader.bool();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowAlias: isSet7(object.allowAlias) ? globalThis.Boolean(object.allowAlias) : false,
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      deprecatedLegacyJsonFieldConflicts: isSet7(object.deprecatedLegacyJsonFieldConflicts) ? globalThis.Boolean(object.deprecatedLegacyJsonFieldConflicts) : false,
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allowAlias !== void 0 && message.allowAlias !== false) {
      obj.allowAlias = message.allowAlias;
    }
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.deprecatedLegacyJsonFieldConflicts !== void 0 && message.deprecatedLegacyJsonFieldConflicts !== false) {
      obj.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts;
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return EnumOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnumOptions();
    message.allowAlias = object.allowAlias ?? false;
    message.deprecated = object.deprecated ?? false;
    message.deprecatedLegacyJsonFieldConflicts = object.deprecatedLegacyJsonFieldConflicts ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(EnumOptions.$type, EnumOptions);
function createBaseEnumValueOptions() {
  return { deprecated: false, uninterpretedOption: [] };
}
var EnumValueOptions = {
  $type: "google.protobuf.EnumValueOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(8).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumValueOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return EnumValueOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnumValueOptions();
    message.deprecated = object.deprecated ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(EnumValueOptions.$type, EnumValueOptions);
function createBaseServiceOptions() {
  return { deprecated: false, uninterpretedOption: [] };
}
var ServiceOptions = {
  $type: "google.protobuf.ServiceOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(264).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseServiceOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 33:
          if (tag !== 264) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ServiceOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseServiceOptions();
    message.deprecated = object.deprecated ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ServiceOptions.$type, ServiceOptions);
function createBaseMethodOptions() {
  return { deprecated: false, idempotencyLevel: 0, uninterpretedOption: [] };
}
var MethodOptions = {
  $type: "google.protobuf.MethodOptions",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      writer.uint32(264).bool(message.deprecated);
    }
    if (message.idempotencyLevel !== void 0 && message.idempotencyLevel !== 0) {
      writer.uint32(272).int32(message.idempotencyLevel);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 33:
          if (tag !== 264) {
            break;
          }
          message.deprecated = reader.bool();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }
          message.idempotencyLevel = reader.int32();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet7(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      idempotencyLevel: isSet7(object.idempotencyLevel) ? methodOptions_IdempotencyLevelFromJSON(object.idempotencyLevel) : 0,
      uninterpretedOption: globalThis.Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deprecated !== void 0 && message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.idempotencyLevel !== void 0 && message.idempotencyLevel !== 0) {
      obj.idempotencyLevel = methodOptions_IdempotencyLevelToJSON(message.idempotencyLevel);
    }
    if (message.uninterpretedOption?.length) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => UninterpretedOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MethodOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMethodOptions();
    message.deprecated = object.deprecated ?? false;
    message.idempotencyLevel = object.idempotencyLevel ?? 0;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(MethodOptions.$type, MethodOptions);
function createBaseUninterpretedOption() {
  return {
    name: [],
    identifierValue: "",
    positiveIntValue: 0,
    negativeIntValue: 0,
    doubleValue: 0,
    stringValue: new Uint8Array(0),
    aggregateValue: ""
  };
}
var UninterpretedOption = {
  $type: "google.protobuf.UninterpretedOption",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    for (const v of message.name) {
      UninterpretedOption_NamePart.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.identifierValue !== void 0 && message.identifierValue !== "") {
      writer.uint32(26).string(message.identifierValue);
    }
    if (message.positiveIntValue !== void 0 && message.positiveIntValue !== 0) {
      writer.uint32(32).uint64(message.positiveIntValue);
    }
    if (message.negativeIntValue !== void 0 && message.negativeIntValue !== 0) {
      writer.uint32(40).int64(message.negativeIntValue);
    }
    if (message.doubleValue !== void 0 && message.doubleValue !== 0) {
      writer.uint32(49).double(message.doubleValue);
    }
    if (message.stringValue !== void 0 && message.stringValue.length !== 0) {
      writer.uint32(58).bytes(message.stringValue);
    }
    if (message.aggregateValue !== void 0 && message.aggregateValue !== "") {
      writer.uint32(66).string(message.aggregateValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUninterpretedOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name.push(UninterpretedOption_NamePart.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.identifierValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.positiveIntValue = longToNumber4(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.negativeIntValue = longToNumber4(reader.int64());
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }
          message.doubleValue = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.stringValue = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.aggregateValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: globalThis.Array.isArray(object?.name) ? object.name.map((e) => UninterpretedOption_NamePart.fromJSON(e)) : [],
      identifierValue: isSet7(object.identifierValue) ? globalThis.String(object.identifierValue) : "",
      positiveIntValue: isSet7(object.positiveIntValue) ? globalThis.Number(object.positiveIntValue) : 0,
      negativeIntValue: isSet7(object.negativeIntValue) ? globalThis.Number(object.negativeIntValue) : 0,
      doubleValue: isSet7(object.doubleValue) ? globalThis.Number(object.doubleValue) : 0,
      stringValue: isSet7(object.stringValue) ? bytesFromBase642(object.stringValue) : new Uint8Array(0),
      aggregateValue: isSet7(object.aggregateValue) ? globalThis.String(object.aggregateValue) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name?.length) {
      obj.name = message.name.map((e) => UninterpretedOption_NamePart.toJSON(e));
    }
    if (message.identifierValue !== void 0 && message.identifierValue !== "") {
      obj.identifierValue = message.identifierValue;
    }
    if (message.positiveIntValue !== void 0 && message.positiveIntValue !== 0) {
      obj.positiveIntValue = Math.round(message.positiveIntValue);
    }
    if (message.negativeIntValue !== void 0 && message.negativeIntValue !== 0) {
      obj.negativeIntValue = Math.round(message.negativeIntValue);
    }
    if (message.doubleValue !== void 0 && message.doubleValue !== 0) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== void 0 && message.stringValue.length !== 0) {
      obj.stringValue = base64FromBytes2(message.stringValue);
    }
    if (message.aggregateValue !== void 0 && message.aggregateValue !== "") {
      obj.aggregateValue = message.aggregateValue;
    }
    return obj;
  },
  create(base) {
    return UninterpretedOption.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUninterpretedOption();
    message.name = object.name?.map((e) => UninterpretedOption_NamePart.fromPartial(e)) || [];
    message.identifierValue = object.identifierValue ?? "";
    message.positiveIntValue = object.positiveIntValue ?? 0;
    message.negativeIntValue = object.negativeIntValue ?? 0;
    message.doubleValue = object.doubleValue ?? 0;
    message.stringValue = object.stringValue ?? new Uint8Array(0);
    message.aggregateValue = object.aggregateValue ?? "";
    return message;
  }
};
messageTypeRegistry.set(UninterpretedOption.$type, UninterpretedOption);
function createBaseUninterpretedOption_NamePart() {
  return { namePart: "", isExtension: false };
}
var UninterpretedOption_NamePart = {
  $type: "google.protobuf.UninterpretedOption.NamePart",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.namePart !== "") {
      writer.uint32(10).string(message.namePart);
    }
    if (message.isExtension !== false) {
      writer.uint32(16).bool(message.isExtension);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUninterpretedOption_NamePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.namePart = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.isExtension = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      namePart: isSet7(object.namePart) ? globalThis.String(object.namePart) : "",
      isExtension: isSet7(object.isExtension) ? globalThis.Boolean(object.isExtension) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.namePart !== "") {
      obj.namePart = message.namePart;
    }
    if (message.isExtension !== false) {
      obj.isExtension = message.isExtension;
    }
    return obj;
  },
  create(base) {
    return UninterpretedOption_NamePart.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUninterpretedOption_NamePart();
    message.namePart = object.namePart ?? "";
    message.isExtension = object.isExtension ?? false;
    return message;
  }
};
messageTypeRegistry.set(UninterpretedOption_NamePart.$type, UninterpretedOption_NamePart);
function createBaseSourceCodeInfo() {
  return { location: [] };
}
var SourceCodeInfo = {
  $type: "google.protobuf.SourceCodeInfo",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    for (const v of message.location) {
      SourceCodeInfo_Location.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSourceCodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.location.push(SourceCodeInfo_Location.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e) => SourceCodeInfo_Location.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.location?.length) {
      obj.location = message.location.map((e) => SourceCodeInfo_Location.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SourceCodeInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSourceCodeInfo();
    message.location = object.location?.map((e) => SourceCodeInfo_Location.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SourceCodeInfo.$type, SourceCodeInfo);
function createBaseSourceCodeInfo_Location() {
  return { path: [], span: [], leadingComments: "", trailingComments: "", leadingDetachedComments: [] };
}
var SourceCodeInfo_Location = {
  $type: "google.protobuf.SourceCodeInfo.Location",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.path) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.span) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.leadingComments !== void 0 && message.leadingComments !== "") {
      writer.uint32(26).string(message.leadingComments);
    }
    if (message.trailingComments !== void 0 && message.trailingComments !== "") {
      writer.uint32(34).string(message.trailingComments);
    }
    for (const v of message.leadingDetachedComments) {
      writer.uint32(50).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSourceCodeInfo_Location();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.path.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.int32());
            }
            continue;
          }
          break;
        case 2:
          if (tag === 16) {
            message.span.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.span.push(reader.int32());
            }
            continue;
          }
          break;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.leadingComments = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.trailingComments = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.leadingDetachedComments.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e) => globalThis.Number(e)) : [],
      span: globalThis.Array.isArray(object?.span) ? object.span.map((e) => globalThis.Number(e)) : [],
      leadingComments: isSet7(object.leadingComments) ? globalThis.String(object.leadingComments) : "",
      trailingComments: isSet7(object.trailingComments) ? globalThis.String(object.trailingComments) : "",
      leadingDetachedComments: globalThis.Array.isArray(object?.leadingDetachedComments) ? object.leadingDetachedComments.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path?.length) {
      obj.path = message.path.map((e) => Math.round(e));
    }
    if (message.span?.length) {
      obj.span = message.span.map((e) => Math.round(e));
    }
    if (message.leadingComments !== void 0 && message.leadingComments !== "") {
      obj.leadingComments = message.leadingComments;
    }
    if (message.trailingComments !== void 0 && message.trailingComments !== "") {
      obj.trailingComments = message.trailingComments;
    }
    if (message.leadingDetachedComments?.length) {
      obj.leadingDetachedComments = message.leadingDetachedComments;
    }
    return obj;
  },
  create(base) {
    return SourceCodeInfo_Location.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSourceCodeInfo_Location();
    message.path = object.path?.map((e) => e) || [];
    message.span = object.span?.map((e) => e) || [];
    message.leadingComments = object.leadingComments ?? "";
    message.trailingComments = object.trailingComments ?? "";
    message.leadingDetachedComments = object.leadingDetachedComments?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(SourceCodeInfo_Location.$type, SourceCodeInfo_Location);
function createBaseGeneratedCodeInfo() {
  return { annotation: [] };
}
var GeneratedCodeInfo = {
  $type: "google.protobuf.GeneratedCodeInfo",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    for (const v of message.annotation) {
      GeneratedCodeInfo_Annotation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratedCodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.annotation.push(GeneratedCodeInfo_Annotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      annotation: globalThis.Array.isArray(object?.annotation) ? object.annotation.map((e) => GeneratedCodeInfo_Annotation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.annotation?.length) {
      obj.annotation = message.annotation.map((e) => GeneratedCodeInfo_Annotation.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GeneratedCodeInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGeneratedCodeInfo();
    message.annotation = object.annotation?.map((e) => GeneratedCodeInfo_Annotation.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GeneratedCodeInfo.$type, GeneratedCodeInfo);
function createBaseGeneratedCodeInfo_Annotation() {
  return { path: [], sourceFile: "", begin: 0, end: 0, semantic: 0 };
}
var GeneratedCodeInfo_Annotation = {
  $type: "google.protobuf.GeneratedCodeInfo.Annotation",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.path) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.sourceFile !== void 0 && message.sourceFile !== "") {
      writer.uint32(18).string(message.sourceFile);
    }
    if (message.begin !== void 0 && message.begin !== 0) {
      writer.uint32(24).int32(message.begin);
    }
    if (message.end !== void 0 && message.end !== 0) {
      writer.uint32(32).int32(message.end);
    }
    if (message.semantic !== void 0 && message.semantic !== 0) {
      writer.uint32(40).int32(message.semantic);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratedCodeInfo_Annotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.path.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.int32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.sourceFile = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.begin = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.end = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.semantic = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e) => globalThis.Number(e)) : [],
      sourceFile: isSet7(object.sourceFile) ? globalThis.String(object.sourceFile) : "",
      begin: isSet7(object.begin) ? globalThis.Number(object.begin) : 0,
      end: isSet7(object.end) ? globalThis.Number(object.end) : 0,
      semantic: isSet7(object.semantic) ? generatedCodeInfo_Annotation_SemanticFromJSON(object.semantic) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path?.length) {
      obj.path = message.path.map((e) => Math.round(e));
    }
    if (message.sourceFile !== void 0 && message.sourceFile !== "") {
      obj.sourceFile = message.sourceFile;
    }
    if (message.begin !== void 0 && message.begin !== 0) {
      obj.begin = Math.round(message.begin);
    }
    if (message.end !== void 0 && message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.semantic !== void 0 && message.semantic !== 0) {
      obj.semantic = generatedCodeInfo_Annotation_SemanticToJSON(message.semantic);
    }
    return obj;
  },
  create(base) {
    return GeneratedCodeInfo_Annotation.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGeneratedCodeInfo_Annotation();
    message.path = object.path?.map((e) => e) || [];
    message.sourceFile = object.sourceFile ?? "";
    message.begin = object.begin ?? 0;
    message.end = object.end ?? 0;
    message.semantic = object.semantic ?? 0;
    return message;
  }
};
messageTypeRegistry.set(GeneratedCodeInfo_Annotation.$type, GeneratedCodeInfo_Annotation);
function bytesFromBase642(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes2(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function longToNumber4(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal8.default.util.Long !== import_long4.default) {
  import_minimal8.default.util.Long = import_long4.default;
  import_minimal8.default.configure();
}
function isSet7(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/any.js
var import_minimal9 = __toESM(require_minimal2(), 1);
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array(0) };
}
var Any = {
  $type: "google.protobuf.Any",
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.typeUrl !== "") {
      writer.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.typeUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      typeUrl: isSet8(object.typeUrl) ? globalThis.String(object.typeUrl) : "",
      value: isSet8(object.value) ? bytesFromBase643(object.value) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.typeUrl !== "") {
      obj.typeUrl = message.typeUrl;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes3(message.value);
    }
    return obj;
  },
  create(base) {
    return Any.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAny();
    message.typeUrl = object.typeUrl ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  }
};
messageTypeRegistry.set(Any.$type, Any);
function bytesFromBase643(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes3(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isSet8(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/service/envelope_service.js
var import_minimal12 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/envelope.js
var import_minimal11 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/runtime_common.js
var import_minimal10 = __toESM(require_minimal2(), 1);
function createBaseAck() {
  return { success: false, messages: [] };
}
var Ack = {
  $type: "devvit.runtime.Ack",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.messages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet9(object.success) ? globalThis.Boolean(object.success) : false,
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.messages?.length) {
      obj.messages = message.messages;
    }
    return obj;
  },
  create(base) {
    return Ack.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAck();
    message.success = object.success ?? false;
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(Ack.$type, Ack);
function createBaseDebug() {
  return { message: void 0 };
}
var Debug = {
  $type: "devvit.runtime.Debug",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.message !== void 0) {
      Value.encode(Value.wrap(message.message), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDebug();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.message = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet9(object?.message) ? object.message : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return Debug.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDebug();
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Debug.$type, Debug);
function createBaseStrings() {
  return { values: [] };
}
var Strings = {
  $type: "devvit.runtime.Strings",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.values) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStrings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return Strings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStrings();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(Strings.$type, Strings);
function createBaseStr() {
  return { value: "" };
}
var Str = {
  $type: "devvit.runtime.Str",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet9(object.value) ? globalThis.String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Str.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStr();
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(Str.$type, Str);
function isSet9(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/envelope.js
function createBaseEnvelope() {
  return {
    id: "",
    src: "",
    dst: "",
    method: "",
    streamId: "",
    traceId: "",
    success: false,
    message: void 0,
    request: false,
    complete: false,
    metadata: {}
  };
}
var Envelope = {
  $type: "devvit.runtime.Envelope",
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(90).string(message.id);
    }
    if (message.src !== "") {
      writer.uint32(10).string(message.src);
    }
    if (message.dst !== "") {
      writer.uint32(18).string(message.dst);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.streamId !== "") {
      writer.uint32(34).string(message.streamId);
    }
    if (message.traceId !== "") {
      writer.uint32(82).string(message.traceId);
    }
    if (message.success !== false) {
      writer.uint32(40).bool(message.success);
    }
    if (message.message !== void 0) {
      Value.encode(Value.wrap(message.message), writer.uint32(50).fork()).ldelim();
    }
    if (message.request !== false) {
      writer.uint32(56).bool(message.request);
    }
    if (message.complete !== false) {
      writer.uint32(64).bool(message.complete);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Envelope_MetadataEntry.encode({ key, value }, writer.uint32(74).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : import_minimal11.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }
          message.id = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }
          message.src = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dst = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.method = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.streamId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.traceId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.message = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.request = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.complete = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          const entry9 = Envelope_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== void 0) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet10(object.id) ? globalThis.String(object.id) : "",
      src: isSet10(object.src) ? globalThis.String(object.src) : "",
      dst: isSet10(object.dst) ? globalThis.String(object.dst) : "",
      method: isSet10(object.method) ? globalThis.String(object.method) : "",
      streamId: isSet10(object.streamId) ? globalThis.String(object.streamId) : "",
      traceId: isSet10(object.traceId) ? globalThis.String(object.traceId) : "",
      success: isSet10(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet10(object?.message) ? object.message : void 0,
      request: isSet10(object.request) ? globalThis.Boolean(object.request) : false,
      complete: isSet10(object.complete) ? globalThis.Boolean(object.complete) : false,
      metadata: isObject2(object.metadata) ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
        acc[key] = Strings.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.dst !== "") {
      obj.dst = message.dst;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    if (message.request !== false) {
      obj.request = message.request;
    }
    if (message.complete !== false) {
      obj.complete = message.complete;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = Strings.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return Envelope.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvelope();
    message.id = object.id ?? "";
    message.src = object.src ?? "";
    message.dst = object.dst ?? "";
    message.method = object.method ?? "";
    message.streamId = object.streamId ?? "";
    message.traceId = object.traceId ?? "";
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    message.request = object.request ?? false;
    message.complete = object.complete ?? false;
    message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Strings.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(Envelope.$type, Envelope);
function createBaseEnvelope_MetadataEntry() {
  return { key: "", value: void 0 };
}
var Envelope_MetadataEntry = {
  $type: "devvit.runtime.Envelope.MetadataEntry",
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : import_minimal11.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = Strings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet10(object.key) ? globalThis.String(object.key) : "",
      value: isSet10(object.value) ? Strings.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = Strings.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return Envelope_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvelope_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Strings.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Envelope_MetadataEntry.$type, Envelope_MetadataEntry);
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function isSet10(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/service/bundle_service.js
var import_minimal15 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/bundle.js
var import_minimal14 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/serializable.js
var import_minimal13 = __toESM(require_minimal2(), 1);
function createBaseSerializableServiceDefinition() {
  return { fullName: "", methods: [], name: "", version: "" };
}
var SerializableServiceDefinition = {
  $type: "devvit.runtime.SerializableServiceDefinition",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.fullName !== "") {
      writer.uint32(10).string(message.fullName);
    }
    for (const v of message.methods) {
      SerializableMethodDefinition.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : import_minimal13.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSerializableServiceDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fullName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.methods.push(SerializableMethodDefinition.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullName: isSet11(object.fullName) ? globalThis.String(object.fullName) : "",
      methods: globalThis.Array.isArray(object?.methods) ? object.methods.map((e) => SerializableMethodDefinition.fromJSON(e)) : [],
      name: isSet11(object.name) ? globalThis.String(object.name) : "",
      version: isSet11(object.version) ? globalThis.String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.methods?.length) {
      obj.methods = message.methods.map((e) => SerializableMethodDefinition.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },
  create(base) {
    return SerializableServiceDefinition.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSerializableServiceDefinition();
    message.fullName = object.fullName ?? "";
    message.methods = object.methods?.map((e) => SerializableMethodDefinition.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set(SerializableServiceDefinition.$type, SerializableServiceDefinition);
function createBaseSerializableMethodDefinition() {
  return { fullName: "", name: "", requestStream: false, responseStream: false, requestType: "", responseType: "" };
}
var SerializableMethodDefinition = {
  $type: "devvit.runtime.SerializableMethodDefinition",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.fullName !== "") {
      writer.uint32(10).string(message.fullName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.requestStream !== false) {
      writer.uint32(24).bool(message.requestStream);
    }
    if (message.responseStream !== false) {
      writer.uint32(32).bool(message.responseStream);
    }
    if (message.requestType !== "") {
      writer.uint32(42).string(message.requestType);
    }
    if (message.responseType !== "") {
      writer.uint32(50).string(message.responseType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : import_minimal13.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSerializableMethodDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fullName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.requestStream = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.responseStream = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.requestType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.responseType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullName: isSet11(object.fullName) ? globalThis.String(object.fullName) : "",
      name: isSet11(object.name) ? globalThis.String(object.name) : "",
      requestStream: isSet11(object.requestStream) ? globalThis.Boolean(object.requestStream) : false,
      responseStream: isSet11(object.responseStream) ? globalThis.Boolean(object.responseStream) : false,
      requestType: isSet11(object.requestType) ? globalThis.String(object.requestType) : "",
      responseType: isSet11(object.responseType) ? globalThis.String(object.responseType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestStream !== false) {
      obj.requestStream = message.requestStream;
    }
    if (message.responseStream !== false) {
      obj.responseStream = message.responseStream;
    }
    if (message.requestType !== "") {
      obj.requestType = message.requestType;
    }
    if (message.responseType !== "") {
      obj.responseType = message.responseType;
    }
    return obj;
  },
  create(base) {
    return SerializableMethodDefinition.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSerializableMethodDefinition();
    message.fullName = object.fullName ?? "";
    message.name = object.name ?? "";
    message.requestStream = object.requestStream ?? false;
    message.responseStream = object.responseStream ?? false;
    message.requestType = object.requestType ?? "";
    message.responseType = object.responseType ?? "";
    return message;
  }
};
messageTypeRegistry.set(SerializableMethodDefinition.$type, SerializableMethodDefinition);
function isSet11(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/bundle.js
var LinkedBundleTargetPlatform;
(function(LinkedBundleTargetPlatform2) {
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["BROWSER"] = 0] = "BROWSER";
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["V8"] = 1] = "V8";
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["SKINNY"] = 2] = "SKINNY";
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LinkedBundleTargetPlatform || (LinkedBundleTargetPlatform = {}));
function createBaseActorSpec() {
  return { name: "", owner: "", version: "" };
}
var ActorSpec = {
  $type: "devvit.runtime.ActorSpec",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActorSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.owner = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet12(object.name) ? globalThis.String(object.name) : "",
      owner: isSet12(object.owner) ? globalThis.String(object.owner) : "",
      version: isSet12(object.version) ? globalThis.String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },
  create(base) {
    return ActorSpec.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseActorSpec();
    message.name = object.name ?? "";
    message.owner = object.owner ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set(ActorSpec.$type, ActorSpec);
function createBaseLocationFilter() {
  return { allow: [], deny: [] };
}
var LocationFilter = {
  $type: "devvit.runtime.LocationFilter",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    for (const v of message.allow) {
      writer.uint32(10).string(v);
    }
    for (const v of message.deny) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.allow.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.deny.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allow: globalThis.Array.isArray(object?.allow) ? object.allow.map((e) => globalThis.String(e)) : [],
      deny: globalThis.Array.isArray(object?.deny) ? object.deny.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allow?.length) {
      obj.allow = message.allow;
    }
    if (message.deny?.length) {
      obj.deny = message.deny;
    }
    return obj;
  },
  create(base) {
    return LocationFilter.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLocationFilter();
    message.allow = object.allow?.map((e) => e) || [];
    message.deny = object.deny?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(LocationFilter.$type, LocationFilter);
function createBasePackageSpec() {
  return { actor: void 0, definition: void 0, locations: void 0, partitionsBy: [] };
}
var PackageSpec = {
  $type: "devvit.runtime.PackageSpec",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.actor !== void 0) {
      ActorSpec.encode(message.actor, writer.uint32(10).fork()).ldelim();
    }
    if (message.definition !== void 0) {
      SerializableServiceDefinition.encode(message.definition, writer.uint32(18).fork()).ldelim();
    }
    if (message.locations !== void 0) {
      LocationFilter.encode(message.locations, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.partitionsBy) {
      writer.uint32(34).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePackageSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = ActorSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.definition = SerializableServiceDefinition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.locations = LocationFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.partitionsBy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet12(object.actor) ? ActorSpec.fromJSON(object.actor) : void 0,
      definition: isSet12(object.definition) ? SerializableServiceDefinition.fromJSON(object.definition) : void 0,
      locations: isSet12(object.locations) ? LocationFilter.fromJSON(object.locations) : void 0,
      partitionsBy: globalThis.Array.isArray(object?.partitionsBy) ? object.partitionsBy.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== void 0) {
      obj.actor = ActorSpec.toJSON(message.actor);
    }
    if (message.definition !== void 0) {
      obj.definition = SerializableServiceDefinition.toJSON(message.definition);
    }
    if (message.locations !== void 0) {
      obj.locations = LocationFilter.toJSON(message.locations);
    }
    if (message.partitionsBy?.length) {
      obj.partitionsBy = message.partitionsBy;
    }
    return obj;
  },
  create(base) {
    return PackageSpec.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePackageSpec();
    message.actor = object.actor !== void 0 && object.actor !== null ? ActorSpec.fromPartial(object.actor) : void 0;
    message.definition = object.definition !== void 0 && object.definition !== null ? SerializableServiceDefinition.fromPartial(object.definition) : void 0;
    message.locations = object.locations !== void 0 && object.locations !== null ? LocationFilter.fromPartial(object.locations) : void 0;
    message.partitionsBy = object.partitionsBy?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(PackageSpec.$type, PackageSpec);
function createBasePackageQuery() {
  return { name: void 0, owner: void 0, typeName: "", versions: void 0 };
}
var PackageQuery = {
  $type: "devvit.runtime.PackageQuery",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(10).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      StringValue.encode({ value: message.owner }, writer.uint32(18).fork()).ldelim();
    }
    if (message.typeName !== "") {
      writer.uint32(26).string(message.typeName);
    }
    if (message.versions !== void 0) {
      StringValue.encode({ value: message.versions }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePackageQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.owner = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.typeName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.versions = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet12(object.name) ? String(object.name) : void 0,
      owner: isSet12(object.owner) ? String(object.owner) : void 0,
      typeName: isSet12(object.typeName) ? globalThis.String(object.typeName) : "",
      versions: isSet12(object.versions) ? String(object.versions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.owner !== void 0) {
      obj.owner = message.owner;
    }
    if (message.typeName !== "") {
      obj.typeName = message.typeName;
    }
    if (message.versions !== void 0) {
      obj.versions = message.versions;
    }
    return obj;
  },
  create(base) {
    return PackageQuery.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePackageQuery();
    message.name = object.name ?? void 0;
    message.owner = object.owner ?? void 0;
    message.typeName = object.typeName ?? "";
    message.versions = object.versions ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(PackageQuery.$type, PackageQuery);
function createBaseDependencySpec() {
  return { actor: void 0, hostname: "", provides: [], uses: [] };
}
var DependencySpec = {
  $type: "devvit.runtime.DependencySpec",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.actor !== void 0) {
      ActorSpec.encode(message.actor, writer.uint32(10).fork()).ldelim();
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    for (const v of message.provides) {
      PackageSpec.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.uses) {
      PackageQuery.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDependencySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = ActorSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.hostname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.provides.push(PackageSpec.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.uses.push(PackageQuery.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet12(object.actor) ? ActorSpec.fromJSON(object.actor) : void 0,
      hostname: isSet12(object.hostname) ? globalThis.String(object.hostname) : "",
      provides: globalThis.Array.isArray(object?.provides) ? object.provides.map((e) => PackageSpec.fromJSON(e)) : [],
      uses: globalThis.Array.isArray(object?.uses) ? object.uses.map((e) => PackageQuery.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== void 0) {
      obj.actor = ActorSpec.toJSON(message.actor);
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.provides?.length) {
      obj.provides = message.provides.map((e) => PackageSpec.toJSON(e));
    }
    if (message.uses?.length) {
      obj.uses = message.uses.map((e) => PackageQuery.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return DependencySpec.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDependencySpec();
    message.actor = object.actor !== void 0 && object.actor !== null ? ActorSpec.fromPartial(object.actor) : void 0;
    message.hostname = object.hostname ?? "";
    message.provides = object.provides?.map((e) => PackageSpec.fromPartial(e)) || [];
    message.uses = object.uses?.map((e) => PackageQuery.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(DependencySpec.$type, DependencySpec);
function createBaseLinkedBundle() {
  return {
    actor: void 0,
    code: "",
    hostname: "",
    provides: [],
    uses: [],
    buildInfo: void 0,
    assetsUrl: void 0,
    assets: {}
  };
}
var LinkedBundle = {
  $type: "devvit.runtime.LinkedBundle",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.actor !== void 0) {
      ActorSpec.encode(message.actor, writer.uint32(10).fork()).ldelim();
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    for (const v of message.provides) {
      SerializableServiceDefinition.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.uses) {
      LinkedBundle.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.buildInfo !== void 0) {
      BuildInfo.encode(message.buildInfo, writer.uint32(50).fork()).ldelim();
    }
    if (message.assetsUrl !== void 0) {
      StringValue.encode({ value: message.assetsUrl }, writer.uint32(58).fork()).ldelim();
    }
    Object.entries(message.assets).forEach(([key, value]) => {
      LinkedBundle_AssetsEntry.encode({ key, value }, writer.uint32(66).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkedBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = ActorSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.code = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.hostname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.provides.push(SerializableServiceDefinition.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.uses.push(LinkedBundle.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.assetsUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          const entry8 = LinkedBundle_AssetsEntry.decode(reader, reader.uint32());
          if (entry8.value !== void 0) {
            message.assets[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet12(object.actor) ? ActorSpec.fromJSON(object.actor) : void 0,
      code: isSet12(object.code) ? globalThis.String(object.code) : "",
      hostname: isSet12(object.hostname) ? globalThis.String(object.hostname) : "",
      provides: globalThis.Array.isArray(object?.provides) ? object.provides.map((e) => SerializableServiceDefinition.fromJSON(e)) : [],
      uses: globalThis.Array.isArray(object?.uses) ? object.uses.map((e) => LinkedBundle.fromJSON(e)) : [],
      buildInfo: isSet12(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : void 0,
      assetsUrl: isSet12(object.assetsUrl) ? String(object.assetsUrl) : void 0,
      assets: isObject3(object.assets) ? Object.entries(object.assets).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== void 0) {
      obj.actor = ActorSpec.toJSON(message.actor);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.provides?.length) {
      obj.provides = message.provides.map((e) => SerializableServiceDefinition.toJSON(e));
    }
    if (message.uses?.length) {
      obj.uses = message.uses.map((e) => LinkedBundle.toJSON(e));
    }
    if (message.buildInfo !== void 0) {
      obj.buildInfo = BuildInfo.toJSON(message.buildInfo);
    }
    if (message.assetsUrl !== void 0) {
      obj.assetsUrl = message.assetsUrl;
    }
    if (message.assets) {
      const entries = Object.entries(message.assets);
      if (entries.length > 0) {
        obj.assets = {};
        entries.forEach(([k, v]) => {
          obj.assets[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return LinkedBundle.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLinkedBundle();
    message.actor = object.actor !== void 0 && object.actor !== null ? ActorSpec.fromPartial(object.actor) : void 0;
    message.code = object.code ?? "";
    message.hostname = object.hostname ?? "";
    message.provides = object.provides?.map((e) => SerializableServiceDefinition.fromPartial(e)) || [];
    message.uses = object.uses?.map((e) => LinkedBundle.fromPartial(e)) || [];
    message.buildInfo = object.buildInfo !== void 0 && object.buildInfo !== null ? BuildInfo.fromPartial(object.buildInfo) : void 0;
    message.assetsUrl = object.assetsUrl ?? void 0;
    message.assets = Object.entries(object.assets ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(LinkedBundle.$type, LinkedBundle);
function createBaseLinkedBundle_AssetsEntry() {
  return { key: "", value: "" };
}
var LinkedBundle_AssetsEntry = {
  $type: "devvit.runtime.LinkedBundle.AssetsEntry",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkedBundle_AssetsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet12(object.key) ? globalThis.String(object.key) : "",
      value: isSet12(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return LinkedBundle_AssetsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLinkedBundle_AssetsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(LinkedBundle_AssetsEntry.$type, LinkedBundle_AssetsEntry);
function createBaseBuildInfo() {
  return { created: void 0, dependencies: {} };
}
var BuildInfo = {
  $type: "devvit.runtime.BuildInfo",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.created !== void 0) {
      Timestamp.encode(toTimestamp(message.created), writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.dependencies).forEach(([key, value]) => {
      BuildInfo_DependenciesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.created = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = BuildInfo_DependenciesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.dependencies[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      created: isSet12(object.created) ? fromJsonTimestamp(object.created) : void 0,
      dependencies: isObject3(object.dependencies) ? Object.entries(object.dependencies).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.created !== void 0) {
      obj.created = message.created.toISOString();
    }
    if (message.dependencies) {
      const entries = Object.entries(message.dependencies);
      if (entries.length > 0) {
        obj.dependencies = {};
        entries.forEach(([k, v]) => {
          obj.dependencies[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return BuildInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBuildInfo();
    message.created = object.created ?? void 0;
    message.dependencies = Object.entries(object.dependencies ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(BuildInfo.$type, BuildInfo);
function createBaseBuildInfo_DependenciesEntry() {
  return { key: "", value: "" };
}
var BuildInfo_DependenciesEntry = {
  $type: "devvit.runtime.BuildInfo.DependenciesEntry",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : import_minimal14.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildInfo_DependenciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet12(object.key) ? globalThis.String(object.key) : "",
      value: isSet12(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return BuildInfo_DependenciesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBuildInfo_DependenciesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(BuildInfo_DependenciesEntry.$type, BuildInfo_DependenciesEntry);
function toTimestamp(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}
function isObject3(value) {
  return typeof value === "object" && value !== null;
}
function isSet12(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/service/bundle_service.js
function createBaseBundleRequest() {
  return { hostname: "" };
}
var BundleRequest = {
  $type: "devvit.service.BundleRequest",
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : import_minimal15.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBundleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { hostname: isSet13(object.hostname) ? globalThis.String(object.hostname) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },
  create(base) {
    return BundleRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBundleRequest();
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set(BundleRequest.$type, BundleRequest);
function isSet13(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/remote_logger/remote_logger.js
var import_minimal17 = __toESM(require_minimal2(), 1);

// ../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// ../../node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// ../../node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// ../../node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// ../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// ../../node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// ../../node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// ../../node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// ../../node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// ../../node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last = i;
      }
      last && _buffer.splice(0, last + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// ../protos/dist/types/devvit/plugin/logger/logger.js
var import_minimal16 = __toESM(require_minimal2(), 1);
var Severity;
(function(Severity2) {
  Severity2[Severity2["DEBUG"] = 0] = "DEBUG";
  Severity2[Severity2["INFO"] = 1] = "INFO";
  Severity2[Severity2["WARN"] = 2] = "WARN";
  Severity2[Severity2["ERROR"] = 3] = "ERROR";
  Severity2[Severity2["VERBOSE"] = 4] = "VERBOSE";
  Severity2[Severity2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Severity || (Severity = {}));
function severityFromJSON(object) {
  switch (object) {
    case 0:
    case "DEBUG":
      return Severity.DEBUG;
    case 1:
    case "INFO":
      return Severity.INFO;
    case 2:
    case "WARN":
      return Severity.WARN;
    case 3:
    case "ERROR":
      return Severity.ERROR;
    case 4:
    case "VERBOSE":
      return Severity.VERBOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}
function severityToJSON(object) {
  switch (object) {
    case Severity.DEBUG:
      return 0;
    case Severity.INFO:
      return 1;
    case Severity.WARN:
      return 2;
    case Severity.ERROR:
      return 3;
    case Severity.VERBOSE:
      return 4;
    case Severity.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseLogErrorMessage() {
  return {
    message: "",
    name: "",
    fileName: void 0,
    lineNumber: void 0,
    columnNumber: void 0,
    stack: void 0,
    timestamp: void 0,
    tags: []
  };
}
var LogErrorMessage = {
  $type: "devvit.plugin.logger.LogErrorMessage",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.fileName !== void 0) {
      StringValue.encode({ value: message.fileName }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lineNumber !== void 0) {
      UInt32Value.encode({ value: message.lineNumber }, writer.uint32(34).fork()).ldelim();
    }
    if (message.columnNumber !== void 0) {
      UInt32Value.encode({ value: message.columnNumber }, writer.uint32(42).fork()).ldelim();
    }
    if (message.stack !== void 0) {
      StringValue.encode({ value: message.stack }, writer.uint32(50).fork()).ldelim();
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp2(message.timestamp), writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogErrorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.fileName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.lineNumber = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.columnNumber = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.stack = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.timestamp = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet14(object.message) ? globalThis.String(object.message) : "",
      name: isSet14(object.name) ? globalThis.String(object.name) : "",
      fileName: isSet14(object.fileName) ? String(object.fileName) : void 0,
      lineNumber: isSet14(object.lineNumber) ? Number(object.lineNumber) : void 0,
      columnNumber: isSet14(object.columnNumber) ? Number(object.columnNumber) : void 0,
      stack: isSet14(object.stack) ? String(object.stack) : void 0,
      timestamp: isSet14(object.timestamp) ? fromJsonTimestamp2(object.timestamp) : void 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fileName !== void 0) {
      obj.fileName = message.fileName;
    }
    if (message.lineNumber !== void 0) {
      obj.lineNumber = message.lineNumber;
    }
    if (message.columnNumber !== void 0) {
      obj.columnNumber = message.columnNumber;
    }
    if (message.stack !== void 0) {
      obj.stack = message.stack;
    }
    if (message.timestamp !== void 0) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },
  create(base) {
    return LogErrorMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLogErrorMessage();
    message.message = object.message ?? "";
    message.name = object.name ?? "";
    message.fileName = object.fileName ?? void 0;
    message.lineNumber = object.lineNumber ?? void 0;
    message.columnNumber = object.columnNumber ?? void 0;
    message.stack = object.stack ?? void 0;
    message.timestamp = object.timestamp ?? void 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(LogErrorMessage.$type, LogErrorMessage);
function createBaseLogEventMessage() {
  return { type: "", timestamp: void 0, labels: {}, data: {} };
}
var LogEventMessage = {
  $type: "devvit.plugin.logger.LogEventMessage",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp2(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LogEventMessage_LabelsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    Object.entries(message.data).forEach(([key, value]) => {
      LogEventMessage_DataEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.timestamp = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = LogEventMessage_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          const entry4 = LogEventMessage_DataEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.data[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet14(object.type) ? globalThis.String(object.type) : "",
      timestamp: isSet14(object.timestamp) ? fromJsonTimestamp2(object.timestamp) : void 0,
      labels: isObject4(object.labels) ? Object.entries(object.labels).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      data: isObject4(object.data) ? Object.entries(object.data).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.timestamp !== void 0) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return LogEventMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLogEventMessage();
    message.type = object.type ?? "";
    message.timestamp = object.timestamp ?? void 0;
    message.labels = Object.entries(object.labels ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.data = Object.entries(object.data ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(LogEventMessage.$type, LogEventMessage);
function createBaseLogEventMessage_LabelsEntry() {
  return { key: "", value: "" };
}
var LogEventMessage_LabelsEntry = {
  $type: "devvit.plugin.logger.LogEventMessage.LabelsEntry",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventMessage_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet14(object.key) ? globalThis.String(object.key) : "",
      value: isSet14(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return LogEventMessage_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLogEventMessage_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(LogEventMessage_LabelsEntry.$type, LogEventMessage_LabelsEntry);
function createBaseLogEventMessage_DataEntry() {
  return { key: "", value: "" };
}
var LogEventMessage_DataEntry = {
  $type: "devvit.plugin.logger.LogEventMessage.DataEntry",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventMessage_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet14(object.key) ? globalThis.String(object.key) : "",
      value: isSet14(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return LogEventMessage_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLogEventMessage_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(LogEventMessage_DataEntry.$type, LogEventMessage_DataEntry);
function createBaseLogMessage() {
  return { severity: 0, message: "", timestamp: void 0, tags: [] };
}
var LogMessage = {
  $type: "devvit.plugin.logger.LogMessage",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp2(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.severity = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.timestamp = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      severity: isSet14(object.severity) ? severityFromJSON(object.severity) : 0,
      message: isSet14(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet14(object.timestamp) ? fromJsonTimestamp2(object.timestamp) : void 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== void 0) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },
  create(base) {
    return LogMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLogMessage();
    message.severity = object.severity ?? 0;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? void 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(LogMessage.$type, LogMessage);
function createBaseLogMessages() {
  return { messages: [] };
}
var LogMessages = {
  $type: "devvit.plugin.logger.LogMessages",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v of message.messages) {
      LogMessage.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.messages.push(LogMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e) => LogMessage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => LogMessage.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return LogMessages.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLogMessages();
    message.messages = object.messages?.map((e) => LogMessage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(LogMessages.$type, LogMessages);
function createBaseLogErrorResponse() {
  return {};
}
var LogErrorResponse = {
  $type: "devvit.plugin.logger.LogErrorResponse",
  encode(_, writer = import_minimal16.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return LogErrorResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseLogErrorResponse();
    return message;
  }
};
messageTypeRegistry.set(LogErrorResponse.$type, LogErrorResponse);
function createBaseLogEventResponse() {
  return {};
}
var LogEventResponse = {
  $type: "devvit.plugin.logger.LogEventResponse",
  encode(_, writer = import_minimal16.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return LogEventResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseLogEventResponse();
    return message;
  }
};
messageTypeRegistry.set(LogEventResponse.$type, LogEventResponse);
function createBaseLogResponse() {
  return {};
}
var LogResponse = {
  $type: "devvit.plugin.logger.LogResponse",
  encode(_, writer = import_minimal16.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : import_minimal16.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return LogResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseLogResponse();
    return message;
  }
};
messageTypeRegistry.set(LogResponse.$type, LogResponse);
function toTimestamp2(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp2(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp2(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp2(Timestamp.fromJSON(o));
  }
}
function isObject4(value) {
  return typeof value === "object" && value !== null;
}
function isSet14(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/remote_logger/remote_logger.js
var RemoteLogType;
(function(RemoteLogType2) {
  RemoteLogType2[RemoteLogType2["LOG"] = 0] = "LOG";
  RemoteLogType2[RemoteLogType2["ERROR"] = 1] = "ERROR";
  RemoteLogType2[RemoteLogType2["EVENT"] = 2] = "EVENT";
  RemoteLogType2[RemoteLogType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RemoteLogType || (RemoteLogType = {}));
function remoteLogTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "LOG":
      return RemoteLogType.LOG;
    case 1:
    case "ERROR":
      return RemoteLogType.ERROR;
    case 2:
    case "EVENT":
      return RemoteLogType.EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RemoteLogType.UNRECOGNIZED;
  }
}
function remoteLogTypeToJSON(object) {
  switch (object) {
    case RemoteLogType.LOG:
      return 0;
    case RemoteLogType.ERROR:
      return 1;
    case RemoteLogType.EVENT:
      return 2;
    case RemoteLogType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseRemoteLogMessages() {
  return { messages: [] };
}
var RemoteLogMessages = {
  $type: "devvit.remote_logger.RemoteLogMessages",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    for (const v of message.messages) {
      RemoteLogMessage.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.messages.push(RemoteLogMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e) => RemoteLogMessage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => RemoteLogMessage.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return RemoteLogMessages.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoteLogMessages();
    message.messages = object.messages?.map((e) => RemoteLogMessage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(RemoteLogMessages.$type, RemoteLogMessages);
function createBaseRemoteLogPutResponse() {
  return {};
}
var RemoteLogPutResponse = {
  $type: "devvit.remote_logger.RemoteLogPutResponse",
  encode(_, writer = import_minimal17.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogPutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return RemoteLogPutResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseRemoteLogPutResponse();
    return message;
  }
};
messageTypeRegistry.set(RemoteLogPutResponse.$type, RemoteLogPutResponse);
function createBaseKeepAliveMessage() {
  return { timestamp: void 0 };
}
var KeepAliveMessage = {
  $type: "devvit.remote_logger.KeepAliveMessage",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp3(message.timestamp), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeepAliveMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.timestamp = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { timestamp: isSet15(object.timestamp) ? fromJsonTimestamp3(object.timestamp) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.timestamp !== void 0) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },
  create(base) {
    return KeepAliveMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeepAliveMessage();
    message.timestamp = object.timestamp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(KeepAliveMessage.$type, KeepAliveMessage);
function createBaseRemoteLogMessage() {
  return { log: void 0, error: void 0, keepalive: void 0, event: void 0 };
}
var RemoteLogMessage = {
  $type: "devvit.remote_logger.RemoteLogMessage",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.log !== void 0) {
      LogMessage.encode(message.log, writer.uint32(10).fork()).ldelim();
    }
    if (message.error !== void 0) {
      LogErrorMessage.encode(message.error, writer.uint32(18).fork()).ldelim();
    }
    if (message.keepalive !== void 0) {
      KeepAliveMessage.encode(message.keepalive, writer.uint32(26).fork()).ldelim();
    }
    if (message.event !== void 0) {
      LogEventMessage.encode(message.event, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.log = LogMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.error = LogErrorMessage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.keepalive = KeepAliveMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.event = LogEventMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      log: isSet15(object.log) ? LogMessage.fromJSON(object.log) : void 0,
      error: isSet15(object.error) ? LogErrorMessage.fromJSON(object.error) : void 0,
      keepalive: isSet15(object.keepalive) ? KeepAliveMessage.fromJSON(object.keepalive) : void 0,
      event: isSet15(object.event) ? LogEventMessage.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.log !== void 0) {
      obj.log = LogMessage.toJSON(message.log);
    }
    if (message.error !== void 0) {
      obj.error = LogErrorMessage.toJSON(message.error);
    }
    if (message.keepalive !== void 0) {
      obj.keepalive = KeepAliveMessage.toJSON(message.keepalive);
    }
    if (message.event !== void 0) {
      obj.event = LogEventMessage.toJSON(message.event);
    }
    return obj;
  },
  create(base) {
    return RemoteLogMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoteLogMessage();
    message.log = object.log !== void 0 && object.log !== null ? LogMessage.fromPartial(object.log) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? LogErrorMessage.fromPartial(object.error) : void 0;
    message.keepalive = object.keepalive !== void 0 && object.keepalive !== null ? KeepAliveMessage.fromPartial(object.keepalive) : void 0;
    message.event = object.event !== void 0 && object.event !== null ? LogEventMessage.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set(RemoteLogMessage.$type, RemoteLogMessage);
function createBaseRemoteLogInstallationFilter() {
  return { installationId: "" };
}
var RemoteLogInstallationFilter = {
  $type: "devvit.remote_logger.RemoteLogInstallationFilter",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogInstallationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet15(object.installationId) ? globalThis.String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    return obj;
  },
  create(base) {
    return RemoteLogInstallationFilter.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoteLogInstallationFilter();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set(RemoteLogInstallationFilter.$type, RemoteLogInstallationFilter);
function createBaseRemoteLogSubredditAppNameFilter() {
  return { subreddit: "", appName: "" };
}
var RemoteLogSubredditAppNameFilter = {
  $type: "devvit.remote_logger.RemoteLogSubredditAppNameFilter",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    if (message.appName !== "") {
      writer.uint32(26).string(message.appName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogSubredditAppNameFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.appName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet15(object.subreddit) ? globalThis.String(object.subreddit) : "",
      appName: isSet15(object.appName) ? globalThis.String(object.appName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    return obj;
  },
  create(base) {
    return RemoteLogSubredditAppNameFilter.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoteLogSubredditAppNameFilter();
    message.subreddit = object.subreddit ?? "";
    message.appName = object.appName ?? "";
    return message;
  }
};
messageTypeRegistry.set(RemoteLogSubredditAppNameFilter.$type, RemoteLogSubredditAppNameFilter);
function createBaseRemoteLogQuery() {
  return { installation: void 0, subredditAppName: void 0, type: 0, since: void 0 };
}
var RemoteLogQuery = {
  $type: "devvit.remote_logger.RemoteLogQuery",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.installation !== void 0) {
      RemoteLogInstallationFilter.encode(message.installation, writer.uint32(10).fork()).ldelim();
    }
    if (message.subredditAppName !== void 0) {
      RemoteLogSubredditAppNameFilter.encode(message.subredditAppName, writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.since !== void 0) {
      Timestamp.encode(toTimestamp3(message.since), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : import_minimal17.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installation = RemoteLogInstallationFilter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subredditAppName = RemoteLogSubredditAppNameFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.since = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installation: isSet15(object.installation) ? RemoteLogInstallationFilter.fromJSON(object.installation) : void 0,
      subredditAppName: isSet15(object.subredditAppName) ? RemoteLogSubredditAppNameFilter.fromJSON(object.subredditAppName) : void 0,
      type: isSet15(object.type) ? remoteLogTypeFromJSON(object.type) : 0,
      since: isSet15(object.since) ? fromJsonTimestamp3(object.since) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installation !== void 0) {
      obj.installation = RemoteLogInstallationFilter.toJSON(message.installation);
    }
    if (message.subredditAppName !== void 0) {
      obj.subredditAppName = RemoteLogSubredditAppNameFilter.toJSON(message.subredditAppName);
    }
    if (message.type !== 0) {
      obj.type = remoteLogTypeToJSON(message.type);
    }
    if (message.since !== void 0) {
      obj.since = message.since.toISOString();
    }
    return obj;
  },
  create(base) {
    return RemoteLogQuery.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoteLogQuery();
    message.installation = object.installation !== void 0 && object.installation !== null ? RemoteLogInstallationFilter.fromPartial(object.installation) : void 0;
    message.subredditAppName = object.subredditAppName !== void 0 && object.subredditAppName !== null ? RemoteLogSubredditAppNameFilter.fromPartial(object.subredditAppName) : void 0;
    message.type = object.type ?? 0;
    message.since = object.since ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RemoteLogQuery.$type, RemoteLogQuery);
function toTimestamp3(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp3(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp3(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp3(Timestamp.fromJSON(o));
  }
}
function isSet15(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/user.js
var import_minimal20 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/subreddit.js
var import_minimal19 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/common.js
var import_minimal18 = __toESM(require_minimal2(), 1);
var BanInfo_BanInfoAction;
(function(BanInfo_BanInfoAction2) {
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["UNKNOWN"] = 0] = "UNKNOWN";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["SPAM"] = 1] = "SPAM";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["FILTER"] = 2] = "FILTER";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["REMOVE"] = 3] = "REMOVE";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BanInfo_BanInfoAction || (BanInfo_BanInfoAction = {}));
function banInfo_BanInfoActionFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return BanInfo_BanInfoAction.UNKNOWN;
    case 1:
    case "SPAM":
      return BanInfo_BanInfoAction.SPAM;
    case 2:
    case "FILTER":
      return BanInfo_BanInfoAction.FILTER;
    case 3:
    case "REMOVE":
      return BanInfo_BanInfoAction.REMOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BanInfo_BanInfoAction.UNRECOGNIZED;
  }
}
function banInfo_BanInfoActionToJSON(object) {
  switch (object) {
    case BanInfo_BanInfoAction.UNKNOWN:
      return 0;
    case BanInfo_BanInfoAction.SPAM:
      return 1;
    case BanInfo_BanInfoAction.FILTER:
      return 2;
    case BanInfo_BanInfoAction.REMOVE:
      return 3;
    case BanInfo_BanInfoAction.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAuthorFlairRichText() {
  return { e: void 0, t: void 0 };
}
var AuthorFlairRichText = {
  $type: "devvit.reddit.AuthorFlairRichText",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthorFlairRichText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.e = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.t = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { e: isSet16(object.e) ? String(object.e) : void 0, t: isSet16(object.t) ? String(object.t) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.e !== void 0) {
      obj.e = message.e;
    }
    if (message.t !== void 0) {
      obj.t = message.t;
    }
    return obj;
  },
  create(base) {
    return AuthorFlairRichText.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAuthorFlairRichText();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AuthorFlairRichText.$type, AuthorFlairRichText);
function createBaseAwarding() {
  return {
    awardSubType: void 0,
    awardType: void 0,
    awardingsRequiredToGrantBenefits: void 0,
    coinPrice: void 0,
    coinReward: void 0,
    count: void 0,
    daysOfDripExtension: void 0,
    daysOfPremium: void 0,
    description: void 0,
    endDate: void 0,
    giverCoinReward: void 0,
    iconFormat: void 0,
    iconHeight: void 0,
    iconUrl: void 0,
    iconWidth: void 0,
    id: void 0,
    isEnabled: void 0,
    isNew: void 0,
    name: void 0,
    pennyDonate: void 0,
    pennyPrice: void 0,
    resizedIcons: [],
    resizedStaticIcons: [],
    startDate: void 0,
    staticIconHeight: void 0,
    staticIconUrl: void 0,
    staticIconWidth: void 0,
    stickyDurationSeconds: void 0,
    subredditCoinReward: void 0,
    subredditId: void 0,
    tiersByRequiredAwardings: void 0
  };
}
var Awarding = {
  $type: "devvit.reddit.Awarding",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.awardSubType !== void 0) {
      StringValue.encode({ value: message.awardSubType }, writer.uint32(10).fork()).ldelim();
    }
    if (message.awardType !== void 0) {
      StringValue.encode({ value: message.awardType }, writer.uint32(18).fork()).ldelim();
    }
    if (message.awardingsRequiredToGrantBenefits !== void 0) {
      Int32Value.encode({ value: message.awardingsRequiredToGrantBenefits }, writer.uint32(26).fork()).ldelim();
    }
    if (message.coinPrice !== void 0) {
      Int64Value.encode({ value: message.coinPrice }, writer.uint32(34).fork()).ldelim();
    }
    if (message.coinReward !== void 0) {
      Int64Value.encode({ value: message.coinReward }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int32Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.daysOfDripExtension !== void 0) {
      Int32Value.encode({ value: message.daysOfDripExtension }, writer.uint32(58).fork()).ldelim();
    }
    if (message.daysOfPremium !== void 0) {
      Int32Value.encode({ value: message.daysOfPremium }, writer.uint32(66).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(74).fork()).ldelim();
    }
    if (message.endDate !== void 0) {
      StringValue.encode({ value: message.endDate }, writer.uint32(82).fork()).ldelim();
    }
    if (message.giverCoinReward !== void 0) {
      Int32Value.encode({ value: message.giverCoinReward }, writer.uint32(90).fork()).ldelim();
    }
    if (message.iconFormat !== void 0) {
      StringValue.encode({ value: message.iconFormat }, writer.uint32(98).fork()).ldelim();
    }
    if (message.iconHeight !== void 0) {
      Int32Value.encode({ value: message.iconHeight }, writer.uint32(106).fork()).ldelim();
    }
    if (message.iconUrl !== void 0) {
      StringValue.encode({ value: message.iconUrl }, writer.uint32(114).fork()).ldelim();
    }
    if (message.iconWidth !== void 0) {
      Int32Value.encode({ value: message.iconWidth }, writer.uint32(122).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
    }
    if (message.isEnabled !== void 0) {
      BoolValue.encode({ value: message.isEnabled }, writer.uint32(138).fork()).ldelim();
    }
    if (message.isNew !== void 0) {
      BoolValue.encode({ value: message.isNew }, writer.uint32(146).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(154).fork()).ldelim();
    }
    if (message.pennyDonate !== void 0) {
      Int32Value.encode({ value: message.pennyDonate }, writer.uint32(162).fork()).ldelim();
    }
    if (message.pennyPrice !== void 0) {
      Int32Value.encode({ value: message.pennyPrice }, writer.uint32(170).fork()).ldelim();
    }
    for (const v of message.resizedIcons) {
      Awarding_Icon.encode(v, writer.uint32(178).fork()).ldelim();
    }
    for (const v of message.resizedStaticIcons) {
      Awarding_Icon.encode(v, writer.uint32(186).fork()).ldelim();
    }
    if (message.startDate !== void 0) {
      StringValue.encode({ value: message.startDate }, writer.uint32(194).fork()).ldelim();
    }
    if (message.staticIconHeight !== void 0) {
      Int32Value.encode({ value: message.staticIconHeight }, writer.uint32(202).fork()).ldelim();
    }
    if (message.staticIconUrl !== void 0) {
      StringValue.encode({ value: message.staticIconUrl }, writer.uint32(210).fork()).ldelim();
    }
    if (message.staticIconWidth !== void 0) {
      Int32Value.encode({ value: message.staticIconWidth }, writer.uint32(218).fork()).ldelim();
    }
    if (message.stickyDurationSeconds !== void 0) {
      Int64Value.encode({ value: message.stickyDurationSeconds }, writer.uint32(226).fork()).ldelim();
    }
    if (message.subredditCoinReward !== void 0) {
      Int64Value.encode({ value: message.subredditCoinReward }, writer.uint32(234).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(242).fork()).ldelim();
    }
    if (message.tiersByRequiredAwardings !== void 0) {
      StringValue.encode({ value: message.tiersByRequiredAwardings }, writer.uint32(250).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAwarding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.awardSubType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.awardType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.awardingsRequiredToGrantBenefits = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.coinPrice = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.coinReward = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.count = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.daysOfDripExtension = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.daysOfPremium = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.endDate = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.giverCoinReward = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.iconFormat = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.iconHeight = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.iconWidth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.isNew = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.pennyDonate = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.pennyPrice = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.resizedIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.resizedStaticIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.startDate = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.staticIconHeight = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.staticIconUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.staticIconWidth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.stickyDurationSeconds = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.subredditCoinReward = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.tiersByRequiredAwardings = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      awardSubType: isSet16(object.awardSubType) ? String(object.awardSubType) : void 0,
      awardType: isSet16(object.awardType) ? String(object.awardType) : void 0,
      awardingsRequiredToGrantBenefits: isSet16(object.awardingsRequiredToGrantBenefits) ? Number(object.awardingsRequiredToGrantBenefits) : void 0,
      coinPrice: isSet16(object.coinPrice) ? Number(object.coinPrice) : void 0,
      coinReward: isSet16(object.coinReward) ? Number(object.coinReward) : void 0,
      count: isSet16(object.count) ? Number(object.count) : void 0,
      daysOfDripExtension: isSet16(object.daysOfDripExtension) ? Number(object.daysOfDripExtension) : void 0,
      daysOfPremium: isSet16(object.daysOfPremium) ? Number(object.daysOfPremium) : void 0,
      description: isSet16(object.description) ? String(object.description) : void 0,
      endDate: isSet16(object.endDate) ? String(object.endDate) : void 0,
      giverCoinReward: isSet16(object.giverCoinReward) ? Number(object.giverCoinReward) : void 0,
      iconFormat: isSet16(object.iconFormat) ? String(object.iconFormat) : void 0,
      iconHeight: isSet16(object.iconHeight) ? Number(object.iconHeight) : void 0,
      iconUrl: isSet16(object.iconUrl) ? String(object.iconUrl) : void 0,
      iconWidth: isSet16(object.iconWidth) ? Number(object.iconWidth) : void 0,
      id: isSet16(object.id) ? String(object.id) : void 0,
      isEnabled: isSet16(object.isEnabled) ? Boolean(object.isEnabled) : void 0,
      isNew: isSet16(object.isNew) ? Boolean(object.isNew) : void 0,
      name: isSet16(object.name) ? String(object.name) : void 0,
      pennyDonate: isSet16(object.pennyDonate) ? Number(object.pennyDonate) : void 0,
      pennyPrice: isSet16(object.pennyPrice) ? Number(object.pennyPrice) : void 0,
      resizedIcons: globalThis.Array.isArray(object?.resizedIcons) ? object.resizedIcons.map((e) => Awarding_Icon.fromJSON(e)) : [],
      resizedStaticIcons: globalThis.Array.isArray(object?.resizedStaticIcons) ? object.resizedStaticIcons.map((e) => Awarding_Icon.fromJSON(e)) : [],
      startDate: isSet16(object.startDate) ? String(object.startDate) : void 0,
      staticIconHeight: isSet16(object.staticIconHeight) ? Number(object.staticIconHeight) : void 0,
      staticIconUrl: isSet16(object.staticIconUrl) ? String(object.staticIconUrl) : void 0,
      staticIconWidth: isSet16(object.staticIconWidth) ? Number(object.staticIconWidth) : void 0,
      stickyDurationSeconds: isSet16(object.stickyDurationSeconds) ? Number(object.stickyDurationSeconds) : void 0,
      subredditCoinReward: isSet16(object.subredditCoinReward) ? Number(object.subredditCoinReward) : void 0,
      subredditId: isSet16(object.subredditId) ? String(object.subredditId) : void 0,
      tiersByRequiredAwardings: isSet16(object.tiersByRequiredAwardings) ? String(object.tiersByRequiredAwardings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.awardSubType !== void 0) {
      obj.awardSubType = message.awardSubType;
    }
    if (message.awardType !== void 0) {
      obj.awardType = message.awardType;
    }
    if (message.awardingsRequiredToGrantBenefits !== void 0) {
      obj.awardingsRequiredToGrantBenefits = message.awardingsRequiredToGrantBenefits;
    }
    if (message.coinPrice !== void 0) {
      obj.coinPrice = message.coinPrice;
    }
    if (message.coinReward !== void 0) {
      obj.coinReward = message.coinReward;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.daysOfDripExtension !== void 0) {
      obj.daysOfDripExtension = message.daysOfDripExtension;
    }
    if (message.daysOfPremium !== void 0) {
      obj.daysOfPremium = message.daysOfPremium;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.endDate !== void 0) {
      obj.endDate = message.endDate;
    }
    if (message.giverCoinReward !== void 0) {
      obj.giverCoinReward = message.giverCoinReward;
    }
    if (message.iconFormat !== void 0) {
      obj.iconFormat = message.iconFormat;
    }
    if (message.iconHeight !== void 0) {
      obj.iconHeight = message.iconHeight;
    }
    if (message.iconUrl !== void 0) {
      obj.iconUrl = message.iconUrl;
    }
    if (message.iconWidth !== void 0) {
      obj.iconWidth = message.iconWidth;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.isEnabled !== void 0) {
      obj.isEnabled = message.isEnabled;
    }
    if (message.isNew !== void 0) {
      obj.isNew = message.isNew;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.pennyDonate !== void 0) {
      obj.pennyDonate = message.pennyDonate;
    }
    if (message.pennyPrice !== void 0) {
      obj.pennyPrice = message.pennyPrice;
    }
    if (message.resizedIcons?.length) {
      obj.resizedIcons = message.resizedIcons.map((e) => Awarding_Icon.toJSON(e));
    }
    if (message.resizedStaticIcons?.length) {
      obj.resizedStaticIcons = message.resizedStaticIcons.map((e) => Awarding_Icon.toJSON(e));
    }
    if (message.startDate !== void 0) {
      obj.startDate = message.startDate;
    }
    if (message.staticIconHeight !== void 0) {
      obj.staticIconHeight = message.staticIconHeight;
    }
    if (message.staticIconUrl !== void 0) {
      obj.staticIconUrl = message.staticIconUrl;
    }
    if (message.staticIconWidth !== void 0) {
      obj.staticIconWidth = message.staticIconWidth;
    }
    if (message.stickyDurationSeconds !== void 0) {
      obj.stickyDurationSeconds = message.stickyDurationSeconds;
    }
    if (message.subredditCoinReward !== void 0) {
      obj.subredditCoinReward = message.subredditCoinReward;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.tiersByRequiredAwardings !== void 0) {
      obj.tiersByRequiredAwardings = message.tiersByRequiredAwardings;
    }
    return obj;
  },
  create(base) {
    return Awarding.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAwarding();
    message.awardSubType = object.awardSubType ?? void 0;
    message.awardType = object.awardType ?? void 0;
    message.awardingsRequiredToGrantBenefits = object.awardingsRequiredToGrantBenefits ?? void 0;
    message.coinPrice = object.coinPrice ?? void 0;
    message.coinReward = object.coinReward ?? void 0;
    message.count = object.count ?? void 0;
    message.daysOfDripExtension = object.daysOfDripExtension ?? void 0;
    message.daysOfPremium = object.daysOfPremium ?? void 0;
    message.description = object.description ?? void 0;
    message.endDate = object.endDate ?? void 0;
    message.giverCoinReward = object.giverCoinReward ?? void 0;
    message.iconFormat = object.iconFormat ?? void 0;
    message.iconHeight = object.iconHeight ?? void 0;
    message.iconUrl = object.iconUrl ?? void 0;
    message.iconWidth = object.iconWidth ?? void 0;
    message.id = object.id ?? void 0;
    message.isEnabled = object.isEnabled ?? void 0;
    message.isNew = object.isNew ?? void 0;
    message.name = object.name ?? void 0;
    message.pennyDonate = object.pennyDonate ?? void 0;
    message.pennyPrice = object.pennyPrice ?? void 0;
    message.resizedIcons = object.resizedIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
    message.resizedStaticIcons = object.resizedStaticIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
    message.startDate = object.startDate ?? void 0;
    message.staticIconHeight = object.staticIconHeight ?? void 0;
    message.staticIconUrl = object.staticIconUrl ?? void 0;
    message.staticIconWidth = object.staticIconWidth ?? void 0;
    message.stickyDurationSeconds = object.stickyDurationSeconds ?? void 0;
    message.subredditCoinReward = object.subredditCoinReward ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.tiersByRequiredAwardings = object.tiersByRequiredAwardings ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Awarding.$type, Awarding);
function createBaseAwarding_Icon() {
  return { height: void 0, url: void 0, width: void 0 };
}
var Awarding_Icon = {
  $type: "devvit.reddit.Awarding.Icon",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAwarding_Icon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet16(object.height) ? Number(object.height) : void 0,
      url: isSet16(object.url) ? String(object.url) : void 0,
      width: isSet16(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    return obj;
  },
  create(base) {
    return Awarding_Icon.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAwarding_Icon();
    message.height = object.height ?? void 0;
    message.url = object.url ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Awarding_Icon.$type, Awarding_Icon);
function createBaseCommentContributionSettings() {
  return { allowedMediaTypes: [] };
}
var CommentContributionSettings = {
  $type: "devvit.reddit.CommentContributionSettings",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v of message.allowedMediaTypes) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentContributionSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.allowedMediaTypes.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowedMediaTypes: globalThis.Array.isArray(object?.allowedMediaTypes) ? object.allowedMediaTypes.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allowedMediaTypes?.length) {
      obj.allowedMediaTypes = message.allowedMediaTypes;
    }
    return obj;
  },
  create(base) {
    return CommentContributionSettings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentContributionSettings();
    message.allowedMediaTypes = object.allowedMediaTypes?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(CommentContributionSettings.$type, CommentContributionSettings);
function createBaseGildings() {
  return { gid1: void 0, gid2: void 0, gid3: void 0 };
}
var Gildings = {
  $type: "devvit.reddit.Gildings",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.gid1 !== void 0) {
      Int32Value.encode({ value: message.gid1 }, writer.uint32(10).fork()).ldelim();
    }
    if (message.gid2 !== void 0) {
      Int32Value.encode({ value: message.gid2 }, writer.uint32(18).fork()).ldelim();
    }
    if (message.gid3 !== void 0) {
      Int32Value.encode({ value: message.gid3 }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGildings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.gid1 = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.gid2 = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.gid3 = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      gid1: isSet16(object.gid1) ? Number(object.gid1) : void 0,
      gid2: isSet16(object.gid2) ? Number(object.gid2) : void 0,
      gid3: isSet16(object.gid3) ? Number(object.gid3) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.gid1 !== void 0) {
      obj.gid1 = message.gid1;
    }
    if (message.gid2 !== void 0) {
      obj.gid2 = message.gid2;
    }
    if (message.gid3 !== void 0) {
      obj.gid3 = message.gid3;
    }
    return obj;
  },
  create(base) {
    return Gildings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGildings();
    message.gid1 = object.gid1 ?? void 0;
    message.gid2 = object.gid2 ?? void 0;
    message.gid3 = object.gid3 ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Gildings.$type, Gildings);
function createBaseMediaEmbed() {
  return {
    content: void 0,
    width: void 0,
    height: void 0,
    sandbox: void 0,
    scrolling: void 0,
    publicThumbnailUrl: void 0
  };
}
var MediaEmbed = {
  $type: "devvit.reddit.MediaEmbed",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.content !== void 0) {
      StringValue.encode({ value: message.content }, writer.uint32(10).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
    }
    if (message.sandbox !== void 0) {
      BoolValue.encode({ value: message.sandbox }, writer.uint32(34).fork()).ldelim();
    }
    if (message.scrolling !== void 0) {
      BoolValue.encode({ value: message.scrolling }, writer.uint32(42).fork()).ldelim();
    }
    if (message.publicThumbnailUrl !== void 0) {
      StringValue.encode({ value: message.publicThumbnailUrl }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.content = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.sandbox = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.scrolling = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.publicThumbnailUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      content: isSet16(object.content) ? String(object.content) : void 0,
      width: isSet16(object.width) ? Number(object.width) : void 0,
      height: isSet16(object.height) ? Number(object.height) : void 0,
      sandbox: isSet16(object.sandbox) ? Boolean(object.sandbox) : void 0,
      scrolling: isSet16(object.scrolling) ? Boolean(object.scrolling) : void 0,
      publicThumbnailUrl: isSet16(object.publicThumbnailUrl) ? String(object.publicThumbnailUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.content !== void 0) {
      obj.content = message.content;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.sandbox !== void 0) {
      obj.sandbox = message.sandbox;
    }
    if (message.scrolling !== void 0) {
      obj.scrolling = message.scrolling;
    }
    if (message.publicThumbnailUrl !== void 0) {
      obj.publicThumbnailUrl = message.publicThumbnailUrl;
    }
    return obj;
  },
  create(base) {
    return MediaEmbed.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMediaEmbed();
    message.content = object.content ?? void 0;
    message.width = object.width ?? void 0;
    message.height = object.height ?? void 0;
    message.sandbox = object.sandbox ?? void 0;
    message.scrolling = object.scrolling ?? void 0;
    message.publicThumbnailUrl = object.publicThumbnailUrl ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(MediaEmbed.$type, MediaEmbed);
function createBaseUserFlairRichtext() {
  return { e: void 0, t: void 0 };
}
var UserFlairRichtext = {
  $type: "devvit.reddit.UserFlairRichtext",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFlairRichtext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.e = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.t = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { e: isSet16(object.e) ? String(object.e) : void 0, t: isSet16(object.t) ? String(object.t) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.e !== void 0) {
      obj.e = message.e;
    }
    if (message.t !== void 0) {
      obj.t = message.t;
    }
    return obj;
  },
  create(base) {
    return UserFlairRichtext.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserFlairRichtext();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserFlairRichtext.$type, UserFlairRichtext);
function createBaseBanInfo() {
  return {
    auto: void 0,
    bannedAt: void 0,
    banner: void 0,
    moderatorBanned: void 0,
    note: void 0,
    unbanner: void 0,
    unbannedAt: void 0,
    resetUsed: void 0,
    reasonId: void 0,
    reasonTitle: void 0,
    reasonMessage: void 0,
    reasonBy: void 0,
    modNote: void 0,
    banAllTriggered: void 0,
    subredditMessage: void 0,
    removeAction: 0
  };
}
var BanInfo = {
  $type: "devvit.reddit.BanInfo",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.auto !== void 0) {
      BoolValue.encode({ value: message.auto }, writer.uint32(10).fork()).ldelim();
    }
    if (message.bannedAt !== void 0) {
      Int32Value.encode({ value: message.bannedAt }, writer.uint32(18).fork()).ldelim();
    }
    if (message.banner !== void 0) {
      StringValue.encode({ value: message.banner }, writer.uint32(26).fork()).ldelim();
    }
    if (message.moderatorBanned !== void 0) {
      BoolValue.encode({ value: message.moderatorBanned }, writer.uint32(34).fork()).ldelim();
    }
    if (message.note !== void 0) {
      StringValue.encode({ value: message.note }, writer.uint32(42).fork()).ldelim();
    }
    if (message.unbanner !== void 0) {
      StringValue.encode({ value: message.unbanner }, writer.uint32(50).fork()).ldelim();
    }
    if (message.unbannedAt !== void 0) {
      Int32Value.encode({ value: message.unbannedAt }, writer.uint32(58).fork()).ldelim();
    }
    if (message.resetUsed !== void 0) {
      BoolValue.encode({ value: message.resetUsed }, writer.uint32(66).fork()).ldelim();
    }
    if (message.reasonId !== void 0) {
      StringValue.encode({ value: message.reasonId }, writer.uint32(74).fork()).ldelim();
    }
    if (message.reasonTitle !== void 0) {
      StringValue.encode({ value: message.reasonTitle }, writer.uint32(82).fork()).ldelim();
    }
    if (message.reasonMessage !== void 0) {
      StringValue.encode({ value: message.reasonMessage }, writer.uint32(90).fork()).ldelim();
    }
    if (message.reasonBy !== void 0) {
      StringValue.encode({ value: message.reasonBy }, writer.uint32(98).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(106).fork()).ldelim();
    }
    if (message.banAllTriggered !== void 0) {
      BoolValue.encode({ value: message.banAllTriggered }, writer.uint32(114).fork()).ldelim();
    }
    if (message.subredditMessage !== void 0) {
      StringValue.encode({ value: message.subredditMessage }, writer.uint32(122).fork()).ldelim();
    }
    if (message.removeAction !== 0) {
      writer.uint32(128).int32(message.removeAction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : import_minimal18.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBanInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.auto = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.bannedAt = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.banner = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.moderatorBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.note = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.unbanner = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.unbannedAt = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.resetUsed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.reasonId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.reasonTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.reasonMessage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.reasonBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.banAllTriggered = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.subredditMessage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }
          message.removeAction = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      auto: isSet16(object.auto) ? Boolean(object.auto) : void 0,
      bannedAt: isSet16(object.bannedAt) ? Number(object.bannedAt) : void 0,
      banner: isSet16(object.banner) ? String(object.banner) : void 0,
      moderatorBanned: isSet16(object.moderatorBanned) ? Boolean(object.moderatorBanned) : void 0,
      note: isSet16(object.note) ? String(object.note) : void 0,
      unbanner: isSet16(object.unbanner) ? String(object.unbanner) : void 0,
      unbannedAt: isSet16(object.unbannedAt) ? Number(object.unbannedAt) : void 0,
      resetUsed: isSet16(object.resetUsed) ? Boolean(object.resetUsed) : void 0,
      reasonId: isSet16(object.reasonId) ? String(object.reasonId) : void 0,
      reasonTitle: isSet16(object.reasonTitle) ? String(object.reasonTitle) : void 0,
      reasonMessage: isSet16(object.reasonMessage) ? String(object.reasonMessage) : void 0,
      reasonBy: isSet16(object.reasonBy) ? String(object.reasonBy) : void 0,
      modNote: isSet16(object.modNote) ? String(object.modNote) : void 0,
      banAllTriggered: isSet16(object.banAllTriggered) ? Boolean(object.banAllTriggered) : void 0,
      subredditMessage: isSet16(object.subredditMessage) ? String(object.subredditMessage) : void 0,
      removeAction: isSet16(object.removeAction) ? banInfo_BanInfoActionFromJSON(object.removeAction) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.auto !== void 0) {
      obj.auto = message.auto;
    }
    if (message.bannedAt !== void 0) {
      obj.bannedAt = message.bannedAt;
    }
    if (message.banner !== void 0) {
      obj.banner = message.banner;
    }
    if (message.moderatorBanned !== void 0) {
      obj.moderatorBanned = message.moderatorBanned;
    }
    if (message.note !== void 0) {
      obj.note = message.note;
    }
    if (message.unbanner !== void 0) {
      obj.unbanner = message.unbanner;
    }
    if (message.unbannedAt !== void 0) {
      obj.unbannedAt = message.unbannedAt;
    }
    if (message.resetUsed !== void 0) {
      obj.resetUsed = message.resetUsed;
    }
    if (message.reasonId !== void 0) {
      obj.reasonId = message.reasonId;
    }
    if (message.reasonTitle !== void 0) {
      obj.reasonTitle = message.reasonTitle;
    }
    if (message.reasonMessage !== void 0) {
      obj.reasonMessage = message.reasonMessage;
    }
    if (message.reasonBy !== void 0) {
      obj.reasonBy = message.reasonBy;
    }
    if (message.modNote !== void 0) {
      obj.modNote = message.modNote;
    }
    if (message.banAllTriggered !== void 0) {
      obj.banAllTriggered = message.banAllTriggered;
    }
    if (message.subredditMessage !== void 0) {
      obj.subredditMessage = message.subredditMessage;
    }
    if (message.removeAction !== 0) {
      obj.removeAction = banInfo_BanInfoActionToJSON(message.removeAction);
    }
    return obj;
  },
  create(base) {
    return BanInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBanInfo();
    message.auto = object.auto ?? void 0;
    message.bannedAt = object.bannedAt ?? void 0;
    message.banner = object.banner ?? void 0;
    message.moderatorBanned = object.moderatorBanned ?? void 0;
    message.note = object.note ?? void 0;
    message.unbanner = object.unbanner ?? void 0;
    message.unbannedAt = object.unbannedAt ?? void 0;
    message.resetUsed = object.resetUsed ?? void 0;
    message.reasonId = object.reasonId ?? void 0;
    message.reasonTitle = object.reasonTitle ?? void 0;
    message.reasonMessage = object.reasonMessage ?? void 0;
    message.reasonBy = object.reasonBy ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.banAllTriggered = object.banAllTriggered ?? void 0;
    message.subredditMessage = object.subredditMessage ?? void 0;
    message.removeAction = object.removeAction ?? 0;
    return message;
  }
};
messageTypeRegistry.set(BanInfo.$type, BanInfo);
function isSet16(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/subreddit.js
function createBaseSubreddit() {
  return {
    acceptFollowers: void 0,
    accountsActiveIsFuzzed: void 0,
    accountsActive: void 0,
    activeUserCount: void 0,
    advertiserCategory: void 0,
    allOriginalContent: void 0,
    allowChatPostCreation: void 0,
    allowDiscovery: void 0,
    allowGalleries: void 0,
    allowImages: void 0,
    allowPolls: void 0,
    allowPredictionContributors: void 0,
    allowPredictionsTournament: void 0,
    allowPredictions: void 0,
    allowTalks: void 0,
    allowVideogifs: void 0,
    allowVideos: void 0,
    allowedMediaInComments: [],
    bannerBackgroundColor: void 0,
    bannerBackgroundImage: void 0,
    bannerImg: void 0,
    bannerSize: [],
    canAssignLinkFlair: void 0,
    canAssignUserFlair: void 0,
    coins: void 0,
    collapseDeletedComments: void 0,
    commentContributionSettings: void 0,
    commentScoreHideMins: void 0,
    communityIcon: void 0,
    communityReviewed: void 0,
    contentCategory: void 0,
    createdUtc: void 0,
    created: void 0,
    defaultSet: void 0,
    description: void 0,
    descriptionHtml: void 0,
    disableContributorRequests: void 0,
    displayName: void 0,
    displayNamePrefixed: void 0,
    emojisCustomSize: [],
    emojisEnabled: void 0,
    freeFormReports: void 0,
    hasMenuWidget: void 0,
    headerImg: void 0,
    headerSize: [],
    headerTitle: void 0,
    hideAds: void 0,
    iconColor: void 0,
    iconImg: void 0,
    iconSize: [],
    id: void 0,
    isChatPostFeatureEnabled: void 0,
    isCrosspostableSubreddit: void 0,
    isDefaultBanner: void 0,
    isDefaultIcon: void 0,
    isEnrolledInNewModmail: void 0,
    keyColor: void 0,
    lang: void 0,
    linkFlairEnabled: void 0,
    linkFlairPosition: void 0,
    mobileBannerImage: void 0,
    name: void 0,
    notificationLevel: void 0,
    originalContentTagEnabled: void 0,
    over18: void 0,
    predictionLeaderboardEntryType: void 0,
    previousNames: [],
    primaryColor: void 0,
    publicDescription: void 0,
    publicDescriptionHtml: void 0,
    publicTraffic: void 0,
    quarantine: void 0,
    restrictCommenting: void 0,
    restrictPosting: void 0,
    shouldArchivePosts: void 0,
    shouldShowMediaInCommentsSetting: void 0,
    showMedia: void 0,
    showMediaPreview: void 0,
    spoilersEnabled: void 0,
    submissionType: void 0,
    submitLinkLabel: void 0,
    submitText: void 0,
    submitTextHtml: void 0,
    submitTextLabel: void 0,
    subredditType: void 0,
    subscribers: void 0,
    suggestedCommentSort: void 0,
    title: void 0,
    url: void 0,
    userCanFlairInSr: void 0,
    userFlairBackgroundColor: void 0,
    userFlairCssClass: void 0,
    userFlairEnabledInSr: void 0,
    userFlairPosition: void 0,
    userFlairRichtext: [],
    userFlairTemplateId: void 0,
    userFlairText: void 0,
    userFlairTextColor: void 0,
    userFlairType: void 0,
    userHasFavorited: void 0,
    userIsBanned: void 0,
    userIsContributor: void 0,
    userIsModerator: void 0,
    userIsSubscriber: void 0,
    userSrFlairEnabled: void 0,
    userSrThemeEnabled: void 0,
    videostreamLinksCount: void 0,
    whitelistStatus: void 0,
    wikiEnabled: void 0,
    wls: void 0,
    markedSpam: void 0,
    postRequirements: void 0,
    userIsMuted: false
  };
}
var Subreddit = {
  $type: "devvit.reddit.Subreddit",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(10).fork()).ldelim();
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(18).fork()).ldelim();
    }
    if (message.accountsActive !== void 0) {
      Int32Value.encode({ value: message.accountsActive }, writer.uint32(26).fork()).ldelim();
    }
    if (message.activeUserCount !== void 0) {
      Int32Value.encode({ value: message.activeUserCount }, writer.uint32(34).fork()).ldelim();
    }
    if (message.advertiserCategory !== void 0) {
      StringValue.encode({ value: message.advertiserCategory }, writer.uint32(42).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(58).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(66).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(74).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(82).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(90).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(98).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(106).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(114).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(122).fork()).ldelim();
    }
    if (message.allowVideogifs !== void 0) {
      BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(130).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(138).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(146).fork()).ldelim();
    }
    if (message.bannerBackgroundColor !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannerBackgroundImage !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(170).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(178).fork()).ldelim();
    }
    if (message.canAssignLinkFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(186).fork()).ldelim();
    }
    if (message.canAssignUserFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(194).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int32Value.encode({ value: message.coins }, writer.uint32(202).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(210).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(218).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(226).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(234).fork()).ldelim();
    }
    if (message.communityReviewed !== void 0) {
      BoolValue.encode({ value: message.communityReviewed }, writer.uint32(242).fork()).ldelim();
    }
    if (message.contentCategory !== void 0) {
      StringValue.encode({ value: message.contentCategory }, writer.uint32(250).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(258).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(266).fork()).ldelim();
    }
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(274).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(282).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(290).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(298).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(306).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(314).fork()).ldelim();
    }
    for (const v of message.emojisCustomSize) {
      Int32Value.encode({ value: v }, writer.uint32(322).fork()).ldelim();
    }
    if (message.emojisEnabled !== void 0) {
      BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(330).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(338).fork()).ldelim();
    }
    if (message.hasMenuWidget !== void 0) {
      BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(346).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(354).fork()).ldelim();
    }
    for (const v of message.headerSize) {
      Int32Value.encode({ value: v }, writer.uint32(362).fork()).ldelim();
    }
    if (message.headerTitle !== void 0) {
      StringValue.encode({ value: message.headerTitle }, writer.uint32(370).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(378).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(386).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(394).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(402).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(410).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(418).fork()).ldelim();
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(426).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(434).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(442).fork()).ldelim();
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(450).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(458).fork()).ldelim();
    }
    if (message.lang !== void 0) {
      StringValue.encode({ value: message.lang }, writer.uint32(466).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(474).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(482).fork()).ldelim();
    }
    if (message.mobileBannerImage !== void 0) {
      StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(490).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(498).fork()).ldelim();
    }
    if (message.notificationLevel !== void 0) {
      StringValue.encode({ value: message.notificationLevel }, writer.uint32(506).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      StringValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(514).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(522).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(530).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(538).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(546).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(554).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(562).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(570).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(578).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(586).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(594).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(602).fork()).ldelim();
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(610).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(618).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(626).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(634).fork()).ldelim();
    }
    if (message.submissionType !== void 0) {
      StringValue.encode({ value: message.submissionType }, writer.uint32(642).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(650).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(658).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(666).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(674).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(682).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int32Value.encode({ value: message.subscribers }, writer.uint32(690).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(698).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(706).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(714).fork()).ldelim();
    }
    if (message.userCanFlairInSr !== void 0) {
      BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(722).fork()).ldelim();
    }
    if (message.userFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(730).fork()).ldelim();
    }
    if (message.userFlairCssClass !== void 0) {
      StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(738).fork()).ldelim();
    }
    if (message.userFlairEnabledInSr !== void 0) {
      BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(746).fork()).ldelim();
    }
    if (message.userFlairPosition !== void 0) {
      StringValue.encode({ value: message.userFlairPosition }, writer.uint32(754).fork()).ldelim();
    }
    for (const v of message.userFlairRichtext) {
      UserFlairRichtext.encode(v, writer.uint32(762).fork()).ldelim();
    }
    if (message.userFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(770).fork()).ldelim();
    }
    if (message.userFlairText !== void 0) {
      StringValue.encode({ value: message.userFlairText }, writer.uint32(778).fork()).ldelim();
    }
    if (message.userFlairTextColor !== void 0) {
      StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(786).fork()).ldelim();
    }
    if (message.userFlairType !== void 0) {
      StringValue.encode({ value: message.userFlairType }, writer.uint32(794).fork()).ldelim();
    }
    if (message.userHasFavorited !== void 0) {
      BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(802).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(810).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(818).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(826).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(842).fork()).ldelim();
    }
    if (message.userSrFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(850).fork()).ldelim();
    }
    if (message.userSrThemeEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(858).fork()).ldelim();
    }
    if (message.videostreamLinksCount !== void 0) {
      Int32Value.encode({ value: message.videostreamLinksCount }, writer.uint32(866).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      StringValue.encode({ value: message.whitelistStatus }, writer.uint32(874).fork()).ldelim();
    }
    if (message.wikiEnabled !== void 0) {
      BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(882).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      Int32Value.encode({ value: message.wls }, writer.uint32(890).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(898).fork()).ldelim();
    }
    if (message.postRequirements !== void 0) {
      Subreddit_PostRequirements.encode(message.postRequirements, writer.uint32(906).fork()).ldelim();
    }
    if (message.userIsMuted !== false) {
      writer.uint32(912).bool(message.userIsMuted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : import_minimal19.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.accountsActive = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.activeUserCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.coins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.contentCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.emojisCustomSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.headerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.lang = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.originalContentTagEnabled = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.submissionType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 85:
          if (tag !== 682) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 86:
          if (tag !== 690) {
            break;
          }
          message.subscribers = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }
          message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 88:
          if (tag !== 706) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 89:
          if (tag !== 714) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }
          message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }
          message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 92:
          if (tag !== 738) {
            break;
          }
          message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }
          message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 94:
          if (tag !== 754) {
            break;
          }
          message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 95:
          if (tag !== 762) {
            break;
          }
          message.userFlairRichtext.push(UserFlairRichtext.decode(reader, reader.uint32()));
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }
          message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }
          message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }
          message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }
          message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }
          message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }
          message.videostreamLinksCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }
          message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }
          message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }
          message.wls = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 112:
          if (tag !== 898) {
            break;
          }
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }
          message.postRequirements = Subreddit_PostRequirements.decode(reader, reader.uint32());
          continue;
        case 114:
          if (tag !== 912) {
            break;
          }
          message.userIsMuted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      acceptFollowers: isSet17(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      accountsActiveIsFuzzed: isSet17(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : void 0,
      accountsActive: isSet17(object.accountsActive) ? Number(object.accountsActive) : void 0,
      activeUserCount: isSet17(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      advertiserCategory: isSet17(object.advertiserCategory) ? String(object.advertiserCategory) : void 0,
      allOriginalContent: isSet17(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      allowChatPostCreation: isSet17(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowDiscovery: isSet17(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      allowGalleries: isSet17(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      allowImages: isSet17(object.allowImages) ? Boolean(object.allowImages) : void 0,
      allowPolls: isSet17(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      allowPredictionContributors: isSet17(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      allowPredictionsTournament: isSet17(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0,
      allowPredictions: isSet17(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      allowTalks: isSet17(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      allowVideogifs: isSet17(object.allowVideogifs) ? Boolean(object.allowVideogifs) : void 0,
      allowVideos: isSet17(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      allowedMediaInComments: globalThis.Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      bannerBackgroundColor: isSet17(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : void 0,
      bannerBackgroundImage: isSet17(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : void 0,
      bannerImg: isSet17(object.bannerImg) ? String(object.bannerImg) : void 0,
      bannerSize: globalThis.Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      canAssignLinkFlair: isSet17(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : void 0,
      canAssignUserFlair: isSet17(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : void 0,
      coins: isSet17(object.coins) ? Number(object.coins) : void 0,
      collapseDeletedComments: isSet17(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      commentContributionSettings: isSet17(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      commentScoreHideMins: isSet17(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      communityIcon: isSet17(object.communityIcon) ? String(object.communityIcon) : void 0,
      communityReviewed: isSet17(object.communityReviewed) ? Boolean(object.communityReviewed) : void 0,
      contentCategory: isSet17(object.contentCategory) ? String(object.contentCategory) : void 0,
      createdUtc: isSet17(object.createdUtc) ? Number(object.createdUtc) : void 0,
      created: isSet17(object.created) ? Number(object.created) : void 0,
      defaultSet: isSet17(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      description: isSet17(object.description) ? String(object.description) : void 0,
      descriptionHtml: isSet17(object.descriptionHtml) ? String(object.descriptionHtml) : void 0,
      disableContributorRequests: isSet17(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      displayName: isSet17(object.displayName) ? String(object.displayName) : void 0,
      displayNamePrefixed: isSet17(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      emojisCustomSize: globalThis.Array.isArray(object?.emojisCustomSize) ? object.emojisCustomSize.map((e) => Number(e)) : [],
      emojisEnabled: isSet17(object.emojisEnabled) ? Boolean(object.emojisEnabled) : void 0,
      freeFormReports: isSet17(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      hasMenuWidget: isSet17(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : void 0,
      headerImg: isSet17(object.headerImg) ? String(object.headerImg) : void 0,
      headerSize: globalThis.Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
      headerTitle: isSet17(object.headerTitle) ? String(object.headerTitle) : void 0,
      hideAds: isSet17(object.hideAds) ? Boolean(object.hideAds) : void 0,
      iconColor: isSet17(object.iconColor) ? String(object.iconColor) : void 0,
      iconImg: isSet17(object.iconImg) ? String(object.iconImg) : void 0,
      iconSize: globalThis.Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      id: isSet17(object.id) ? String(object.id) : void 0,
      isChatPostFeatureEnabled: isSet17(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      isCrosspostableSubreddit: isSet17(object.isCrosspostableSubreddit) ? Boolean(object.isCrosspostableSubreddit) : void 0,
      isDefaultBanner: isSet17(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      isDefaultIcon: isSet17(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      isEnrolledInNewModmail: isSet17(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : void 0,
      keyColor: isSet17(object.keyColor) ? String(object.keyColor) : void 0,
      lang: isSet17(object.lang) ? String(object.lang) : void 0,
      linkFlairEnabled: isSet17(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      linkFlairPosition: isSet17(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      mobileBannerImage: isSet17(object.mobileBannerImage) ? String(object.mobileBannerImage) : void 0,
      name: isSet17(object.name) ? String(object.name) : void 0,
      notificationLevel: isSet17(object.notificationLevel) ? String(object.notificationLevel) : void 0,
      originalContentTagEnabled: isSet17(object.originalContentTagEnabled) ? String(object.originalContentTagEnabled) : void 0,
      over18: isSet17(object.over18) ? Boolean(object.over18) : void 0,
      predictionLeaderboardEntryType: isSet17(object.predictionLeaderboardEntryType) ? String(object.predictionLeaderboardEntryType) : void 0,
      previousNames: globalThis.Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      primaryColor: isSet17(object.primaryColor) ? String(object.primaryColor) : void 0,
      publicDescription: isSet17(object.publicDescription) ? String(object.publicDescription) : void 0,
      publicDescriptionHtml: isSet17(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      publicTraffic: isSet17(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      quarantine: isSet17(object.quarantine) ? Boolean(object.quarantine) : void 0,
      restrictCommenting: isSet17(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      restrictPosting: isSet17(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      shouldArchivePosts: isSet17(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      shouldShowMediaInCommentsSetting: isSet17(object.shouldShowMediaInCommentsSetting) ? Boolean(object.shouldShowMediaInCommentsSetting) : void 0,
      showMedia: isSet17(object.showMedia) ? Boolean(object.showMedia) : void 0,
      showMediaPreview: isSet17(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      spoilersEnabled: isSet17(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      submissionType: isSet17(object.submissionType) ? String(object.submissionType) : void 0,
      submitLinkLabel: isSet17(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      submitText: isSet17(object.submitText) ? String(object.submitText) : void 0,
      submitTextHtml: isSet17(object.submitTextHtml) ? String(object.submitTextHtml) : void 0,
      submitTextLabel: isSet17(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      subredditType: isSet17(object.subredditType) ? String(object.subredditType) : void 0,
      subscribers: isSet17(object.subscribers) ? Number(object.subscribers) : void 0,
      suggestedCommentSort: isSet17(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : void 0,
      title: isSet17(object.title) ? String(object.title) : void 0,
      url: isSet17(object.url) ? String(object.url) : void 0,
      userCanFlairInSr: isSet17(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : void 0,
      userFlairBackgroundColor: isSet17(object.userFlairBackgroundColor) ? String(object.userFlairBackgroundColor) : void 0,
      userFlairCssClass: isSet17(object.userFlairCssClass) ? String(object.userFlairCssClass) : void 0,
      userFlairEnabledInSr: isSet17(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : void 0,
      userFlairPosition: isSet17(object.userFlairPosition) ? String(object.userFlairPosition) : void 0,
      userFlairRichtext: globalThis.Array.isArray(object?.userFlairRichtext) ? object.userFlairRichtext.map((e) => UserFlairRichtext.fromJSON(e)) : [],
      userFlairTemplateId: isSet17(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : void 0,
      userFlairText: isSet17(object.userFlairText) ? String(object.userFlairText) : void 0,
      userFlairTextColor: isSet17(object.userFlairTextColor) ? String(object.userFlairTextColor) : void 0,
      userFlairType: isSet17(object.userFlairType) ? String(object.userFlairType) : void 0,
      userHasFavorited: isSet17(object.userHasFavorited) ? Boolean(object.userHasFavorited) : void 0,
      userIsBanned: isSet17(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      userIsContributor: isSet17(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      userIsModerator: isSet17(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      userIsSubscriber: isSet17(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      userSrFlairEnabled: isSet17(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : void 0,
      userSrThemeEnabled: isSet17(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : void 0,
      videostreamLinksCount: isSet17(object.videostreamLinksCount) ? Number(object.videostreamLinksCount) : void 0,
      whitelistStatus: isSet17(object.whitelistStatus) ? String(object.whitelistStatus) : void 0,
      wikiEnabled: isSet17(object.wikiEnabled) ? Boolean(object.wikiEnabled) : void 0,
      wls: isSet17(object.wls) ? Number(object.wls) : void 0,
      markedSpam: isSet17(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      postRequirements: isSet17(object.postRequirements) ? Subreddit_PostRequirements.fromJSON(object.postRequirements) : void 0,
      userIsMuted: isSet17(object.userIsMuted) ? globalThis.Boolean(object.userIsMuted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed;
    }
    if (message.accountsActive !== void 0) {
      obj.accountsActive = message.accountsActive;
    }
    if (message.activeUserCount !== void 0) {
      obj.activeUserCount = message.activeUserCount;
    }
    if (message.advertiserCategory !== void 0) {
      obj.advertiserCategory = message.advertiserCategory;
    }
    if (message.allOriginalContent !== void 0) {
      obj.allOriginalContent = message.allOriginalContent;
    }
    if (message.allowChatPostCreation !== void 0) {
      obj.allowChatPostCreation = message.allowChatPostCreation;
    }
    if (message.allowDiscovery !== void 0) {
      obj.allowDiscovery = message.allowDiscovery;
    }
    if (message.allowGalleries !== void 0) {
      obj.allowGalleries = message.allowGalleries;
    }
    if (message.allowImages !== void 0) {
      obj.allowImages = message.allowImages;
    }
    if (message.allowPolls !== void 0) {
      obj.allowPolls = message.allowPolls;
    }
    if (message.allowPredictionContributors !== void 0) {
      obj.allowPredictionContributors = message.allowPredictionContributors;
    }
    if (message.allowPredictionsTournament !== void 0) {
      obj.allowPredictionsTournament = message.allowPredictionsTournament;
    }
    if (message.allowPredictions !== void 0) {
      obj.allowPredictions = message.allowPredictions;
    }
    if (message.allowTalks !== void 0) {
      obj.allowTalks = message.allowTalks;
    }
    if (message.allowVideogifs !== void 0) {
      obj.allowVideogifs = message.allowVideogifs;
    }
    if (message.allowVideos !== void 0) {
      obj.allowVideos = message.allowVideos;
    }
    if (message.allowedMediaInComments?.length) {
      obj.allowedMediaInComments = message.allowedMediaInComments;
    }
    if (message.bannerBackgroundColor !== void 0) {
      obj.bannerBackgroundColor = message.bannerBackgroundColor;
    }
    if (message.bannerBackgroundImage !== void 0) {
      obj.bannerBackgroundImage = message.bannerBackgroundImage;
    }
    if (message.bannerImg !== void 0) {
      obj.bannerImg = message.bannerImg;
    }
    if (message.bannerSize?.length) {
      obj.bannerSize = message.bannerSize;
    }
    if (message.canAssignLinkFlair !== void 0) {
      obj.canAssignLinkFlair = message.canAssignLinkFlair;
    }
    if (message.canAssignUserFlair !== void 0) {
      obj.canAssignUserFlair = message.canAssignUserFlair;
    }
    if (message.coins !== void 0) {
      obj.coins = message.coins;
    }
    if (message.collapseDeletedComments !== void 0) {
      obj.collapseDeletedComments = message.collapseDeletedComments;
    }
    if (message.commentContributionSettings !== void 0) {
      obj.commentContributionSettings = CommentContributionSettings.toJSON(message.commentContributionSettings);
    }
    if (message.commentScoreHideMins !== void 0) {
      obj.commentScoreHideMins = message.commentScoreHideMins;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.communityReviewed !== void 0) {
      obj.communityReviewed = message.communityReviewed;
    }
    if (message.contentCategory !== void 0) {
      obj.contentCategory = message.contentCategory;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.defaultSet !== void 0) {
      obj.defaultSet = message.defaultSet;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.descriptionHtml !== void 0) {
      obj.descriptionHtml = message.descriptionHtml;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.displayNamePrefixed !== void 0) {
      obj.displayNamePrefixed = message.displayNamePrefixed;
    }
    if (message.emojisCustomSize?.length) {
      obj.emojisCustomSize = message.emojisCustomSize;
    }
    if (message.emojisEnabled !== void 0) {
      obj.emojisEnabled = message.emojisEnabled;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.hasMenuWidget !== void 0) {
      obj.hasMenuWidget = message.hasMenuWidget;
    }
    if (message.headerImg !== void 0) {
      obj.headerImg = message.headerImg;
    }
    if (message.headerSize?.length) {
      obj.headerSize = message.headerSize;
    }
    if (message.headerTitle !== void 0) {
      obj.headerTitle = message.headerTitle;
    }
    if (message.hideAds !== void 0) {
      obj.hideAds = message.hideAds;
    }
    if (message.iconColor !== void 0) {
      obj.iconColor = message.iconColor;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.iconSize?.length) {
      obj.iconSize = message.iconSize;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled;
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit;
    }
    if (message.isDefaultBanner !== void 0) {
      obj.isDefaultBanner = message.isDefaultBanner;
    }
    if (message.isDefaultIcon !== void 0) {
      obj.isDefaultIcon = message.isDefaultIcon;
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.lang !== void 0) {
      obj.lang = message.lang;
    }
    if (message.linkFlairEnabled !== void 0) {
      obj.linkFlairEnabled = message.linkFlairEnabled;
    }
    if (message.linkFlairPosition !== void 0) {
      obj.linkFlairPosition = message.linkFlairPosition;
    }
    if (message.mobileBannerImage !== void 0) {
      obj.mobileBannerImage = message.mobileBannerImage;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.notificationLevel !== void 0) {
      obj.notificationLevel = message.notificationLevel;
    }
    if (message.originalContentTagEnabled !== void 0) {
      obj.originalContentTagEnabled = message.originalContentTagEnabled;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType;
    }
    if (message.previousNames?.length) {
      obj.previousNames = message.previousNames;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.publicDescriptionHtml !== void 0) {
      obj.publicDescriptionHtml = message.publicDescriptionHtml;
    }
    if (message.publicTraffic !== void 0) {
      obj.publicTraffic = message.publicTraffic;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.shouldArchivePosts !== void 0) {
      obj.shouldArchivePosts = message.shouldArchivePosts;
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.showMediaPreview !== void 0) {
      obj.showMediaPreview = message.showMediaPreview;
    }
    if (message.spoilersEnabled !== void 0) {
      obj.spoilersEnabled = message.spoilersEnabled;
    }
    if (message.submissionType !== void 0) {
      obj.submissionType = message.submissionType;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.submitText !== void 0) {
      obj.submitText = message.submitText;
    }
    if (message.submitTextHtml !== void 0) {
      obj.submitTextHtml = message.submitTextHtml;
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.suggestedCommentSort !== void 0) {
      obj.suggestedCommentSort = message.suggestedCommentSort;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.userCanFlairInSr !== void 0) {
      obj.userCanFlairInSr = message.userCanFlairInSr;
    }
    if (message.userFlairBackgroundColor !== void 0) {
      obj.userFlairBackgroundColor = message.userFlairBackgroundColor;
    }
    if (message.userFlairCssClass !== void 0) {
      obj.userFlairCssClass = message.userFlairCssClass;
    }
    if (message.userFlairEnabledInSr !== void 0) {
      obj.userFlairEnabledInSr = message.userFlairEnabledInSr;
    }
    if (message.userFlairPosition !== void 0) {
      obj.userFlairPosition = message.userFlairPosition;
    }
    if (message.userFlairRichtext?.length) {
      obj.userFlairRichtext = message.userFlairRichtext.map((e) => UserFlairRichtext.toJSON(e));
    }
    if (message.userFlairTemplateId !== void 0) {
      obj.userFlairTemplateId = message.userFlairTemplateId;
    }
    if (message.userFlairText !== void 0) {
      obj.userFlairText = message.userFlairText;
    }
    if (message.userFlairTextColor !== void 0) {
      obj.userFlairTextColor = message.userFlairTextColor;
    }
    if (message.userFlairType !== void 0) {
      obj.userFlairType = message.userFlairType;
    }
    if (message.userHasFavorited !== void 0) {
      obj.userHasFavorited = message.userHasFavorited;
    }
    if (message.userIsBanned !== void 0) {
      obj.userIsBanned = message.userIsBanned;
    }
    if (message.userIsContributor !== void 0) {
      obj.userIsContributor = message.userIsContributor;
    }
    if (message.userIsModerator !== void 0) {
      obj.userIsModerator = message.userIsModerator;
    }
    if (message.userIsSubscriber !== void 0) {
      obj.userIsSubscriber = message.userIsSubscriber;
    }
    if (message.userSrFlairEnabled !== void 0) {
      obj.userSrFlairEnabled = message.userSrFlairEnabled;
    }
    if (message.userSrThemeEnabled !== void 0) {
      obj.userSrThemeEnabled = message.userSrThemeEnabled;
    }
    if (message.videostreamLinksCount !== void 0) {
      obj.videostreamLinksCount = message.videostreamLinksCount;
    }
    if (message.whitelistStatus !== void 0) {
      obj.whitelistStatus = message.whitelistStatus;
    }
    if (message.wikiEnabled !== void 0) {
      obj.wikiEnabled = message.wikiEnabled;
    }
    if (message.wls !== void 0) {
      obj.wls = message.wls;
    }
    if (message.markedSpam !== void 0) {
      obj.markedSpam = message.markedSpam;
    }
    if (message.postRequirements !== void 0) {
      obj.postRequirements = Subreddit_PostRequirements.toJSON(message.postRequirements);
    }
    if (message.userIsMuted !== false) {
      obj.userIsMuted = message.userIsMuted;
    }
    return obj;
  },
  create(base) {
    return Subreddit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubreddit();
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? void 0;
    message.accountsActive = object.accountsActive ?? void 0;
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.advertiserCategory = object.advertiserCategory ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.allowVideogifs = object.allowVideogifs ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.bannerBackgroundColor = object.bannerBackgroundColor ?? void 0;
    message.bannerBackgroundImage = object.bannerBackgroundImage ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.canAssignLinkFlair = object.canAssignLinkFlair ?? void 0;
    message.canAssignUserFlair = object.canAssignUserFlair ?? void 0;
    message.coins = object.coins ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.communityReviewed = object.communityReviewed ?? void 0;
    message.contentCategory = object.contentCategory ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.created = object.created ?? void 0;
    message.defaultSet = object.defaultSet ?? void 0;
    message.description = object.description ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.emojisCustomSize = object.emojisCustomSize?.map((e) => e) || [];
    message.emojisEnabled = object.emojisEnabled ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.hasMenuWidget = object.hasMenuWidget ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.headerSize = object.headerSize?.map((e) => e) || [];
    message.headerTitle = object.headerTitle ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.id = object.id ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.lang = object.lang ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.mobileBannerImage = object.mobileBannerImage ?? void 0;
    message.name = object.name ?? void 0;
    message.notificationLevel = object.notificationLevel ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.submissionType = object.submissionType ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.title = object.title ?? void 0;
    message.url = object.url ?? void 0;
    message.userCanFlairInSr = object.userCanFlairInSr ?? void 0;
    message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? void 0;
    message.userFlairCssClass = object.userFlairCssClass ?? void 0;
    message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? void 0;
    message.userFlairPosition = object.userFlairPosition ?? void 0;
    message.userFlairRichtext = object.userFlairRichtext?.map((e) => UserFlairRichtext.fromPartial(e)) || [];
    message.userFlairTemplateId = object.userFlairTemplateId ?? void 0;
    message.userFlairText = object.userFlairText ?? void 0;
    message.userFlairTextColor = object.userFlairTextColor ?? void 0;
    message.userFlairType = object.userFlairType ?? void 0;
    message.userHasFavorited = object.userHasFavorited ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.userSrFlairEnabled = object.userSrFlairEnabled ?? void 0;
    message.userSrThemeEnabled = object.userSrThemeEnabled ?? void 0;
    message.videostreamLinksCount = object.videostreamLinksCount ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.wikiEnabled = object.wikiEnabled ?? void 0;
    message.wls = object.wls ?? void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.postRequirements = object.postRequirements !== void 0 && object.postRequirements !== null ? Subreddit_PostRequirements.fromPartial(object.postRequirements) : void 0;
    message.userIsMuted = object.userIsMuted ?? false;
    return message;
  }
};
messageTypeRegistry.set(Subreddit.$type, Subreddit);
function createBaseSubreddit_PostRequirements() {
  return { bodyRestrictionPolicy: void 0 };
}
var Subreddit_PostRequirements = {
  $type: "devvit.reddit.Subreddit.PostRequirements",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.bodyRestrictionPolicy !== void 0) {
      StringValue.encode({ value: message.bodyRestrictionPolicy }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : import_minimal19.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubreddit_PostRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bodyRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bodyRestrictionPolicy: isSet17(object.bodyRestrictionPolicy) ? String(object.bodyRestrictionPolicy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bodyRestrictionPolicy !== void 0) {
      obj.bodyRestrictionPolicy = message.bodyRestrictionPolicy;
    }
    return obj;
  },
  create(base) {
    return Subreddit_PostRequirements.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubreddit_PostRequirements();
    message.bodyRestrictionPolicy = object.bodyRestrictionPolicy ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Subreddit_PostRequirements.$type, Subreddit_PostRequirements);
function isSet17(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/user.js
function createBaseUser() {
  return {
    acceptChats: void 0,
    acceptFollowers: void 0,
    acceptPms: void 0,
    awardeeKarma: void 0,
    awarderKarma: void 0,
    canCreateSubreddit: void 0,
    canEditName: void 0,
    coins: void 0,
    commentKarma: void 0,
    created: void 0,
    createdUtc: void 0,
    features: void 0,
    forcePasswordReset: void 0,
    goldCreddits: void 0,
    goldExpiration: void 0,
    hasAndroidSubscription: void 0,
    hasExternalAccount: void 0,
    hasGoldSubscription: void 0,
    hasIosSubscription: void 0,
    hasMail: void 0,
    hasModMail: void 0,
    hasPaypalSubscription: void 0,
    hasStripeSubscription: void 0,
    hasSubscribed: void 0,
    hasSubscribedToPremium: void 0,
    hasVerifiedEmail: void 0,
    hasVisitedNewProfile: void 0,
    hideFromRobots: void 0,
    iconImg: void 0,
    id: void 0,
    inBeta: void 0,
    inChat: void 0,
    inRedesignBeta: void 0,
    inboxCount: void 0,
    isBlocked: void 0,
    isEmployee: void 0,
    isFriend: void 0,
    isGold: void 0,
    isMod: void 0,
    isSponsor: void 0,
    isSuspended: void 0,
    linkKarma: void 0,
    modhash: void 0,
    name: void 0,
    newModmailExists: void 0,
    numFriends: void 0,
    over18: void 0,
    passwordSet: void 0,
    prefAutoplay: void 0,
    prefClickgadget: void 0,
    prefGeopopular: void 0,
    prefNightmode: void 0,
    prefNoProfanity: void 0,
    prefShowPresence: void 0,
    prefShowSnoovatar: void 0,
    prefShowTrending: void 0,
    prefShowTwitter: void 0,
    prefTopKarmaSubreddits: void 0,
    prefVideoAutoplay: void 0,
    snoovatarImg: void 0,
    snoovatarSize: [],
    subreddit: void 0,
    suspensionExpirationUtc: void 0,
    totalKarma: void 0,
    verified: void 0,
    hasPhoneNumber: void 0,
    subredditsModerated: void 0,
    hasMetaSubscription: void 0,
    metaSubscriptionAge: void 0,
    metaPointsBalance: void 0,
    metaLockedPointsBalance: void 0,
    commentSubredditKarma: void 0,
    postSubredditKarma: void 0,
    markedSpam: void 0,
    isSubredditProxyAccount: void 0
  };
}
var User = {
  $type: "devvit.reddit.User",
  encode(message, writer = import_minimal20.default.Writer.create()) {
    if (message.acceptChats !== void 0) {
      BoolValue.encode({ value: message.acceptChats }, writer.uint32(10).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(18).fork()).ldelim();
    }
    if (message.acceptPms !== void 0) {
      BoolValue.encode({ value: message.acceptPms }, writer.uint32(26).fork()).ldelim();
    }
    if (message.awardeeKarma !== void 0) {
      Int32Value.encode({ value: message.awardeeKarma }, writer.uint32(34).fork()).ldelim();
    }
    if (message.awarderKarma !== void 0) {
      Int32Value.encode({ value: message.awarderKarma }, writer.uint32(42).fork()).ldelim();
    }
    if (message.canCreateSubreddit !== void 0) {
      BoolValue.encode({ value: message.canCreateSubreddit }, writer.uint32(50).fork()).ldelim();
    }
    if (message.canEditName !== void 0) {
      BoolValue.encode({ value: message.canEditName }, writer.uint32(58).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int32Value.encode({ value: message.coins }, writer.uint32(66).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int32Value.encode({ value: message.commentKarma }, writer.uint32(74).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(82).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(90).fork()).ldelim();
    }
    if (message.features !== void 0) {
      UserFeatures.encode(message.features, writer.uint32(98).fork()).ldelim();
    }
    if (message.forcePasswordReset !== void 0) {
      BoolValue.encode({ value: message.forcePasswordReset }, writer.uint32(106).fork()).ldelim();
    }
    if (message.goldCreddits !== void 0) {
      Int32Value.encode({ value: message.goldCreddits }, writer.uint32(114).fork()).ldelim();
    }
    if (message.goldExpiration !== void 0) {
      StringValue.encode({ value: message.goldExpiration }, writer.uint32(122).fork()).ldelim();
    }
    if (message.hasAndroidSubscription !== void 0) {
      BoolValue.encode({ value: message.hasAndroidSubscription }, writer.uint32(130).fork()).ldelim();
    }
    if (message.hasExternalAccount !== void 0) {
      BoolValue.encode({ value: message.hasExternalAccount }, writer.uint32(138).fork()).ldelim();
    }
    if (message.hasGoldSubscription !== void 0) {
      BoolValue.encode({ value: message.hasGoldSubscription }, writer.uint32(146).fork()).ldelim();
    }
    if (message.hasIosSubscription !== void 0) {
      BoolValue.encode({ value: message.hasIosSubscription }, writer.uint32(154).fork()).ldelim();
    }
    if (message.hasMail !== void 0) {
      BoolValue.encode({ value: message.hasMail }, writer.uint32(162).fork()).ldelim();
    }
    if (message.hasModMail !== void 0) {
      BoolValue.encode({ value: message.hasModMail }, writer.uint32(170).fork()).ldelim();
    }
    if (message.hasPaypalSubscription !== void 0) {
      BoolValue.encode({ value: message.hasPaypalSubscription }, writer.uint32(178).fork()).ldelim();
    }
    if (message.hasStripeSubscription !== void 0) {
      BoolValue.encode({ value: message.hasStripeSubscription }, writer.uint32(186).fork()).ldelim();
    }
    if (message.hasSubscribed !== void 0) {
      BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(194).fork()).ldelim();
    }
    if (message.hasSubscribedToPremium !== void 0) {
      BoolValue.encode({ value: message.hasSubscribedToPremium }, writer.uint32(202).fork()).ldelim();
    }
    if (message.hasVerifiedEmail !== void 0) {
      BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(210).fork()).ldelim();
    }
    if (message.hasVisitedNewProfile !== void 0) {
      BoolValue.encode({ value: message.hasVisitedNewProfile }, writer.uint32(218).fork()).ldelim();
    }
    if (message.hideFromRobots !== void 0) {
      BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(226).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(234).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(242).fork()).ldelim();
    }
    if (message.inBeta !== void 0) {
      BoolValue.encode({ value: message.inBeta }, writer.uint32(250).fork()).ldelim();
    }
    if (message.inChat !== void 0) {
      BoolValue.encode({ value: message.inChat }, writer.uint32(258).fork()).ldelim();
    }
    if (message.inRedesignBeta !== void 0) {
      BoolValue.encode({ value: message.inRedesignBeta }, writer.uint32(266).fork()).ldelim();
    }
    if (message.inboxCount !== void 0) {
      Int32Value.encode({ value: message.inboxCount }, writer.uint32(274).fork()).ldelim();
    }
    if (message.isBlocked !== void 0) {
      BoolValue.encode({ value: message.isBlocked }, writer.uint32(282).fork()).ldelim();
    }
    if (message.isEmployee !== void 0) {
      BoolValue.encode({ value: message.isEmployee }, writer.uint32(290).fork()).ldelim();
    }
    if (message.isFriend !== void 0) {
      BoolValue.encode({ value: message.isFriend }, writer.uint32(298).fork()).ldelim();
    }
    if (message.isGold !== void 0) {
      BoolValue.encode({ value: message.isGold }, writer.uint32(306).fork()).ldelim();
    }
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(314).fork()).ldelim();
    }
    if (message.isSponsor !== void 0) {
      BoolValue.encode({ value: message.isSponsor }, writer.uint32(322).fork()).ldelim();
    }
    if (message.isSuspended !== void 0) {
      BoolValue.encode({ value: message.isSuspended }, writer.uint32(330).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int32Value.encode({ value: message.linkKarma }, writer.uint32(338).fork()).ldelim();
    }
    if (message.modhash !== void 0) {
      StringValue.encode({ value: message.modhash }, writer.uint32(346).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(354).fork()).ldelim();
    }
    if (message.newModmailExists !== void 0) {
      BoolValue.encode({ value: message.newModmailExists }, writer.uint32(362).fork()).ldelim();
    }
    if (message.numFriends !== void 0) {
      Int32Value.encode({ value: message.numFriends }, writer.uint32(370).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(378).fork()).ldelim();
    }
    if (message.passwordSet !== void 0) {
      BoolValue.encode({ value: message.passwordSet }, writer.uint32(386).fork()).ldelim();
    }
    if (message.prefAutoplay !== void 0) {
      BoolValue.encode({ value: message.prefAutoplay }, writer.uint32(394).fork()).ldelim();
    }
    if (message.prefClickgadget !== void 0) {
      Int32Value.encode({ value: message.prefClickgadget }, writer.uint32(402).fork()).ldelim();
    }
    if (message.prefGeopopular !== void 0) {
      StringValue.encode({ value: message.prefGeopopular }, writer.uint32(410).fork()).ldelim();
    }
    if (message.prefNightmode !== void 0) {
      BoolValue.encode({ value: message.prefNightmode }, writer.uint32(418).fork()).ldelim();
    }
    if (message.prefNoProfanity !== void 0) {
      BoolValue.encode({ value: message.prefNoProfanity }, writer.uint32(426).fork()).ldelim();
    }
    if (message.prefShowPresence !== void 0) {
      BoolValue.encode({ value: message.prefShowPresence }, writer.uint32(434).fork()).ldelim();
    }
    if (message.prefShowSnoovatar !== void 0) {
      BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(442).fork()).ldelim();
    }
    if (message.prefShowTrending !== void 0) {
      BoolValue.encode({ value: message.prefShowTrending }, writer.uint32(450).fork()).ldelim();
    }
    if (message.prefShowTwitter !== void 0) {
      BoolValue.encode({ value: message.prefShowTwitter }, writer.uint32(458).fork()).ldelim();
    }
    if (message.prefTopKarmaSubreddits !== void 0) {
      BoolValue.encode({ value: message.prefTopKarmaSubreddits }, writer.uint32(466).fork()).ldelim();
    }
    if (message.prefVideoAutoplay !== void 0) {
      BoolValue.encode({ value: message.prefVideoAutoplay }, writer.uint32(474).fork()).ldelim();
    }
    if (message.snoovatarImg !== void 0) {
      StringValue.encode({ value: message.snoovatarImg }, writer.uint32(482).fork()).ldelim();
    }
    for (const v of message.snoovatarSize) {
      Int32Value.encode({ value: v }, writer.uint32(490).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      Subreddit.encode(message.subreddit, writer.uint32(498).fork()).ldelim();
    }
    if (message.suspensionExpirationUtc !== void 0) {
      StringValue.encode({ value: message.suspensionExpirationUtc }, writer.uint32(506).fork()).ldelim();
    }
    if (message.totalKarma !== void 0) {
      Int32Value.encode({ value: message.totalKarma }, writer.uint32(514).fork()).ldelim();
    }
    if (message.verified !== void 0) {
      BoolValue.encode({ value: message.verified }, writer.uint32(522).fork()).ldelim();
    }
    if (message.hasPhoneNumber !== void 0) {
      BoolValue.encode({ value: message.hasPhoneNumber }, writer.uint32(530).fork()).ldelim();
    }
    if (message.subredditsModerated !== void 0) {
      Int32Value.encode({ value: message.subredditsModerated }, writer.uint32(802).fork()).ldelim();
    }
    if (message.hasMetaSubscription !== void 0) {
      BoolValue.encode({ value: message.hasMetaSubscription }, writer.uint32(810).fork()).ldelim();
    }
    if (message.metaSubscriptionAge !== void 0) {
      Int32Value.encode({ value: message.metaSubscriptionAge }, writer.uint32(818).fork()).ldelim();
    }
    if (message.metaPointsBalance !== void 0) {
      StringValue.encode({ value: message.metaPointsBalance }, writer.uint32(826).fork()).ldelim();
    }
    if (message.metaLockedPointsBalance !== void 0) {
      StringValue.encode({ value: message.metaLockedPointsBalance }, writer.uint32(834).fork()).ldelim();
    }
    if (message.commentSubredditKarma !== void 0) {
      Int32Value.encode({ value: message.commentSubredditKarma }, writer.uint32(842).fork()).ldelim();
    }
    if (message.postSubredditKarma !== void 0) {
      Int32Value.encode({ value: message.postSubredditKarma }, writer.uint32(850).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(858).fork()).ldelim();
    }
    if (message.isSubredditProxyAccount !== void 0) {
      BoolValue.encode({ value: message.isSubredditProxyAccount }, writer.uint32(866).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal20.default.Reader ? input : import_minimal20.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.awardeeKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.awarderKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.canCreateSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.canEditName = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.coins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.commentKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.features = UserFeatures.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.forcePasswordReset = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.goldCreddits = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.goldExpiration = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.hasAndroidSubscription = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.hasExternalAccount = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.hasGoldSubscription = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.hasIosSubscription = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.hasMail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.hasModMail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.hasPaypalSubscription = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.hasStripeSubscription = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.hasSubscribedToPremium = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.hasVisitedNewProfile = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.inBeta = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.inChat = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.inRedesignBeta = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.inboxCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.isGold = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.isSponsor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.modhash = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.newModmailExists = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.numFriends = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.passwordSet = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.prefAutoplay = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.prefClickgadget = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.prefGeopopular = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.prefNightmode = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.prefNoProfanity = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.prefShowPresence = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.prefShowTrending = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.prefShowTwitter = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.prefTopKarmaSubreddits = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.prefVideoAutoplay = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.snoovatarSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.subreddit = Subreddit.decode(reader, reader.uint32());
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.suspensionExpirationUtc = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.totalKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.hasPhoneNumber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.subredditsModerated = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.hasMetaSubscription = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.metaSubscriptionAge = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.metaPointsBalance = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.metaLockedPointsBalance = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.commentSubredditKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.postSubredditKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }
          message.isSubredditProxyAccount = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      acceptChats: isSet18(object.acceptChats) ? Boolean(object.acceptChats) : void 0,
      acceptFollowers: isSet18(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      acceptPms: isSet18(object.acceptPms) ? Boolean(object.acceptPms) : void 0,
      awardeeKarma: isSet18(object.awardeeKarma) ? Number(object.awardeeKarma) : void 0,
      awarderKarma: isSet18(object.awarderKarma) ? Number(object.awarderKarma) : void 0,
      canCreateSubreddit: isSet18(object.canCreateSubreddit) ? Boolean(object.canCreateSubreddit) : void 0,
      canEditName: isSet18(object.canEditName) ? Boolean(object.canEditName) : void 0,
      coins: isSet18(object.coins) ? Number(object.coins) : void 0,
      commentKarma: isSet18(object.commentKarma) ? Number(object.commentKarma) : void 0,
      created: isSet18(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet18(object.createdUtc) ? Number(object.createdUtc) : void 0,
      features: isSet18(object.features) ? UserFeatures.fromJSON(object.features) : void 0,
      forcePasswordReset: isSet18(object.forcePasswordReset) ? Boolean(object.forcePasswordReset) : void 0,
      goldCreddits: isSet18(object.goldCreddits) ? Number(object.goldCreddits) : void 0,
      goldExpiration: isSet18(object.goldExpiration) ? String(object.goldExpiration) : void 0,
      hasAndroidSubscription: isSet18(object.hasAndroidSubscription) ? Boolean(object.hasAndroidSubscription) : void 0,
      hasExternalAccount: isSet18(object.hasExternalAccount) ? Boolean(object.hasExternalAccount) : void 0,
      hasGoldSubscription: isSet18(object.hasGoldSubscription) ? Boolean(object.hasGoldSubscription) : void 0,
      hasIosSubscription: isSet18(object.hasIosSubscription) ? Boolean(object.hasIosSubscription) : void 0,
      hasMail: isSet18(object.hasMail) ? Boolean(object.hasMail) : void 0,
      hasModMail: isSet18(object.hasModMail) ? Boolean(object.hasModMail) : void 0,
      hasPaypalSubscription: isSet18(object.hasPaypalSubscription) ? Boolean(object.hasPaypalSubscription) : void 0,
      hasStripeSubscription: isSet18(object.hasStripeSubscription) ? Boolean(object.hasStripeSubscription) : void 0,
      hasSubscribed: isSet18(object.hasSubscribed) ? Boolean(object.hasSubscribed) : void 0,
      hasSubscribedToPremium: isSet18(object.hasSubscribedToPremium) ? Boolean(object.hasSubscribedToPremium) : void 0,
      hasVerifiedEmail: isSet18(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : void 0,
      hasVisitedNewProfile: isSet18(object.hasVisitedNewProfile) ? Boolean(object.hasVisitedNewProfile) : void 0,
      hideFromRobots: isSet18(object.hideFromRobots) ? Boolean(object.hideFromRobots) : void 0,
      iconImg: isSet18(object.iconImg) ? String(object.iconImg) : void 0,
      id: isSet18(object.id) ? String(object.id) : void 0,
      inBeta: isSet18(object.inBeta) ? Boolean(object.inBeta) : void 0,
      inChat: isSet18(object.inChat) ? Boolean(object.inChat) : void 0,
      inRedesignBeta: isSet18(object.inRedesignBeta) ? Boolean(object.inRedesignBeta) : void 0,
      inboxCount: isSet18(object.inboxCount) ? Number(object.inboxCount) : void 0,
      isBlocked: isSet18(object.isBlocked) ? Boolean(object.isBlocked) : void 0,
      isEmployee: isSet18(object.isEmployee) ? Boolean(object.isEmployee) : void 0,
      isFriend: isSet18(object.isFriend) ? Boolean(object.isFriend) : void 0,
      isGold: isSet18(object.isGold) ? Boolean(object.isGold) : void 0,
      isMod: isSet18(object.isMod) ? Boolean(object.isMod) : void 0,
      isSponsor: isSet18(object.isSponsor) ? Boolean(object.isSponsor) : void 0,
      isSuspended: isSet18(object.isSuspended) ? Boolean(object.isSuspended) : void 0,
      linkKarma: isSet18(object.linkKarma) ? Number(object.linkKarma) : void 0,
      modhash: isSet18(object.modhash) ? String(object.modhash) : void 0,
      name: isSet18(object.name) ? String(object.name) : void 0,
      newModmailExists: isSet18(object.newModmailExists) ? Boolean(object.newModmailExists) : void 0,
      numFriends: isSet18(object.numFriends) ? Number(object.numFriends) : void 0,
      over18: isSet18(object.over18) ? Boolean(object.over18) : void 0,
      passwordSet: isSet18(object.passwordSet) ? Boolean(object.passwordSet) : void 0,
      prefAutoplay: isSet18(object.prefAutoplay) ? Boolean(object.prefAutoplay) : void 0,
      prefClickgadget: isSet18(object.prefClickgadget) ? Number(object.prefClickgadget) : void 0,
      prefGeopopular: isSet18(object.prefGeopopular) ? String(object.prefGeopopular) : void 0,
      prefNightmode: isSet18(object.prefNightmode) ? Boolean(object.prefNightmode) : void 0,
      prefNoProfanity: isSet18(object.prefNoProfanity) ? Boolean(object.prefNoProfanity) : void 0,
      prefShowPresence: isSet18(object.prefShowPresence) ? Boolean(object.prefShowPresence) : void 0,
      prefShowSnoovatar: isSet18(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : void 0,
      prefShowTrending: isSet18(object.prefShowTrending) ? Boolean(object.prefShowTrending) : void 0,
      prefShowTwitter: isSet18(object.prefShowTwitter) ? Boolean(object.prefShowTwitter) : void 0,
      prefTopKarmaSubreddits: isSet18(object.prefTopKarmaSubreddits) ? Boolean(object.prefTopKarmaSubreddits) : void 0,
      prefVideoAutoplay: isSet18(object.prefVideoAutoplay) ? Boolean(object.prefVideoAutoplay) : void 0,
      snoovatarImg: isSet18(object.snoovatarImg) ? String(object.snoovatarImg) : void 0,
      snoovatarSize: globalThis.Array.isArray(object?.snoovatarSize) ? object.snoovatarSize.map((e) => Number(e)) : [],
      subreddit: isSet18(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : void 0,
      suspensionExpirationUtc: isSet18(object.suspensionExpirationUtc) ? String(object.suspensionExpirationUtc) : void 0,
      totalKarma: isSet18(object.totalKarma) ? Number(object.totalKarma) : void 0,
      verified: isSet18(object.verified) ? Boolean(object.verified) : void 0,
      hasPhoneNumber: isSet18(object.hasPhoneNumber) ? Boolean(object.hasPhoneNumber) : void 0,
      subredditsModerated: isSet18(object.subredditsModerated) ? Number(object.subredditsModerated) : void 0,
      hasMetaSubscription: isSet18(object.hasMetaSubscription) ? Boolean(object.hasMetaSubscription) : void 0,
      metaSubscriptionAge: isSet18(object.metaSubscriptionAge) ? Number(object.metaSubscriptionAge) : void 0,
      metaPointsBalance: isSet18(object.metaPointsBalance) ? String(object.metaPointsBalance) : void 0,
      metaLockedPointsBalance: isSet18(object.metaLockedPointsBalance) ? String(object.metaLockedPointsBalance) : void 0,
      commentSubredditKarma: isSet18(object.commentSubredditKarma) ? Number(object.commentSubredditKarma) : void 0,
      postSubredditKarma: isSet18(object.postSubredditKarma) ? Number(object.postSubredditKarma) : void 0,
      markedSpam: isSet18(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      isSubredditProxyAccount: isSet18(object.isSubredditProxyAccount) ? Boolean(object.isSubredditProxyAccount) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.acceptChats !== void 0) {
      obj.acceptChats = message.acceptChats;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.acceptPms !== void 0) {
      obj.acceptPms = message.acceptPms;
    }
    if (message.awardeeKarma !== void 0) {
      obj.awardeeKarma = message.awardeeKarma;
    }
    if (message.awarderKarma !== void 0) {
      obj.awarderKarma = message.awarderKarma;
    }
    if (message.canCreateSubreddit !== void 0) {
      obj.canCreateSubreddit = message.canCreateSubreddit;
    }
    if (message.canEditName !== void 0) {
      obj.canEditName = message.canEditName;
    }
    if (message.coins !== void 0) {
      obj.coins = message.coins;
    }
    if (message.commentKarma !== void 0) {
      obj.commentKarma = message.commentKarma;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.features !== void 0) {
      obj.features = UserFeatures.toJSON(message.features);
    }
    if (message.forcePasswordReset !== void 0) {
      obj.forcePasswordReset = message.forcePasswordReset;
    }
    if (message.goldCreddits !== void 0) {
      obj.goldCreddits = message.goldCreddits;
    }
    if (message.goldExpiration !== void 0) {
      obj.goldExpiration = message.goldExpiration;
    }
    if (message.hasAndroidSubscription !== void 0) {
      obj.hasAndroidSubscription = message.hasAndroidSubscription;
    }
    if (message.hasExternalAccount !== void 0) {
      obj.hasExternalAccount = message.hasExternalAccount;
    }
    if (message.hasGoldSubscription !== void 0) {
      obj.hasGoldSubscription = message.hasGoldSubscription;
    }
    if (message.hasIosSubscription !== void 0) {
      obj.hasIosSubscription = message.hasIosSubscription;
    }
    if (message.hasMail !== void 0) {
      obj.hasMail = message.hasMail;
    }
    if (message.hasModMail !== void 0) {
      obj.hasModMail = message.hasModMail;
    }
    if (message.hasPaypalSubscription !== void 0) {
      obj.hasPaypalSubscription = message.hasPaypalSubscription;
    }
    if (message.hasStripeSubscription !== void 0) {
      obj.hasStripeSubscription = message.hasStripeSubscription;
    }
    if (message.hasSubscribed !== void 0) {
      obj.hasSubscribed = message.hasSubscribed;
    }
    if (message.hasSubscribedToPremium !== void 0) {
      obj.hasSubscribedToPremium = message.hasSubscribedToPremium;
    }
    if (message.hasVerifiedEmail !== void 0) {
      obj.hasVerifiedEmail = message.hasVerifiedEmail;
    }
    if (message.hasVisitedNewProfile !== void 0) {
      obj.hasVisitedNewProfile = message.hasVisitedNewProfile;
    }
    if (message.hideFromRobots !== void 0) {
      obj.hideFromRobots = message.hideFromRobots;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.inBeta !== void 0) {
      obj.inBeta = message.inBeta;
    }
    if (message.inChat !== void 0) {
      obj.inChat = message.inChat;
    }
    if (message.inRedesignBeta !== void 0) {
      obj.inRedesignBeta = message.inRedesignBeta;
    }
    if (message.inboxCount !== void 0) {
      obj.inboxCount = message.inboxCount;
    }
    if (message.isBlocked !== void 0) {
      obj.isBlocked = message.isBlocked;
    }
    if (message.isEmployee !== void 0) {
      obj.isEmployee = message.isEmployee;
    }
    if (message.isFriend !== void 0) {
      obj.isFriend = message.isFriend;
    }
    if (message.isGold !== void 0) {
      obj.isGold = message.isGold;
    }
    if (message.isMod !== void 0) {
      obj.isMod = message.isMod;
    }
    if (message.isSponsor !== void 0) {
      obj.isSponsor = message.isSponsor;
    }
    if (message.isSuspended !== void 0) {
      obj.isSuspended = message.isSuspended;
    }
    if (message.linkKarma !== void 0) {
      obj.linkKarma = message.linkKarma;
    }
    if (message.modhash !== void 0) {
      obj.modhash = message.modhash;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.newModmailExists !== void 0) {
      obj.newModmailExists = message.newModmailExists;
    }
    if (message.numFriends !== void 0) {
      obj.numFriends = message.numFriends;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.passwordSet !== void 0) {
      obj.passwordSet = message.passwordSet;
    }
    if (message.prefAutoplay !== void 0) {
      obj.prefAutoplay = message.prefAutoplay;
    }
    if (message.prefClickgadget !== void 0) {
      obj.prefClickgadget = message.prefClickgadget;
    }
    if (message.prefGeopopular !== void 0) {
      obj.prefGeopopular = message.prefGeopopular;
    }
    if (message.prefNightmode !== void 0) {
      obj.prefNightmode = message.prefNightmode;
    }
    if (message.prefNoProfanity !== void 0) {
      obj.prefNoProfanity = message.prefNoProfanity;
    }
    if (message.prefShowPresence !== void 0) {
      obj.prefShowPresence = message.prefShowPresence;
    }
    if (message.prefShowSnoovatar !== void 0) {
      obj.prefShowSnoovatar = message.prefShowSnoovatar;
    }
    if (message.prefShowTrending !== void 0) {
      obj.prefShowTrending = message.prefShowTrending;
    }
    if (message.prefShowTwitter !== void 0) {
      obj.prefShowTwitter = message.prefShowTwitter;
    }
    if (message.prefTopKarmaSubreddits !== void 0) {
      obj.prefTopKarmaSubreddits = message.prefTopKarmaSubreddits;
    }
    if (message.prefVideoAutoplay !== void 0) {
      obj.prefVideoAutoplay = message.prefVideoAutoplay;
    }
    if (message.snoovatarImg !== void 0) {
      obj.snoovatarImg = message.snoovatarImg;
    }
    if (message.snoovatarSize?.length) {
      obj.snoovatarSize = message.snoovatarSize;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = Subreddit.toJSON(message.subreddit);
    }
    if (message.suspensionExpirationUtc !== void 0) {
      obj.suspensionExpirationUtc = message.suspensionExpirationUtc;
    }
    if (message.totalKarma !== void 0) {
      obj.totalKarma = message.totalKarma;
    }
    if (message.verified !== void 0) {
      obj.verified = message.verified;
    }
    if (message.hasPhoneNumber !== void 0) {
      obj.hasPhoneNumber = message.hasPhoneNumber;
    }
    if (message.subredditsModerated !== void 0) {
      obj.subredditsModerated = message.subredditsModerated;
    }
    if (message.hasMetaSubscription !== void 0) {
      obj.hasMetaSubscription = message.hasMetaSubscription;
    }
    if (message.metaSubscriptionAge !== void 0) {
      obj.metaSubscriptionAge = message.metaSubscriptionAge;
    }
    if (message.metaPointsBalance !== void 0) {
      obj.metaPointsBalance = message.metaPointsBalance;
    }
    if (message.metaLockedPointsBalance !== void 0) {
      obj.metaLockedPointsBalance = message.metaLockedPointsBalance;
    }
    if (message.commentSubredditKarma !== void 0) {
      obj.commentSubredditKarma = message.commentSubredditKarma;
    }
    if (message.postSubredditKarma !== void 0) {
      obj.postSubredditKarma = message.postSubredditKarma;
    }
    if (message.markedSpam !== void 0) {
      obj.markedSpam = message.markedSpam;
    }
    if (message.isSubredditProxyAccount !== void 0) {
      obj.isSubredditProxyAccount = message.isSubredditProxyAccount;
    }
    return obj;
  },
  create(base) {
    return User.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUser();
    message.acceptChats = object.acceptChats ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.acceptPms = object.acceptPms ?? void 0;
    message.awardeeKarma = object.awardeeKarma ?? void 0;
    message.awarderKarma = object.awarderKarma ?? void 0;
    message.canCreateSubreddit = object.canCreateSubreddit ?? void 0;
    message.canEditName = object.canEditName ?? void 0;
    message.coins = object.coins ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.features = object.features !== void 0 && object.features !== null ? UserFeatures.fromPartial(object.features) : void 0;
    message.forcePasswordReset = object.forcePasswordReset ?? void 0;
    message.goldCreddits = object.goldCreddits ?? void 0;
    message.goldExpiration = object.goldExpiration ?? void 0;
    message.hasAndroidSubscription = object.hasAndroidSubscription ?? void 0;
    message.hasExternalAccount = object.hasExternalAccount ?? void 0;
    message.hasGoldSubscription = object.hasGoldSubscription ?? void 0;
    message.hasIosSubscription = object.hasIosSubscription ?? void 0;
    message.hasMail = object.hasMail ?? void 0;
    message.hasModMail = object.hasModMail ?? void 0;
    message.hasPaypalSubscription = object.hasPaypalSubscription ?? void 0;
    message.hasStripeSubscription = object.hasStripeSubscription ?? void 0;
    message.hasSubscribed = object.hasSubscribed ?? void 0;
    message.hasSubscribedToPremium = object.hasSubscribedToPremium ?? void 0;
    message.hasVerifiedEmail = object.hasVerifiedEmail ?? void 0;
    message.hasVisitedNewProfile = object.hasVisitedNewProfile ?? void 0;
    message.hideFromRobots = object.hideFromRobots ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.id = object.id ?? void 0;
    message.inBeta = object.inBeta ?? void 0;
    message.inChat = object.inChat ?? void 0;
    message.inRedesignBeta = object.inRedesignBeta ?? void 0;
    message.inboxCount = object.inboxCount ?? void 0;
    message.isBlocked = object.isBlocked ?? void 0;
    message.isEmployee = object.isEmployee ?? void 0;
    message.isFriend = object.isFriend ?? void 0;
    message.isGold = object.isGold ?? void 0;
    message.isMod = object.isMod ?? void 0;
    message.isSponsor = object.isSponsor ?? void 0;
    message.isSuspended = object.isSuspended ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.modhash = object.modhash ?? void 0;
    message.name = object.name ?? void 0;
    message.newModmailExists = object.newModmailExists ?? void 0;
    message.numFriends = object.numFriends ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.passwordSet = object.passwordSet ?? void 0;
    message.prefAutoplay = object.prefAutoplay ?? void 0;
    message.prefClickgadget = object.prefClickgadget ?? void 0;
    message.prefGeopopular = object.prefGeopopular ?? void 0;
    message.prefNightmode = object.prefNightmode ?? void 0;
    message.prefNoProfanity = object.prefNoProfanity ?? void 0;
    message.prefShowPresence = object.prefShowPresence ?? void 0;
    message.prefShowSnoovatar = object.prefShowSnoovatar ?? void 0;
    message.prefShowTrending = object.prefShowTrending ?? void 0;
    message.prefShowTwitter = object.prefShowTwitter ?? void 0;
    message.prefTopKarmaSubreddits = object.prefTopKarmaSubreddits ?? void 0;
    message.prefVideoAutoplay = object.prefVideoAutoplay ?? void 0;
    message.snoovatarImg = object.snoovatarImg ?? void 0;
    message.snoovatarSize = object.snoovatarSize?.map((e) => e) || [];
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? Subreddit.fromPartial(object.subreddit) : void 0;
    message.suspensionExpirationUtc = object.suspensionExpirationUtc ?? void 0;
    message.totalKarma = object.totalKarma ?? void 0;
    message.verified = object.verified ?? void 0;
    message.hasPhoneNumber = object.hasPhoneNumber ?? void 0;
    message.subredditsModerated = object.subredditsModerated ?? void 0;
    message.hasMetaSubscription = object.hasMetaSubscription ?? void 0;
    message.metaSubscriptionAge = object.metaSubscriptionAge ?? void 0;
    message.metaPointsBalance = object.metaPointsBalance ?? void 0;
    message.metaLockedPointsBalance = object.metaLockedPointsBalance ?? void 0;
    message.commentSubredditKarma = object.commentSubredditKarma ?? void 0;
    message.postSubredditKarma = object.postSubredditKarma ?? void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.isSubredditProxyAccount = object.isSubredditProxyAccount ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(User.$type, User);
function createBaseUserFeatures() {
  return {
    awardsOnStreams: void 0,
    canMakeMobileTestBuildPurchases: void 0,
    chatGroupRollout: void 0,
    chatSubreddit: void 0,
    chatUserSettings: void 0,
    chat: void 0,
    cookieConsentBanner: void 0,
    crosspostNotif: void 0,
    crowdControlForPost: void 0,
    customFeedImage: void 0,
    doNotTrack: void 0,
    expensiveCoinsPackage: void 0,
    isEmailPermissionRequired: void 0,
    liveComments: void 0,
    liveOrangereds: void 0,
    modAwards: void 0,
    modServiceMuteReads: void 0,
    modServiceMuteWrites: void 0,
    modlogCopyrightRemoval: void 0,
    mwebNsfwXpromo: void 0,
    mwebXpromoInterstitialCommentsAndroid: void 0,
    mwebXpromoInterstitialCommentsIos: void 0,
    mwebXpromoModalListingClickDailyDismissibleAndroid: void 0,
    mwebXpromoModalListingClickDailyDismissibleIos: void 0,
    mwebXpromoRevampV2: void 0,
    mwebXpromoRevampV3: void 0,
    noreferrerToNoopener: void 0,
    pollsMobile: void 0,
    premiumSubscriptionsTable: void 0,
    promotedTrendBlanks: void 0,
    resizedStylesImages: void 0,
    showAmpLink: void 0,
    showNpsSurvey: void 0,
    spezModal: void 0,
    usePrefAccountDeployment: void 0,
    userFlairMigrationTesting: void 0,
    webhookConfig: void 0
  };
}
var UserFeatures = {
  $type: "devvit.reddit.UserFeatures",
  encode(message, writer = import_minimal20.default.Writer.create()) {
    if (message.awardsOnStreams !== void 0) {
      BoolValue.encode({ value: message.awardsOnStreams }, writer.uint32(10).fork()).ldelim();
    }
    if (message.canMakeMobileTestBuildPurchases !== void 0) {
      BoolValue.encode({ value: message.canMakeMobileTestBuildPurchases }, writer.uint32(18).fork()).ldelim();
    }
    if (message.chatGroupRollout !== void 0) {
      BoolValue.encode({ value: message.chatGroupRollout }, writer.uint32(26).fork()).ldelim();
    }
    if (message.chatSubreddit !== void 0) {
      BoolValue.encode({ value: message.chatSubreddit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.chatUserSettings !== void 0) {
      BoolValue.encode({ value: message.chatUserSettings }, writer.uint32(42).fork()).ldelim();
    }
    if (message.chat !== void 0) {
      BoolValue.encode({ value: message.chat }, writer.uint32(50).fork()).ldelim();
    }
    if (message.cookieConsentBanner !== void 0) {
      BoolValue.encode({ value: message.cookieConsentBanner }, writer.uint32(58).fork()).ldelim();
    }
    if (message.crosspostNotif !== void 0) {
      BoolValue.encode({ value: message.crosspostNotif }, writer.uint32(66).fork()).ldelim();
    }
    if (message.crowdControlForPost !== void 0) {
      BoolValue.encode({ value: message.crowdControlForPost }, writer.uint32(74).fork()).ldelim();
    }
    if (message.customFeedImage !== void 0) {
      BoolValue.encode({ value: message.customFeedImage }, writer.uint32(82).fork()).ldelim();
    }
    if (message.doNotTrack !== void 0) {
      BoolValue.encode({ value: message.doNotTrack }, writer.uint32(90).fork()).ldelim();
    }
    if (message.expensiveCoinsPackage !== void 0) {
      BoolValue.encode({ value: message.expensiveCoinsPackage }, writer.uint32(98).fork()).ldelim();
    }
    if (message.isEmailPermissionRequired !== void 0) {
      BoolValue.encode({ value: message.isEmailPermissionRequired }, writer.uint32(106).fork()).ldelim();
    }
    if (message.liveComments !== void 0) {
      BoolValue.encode({ value: message.liveComments }, writer.uint32(114).fork()).ldelim();
    }
    if (message.liveOrangereds !== void 0) {
      BoolValue.encode({ value: message.liveOrangereds }, writer.uint32(122).fork()).ldelim();
    }
    if (message.modAwards !== void 0) {
      BoolValue.encode({ value: message.modAwards }, writer.uint32(130).fork()).ldelim();
    }
    if (message.modServiceMuteReads !== void 0) {
      BoolValue.encode({ value: message.modServiceMuteReads }, writer.uint32(138).fork()).ldelim();
    }
    if (message.modServiceMuteWrites !== void 0) {
      BoolValue.encode({ value: message.modServiceMuteWrites }, writer.uint32(146).fork()).ldelim();
    }
    if (message.modlogCopyrightRemoval !== void 0) {
      BoolValue.encode({ value: message.modlogCopyrightRemoval }, writer.uint32(154).fork()).ldelim();
    }
    if (message.mwebNsfwXpromo !== void 0) {
      UserFeatures_Experiment.encode(message.mwebNsfwXpromo, writer.uint32(162).fork()).ldelim();
    }
    if (message.mwebXpromoInterstitialCommentsAndroid !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoInterstitialCommentsAndroid }, writer.uint32(170).fork()).ldelim();
    }
    if (message.mwebXpromoInterstitialCommentsIos !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoInterstitialCommentsIos }, writer.uint32(178).fork()).ldelim();
    }
    if (message.mwebXpromoModalListingClickDailyDismissibleAndroid !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoModalListingClickDailyDismissibleAndroid }, writer.uint32(186).fork()).ldelim();
    }
    if (message.mwebXpromoModalListingClickDailyDismissibleIos !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoModalListingClickDailyDismissibleIos }, writer.uint32(194).fork()).ldelim();
    }
    if (message.mwebXpromoRevampV2 !== void 0) {
      UserFeatures_Experiment.encode(message.mwebXpromoRevampV2, writer.uint32(202).fork()).ldelim();
    }
    if (message.mwebXpromoRevampV3 !== void 0) {
      UserFeatures_Experiment.encode(message.mwebXpromoRevampV3, writer.uint32(210).fork()).ldelim();
    }
    if (message.noreferrerToNoopener !== void 0) {
      BoolValue.encode({ value: message.noreferrerToNoopener }, writer.uint32(218).fork()).ldelim();
    }
    if (message.pollsMobile !== void 0) {
      BoolValue.encode({ value: message.pollsMobile }, writer.uint32(226).fork()).ldelim();
    }
    if (message.premiumSubscriptionsTable !== void 0) {
      BoolValue.encode({ value: message.premiumSubscriptionsTable }, writer.uint32(234).fork()).ldelim();
    }
    if (message.promotedTrendBlanks !== void 0) {
      BoolValue.encode({ value: message.promotedTrendBlanks }, writer.uint32(242).fork()).ldelim();
    }
    if (message.resizedStylesImages !== void 0) {
      BoolValue.encode({ value: message.resizedStylesImages }, writer.uint32(250).fork()).ldelim();
    }
    if (message.showAmpLink !== void 0) {
      BoolValue.encode({ value: message.showAmpLink }, writer.uint32(258).fork()).ldelim();
    }
    if (message.showNpsSurvey !== void 0) {
      BoolValue.encode({ value: message.showNpsSurvey }, writer.uint32(266).fork()).ldelim();
    }
    if (message.spezModal !== void 0) {
      BoolValue.encode({ value: message.spezModal }, writer.uint32(274).fork()).ldelim();
    }
    if (message.usePrefAccountDeployment !== void 0) {
      BoolValue.encode({ value: message.usePrefAccountDeployment }, writer.uint32(282).fork()).ldelim();
    }
    if (message.userFlairMigrationTesting !== void 0) {
      BoolValue.encode({ value: message.userFlairMigrationTesting }, writer.uint32(290).fork()).ldelim();
    }
    if (message.webhookConfig !== void 0) {
      BoolValue.encode({ value: message.webhookConfig }, writer.uint32(298).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal20.default.Reader ? input : import_minimal20.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.awardsOnStreams = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.canMakeMobileTestBuildPurchases = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.chatGroupRollout = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.chatSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.chatUserSettings = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.chat = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.cookieConsentBanner = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.crosspostNotif = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.crowdControlForPost = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.customFeedImage = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.doNotTrack = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.expensiveCoinsPackage = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.isEmailPermissionRequired = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.liveComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.liveOrangereds = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.modAwards = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.modServiceMuteReads = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.modServiceMuteWrites = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.modlogCopyrightRemoval = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.mwebNsfwXpromo = UserFeatures_Experiment.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.mwebXpromoInterstitialCommentsAndroid = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.mwebXpromoInterstitialCommentsIos = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.mwebXpromoModalListingClickDailyDismissibleAndroid = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.mwebXpromoModalListingClickDailyDismissibleIos = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.mwebXpromoRevampV2 = UserFeatures_Experiment.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.mwebXpromoRevampV3 = UserFeatures_Experiment.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.noreferrerToNoopener = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.pollsMobile = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.premiumSubscriptionsTable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.promotedTrendBlanks = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.resizedStylesImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.showAmpLink = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.showNpsSurvey = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.spezModal = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.usePrefAccountDeployment = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.userFlairMigrationTesting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.webhookConfig = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      awardsOnStreams: isSet18(object.awardsOnStreams) ? Boolean(object.awardsOnStreams) : void 0,
      canMakeMobileTestBuildPurchases: isSet18(object.canMakeMobileTestBuildPurchases) ? Boolean(object.canMakeMobileTestBuildPurchases) : void 0,
      chatGroupRollout: isSet18(object.chatGroupRollout) ? Boolean(object.chatGroupRollout) : void 0,
      chatSubreddit: isSet18(object.chatSubreddit) ? Boolean(object.chatSubreddit) : void 0,
      chatUserSettings: isSet18(object.chatUserSettings) ? Boolean(object.chatUserSettings) : void 0,
      chat: isSet18(object.chat) ? Boolean(object.chat) : void 0,
      cookieConsentBanner: isSet18(object.cookieConsentBanner) ? Boolean(object.cookieConsentBanner) : void 0,
      crosspostNotif: isSet18(object.crosspostNotif) ? Boolean(object.crosspostNotif) : void 0,
      crowdControlForPost: isSet18(object.crowdControlForPost) ? Boolean(object.crowdControlForPost) : void 0,
      customFeedImage: isSet18(object.customFeedImage) ? Boolean(object.customFeedImage) : void 0,
      doNotTrack: isSet18(object.doNotTrack) ? Boolean(object.doNotTrack) : void 0,
      expensiveCoinsPackage: isSet18(object.expensiveCoinsPackage) ? Boolean(object.expensiveCoinsPackage) : void 0,
      isEmailPermissionRequired: isSet18(object.isEmailPermissionRequired) ? Boolean(object.isEmailPermissionRequired) : void 0,
      liveComments: isSet18(object.liveComments) ? Boolean(object.liveComments) : void 0,
      liveOrangereds: isSet18(object.liveOrangereds) ? Boolean(object.liveOrangereds) : void 0,
      modAwards: isSet18(object.modAwards) ? Boolean(object.modAwards) : void 0,
      modServiceMuteReads: isSet18(object.modServiceMuteReads) ? Boolean(object.modServiceMuteReads) : void 0,
      modServiceMuteWrites: isSet18(object.modServiceMuteWrites) ? Boolean(object.modServiceMuteWrites) : void 0,
      modlogCopyrightRemoval: isSet18(object.modlogCopyrightRemoval) ? Boolean(object.modlogCopyrightRemoval) : void 0,
      mwebNsfwXpromo: isSet18(object.mwebNsfwXpromo) ? UserFeatures_Experiment.fromJSON(object.mwebNsfwXpromo) : void 0,
      mwebXpromoInterstitialCommentsAndroid: isSet18(object.mwebXpromoInterstitialCommentsAndroid) ? Boolean(object.mwebXpromoInterstitialCommentsAndroid) : void 0,
      mwebXpromoInterstitialCommentsIos: isSet18(object.mwebXpromoInterstitialCommentsIos) ? Boolean(object.mwebXpromoInterstitialCommentsIos) : void 0,
      mwebXpromoModalListingClickDailyDismissibleAndroid: isSet18(object.mwebXpromoModalListingClickDailyDismissibleAndroid) ? Boolean(object.mwebXpromoModalListingClickDailyDismissibleAndroid) : void 0,
      mwebXpromoModalListingClickDailyDismissibleIos: isSet18(object.mwebXpromoModalListingClickDailyDismissibleIos) ? Boolean(object.mwebXpromoModalListingClickDailyDismissibleIos) : void 0,
      mwebXpromoRevampV2: isSet18(object.mwebXpromoRevampV2) ? UserFeatures_Experiment.fromJSON(object.mwebXpromoRevampV2) : void 0,
      mwebXpromoRevampV3: isSet18(object.mwebXpromoRevampV3) ? UserFeatures_Experiment.fromJSON(object.mwebXpromoRevampV3) : void 0,
      noreferrerToNoopener: isSet18(object.noreferrerToNoopener) ? Boolean(object.noreferrerToNoopener) : void 0,
      pollsMobile: isSet18(object.pollsMobile) ? Boolean(object.pollsMobile) : void 0,
      premiumSubscriptionsTable: isSet18(object.premiumSubscriptionsTable) ? Boolean(object.premiumSubscriptionsTable) : void 0,
      promotedTrendBlanks: isSet18(object.promotedTrendBlanks) ? Boolean(object.promotedTrendBlanks) : void 0,
      resizedStylesImages: isSet18(object.resizedStylesImages) ? Boolean(object.resizedStylesImages) : void 0,
      showAmpLink: isSet18(object.showAmpLink) ? Boolean(object.showAmpLink) : void 0,
      showNpsSurvey: isSet18(object.showNpsSurvey) ? Boolean(object.showNpsSurvey) : void 0,
      spezModal: isSet18(object.spezModal) ? Boolean(object.spezModal) : void 0,
      usePrefAccountDeployment: isSet18(object.usePrefAccountDeployment) ? Boolean(object.usePrefAccountDeployment) : void 0,
      userFlairMigrationTesting: isSet18(object.userFlairMigrationTesting) ? Boolean(object.userFlairMigrationTesting) : void 0,
      webhookConfig: isSet18(object.webhookConfig) ? Boolean(object.webhookConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.awardsOnStreams !== void 0) {
      obj.awardsOnStreams = message.awardsOnStreams;
    }
    if (message.canMakeMobileTestBuildPurchases !== void 0) {
      obj.canMakeMobileTestBuildPurchases = message.canMakeMobileTestBuildPurchases;
    }
    if (message.chatGroupRollout !== void 0) {
      obj.chatGroupRollout = message.chatGroupRollout;
    }
    if (message.chatSubreddit !== void 0) {
      obj.chatSubreddit = message.chatSubreddit;
    }
    if (message.chatUserSettings !== void 0) {
      obj.chatUserSettings = message.chatUserSettings;
    }
    if (message.chat !== void 0) {
      obj.chat = message.chat;
    }
    if (message.cookieConsentBanner !== void 0) {
      obj.cookieConsentBanner = message.cookieConsentBanner;
    }
    if (message.crosspostNotif !== void 0) {
      obj.crosspostNotif = message.crosspostNotif;
    }
    if (message.crowdControlForPost !== void 0) {
      obj.crowdControlForPost = message.crowdControlForPost;
    }
    if (message.customFeedImage !== void 0) {
      obj.customFeedImage = message.customFeedImage;
    }
    if (message.doNotTrack !== void 0) {
      obj.doNotTrack = message.doNotTrack;
    }
    if (message.expensiveCoinsPackage !== void 0) {
      obj.expensiveCoinsPackage = message.expensiveCoinsPackage;
    }
    if (message.isEmailPermissionRequired !== void 0) {
      obj.isEmailPermissionRequired = message.isEmailPermissionRequired;
    }
    if (message.liveComments !== void 0) {
      obj.liveComments = message.liveComments;
    }
    if (message.liveOrangereds !== void 0) {
      obj.liveOrangereds = message.liveOrangereds;
    }
    if (message.modAwards !== void 0) {
      obj.modAwards = message.modAwards;
    }
    if (message.modServiceMuteReads !== void 0) {
      obj.modServiceMuteReads = message.modServiceMuteReads;
    }
    if (message.modServiceMuteWrites !== void 0) {
      obj.modServiceMuteWrites = message.modServiceMuteWrites;
    }
    if (message.modlogCopyrightRemoval !== void 0) {
      obj.modlogCopyrightRemoval = message.modlogCopyrightRemoval;
    }
    if (message.mwebNsfwXpromo !== void 0) {
      obj.mwebNsfwXpromo = UserFeatures_Experiment.toJSON(message.mwebNsfwXpromo);
    }
    if (message.mwebXpromoInterstitialCommentsAndroid !== void 0) {
      obj.mwebXpromoInterstitialCommentsAndroid = message.mwebXpromoInterstitialCommentsAndroid;
    }
    if (message.mwebXpromoInterstitialCommentsIos !== void 0) {
      obj.mwebXpromoInterstitialCommentsIos = message.mwebXpromoInterstitialCommentsIos;
    }
    if (message.mwebXpromoModalListingClickDailyDismissibleAndroid !== void 0) {
      obj.mwebXpromoModalListingClickDailyDismissibleAndroid = message.mwebXpromoModalListingClickDailyDismissibleAndroid;
    }
    if (message.mwebXpromoModalListingClickDailyDismissibleIos !== void 0) {
      obj.mwebXpromoModalListingClickDailyDismissibleIos = message.mwebXpromoModalListingClickDailyDismissibleIos;
    }
    if (message.mwebXpromoRevampV2 !== void 0) {
      obj.mwebXpromoRevampV2 = UserFeatures_Experiment.toJSON(message.mwebXpromoRevampV2);
    }
    if (message.mwebXpromoRevampV3 !== void 0) {
      obj.mwebXpromoRevampV3 = UserFeatures_Experiment.toJSON(message.mwebXpromoRevampV3);
    }
    if (message.noreferrerToNoopener !== void 0) {
      obj.noreferrerToNoopener = message.noreferrerToNoopener;
    }
    if (message.pollsMobile !== void 0) {
      obj.pollsMobile = message.pollsMobile;
    }
    if (message.premiumSubscriptionsTable !== void 0) {
      obj.premiumSubscriptionsTable = message.premiumSubscriptionsTable;
    }
    if (message.promotedTrendBlanks !== void 0) {
      obj.promotedTrendBlanks = message.promotedTrendBlanks;
    }
    if (message.resizedStylesImages !== void 0) {
      obj.resizedStylesImages = message.resizedStylesImages;
    }
    if (message.showAmpLink !== void 0) {
      obj.showAmpLink = message.showAmpLink;
    }
    if (message.showNpsSurvey !== void 0) {
      obj.showNpsSurvey = message.showNpsSurvey;
    }
    if (message.spezModal !== void 0) {
      obj.spezModal = message.spezModal;
    }
    if (message.usePrefAccountDeployment !== void 0) {
      obj.usePrefAccountDeployment = message.usePrefAccountDeployment;
    }
    if (message.userFlairMigrationTesting !== void 0) {
      obj.userFlairMigrationTesting = message.userFlairMigrationTesting;
    }
    if (message.webhookConfig !== void 0) {
      obj.webhookConfig = message.webhookConfig;
    }
    return obj;
  },
  create(base) {
    return UserFeatures.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserFeatures();
    message.awardsOnStreams = object.awardsOnStreams ?? void 0;
    message.canMakeMobileTestBuildPurchases = object.canMakeMobileTestBuildPurchases ?? void 0;
    message.chatGroupRollout = object.chatGroupRollout ?? void 0;
    message.chatSubreddit = object.chatSubreddit ?? void 0;
    message.chatUserSettings = object.chatUserSettings ?? void 0;
    message.chat = object.chat ?? void 0;
    message.cookieConsentBanner = object.cookieConsentBanner ?? void 0;
    message.crosspostNotif = object.crosspostNotif ?? void 0;
    message.crowdControlForPost = object.crowdControlForPost ?? void 0;
    message.customFeedImage = object.customFeedImage ?? void 0;
    message.doNotTrack = object.doNotTrack ?? void 0;
    message.expensiveCoinsPackage = object.expensiveCoinsPackage ?? void 0;
    message.isEmailPermissionRequired = object.isEmailPermissionRequired ?? void 0;
    message.liveComments = object.liveComments ?? void 0;
    message.liveOrangereds = object.liveOrangereds ?? void 0;
    message.modAwards = object.modAwards ?? void 0;
    message.modServiceMuteReads = object.modServiceMuteReads ?? void 0;
    message.modServiceMuteWrites = object.modServiceMuteWrites ?? void 0;
    message.modlogCopyrightRemoval = object.modlogCopyrightRemoval ?? void 0;
    message.mwebNsfwXpromo = object.mwebNsfwXpromo !== void 0 && object.mwebNsfwXpromo !== null ? UserFeatures_Experiment.fromPartial(object.mwebNsfwXpromo) : void 0;
    message.mwebXpromoInterstitialCommentsAndroid = object.mwebXpromoInterstitialCommentsAndroid ?? void 0;
    message.mwebXpromoInterstitialCommentsIos = object.mwebXpromoInterstitialCommentsIos ?? void 0;
    message.mwebXpromoModalListingClickDailyDismissibleAndroid = object.mwebXpromoModalListingClickDailyDismissibleAndroid ?? void 0;
    message.mwebXpromoModalListingClickDailyDismissibleIos = object.mwebXpromoModalListingClickDailyDismissibleIos ?? void 0;
    message.mwebXpromoRevampV2 = object.mwebXpromoRevampV2 !== void 0 && object.mwebXpromoRevampV2 !== null ? UserFeatures_Experiment.fromPartial(object.mwebXpromoRevampV2) : void 0;
    message.mwebXpromoRevampV3 = object.mwebXpromoRevampV3 !== void 0 && object.mwebXpromoRevampV3 !== null ? UserFeatures_Experiment.fromPartial(object.mwebXpromoRevampV3) : void 0;
    message.noreferrerToNoopener = object.noreferrerToNoopener ?? void 0;
    message.pollsMobile = object.pollsMobile ?? void 0;
    message.premiumSubscriptionsTable = object.premiumSubscriptionsTable ?? void 0;
    message.promotedTrendBlanks = object.promotedTrendBlanks ?? void 0;
    message.resizedStylesImages = object.resizedStylesImages ?? void 0;
    message.showAmpLink = object.showAmpLink ?? void 0;
    message.showNpsSurvey = object.showNpsSurvey ?? void 0;
    message.spezModal = object.spezModal ?? void 0;
    message.usePrefAccountDeployment = object.usePrefAccountDeployment ?? void 0;
    message.userFlairMigrationTesting = object.userFlairMigrationTesting ?? void 0;
    message.webhookConfig = object.webhookConfig ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserFeatures.$type, UserFeatures);
function createBaseUserFeatures_Experiment() {
  return { experimentId: void 0, owner: void 0, variant: void 0 };
}
var UserFeatures_Experiment = {
  $type: "devvit.reddit.UserFeatures.Experiment",
  encode(message, writer = import_minimal20.default.Writer.create()) {
    if (message.experimentId !== void 0) {
      Int32Value.encode({ value: message.experimentId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      StringValue.encode({ value: message.owner }, writer.uint32(18).fork()).ldelim();
    }
    if (message.variant !== void 0) {
      StringValue.encode({ value: message.variant }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal20.default.Reader ? input : import_minimal20.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFeatures_Experiment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.experimentId = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.owner = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.variant = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      experimentId: isSet18(object.experimentId) ? Number(object.experimentId) : void 0,
      owner: isSet18(object.owner) ? String(object.owner) : void 0,
      variant: isSet18(object.variant) ? String(object.variant) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.experimentId !== void 0) {
      obj.experimentId = message.experimentId;
    }
    if (message.owner !== void 0) {
      obj.owner = message.owner;
    }
    if (message.variant !== void 0) {
      obj.variant = message.variant;
    }
    return obj;
  },
  create(base) {
    return UserFeatures_Experiment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserFeatures_Experiment();
    message.experimentId = object.experimentId ?? void 0;
    message.owner = object.owner ?? void 0;
    message.variant = object.variant ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserFeatures_Experiment.$type, UserFeatures_Experiment);
function isSet18(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/thing_type.js
var ThingType;
(function(ThingType2) {
  ThingType2[ThingType2["UNKNOWN"] = 0] = "UNKNOWN";
  ThingType2[ThingType2["COMMENT"] = 1] = "COMMENT";
  ThingType2[ThingType2["ACCOUNT"] = 2] = "ACCOUNT";
  ThingType2[ThingType2["POST"] = 3] = "POST";
  ThingType2[ThingType2["MESSAGE"] = 4] = "MESSAGE";
  ThingType2[ThingType2["SUBREDDIT"] = 5] = "SUBREDDIT";
  ThingType2[ThingType2["AWARD"] = 6] = "AWARD";
  ThingType2[ThingType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ThingType || (ThingType = {}));
function thingTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ThingType.UNKNOWN;
    case 1:
    case "COMMENT":
      return ThingType.COMMENT;
    case 2:
    case "ACCOUNT":
      return ThingType.ACCOUNT;
    case 3:
    case "POST":
      return ThingType.POST;
    case 4:
    case "MESSAGE":
      return ThingType.MESSAGE;
    case 5:
    case "SUBREDDIT":
      return ThingType.SUBREDDIT;
    case 6:
    case "AWARD":
      return ThingType.AWARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThingType.UNRECOGNIZED;
  }
}
function thingTypeToJSON(object) {
  switch (object) {
    case ThingType.UNKNOWN:
      return 0;
    case ThingType.COMMENT:
      return 1;
    case ThingType.ACCOUNT:
      return 2;
    case ThingType.POST:
      return 3;
    case ThingType.MESSAGE:
      return 4;
    case ThingType.SUBREDDIT:
      return 5;
    case ThingType.AWARD:
      return 6;
    case ThingType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/reddit/post.js
var import_minimal21 = __toESM(require_minimal2(), 1);
function createBasePost() {
  return {
    allAwardings: [],
    allowLiveComments: void 0,
    approved: void 0,
    approvedAtUtc: void 0,
    approvedBy: void 0,
    archived: void 0,
    author: void 0,
    authorFlairBackgroundColor: void 0,
    authorFlairCssClass: void 0,
    authorFlairRichtext: [],
    authorFlairTemplateId: void 0,
    authorFlairText: void 0,
    authorFlairTextColor: void 0,
    authorFlairType: void 0,
    authorFullname: void 0,
    authorIsBlocked: void 0,
    authorPatreonFlair: void 0,
    authorPremium: void 0,
    awarders: [],
    bannedAtUtc: void 0,
    bannedBy: void 0,
    canGild: void 0,
    canModPost: void 0,
    category: void 0,
    clicked: void 0,
    contentCategories: [],
    contestMode: void 0,
    created: void 0,
    createdUtc: void 0,
    discussionType: void 0,
    distinguished: void 0,
    domain: void 0,
    downs: void 0,
    edited: void 0,
    gilded: void 0,
    gildings: void 0,
    hidden: void 0,
    hideScore: void 0,
    id: void 0,
    ignoreReports: void 0,
    isCreatedFromAdsUi: void 0,
    isCrosspostable: void 0,
    isMeta: void 0,
    isOriginalContent: void 0,
    isRedditMediaDomain: void 0,
    isRobotIndexable: void 0,
    isSelf: void 0,
    isVideo: void 0,
    likes: void 0,
    linkFlairBackgroundColor: void 0,
    linkFlairCssClass: void 0,
    linkFlairRichtext: [],
    linkFlairTextColor: void 0,
    linkFlairText: void 0,
    linkFlairType: void 0,
    locked: void 0,
    mediaEmbed: void 0,
    mediaOnly: void 0,
    media: void 0,
    modNote: void 0,
    modReasonBy: void 0,
    modReasonTitle: void 0,
    modReports: [],
    name: void 0,
    noFollow: void 0,
    numComments: void 0,
    numCrossposts: void 0,
    numDuplicates: void 0,
    numReports: void 0,
    over18: void 0,
    parentWhitelistStatus: void 0,
    permalink: void 0,
    pinned: void 0,
    postHint: void 0,
    preview: void 0,
    pwls: void 0,
    quarantine: void 0,
    removalReason: void 0,
    removedByCategory: void 0,
    removedBy: void 0,
    removed: void 0,
    reportReasons: [],
    rteMode: void 0,
    saved: void 0,
    score: void 0,
    secureMediaEmbed: void 0,
    secureMedia: void 0,
    selftextHtml: void 0,
    selftext: void 0,
    sendReplies: void 0,
    spam: void 0,
    spoiler: void 0,
    stickied: void 0,
    subredditId: void 0,
    subredditNamePrefixed: void 0,
    subredditSubscribers: void 0,
    subredditType: void 0,
    subreddit: void 0,
    suggestedSort: void 0,
    thumbnailHeight: void 0,
    thumbnailWidth: void 0,
    thumbnail: void 0,
    title: void 0,
    topAwardedType: void 0,
    totalAwardsReceived: void 0,
    treatmentTags: [],
    ups: void 0,
    upvoteRatio: void 0,
    urlOverriddenByDest: void 0,
    url: void 0,
    userReports: [],
    viewCount: void 0,
    visited: void 0,
    whitelistStatus: void 0,
    wls: void 0,
    linkFlairTemplateId: void 0,
    crowdControlLevel: void 0,
    isGallery: void 0,
    isLiveStream: void 0,
    isMetaDiscussion: void 0,
    oembed: void 0,
    banInfo: void 0,
    markedSpam: void 0,
    verdict: void 0,
    gallery: void 0
  };
}
var Post = {
  $type: "devvit.reddit.Post",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    for (const v of message.allAwardings) {
      Awarding.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.allowLiveComments !== void 0) {
      BoolValue.encode({ value: message.allowLiveComments }, writer.uint32(18).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(26).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(34).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(42).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(50).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(178).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(186).fork()).ldelim();
    }
    if (message.category !== void 0) {
      StringValue.encode({ value: message.category }, writer.uint32(194).fork()).ldelim();
    }
    if (message.clicked !== void 0) {
      BoolValue.encode({ value: message.clicked }, writer.uint32(202).fork()).ldelim();
    }
    for (const v of message.contentCategories) {
      StringValue.encode({ value: v }, writer.uint32(210).fork()).ldelim();
    }
    if (message.contestMode !== void 0) {
      BoolValue.encode({ value: message.contestMode }, writer.uint32(218).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(226).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(234).fork()).ldelim();
    }
    if (message.discussionType !== void 0) {
      StringValue.encode({ value: message.discussionType }, writer.uint32(242).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(250).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(258).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int32Value.encode({ value: message.downs }, writer.uint32(266).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(274).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int32Value.encode({ value: message.gilded }, writer.uint32(282).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Gildings.encode(message.gildings, writer.uint32(290).fork()).ldelim();
    }
    if (message.hidden !== void 0) {
      BoolValue.encode({ value: message.hidden }, writer.uint32(298).fork()).ldelim();
    }
    if (message.hideScore !== void 0) {
      BoolValue.encode({ value: message.hideScore }, writer.uint32(306).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(314).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(322).fork()).ldelim();
    }
    if (message.isCreatedFromAdsUi !== void 0) {
      BoolValue.encode({ value: message.isCreatedFromAdsUi }, writer.uint32(330).fork()).ldelim();
    }
    if (message.isCrosspostable !== void 0) {
      BoolValue.encode({ value: message.isCrosspostable }, writer.uint32(338).fork()).ldelim();
    }
    if (message.isMeta !== void 0) {
      BoolValue.encode({ value: message.isMeta }, writer.uint32(346).fork()).ldelim();
    }
    if (message.isOriginalContent !== void 0) {
      BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(354).fork()).ldelim();
    }
    if (message.isRedditMediaDomain !== void 0) {
      BoolValue.encode({ value: message.isRedditMediaDomain }, writer.uint32(362).fork()).ldelim();
    }
    if (message.isRobotIndexable !== void 0) {
      BoolValue.encode({ value: message.isRobotIndexable }, writer.uint32(370).fork()).ldelim();
    }
    if (message.isSelf !== void 0) {
      BoolValue.encode({ value: message.isSelf }, writer.uint32(378).fork()).ldelim();
    }
    if (message.isVideo !== void 0) {
      BoolValue.encode({ value: message.isVideo }, writer.uint32(386).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(394).fork()).ldelim();
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(402).fork()).ldelim();
    }
    if (message.linkFlairCssClass !== void 0) {
      StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(410).fork()).ldelim();
    }
    for (const v of message.linkFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(418).fork()).ldelim();
    }
    if (message.linkFlairTextColor !== void 0) {
      StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(426).fork()).ldelim();
    }
    if (message.linkFlairText !== void 0) {
      StringValue.encode({ value: message.linkFlairText }, writer.uint32(434).fork()).ldelim();
    }
    if (message.linkFlairType !== void 0) {
      StringValue.encode({ value: message.linkFlairType }, writer.uint32(442).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(450).fork()).ldelim();
    }
    if (message.mediaEmbed !== void 0) {
      MediaEmbed.encode(message.mediaEmbed, writer.uint32(458).fork()).ldelim();
    }
    if (message.mediaOnly !== void 0) {
      BoolValue.encode({ value: message.mediaOnly }, writer.uint32(466).fork()).ldelim();
    }
    if (message.media !== void 0) {
      Media.encode(message.media, writer.uint32(474).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(482).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(490).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(498).fork()).ldelim();
    }
    for (const v of message.modReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(506).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(514).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(522).fork()).ldelim();
    }
    if (message.numComments !== void 0) {
      Int32Value.encode({ value: message.numComments }, writer.uint32(530).fork()).ldelim();
    }
    if (message.numCrossposts !== void 0) {
      Int32Value.encode({ value: message.numCrossposts }, writer.uint32(538).fork()).ldelim();
    }
    if (message.numDuplicates !== void 0) {
      Int32Value.encode({ value: message.numDuplicates }, writer.uint32(546).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int32Value.encode({ value: message.numReports }, writer.uint32(554).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(562).fork()).ldelim();
    }
    if (message.parentWhitelistStatus !== void 0) {
      StringValue.encode({ value: message.parentWhitelistStatus }, writer.uint32(570).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(578).fork()).ldelim();
    }
    if (message.pinned !== void 0) {
      BoolValue.encode({ value: message.pinned }, writer.uint32(586).fork()).ldelim();
    }
    if (message.postHint !== void 0) {
      StringValue.encode({ value: message.postHint }, writer.uint32(594).fork()).ldelim();
    }
    if (message.preview !== void 0) {
      Preview.encode(message.preview, writer.uint32(602).fork()).ldelim();
    }
    if (message.pwls !== void 0) {
      Int32Value.encode({ value: message.pwls }, writer.uint32(610).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(618).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(626).fork()).ldelim();
    }
    if (message.removedByCategory !== void 0) {
      StringValue.encode({ value: message.removedByCategory }, writer.uint32(634).fork()).ldelim();
    }
    if (message.removedBy !== void 0) {
      StringValue.encode({ value: message.removedBy }, writer.uint32(642).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(650).fork()).ldelim();
    }
    for (const v of message.reportReasons) {
      StringValue.encode({ value: v }, writer.uint32(658).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(666).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(674).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int32Value.encode({ value: message.score }, writer.uint32(682).fork()).ldelim();
    }
    if (message.secureMediaEmbed !== void 0) {
      MediaEmbed.encode(message.secureMediaEmbed, writer.uint32(690).fork()).ldelim();
    }
    if (message.secureMedia !== void 0) {
      Media.encode(message.secureMedia, writer.uint32(698).fork()).ldelim();
    }
    if (message.selftextHtml !== void 0) {
      StringValue.encode({ value: message.selftextHtml }, writer.uint32(706).fork()).ldelim();
    }
    if (message.selftext !== void 0) {
      StringValue.encode({ value: message.selftext }, writer.uint32(714).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(722).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(730).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      BoolValue.encode({ value: message.spoiler }, writer.uint32(738).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(746).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(754).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(762).fork()).ldelim();
    }
    if (message.subredditSubscribers !== void 0) {
      Int32Value.encode({ value: message.subredditSubscribers }, writer.uint32(770).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(778).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(786).fork()).ldelim();
    }
    if (message.suggestedSort !== void 0) {
      StringValue.encode({ value: message.suggestedSort }, writer.uint32(794).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(802).fork()).ldelim();
    }
    if (message.thumbnailWidth !== void 0) {
      Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(810).fork()).ldelim();
    }
    if (message.thumbnail !== void 0) {
      StringValue.encode({ value: message.thumbnail }, writer.uint32(818).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(826).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(834).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int32Value.encode({ value: message.totalAwardsReceived }, writer.uint32(842).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      StringValue.encode({ value: v }, writer.uint32(850).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int32Value.encode({ value: message.ups }, writer.uint32(858).fork()).ldelim();
    }
    if (message.upvoteRatio !== void 0) {
      FloatValue.encode({ value: message.upvoteRatio }, writer.uint32(866).fork()).ldelim();
    }
    if (message.urlOverriddenByDest !== void 0) {
      StringValue.encode({ value: message.urlOverriddenByDest }, writer.uint32(874).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(882).fork()).ldelim();
    }
    for (const v of message.userReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(890).fork()).ldelim();
    }
    if (message.viewCount !== void 0) {
      Int32Value.encode({ value: message.viewCount }, writer.uint32(898).fork()).ldelim();
    }
    if (message.visited !== void 0) {
      BoolValue.encode({ value: message.visited }, writer.uint32(906).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      StringValue.encode({ value: message.whitelistStatus }, writer.uint32(914).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      Int32Value.encode({ value: message.wls }, writer.uint32(922).fork()).ldelim();
    }
    if (message.linkFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.linkFlairTemplateId }, writer.uint32(1202).fork()).ldelim();
    }
    if (message.crowdControlLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlLevel }, writer.uint32(1210).fork()).ldelim();
    }
    if (message.isGallery !== void 0) {
      BoolValue.encode({ value: message.isGallery }, writer.uint32(1218).fork()).ldelim();
    }
    if (message.isLiveStream !== void 0) {
      BoolValue.encode({ value: message.isLiveStream }, writer.uint32(1226).fork()).ldelim();
    }
    if (message.isMetaDiscussion !== void 0) {
      BoolValue.encode({ value: message.isMetaDiscussion }, writer.uint32(1234).fork()).ldelim();
    }
    if (message.oembed !== void 0) {
      OEmbed.encode(message.oembed, writer.uint32(1242).fork()).ldelim();
    }
    if (message.banInfo !== void 0) {
      BanInfo.encode(message.banInfo, writer.uint32(1250).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(1258).fork()).ldelim();
    }
    if (message.verdict !== void 0) {
      StringValue.encode({ value: message.verdict }, writer.uint32(1266).fork()).ldelim();
    }
    if (message.gallery !== void 0) {
      RedditPostGallery.encode(message.gallery, writer.uint32(1274).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.allAwardings.push(Awarding.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.allowLiveComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.author = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.category = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.clicked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.contentCategories.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.contestMode = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.discussionType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.downs = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.gilded = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.gildings = Gildings.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.hidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.hideScore = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.isCreatedFromAdsUi = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.isCrosspostable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.isMeta = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.isRedditMediaDomain = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.isRobotIndexable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.isSelf = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.isVideo = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.linkFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.mediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.mediaOnly = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.media = Media.decode(reader, reader.uint32());
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.numComments = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.numCrossposts = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.numDuplicates = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.numReports = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.parentWhitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.pinned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.postHint = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }
          message.preview = Preview.decode(reader, reader.uint32());
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.pwls = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.removedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }
          message.reportReasons.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 85:
          if (tag !== 682) {
            break;
          }
          message.score = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 86:
          if (tag !== 690) {
            break;
          }
          message.secureMediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }
          message.secureMedia = Media.decode(reader, reader.uint32());
          continue;
        case 88:
          if (tag !== 706) {
            break;
          }
          message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 89:
          if (tag !== 714) {
            break;
          }
          message.selftext = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 92:
          if (tag !== 738) {
            break;
          }
          message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 94:
          if (tag !== 754) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 95:
          if (tag !== 762) {
            break;
          }
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }
          message.subredditSubscribers = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }
          message.suggestedSort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.totalAwardsReceived = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.treatmentTags.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }
          message.ups = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }
          message.upvoteRatio = FloatValue.decode(reader, reader.uint32()).value;
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }
          message.urlOverriddenByDest = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }
          message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 112:
          if (tag !== 898) {
            break;
          }
          message.viewCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }
          message.visited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 114:
          if (tag !== 914) {
            break;
          }
          message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 115:
          if (tag !== 922) {
            break;
          }
          message.wls = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 150:
          if (tag !== 1202) {
            break;
          }
          message.linkFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 151:
          if (tag !== 1210) {
            break;
          }
          message.crowdControlLevel = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 152:
          if (tag !== 1218) {
            break;
          }
          message.isGallery = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 153:
          if (tag !== 1226) {
            break;
          }
          message.isLiveStream = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 154:
          if (tag !== 1234) {
            break;
          }
          message.isMetaDiscussion = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 155:
          if (tag !== 1242) {
            break;
          }
          message.oembed = OEmbed.decode(reader, reader.uint32());
          continue;
        case 156:
          if (tag !== 1250) {
            break;
          }
          message.banInfo = BanInfo.decode(reader, reader.uint32());
          continue;
        case 157:
          if (tag !== 1258) {
            break;
          }
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 158:
          if (tag !== 1266) {
            break;
          }
          message.verdict = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 159:
          if (tag !== 1274) {
            break;
          }
          message.gallery = RedditPostGallery.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allAwardings: globalThis.Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Awarding.fromJSON(e)) : [],
      allowLiveComments: isSet19(object.allowLiveComments) ? Boolean(object.allowLiveComments) : void 0,
      approved: isSet19(object.approved) ? Boolean(object.approved) : void 0,
      approvedAtUtc: isSet19(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      approvedBy: isSet19(object.approvedBy) ? String(object.approvedBy) : void 0,
      archived: isSet19(object.archived) ? Boolean(object.archived) : void 0,
      author: isSet19(object.author) ? String(object.author) : void 0,
      authorFlairBackgroundColor: isSet19(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      authorFlairCssClass: isSet19(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      authorFlairRichtext: globalThis.Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
      authorFlairTemplateId: isSet19(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      authorFlairText: isSet19(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      authorFlairTextColor: isSet19(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      authorFlairType: isSet19(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      authorFullname: isSet19(object.authorFullname) ? String(object.authorFullname) : void 0,
      authorIsBlocked: isSet19(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      authorPatreonFlair: isSet19(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      authorPremium: isSet19(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      awarders: globalThis.Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      bannedAtUtc: isSet19(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      bannedBy: isSet19(object.bannedBy) ? String(object.bannedBy) : void 0,
      canGild: isSet19(object.canGild) ? Boolean(object.canGild) : void 0,
      canModPost: isSet19(object.canModPost) ? Boolean(object.canModPost) : void 0,
      category: isSet19(object.category) ? String(object.category) : void 0,
      clicked: isSet19(object.clicked) ? Boolean(object.clicked) : void 0,
      contentCategories: globalThis.Array.isArray(object?.contentCategories) ? object.contentCategories.map((e) => String(e)) : [],
      contestMode: isSet19(object.contestMode) ? Boolean(object.contestMode) : void 0,
      created: isSet19(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet19(object.createdUtc) ? Number(object.createdUtc) : void 0,
      discussionType: isSet19(object.discussionType) ? String(object.discussionType) : void 0,
      distinguished: isSet19(object.distinguished) ? String(object.distinguished) : void 0,
      domain: isSet19(object.domain) ? String(object.domain) : void 0,
      downs: isSet19(object.downs) ? Number(object.downs) : void 0,
      edited: isSet19(object.edited) ? Boolean(object.edited) : void 0,
      gilded: isSet19(object.gilded) ? Number(object.gilded) : void 0,
      gildings: isSet19(object.gildings) ? Gildings.fromJSON(object.gildings) : void 0,
      hidden: isSet19(object.hidden) ? Boolean(object.hidden) : void 0,
      hideScore: isSet19(object.hideScore) ? Boolean(object.hideScore) : void 0,
      id: isSet19(object.id) ? String(object.id) : void 0,
      ignoreReports: isSet19(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      isCreatedFromAdsUi: isSet19(object.isCreatedFromAdsUi) ? Boolean(object.isCreatedFromAdsUi) : void 0,
      isCrosspostable: isSet19(object.isCrosspostable) ? Boolean(object.isCrosspostable) : void 0,
      isMeta: isSet19(object.isMeta) ? Boolean(object.isMeta) : void 0,
      isOriginalContent: isSet19(object.isOriginalContent) ? Boolean(object.isOriginalContent) : void 0,
      isRedditMediaDomain: isSet19(object.isRedditMediaDomain) ? Boolean(object.isRedditMediaDomain) : void 0,
      isRobotIndexable: isSet19(object.isRobotIndexable) ? Boolean(object.isRobotIndexable) : void 0,
      isSelf: isSet19(object.isSelf) ? Boolean(object.isSelf) : void 0,
      isVideo: isSet19(object.isVideo) ? Boolean(object.isVideo) : void 0,
      likes: isSet19(object.likes) ? Boolean(object.likes) : void 0,
      linkFlairBackgroundColor: isSet19(object.linkFlairBackgroundColor) ? String(object.linkFlairBackgroundColor) : void 0,
      linkFlairCssClass: isSet19(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : void 0,
      linkFlairRichtext: globalThis.Array.isArray(object?.linkFlairRichtext) ? object.linkFlairRichtext.map((e) => String(e)) : [],
      linkFlairTextColor: isSet19(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : void 0,
      linkFlairText: isSet19(object.linkFlairText) ? String(object.linkFlairText) : void 0,
      linkFlairType: isSet19(object.linkFlairType) ? String(object.linkFlairType) : void 0,
      locked: isSet19(object.locked) ? Boolean(object.locked) : void 0,
      mediaEmbed: isSet19(object.mediaEmbed) ? MediaEmbed.fromJSON(object.mediaEmbed) : void 0,
      mediaOnly: isSet19(object.mediaOnly) ? Boolean(object.mediaOnly) : void 0,
      media: isSet19(object.media) ? Media.fromJSON(object.media) : void 0,
      modNote: isSet19(object.modNote) ? String(object.modNote) : void 0,
      modReasonBy: isSet19(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      modReasonTitle: isSet19(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      modReports: globalThis.Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
      name: isSet19(object.name) ? String(object.name) : void 0,
      noFollow: isSet19(object.noFollow) ? Boolean(object.noFollow) : void 0,
      numComments: isSet19(object.numComments) ? Number(object.numComments) : void 0,
      numCrossposts: isSet19(object.numCrossposts) ? Number(object.numCrossposts) : void 0,
      numDuplicates: isSet19(object.numDuplicates) ? Number(object.numDuplicates) : void 0,
      numReports: isSet19(object.numReports) ? Number(object.numReports) : void 0,
      over18: isSet19(object.over18) ? Boolean(object.over18) : void 0,
      parentWhitelistStatus: isSet19(object.parentWhitelistStatus) ? String(object.parentWhitelistStatus) : void 0,
      permalink: isSet19(object.permalink) ? String(object.permalink) : void 0,
      pinned: isSet19(object.pinned) ? Boolean(object.pinned) : void 0,
      postHint: isSet19(object.postHint) ? String(object.postHint) : void 0,
      preview: isSet19(object.preview) ? Preview.fromJSON(object.preview) : void 0,
      pwls: isSet19(object.pwls) ? Number(object.pwls) : void 0,
      quarantine: isSet19(object.quarantine) ? Boolean(object.quarantine) : void 0,
      removalReason: isSet19(object.removalReason) ? String(object.removalReason) : void 0,
      removedByCategory: isSet19(object.removedByCategory) ? String(object.removedByCategory) : void 0,
      removedBy: isSet19(object.removedBy) ? String(object.removedBy) : void 0,
      removed: isSet19(object.removed) ? Boolean(object.removed) : void 0,
      reportReasons: globalThis.Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => String(e)) : [],
      rteMode: isSet19(object.rteMode) ? String(object.rteMode) : void 0,
      saved: isSet19(object.saved) ? Boolean(object.saved) : void 0,
      score: isSet19(object.score) ? Number(object.score) : void 0,
      secureMediaEmbed: isSet19(object.secureMediaEmbed) ? MediaEmbed.fromJSON(object.secureMediaEmbed) : void 0,
      secureMedia: isSet19(object.secureMedia) ? Media.fromJSON(object.secureMedia) : void 0,
      selftextHtml: isSet19(object.selftextHtml) ? String(object.selftextHtml) : void 0,
      selftext: isSet19(object.selftext) ? String(object.selftext) : void 0,
      sendReplies: isSet19(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      spam: isSet19(object.spam) ? Boolean(object.spam) : void 0,
      spoiler: isSet19(object.spoiler) ? Boolean(object.spoiler) : void 0,
      stickied: isSet19(object.stickied) ? Boolean(object.stickied) : void 0,
      subredditId: isSet19(object.subredditId) ? String(object.subredditId) : void 0,
      subredditNamePrefixed: isSet19(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      subredditSubscribers: isSet19(object.subredditSubscribers) ? Number(object.subredditSubscribers) : void 0,
      subredditType: isSet19(object.subredditType) ? String(object.subredditType) : void 0,
      subreddit: isSet19(object.subreddit) ? String(object.subreddit) : void 0,
      suggestedSort: isSet19(object.suggestedSort) ? String(object.suggestedSort) : void 0,
      thumbnailHeight: isSet19(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      thumbnailWidth: isSet19(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      thumbnail: isSet19(object.thumbnail) ? String(object.thumbnail) : void 0,
      title: isSet19(object.title) ? String(object.title) : void 0,
      topAwardedType: isSet19(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      totalAwardsReceived: isSet19(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      treatmentTags: globalThis.Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => String(e)) : [],
      ups: isSet19(object.ups) ? Number(object.ups) : void 0,
      upvoteRatio: isSet19(object.upvoteRatio) ? Number(object.upvoteRatio) : void 0,
      urlOverriddenByDest: isSet19(object.urlOverriddenByDest) ? String(object.urlOverriddenByDest) : void 0,
      url: isSet19(object.url) ? String(object.url) : void 0,
      userReports: globalThis.Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
      viewCount: isSet19(object.viewCount) ? Number(object.viewCount) : void 0,
      visited: isSet19(object.visited) ? Boolean(object.visited) : void 0,
      whitelistStatus: isSet19(object.whitelistStatus) ? String(object.whitelistStatus) : void 0,
      wls: isSet19(object.wls) ? Number(object.wls) : void 0,
      linkFlairTemplateId: isSet19(object.linkFlairTemplateId) ? String(object.linkFlairTemplateId) : void 0,
      crowdControlLevel: isSet19(object.crowdControlLevel) ? Number(object.crowdControlLevel) : void 0,
      isGallery: isSet19(object.isGallery) ? Boolean(object.isGallery) : void 0,
      isLiveStream: isSet19(object.isLiveStream) ? Boolean(object.isLiveStream) : void 0,
      isMetaDiscussion: isSet19(object.isMetaDiscussion) ? Boolean(object.isMetaDiscussion) : void 0,
      oembed: isSet19(object.oembed) ? OEmbed.fromJSON(object.oembed) : void 0,
      banInfo: isSet19(object.banInfo) ? BanInfo.fromJSON(object.banInfo) : void 0,
      markedSpam: isSet19(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      verdict: isSet19(object.verdict) ? String(object.verdict) : void 0,
      gallery: isSet19(object.gallery) ? RedditPostGallery.fromJSON(object.gallery) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allAwardings?.length) {
      obj.allAwardings = message.allAwardings.map((e) => Awarding.toJSON(e));
    }
    if (message.allowLiveComments !== void 0) {
      obj.allowLiveComments = message.allowLiveComments;
    }
    if (message.approved !== void 0) {
      obj.approved = message.approved;
    }
    if (message.approvedAtUtc !== void 0) {
      obj.approvedAtUtc = message.approvedAtUtc;
    }
    if (message.approvedBy !== void 0) {
      obj.approvedBy = message.approvedBy;
    }
    if (message.archived !== void 0) {
      obj.archived = message.archived;
    }
    if (message.author !== void 0) {
      obj.author = message.author;
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor;
    }
    if (message.authorFlairCssClass !== void 0) {
      obj.authorFlairCssClass = message.authorFlairCssClass;
    }
    if (message.authorFlairRichtext?.length) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => AuthorFlairRichText.toJSON(e));
    }
    if (message.authorFlairTemplateId !== void 0) {
      obj.authorFlairTemplateId = message.authorFlairTemplateId;
    }
    if (message.authorFlairText !== void 0) {
      obj.authorFlairText = message.authorFlairText;
    }
    if (message.authorFlairTextColor !== void 0) {
      obj.authorFlairTextColor = message.authorFlairTextColor;
    }
    if (message.authorFlairType !== void 0) {
      obj.authorFlairType = message.authorFlairType;
    }
    if (message.authorFullname !== void 0) {
      obj.authorFullname = message.authorFullname;
    }
    if (message.authorIsBlocked !== void 0) {
      obj.authorIsBlocked = message.authorIsBlocked;
    }
    if (message.authorPatreonFlair !== void 0) {
      obj.authorPatreonFlair = message.authorPatreonFlair;
    }
    if (message.authorPremium !== void 0) {
      obj.authorPremium = message.authorPremium;
    }
    if (message.awarders?.length) {
      obj.awarders = message.awarders;
    }
    if (message.bannedAtUtc !== void 0) {
      obj.bannedAtUtc = message.bannedAtUtc;
    }
    if (message.bannedBy !== void 0) {
      obj.bannedBy = message.bannedBy;
    }
    if (message.canGild !== void 0) {
      obj.canGild = message.canGild;
    }
    if (message.canModPost !== void 0) {
      obj.canModPost = message.canModPost;
    }
    if (message.category !== void 0) {
      obj.category = message.category;
    }
    if (message.clicked !== void 0) {
      obj.clicked = message.clicked;
    }
    if (message.contentCategories?.length) {
      obj.contentCategories = message.contentCategories;
    }
    if (message.contestMode !== void 0) {
      obj.contestMode = message.contestMode;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.discussionType !== void 0) {
      obj.discussionType = message.discussionType;
    }
    if (message.distinguished !== void 0) {
      obj.distinguished = message.distinguished;
    }
    if (message.domain !== void 0) {
      obj.domain = message.domain;
    }
    if (message.downs !== void 0) {
      obj.downs = message.downs;
    }
    if (message.edited !== void 0) {
      obj.edited = message.edited;
    }
    if (message.gilded !== void 0) {
      obj.gilded = message.gilded;
    }
    if (message.gildings !== void 0) {
      obj.gildings = Gildings.toJSON(message.gildings);
    }
    if (message.hidden !== void 0) {
      obj.hidden = message.hidden;
    }
    if (message.hideScore !== void 0) {
      obj.hideScore = message.hideScore;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.ignoreReports !== void 0) {
      obj.ignoreReports = message.ignoreReports;
    }
    if (message.isCreatedFromAdsUi !== void 0) {
      obj.isCreatedFromAdsUi = message.isCreatedFromAdsUi;
    }
    if (message.isCrosspostable !== void 0) {
      obj.isCrosspostable = message.isCrosspostable;
    }
    if (message.isMeta !== void 0) {
      obj.isMeta = message.isMeta;
    }
    if (message.isOriginalContent !== void 0) {
      obj.isOriginalContent = message.isOriginalContent;
    }
    if (message.isRedditMediaDomain !== void 0) {
      obj.isRedditMediaDomain = message.isRedditMediaDomain;
    }
    if (message.isRobotIndexable !== void 0) {
      obj.isRobotIndexable = message.isRobotIndexable;
    }
    if (message.isSelf !== void 0) {
      obj.isSelf = message.isSelf;
    }
    if (message.isVideo !== void 0) {
      obj.isVideo = message.isVideo;
    }
    if (message.likes !== void 0) {
      obj.likes = message.likes;
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor;
    }
    if (message.linkFlairCssClass !== void 0) {
      obj.linkFlairCssClass = message.linkFlairCssClass;
    }
    if (message.linkFlairRichtext?.length) {
      obj.linkFlairRichtext = message.linkFlairRichtext;
    }
    if (message.linkFlairTextColor !== void 0) {
      obj.linkFlairTextColor = message.linkFlairTextColor;
    }
    if (message.linkFlairText !== void 0) {
      obj.linkFlairText = message.linkFlairText;
    }
    if (message.linkFlairType !== void 0) {
      obj.linkFlairType = message.linkFlairType;
    }
    if (message.locked !== void 0) {
      obj.locked = message.locked;
    }
    if (message.mediaEmbed !== void 0) {
      obj.mediaEmbed = MediaEmbed.toJSON(message.mediaEmbed);
    }
    if (message.mediaOnly !== void 0) {
      obj.mediaOnly = message.mediaOnly;
    }
    if (message.media !== void 0) {
      obj.media = Media.toJSON(message.media);
    }
    if (message.modNote !== void 0) {
      obj.modNote = message.modNote;
    }
    if (message.modReasonBy !== void 0) {
      obj.modReasonBy = message.modReasonBy;
    }
    if (message.modReasonTitle !== void 0) {
      obj.modReasonTitle = message.modReasonTitle;
    }
    if (message.modReports?.length) {
      obj.modReports = message.modReports;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.noFollow !== void 0) {
      obj.noFollow = message.noFollow;
    }
    if (message.numComments !== void 0) {
      obj.numComments = message.numComments;
    }
    if (message.numCrossposts !== void 0) {
      obj.numCrossposts = message.numCrossposts;
    }
    if (message.numDuplicates !== void 0) {
      obj.numDuplicates = message.numDuplicates;
    }
    if (message.numReports !== void 0) {
      obj.numReports = message.numReports;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.parentWhitelistStatus !== void 0) {
      obj.parentWhitelistStatus = message.parentWhitelistStatus;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.pinned !== void 0) {
      obj.pinned = message.pinned;
    }
    if (message.postHint !== void 0) {
      obj.postHint = message.postHint;
    }
    if (message.preview !== void 0) {
      obj.preview = Preview.toJSON(message.preview);
    }
    if (message.pwls !== void 0) {
      obj.pwls = message.pwls;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.removalReason !== void 0) {
      obj.removalReason = message.removalReason;
    }
    if (message.removedByCategory !== void 0) {
      obj.removedByCategory = message.removedByCategory;
    }
    if (message.removedBy !== void 0) {
      obj.removedBy = message.removedBy;
    }
    if (message.removed !== void 0) {
      obj.removed = message.removed;
    }
    if (message.reportReasons?.length) {
      obj.reportReasons = message.reportReasons;
    }
    if (message.rteMode !== void 0) {
      obj.rteMode = message.rteMode;
    }
    if (message.saved !== void 0) {
      obj.saved = message.saved;
    }
    if (message.score !== void 0) {
      obj.score = message.score;
    }
    if (message.secureMediaEmbed !== void 0) {
      obj.secureMediaEmbed = MediaEmbed.toJSON(message.secureMediaEmbed);
    }
    if (message.secureMedia !== void 0) {
      obj.secureMedia = Media.toJSON(message.secureMedia);
    }
    if (message.selftextHtml !== void 0) {
      obj.selftextHtml = message.selftextHtml;
    }
    if (message.selftext !== void 0) {
      obj.selftext = message.selftext;
    }
    if (message.sendReplies !== void 0) {
      obj.sendReplies = message.sendReplies;
    }
    if (message.spam !== void 0) {
      obj.spam = message.spam;
    }
    if (message.spoiler !== void 0) {
      obj.spoiler = message.spoiler;
    }
    if (message.stickied !== void 0) {
      obj.stickied = message.stickied;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.subredditNamePrefixed !== void 0) {
      obj.subredditNamePrefixed = message.subredditNamePrefixed;
    }
    if (message.subredditSubscribers !== void 0) {
      obj.subredditSubscribers = message.subredditSubscribers;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.suggestedSort !== void 0) {
      obj.suggestedSort = message.suggestedSort;
    }
    if (message.thumbnailHeight !== void 0) {
      obj.thumbnailHeight = message.thumbnailHeight;
    }
    if (message.thumbnailWidth !== void 0) {
      obj.thumbnailWidth = message.thumbnailWidth;
    }
    if (message.thumbnail !== void 0) {
      obj.thumbnail = message.thumbnail;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.topAwardedType !== void 0) {
      obj.topAwardedType = message.topAwardedType;
    }
    if (message.totalAwardsReceived !== void 0) {
      obj.totalAwardsReceived = message.totalAwardsReceived;
    }
    if (message.treatmentTags?.length) {
      obj.treatmentTags = message.treatmentTags;
    }
    if (message.ups !== void 0) {
      obj.ups = message.ups;
    }
    if (message.upvoteRatio !== void 0) {
      obj.upvoteRatio = message.upvoteRatio;
    }
    if (message.urlOverriddenByDest !== void 0) {
      obj.urlOverriddenByDest = message.urlOverriddenByDest;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.userReports?.length) {
      obj.userReports = message.userReports;
    }
    if (message.viewCount !== void 0) {
      obj.viewCount = message.viewCount;
    }
    if (message.visited !== void 0) {
      obj.visited = message.visited;
    }
    if (message.whitelistStatus !== void 0) {
      obj.whitelistStatus = message.whitelistStatus;
    }
    if (message.wls !== void 0) {
      obj.wls = message.wls;
    }
    if (message.linkFlairTemplateId !== void 0) {
      obj.linkFlairTemplateId = message.linkFlairTemplateId;
    }
    if (message.crowdControlLevel !== void 0) {
      obj.crowdControlLevel = message.crowdControlLevel;
    }
    if (message.isGallery !== void 0) {
      obj.isGallery = message.isGallery;
    }
    if (message.isLiveStream !== void 0) {
      obj.isLiveStream = message.isLiveStream;
    }
    if (message.isMetaDiscussion !== void 0) {
      obj.isMetaDiscussion = message.isMetaDiscussion;
    }
    if (message.oembed !== void 0) {
      obj.oembed = OEmbed.toJSON(message.oembed);
    }
    if (message.banInfo !== void 0) {
      obj.banInfo = BanInfo.toJSON(message.banInfo);
    }
    if (message.markedSpam !== void 0) {
      obj.markedSpam = message.markedSpam;
    }
    if (message.verdict !== void 0) {
      obj.verdict = message.verdict;
    }
    if (message.gallery !== void 0) {
      obj.gallery = RedditPostGallery.toJSON(message.gallery);
    }
    return obj;
  },
  create(base) {
    return Post.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePost();
    message.allAwardings = object.allAwardings?.map((e) => Awarding.fromPartial(e)) || [];
    message.allowLiveComments = object.allowLiveComments ?? void 0;
    message.approved = object.approved ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.archived = object.archived ?? void 0;
    message.author = object.author ?? void 0;
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.awarders = object.awarders?.map((e) => e) || [];
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.category = object.category ?? void 0;
    message.clicked = object.clicked ?? void 0;
    message.contentCategories = object.contentCategories?.map((e) => e) || [];
    message.contestMode = object.contestMode ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.discussionType = object.discussionType ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.domain = object.domain ?? void 0;
    message.downs = object.downs ?? void 0;
    message.edited = object.edited ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Gildings.fromPartial(object.gildings) : void 0;
    message.hidden = object.hidden ?? void 0;
    message.hideScore = object.hideScore ?? void 0;
    message.id = object.id ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.isCreatedFromAdsUi = object.isCreatedFromAdsUi ?? void 0;
    message.isCrosspostable = object.isCrosspostable ?? void 0;
    message.isMeta = object.isMeta ?? void 0;
    message.isOriginalContent = object.isOriginalContent ?? void 0;
    message.isRedditMediaDomain = object.isRedditMediaDomain ?? void 0;
    message.isRobotIndexable = object.isRobotIndexable ?? void 0;
    message.isSelf = object.isSelf ?? void 0;
    message.isVideo = object.isVideo ?? void 0;
    message.likes = object.likes ?? void 0;
    message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? void 0;
    message.linkFlairCssClass = object.linkFlairCssClass ?? void 0;
    message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => e) || [];
    message.linkFlairTextColor = object.linkFlairTextColor ?? void 0;
    message.linkFlairText = object.linkFlairText ?? void 0;
    message.linkFlairType = object.linkFlairType ?? void 0;
    message.locked = object.locked ?? void 0;
    message.mediaEmbed = object.mediaEmbed !== void 0 && object.mediaEmbed !== null ? MediaEmbed.fromPartial(object.mediaEmbed) : void 0;
    message.mediaOnly = object.mediaOnly ?? void 0;
    message.media = object.media !== void 0 && object.media !== null ? Media.fromPartial(object.media) : void 0;
    message.modNote = object.modNote ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.modReports = object.modReports?.map((e) => e) || [];
    message.name = object.name ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.numComments = object.numComments ?? void 0;
    message.numCrossposts = object.numCrossposts ?? void 0;
    message.numDuplicates = object.numDuplicates ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.parentWhitelistStatus = object.parentWhitelistStatus ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.pinned = object.pinned ?? void 0;
    message.postHint = object.postHint ?? void 0;
    message.preview = object.preview !== void 0 && object.preview !== null ? Preview.fromPartial(object.preview) : void 0;
    message.pwls = object.pwls ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.removedByCategory = object.removedByCategory ?? void 0;
    message.removedBy = object.removedBy ?? void 0;
    message.removed = object.removed ?? void 0;
    message.reportReasons = object.reportReasons?.map((e) => e) || [];
    message.rteMode = object.rteMode ?? void 0;
    message.saved = object.saved ?? void 0;
    message.score = object.score ?? void 0;
    message.secureMediaEmbed = object.secureMediaEmbed !== void 0 && object.secureMediaEmbed !== null ? MediaEmbed.fromPartial(object.secureMediaEmbed) : void 0;
    message.secureMedia = object.secureMedia !== void 0 && object.secureMedia !== null ? Media.fromPartial(object.secureMedia) : void 0;
    message.selftextHtml = object.selftextHtml ?? void 0;
    message.selftext = object.selftext ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.spam = object.spam ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.subredditSubscribers = object.subredditSubscribers ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.suggestedSort = object.suggestedSort ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.thumbnail = object.thumbnail ?? void 0;
    message.title = object.title ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => e) || [];
    message.ups = object.ups ?? void 0;
    message.upvoteRatio = object.upvoteRatio ?? void 0;
    message.urlOverriddenByDest = object.urlOverriddenByDest ?? void 0;
    message.url = object.url ?? void 0;
    message.userReports = object.userReports?.map((e) => e) || [];
    message.viewCount = object.viewCount ?? void 0;
    message.visited = object.visited ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.wls = object.wls ?? void 0;
    message.linkFlairTemplateId = object.linkFlairTemplateId ?? void 0;
    message.crowdControlLevel = object.crowdControlLevel ?? void 0;
    message.isGallery = object.isGallery ?? void 0;
    message.isLiveStream = object.isLiveStream ?? void 0;
    message.isMetaDiscussion = object.isMetaDiscussion ?? void 0;
    message.oembed = object.oembed !== void 0 && object.oembed !== null ? OEmbed.fromPartial(object.oembed) : void 0;
    message.banInfo = object.banInfo !== void 0 && object.banInfo !== null ? BanInfo.fromPartial(object.banInfo) : void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.verdict = object.verdict ?? void 0;
    message.gallery = object.gallery !== void 0 && object.gallery !== null ? RedditPostGallery.fromPartial(object.gallery) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Post.$type, Post);
function createBaseMedia() {
  return { redditVideo: void 0 };
}
var Media = {
  $type: "devvit.reddit.Media",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.redditVideo !== void 0) {
      Media_RedditVideo.encode(message.redditVideo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMedia();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.redditVideo = Media_RedditVideo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { redditVideo: isSet19(object.redditVideo) ? Media_RedditVideo.fromJSON(object.redditVideo) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.redditVideo !== void 0) {
      obj.redditVideo = Media_RedditVideo.toJSON(message.redditVideo);
    }
    return obj;
  },
  create(base) {
    return Media.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMedia();
    message.redditVideo = object.redditVideo !== void 0 && object.redditVideo !== null ? Media_RedditVideo.fromPartial(object.redditVideo) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Media.$type, Media);
function createBaseMedia_RedditVideo() {
  return {
    bitrateKbps: void 0,
    dashUrl: void 0,
    duration: void 0,
    fallbackUrl: void 0,
    height: void 0,
    hlsUrl: void 0,
    isGif: void 0,
    scrubberMediaUrl: void 0,
    transcodingStatus: void 0,
    width: void 0
  };
}
var Media_RedditVideo = {
  $type: "devvit.reddit.Media.RedditVideo",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.bitrateKbps !== void 0) {
      Int32Value.encode({ value: message.bitrateKbps }, writer.uint32(10).fork()).ldelim();
    }
    if (message.dashUrl !== void 0) {
      StringValue.encode({ value: message.dashUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.duration !== void 0) {
      Int32Value.encode({ value: message.duration }, writer.uint32(26).fork()).ldelim();
    }
    if (message.fallbackUrl !== void 0) {
      StringValue.encode({ value: message.fallbackUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(42).fork()).ldelim();
    }
    if (message.hlsUrl !== void 0) {
      StringValue.encode({ value: message.hlsUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isGif !== void 0) {
      BoolValue.encode({ value: message.isGif }, writer.uint32(58).fork()).ldelim();
    }
    if (message.scrubberMediaUrl !== void 0) {
      StringValue.encode({ value: message.scrubberMediaUrl }, writer.uint32(66).fork()).ldelim();
    }
    if (message.transcodingStatus !== void 0) {
      StringValue.encode({ value: message.transcodingStatus }, writer.uint32(74).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMedia_RedditVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bitrateKbps = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dashUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.duration = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.fallbackUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.hlsUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.isGif = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.scrubberMediaUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.transcodingStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bitrateKbps: isSet19(object.bitrateKbps) ? Number(object.bitrateKbps) : void 0,
      dashUrl: isSet19(object.dashUrl) ? String(object.dashUrl) : void 0,
      duration: isSet19(object.duration) ? Number(object.duration) : void 0,
      fallbackUrl: isSet19(object.fallbackUrl) ? String(object.fallbackUrl) : void 0,
      height: isSet19(object.height) ? Number(object.height) : void 0,
      hlsUrl: isSet19(object.hlsUrl) ? String(object.hlsUrl) : void 0,
      isGif: isSet19(object.isGif) ? Boolean(object.isGif) : void 0,
      scrubberMediaUrl: isSet19(object.scrubberMediaUrl) ? String(object.scrubberMediaUrl) : void 0,
      transcodingStatus: isSet19(object.transcodingStatus) ? String(object.transcodingStatus) : void 0,
      width: isSet19(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bitrateKbps !== void 0) {
      obj.bitrateKbps = message.bitrateKbps;
    }
    if (message.dashUrl !== void 0) {
      obj.dashUrl = message.dashUrl;
    }
    if (message.duration !== void 0) {
      obj.duration = message.duration;
    }
    if (message.fallbackUrl !== void 0) {
      obj.fallbackUrl = message.fallbackUrl;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.hlsUrl !== void 0) {
      obj.hlsUrl = message.hlsUrl;
    }
    if (message.isGif !== void 0) {
      obj.isGif = message.isGif;
    }
    if (message.scrubberMediaUrl !== void 0) {
      obj.scrubberMediaUrl = message.scrubberMediaUrl;
    }
    if (message.transcodingStatus !== void 0) {
      obj.transcodingStatus = message.transcodingStatus;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    return obj;
  },
  create(base) {
    return Media_RedditVideo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMedia_RedditVideo();
    message.bitrateKbps = object.bitrateKbps ?? void 0;
    message.dashUrl = object.dashUrl ?? void 0;
    message.duration = object.duration ?? void 0;
    message.fallbackUrl = object.fallbackUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.hlsUrl = object.hlsUrl ?? void 0;
    message.isGif = object.isGif ?? void 0;
    message.scrubberMediaUrl = object.scrubberMediaUrl ?? void 0;
    message.transcodingStatus = object.transcodingStatus ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Media_RedditVideo.$type, Media_RedditVideo);
function createBasePreview() {
  return { enabled: void 0, images: [] };
}
var Preview = {
  $type: "devvit.reddit.Preview",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.enabled !== void 0) {
      BoolValue.encode({ value: message.enabled }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.images) {
      Preview_PreviewImage.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.images.push(Preview_PreviewImage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      enabled: isSet19(object.enabled) ? Boolean(object.enabled) : void 0,
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e) => Preview_PreviewImage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.enabled !== void 0) {
      obj.enabled = message.enabled;
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Preview_PreviewImage.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Preview.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePreview();
    message.enabled = object.enabled ?? void 0;
    message.images = object.images?.map((e) => Preview_PreviewImage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(Preview.$type, Preview);
function createBasePreview_PreviewImage() {
  return { id: void 0, resolutions: [], source: void 0, variants: void 0 };
}
var Preview_PreviewImage = {
  $type: "devvit.reddit.Preview.PreviewImage",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.resolutions) {
      Preview_PreviewImage_Image.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.source !== void 0) {
      Preview_PreviewImage_Image.encode(message.source, writer.uint32(26).fork()).ldelim();
    }
    if (message.variants !== void 0) {
      Preview_PreviewImage_Image.encode(message.variants, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview_PreviewImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.resolutions.push(Preview_PreviewImage_Image.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.source = Preview_PreviewImage_Image.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.variants = Preview_PreviewImage_Image.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet19(object.id) ? String(object.id) : void 0,
      resolutions: globalThis.Array.isArray(object?.resolutions) ? object.resolutions.map((e) => Preview_PreviewImage_Image.fromJSON(e)) : [],
      source: isSet19(object.source) ? Preview_PreviewImage_Image.fromJSON(object.source) : void 0,
      variants: isSet19(object.variants) ? Preview_PreviewImage_Image.fromJSON(object.variants) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.resolutions?.length) {
      obj.resolutions = message.resolutions.map((e) => Preview_PreviewImage_Image.toJSON(e));
    }
    if (message.source !== void 0) {
      obj.source = Preview_PreviewImage_Image.toJSON(message.source);
    }
    if (message.variants !== void 0) {
      obj.variants = Preview_PreviewImage_Image.toJSON(message.variants);
    }
    return obj;
  },
  create(base) {
    return Preview_PreviewImage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePreview_PreviewImage();
    message.id = object.id ?? void 0;
    message.resolutions = object.resolutions?.map((e) => Preview_PreviewImage_Image.fromPartial(e)) || [];
    message.source = object.source !== void 0 && object.source !== null ? Preview_PreviewImage_Image.fromPartial(object.source) : void 0;
    message.variants = object.variants !== void 0 && object.variants !== null ? Preview_PreviewImage_Image.fromPartial(object.variants) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Preview_PreviewImage.$type, Preview_PreviewImage);
function createBasePreview_PreviewImage_Image() {
  return { height: void 0, url: void 0, width: void 0 };
}
var Preview_PreviewImage_Image = {
  $type: "devvit.reddit.Preview.PreviewImage.Image",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview_PreviewImage_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet19(object.height) ? Number(object.height) : void 0,
      url: isSet19(object.url) ? String(object.url) : void 0,
      width: isSet19(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    return obj;
  },
  create(base) {
    return Preview_PreviewImage_Image.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePreview_PreviewImage_Image();
    message.height = object.height ?? void 0;
    message.url = object.url ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Preview_PreviewImage_Image.$type, Preview_PreviewImage_Image);
function createBaseOEmbed() {
  return { authorName: void 0, authorUrl: void 0, description: void 0, title: void 0 };
}
var OEmbed = {
  $type: "devvit.reddit.OEmbed",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.authorName !== void 0) {
      StringValue.encode({ value: message.authorName }, writer.uint32(10).fork()).ldelim();
    }
    if (message.authorUrl !== void 0) {
      StringValue.encode({ value: message.authorUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.authorName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.authorUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorName: isSet19(object.authorName) ? String(object.authorName) : void 0,
      authorUrl: isSet19(object.authorUrl) ? String(object.authorUrl) : void 0,
      description: isSet19(object.description) ? String(object.description) : void 0,
      title: isSet19(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.authorName !== void 0) {
      obj.authorName = message.authorName;
    }
    if (message.authorUrl !== void 0) {
      obj.authorUrl = message.authorUrl;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return OEmbed.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOEmbed();
    message.authorName = object.authorName ?? void 0;
    message.authorUrl = object.authorUrl ?? void 0;
    message.description = object.description ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(OEmbed.$type, OEmbed);
function createBaseRedditPostGallery() {
  return { body: void 0, domain: void 0, url: void 0 };
}
var RedditPostGallery = {
  $type: "devvit.reddit.RedditPostGallery",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(18).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : import_minimal21.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditPostGallery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.body = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet19(object.body) ? String(object.body) : void 0,
      domain: isSet19(object.domain) ? String(object.domain) : void 0,
      url: isSet19(object.url) ? String(object.url) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.body !== void 0) {
      obj.body = message.body;
    }
    if (message.domain !== void 0) {
      obj.domain = message.domain;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return RedditPostGallery.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditPostGallery();
    message.body = object.body ?? void 0;
    message.domain = object.domain ?? void 0;
    message.url = object.url ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditPostGallery.$type, RedditPostGallery);
function isSet19(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/comment.js
var import_minimal22 = __toESM(require_minimal2(), 1);
function createBaseComment() {
  return {
    allAwardings: [],
    approved: void 0,
    approvedAtUtc: void 0,
    approvedBy: void 0,
    archived: void 0,
    associatedAward: void 0,
    author: void 0,
    authorFlairBackgroundColor: void 0,
    authorFlairCssClass: void 0,
    authorFlairRichtext: [],
    authorFlairTemplateId: void 0,
    authorFlairText: void 0,
    authorFlairTextColor: void 0,
    authorFlairType: void 0,
    authorFullname: void 0,
    authorIsBlocked: void 0,
    authorPatreonFlair: void 0,
    authorPremium: void 0,
    awarders: [],
    bannedAtUtc: void 0,
    bannedBy: void 0,
    body: void 0,
    bodyHtml: void 0,
    canGild: void 0,
    canModPost: void 0,
    collapsed: void 0,
    collapsedBecauseCrowdControl: void 0,
    collapsedReason: void 0,
    collapsedReasonCode: void 0,
    commentType: void 0,
    controversiality: void 0,
    created: void 0,
    createdUtc: void 0,
    depth: void 0,
    distinguished: void 0,
    downs: void 0,
    edited: void 0,
    gilded: void 0,
    gildings: void 0,
    id: void 0,
    ignoreReports: void 0,
    isSubmitter: void 0,
    likes: void 0,
    linkId: void 0,
    locked: void 0,
    modNote: void 0,
    modReasonBy: void 0,
    modReasonTitle: void 0,
    modReports: [],
    name: void 0,
    noFollow: void 0,
    numReports: void 0,
    parentId: void 0,
    permalink: void 0,
    removalReason: void 0,
    removed: void 0,
    replies: void 0,
    reportReasons: [],
    rteMode: void 0,
    saved: void 0,
    score: void 0,
    scoreHidden: void 0,
    sendReplies: void 0,
    spam: void 0,
    stickied: void 0,
    subreddit: void 0,
    subredditId: void 0,
    subredditNamePrefixed: void 0,
    subredditType: void 0,
    topAwardedType: void 0,
    totalAwardsReceived: void 0,
    treatmentTags: [],
    unrepliableReason: void 0,
    ups: void 0,
    userReports: [],
    count: void 0,
    children: [],
    banInfo: void 0,
    markedSpam: void 0,
    verdict: void 0
  };
}
var Comment = {
  $type: "devvit.reddit.Comment",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    for (const v of message.allAwardings) {
      Awarding.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(18).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(26).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(34).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(42).fork()).ldelim();
    }
    if (message.associatedAward !== void 0) {
      StringValue.encode({ value: message.associatedAward }, writer.uint32(50).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
    }
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(178).fork()).ldelim();
    }
    if (message.bodyHtml !== void 0) {
      StringValue.encode({ value: message.bodyHtml }, writer.uint32(186).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(194).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(202).fork()).ldelim();
    }
    if (message.collapsed !== void 0) {
      BoolValue.encode({ value: message.collapsed }, writer.uint32(210).fork()).ldelim();
    }
    if (message.collapsedBecauseCrowdControl !== void 0) {
      BoolValue.encode({ value: message.collapsedBecauseCrowdControl }, writer.uint32(218).fork()).ldelim();
    }
    if (message.collapsedReason !== void 0) {
      StringValue.encode({ value: message.collapsedReason }, writer.uint32(226).fork()).ldelim();
    }
    if (message.collapsedReasonCode !== void 0) {
      StringValue.encode({ value: message.collapsedReasonCode }, writer.uint32(234).fork()).ldelim();
    }
    if (message.commentType !== void 0) {
      StringValue.encode({ value: message.commentType }, writer.uint32(242).fork()).ldelim();
    }
    if (message.controversiality !== void 0) {
      Int32Value.encode({ value: message.controversiality }, writer.uint32(250).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(258).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(266).fork()).ldelim();
    }
    if (message.depth !== void 0) {
      Int32Value.encode({ value: message.depth }, writer.uint32(274).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(282).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int32Value.encode({ value: message.downs }, writer.uint32(290).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(298).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int32Value.encode({ value: message.gilded }, writer.uint32(306).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Gildings.encode(message.gildings, writer.uint32(314).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(322).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(330).fork()).ldelim();
    }
    if (message.isSubmitter !== void 0) {
      BoolValue.encode({ value: message.isSubmitter }, writer.uint32(338).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(346).fork()).ldelim();
    }
    if (message.linkId !== void 0) {
      StringValue.encode({ value: message.linkId }, writer.uint32(354).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(362).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(370).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(378).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(386).fork()).ldelim();
    }
    for (const v of message.modReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(394).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(402).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(410).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int32Value.encode({ value: message.numReports }, writer.uint32(418).fork()).ldelim();
    }
    if (message.parentId !== void 0) {
      StringValue.encode({ value: message.parentId }, writer.uint32(426).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(434).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(442).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(450).fork()).ldelim();
    }
    if (message.replies !== void 0) {
      StringValue.encode({ value: message.replies }, writer.uint32(458).fork()).ldelim();
    }
    for (const v of message.reportReasons) {
      StringValue.encode({ value: v }, writer.uint32(466).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(474).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(482).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int32Value.encode({ value: message.score }, writer.uint32(490).fork()).ldelim();
    }
    if (message.scoreHidden !== void 0) {
      BoolValue.encode({ value: message.scoreHidden }, writer.uint32(498).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(506).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(514).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(522).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(530).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(538).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(546).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(554).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(562).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int32Value.encode({ value: message.totalAwardsReceived }, writer.uint32(570).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      StringValue.encode({ value: v }, writer.uint32(578).fork()).ldelim();
    }
    if (message.unrepliableReason !== void 0) {
      StringValue.encode({ value: message.unrepliableReason }, writer.uint32(586).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int32Value.encode({ value: message.ups }, writer.uint32(594).fork()).ldelim();
    }
    for (const v of message.userReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(602).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int32Value.encode({ value: message.count }, writer.uint32(610).fork()).ldelim();
    }
    for (const v of message.children) {
      StringValue.encode({ value: v }, writer.uint32(618).fork()).ldelim();
    }
    if (message.banInfo !== void 0) {
      BanInfo.encode(message.banInfo, writer.uint32(626).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(634).fork()).ldelim();
    }
    if (message.verdict !== void 0) {
      StringValue.encode({ value: message.verdict }, writer.uint32(642).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : import_minimal22.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.allAwardings.push(Awarding.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.associatedAward = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.author = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.body = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.bodyHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.collapsed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.collapsedBecauseCrowdControl = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.collapsedReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.collapsedReasonCode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.commentType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.controversiality = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.depth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.downs = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.gilded = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.gildings = Gildings.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.isSubmitter = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.linkId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.numReports = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.parentId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.replies = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.reportReasons.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.score = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.scoreHidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.totalAwardsReceived = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.treatmentTags.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.unrepliableReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.ups = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }
          message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.count = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.children.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.banInfo = BanInfo.decode(reader, reader.uint32());
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.verdict = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allAwardings: globalThis.Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Awarding.fromJSON(e)) : [],
      approved: isSet20(object.approved) ? Boolean(object.approved) : void 0,
      approvedAtUtc: isSet20(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      approvedBy: isSet20(object.approvedBy) ? String(object.approvedBy) : void 0,
      archived: isSet20(object.archived) ? Boolean(object.archived) : void 0,
      associatedAward: isSet20(object.associatedAward) ? String(object.associatedAward) : void 0,
      author: isSet20(object.author) ? String(object.author) : void 0,
      authorFlairBackgroundColor: isSet20(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      authorFlairCssClass: isSet20(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      authorFlairRichtext: globalThis.Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
      authorFlairTemplateId: isSet20(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      authorFlairText: isSet20(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      authorFlairTextColor: isSet20(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      authorFlairType: isSet20(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      authorFullname: isSet20(object.authorFullname) ? String(object.authorFullname) : void 0,
      authorIsBlocked: isSet20(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      authorPatreonFlair: isSet20(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      authorPremium: isSet20(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      awarders: globalThis.Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      bannedAtUtc: isSet20(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      bannedBy: isSet20(object.bannedBy) ? String(object.bannedBy) : void 0,
      body: isSet20(object.body) ? String(object.body) : void 0,
      bodyHtml: isSet20(object.bodyHtml) ? String(object.bodyHtml) : void 0,
      canGild: isSet20(object.canGild) ? Boolean(object.canGild) : void 0,
      canModPost: isSet20(object.canModPost) ? Boolean(object.canModPost) : void 0,
      collapsed: isSet20(object.collapsed) ? Boolean(object.collapsed) : void 0,
      collapsedBecauseCrowdControl: isSet20(object.collapsedBecauseCrowdControl) ? Boolean(object.collapsedBecauseCrowdControl) : void 0,
      collapsedReason: isSet20(object.collapsedReason) ? String(object.collapsedReason) : void 0,
      collapsedReasonCode: isSet20(object.collapsedReasonCode) ? String(object.collapsedReasonCode) : void 0,
      commentType: isSet20(object.commentType) ? String(object.commentType) : void 0,
      controversiality: isSet20(object.controversiality) ? Number(object.controversiality) : void 0,
      created: isSet20(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet20(object.createdUtc) ? Number(object.createdUtc) : void 0,
      depth: isSet20(object.depth) ? Number(object.depth) : void 0,
      distinguished: isSet20(object.distinguished) ? String(object.distinguished) : void 0,
      downs: isSet20(object.downs) ? Number(object.downs) : void 0,
      edited: isSet20(object.edited) ? Boolean(object.edited) : void 0,
      gilded: isSet20(object.gilded) ? Number(object.gilded) : void 0,
      gildings: isSet20(object.gildings) ? Gildings.fromJSON(object.gildings) : void 0,
      id: isSet20(object.id) ? String(object.id) : void 0,
      ignoreReports: isSet20(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      isSubmitter: isSet20(object.isSubmitter) ? Boolean(object.isSubmitter) : void 0,
      likes: isSet20(object.likes) ? Boolean(object.likes) : void 0,
      linkId: isSet20(object.linkId) ? String(object.linkId) : void 0,
      locked: isSet20(object.locked) ? Boolean(object.locked) : void 0,
      modNote: isSet20(object.modNote) ? String(object.modNote) : void 0,
      modReasonBy: isSet20(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      modReasonTitle: isSet20(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      modReports: globalThis.Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
      name: isSet20(object.name) ? String(object.name) : void 0,
      noFollow: isSet20(object.noFollow) ? Boolean(object.noFollow) : void 0,
      numReports: isSet20(object.numReports) ? Number(object.numReports) : void 0,
      parentId: isSet20(object.parentId) ? String(object.parentId) : void 0,
      permalink: isSet20(object.permalink) ? String(object.permalink) : void 0,
      removalReason: isSet20(object.removalReason) ? String(object.removalReason) : void 0,
      removed: isSet20(object.removed) ? Boolean(object.removed) : void 0,
      replies: isSet20(object.replies) ? String(object.replies) : void 0,
      reportReasons: globalThis.Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => String(e)) : [],
      rteMode: isSet20(object.rteMode) ? String(object.rteMode) : void 0,
      saved: isSet20(object.saved) ? Boolean(object.saved) : void 0,
      score: isSet20(object.score) ? Number(object.score) : void 0,
      scoreHidden: isSet20(object.scoreHidden) ? Boolean(object.scoreHidden) : void 0,
      sendReplies: isSet20(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      spam: isSet20(object.spam) ? Boolean(object.spam) : void 0,
      stickied: isSet20(object.stickied) ? Boolean(object.stickied) : void 0,
      subreddit: isSet20(object.subreddit) ? String(object.subreddit) : void 0,
      subredditId: isSet20(object.subredditId) ? String(object.subredditId) : void 0,
      subredditNamePrefixed: isSet20(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      subredditType: isSet20(object.subredditType) ? String(object.subredditType) : void 0,
      topAwardedType: isSet20(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      totalAwardsReceived: isSet20(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      treatmentTags: globalThis.Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => String(e)) : [],
      unrepliableReason: isSet20(object.unrepliableReason) ? String(object.unrepliableReason) : void 0,
      ups: isSet20(object.ups) ? Number(object.ups) : void 0,
      userReports: globalThis.Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
      count: isSet20(object.count) ? Number(object.count) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => String(e)) : [],
      banInfo: isSet20(object.banInfo) ? BanInfo.fromJSON(object.banInfo) : void 0,
      markedSpam: isSet20(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      verdict: isSet20(object.verdict) ? String(object.verdict) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allAwardings?.length) {
      obj.allAwardings = message.allAwardings.map((e) => Awarding.toJSON(e));
    }
    if (message.approved !== void 0) {
      obj.approved = message.approved;
    }
    if (message.approvedAtUtc !== void 0) {
      obj.approvedAtUtc = message.approvedAtUtc;
    }
    if (message.approvedBy !== void 0) {
      obj.approvedBy = message.approvedBy;
    }
    if (message.archived !== void 0) {
      obj.archived = message.archived;
    }
    if (message.associatedAward !== void 0) {
      obj.associatedAward = message.associatedAward;
    }
    if (message.author !== void 0) {
      obj.author = message.author;
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor;
    }
    if (message.authorFlairCssClass !== void 0) {
      obj.authorFlairCssClass = message.authorFlairCssClass;
    }
    if (message.authorFlairRichtext?.length) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => AuthorFlairRichText.toJSON(e));
    }
    if (message.authorFlairTemplateId !== void 0) {
      obj.authorFlairTemplateId = message.authorFlairTemplateId;
    }
    if (message.authorFlairText !== void 0) {
      obj.authorFlairText = message.authorFlairText;
    }
    if (message.authorFlairTextColor !== void 0) {
      obj.authorFlairTextColor = message.authorFlairTextColor;
    }
    if (message.authorFlairType !== void 0) {
      obj.authorFlairType = message.authorFlairType;
    }
    if (message.authorFullname !== void 0) {
      obj.authorFullname = message.authorFullname;
    }
    if (message.authorIsBlocked !== void 0) {
      obj.authorIsBlocked = message.authorIsBlocked;
    }
    if (message.authorPatreonFlair !== void 0) {
      obj.authorPatreonFlair = message.authorPatreonFlair;
    }
    if (message.authorPremium !== void 0) {
      obj.authorPremium = message.authorPremium;
    }
    if (message.awarders?.length) {
      obj.awarders = message.awarders;
    }
    if (message.bannedAtUtc !== void 0) {
      obj.bannedAtUtc = message.bannedAtUtc;
    }
    if (message.bannedBy !== void 0) {
      obj.bannedBy = message.bannedBy;
    }
    if (message.body !== void 0) {
      obj.body = message.body;
    }
    if (message.bodyHtml !== void 0) {
      obj.bodyHtml = message.bodyHtml;
    }
    if (message.canGild !== void 0) {
      obj.canGild = message.canGild;
    }
    if (message.canModPost !== void 0) {
      obj.canModPost = message.canModPost;
    }
    if (message.collapsed !== void 0) {
      obj.collapsed = message.collapsed;
    }
    if (message.collapsedBecauseCrowdControl !== void 0) {
      obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl;
    }
    if (message.collapsedReason !== void 0) {
      obj.collapsedReason = message.collapsedReason;
    }
    if (message.collapsedReasonCode !== void 0) {
      obj.collapsedReasonCode = message.collapsedReasonCode;
    }
    if (message.commentType !== void 0) {
      obj.commentType = message.commentType;
    }
    if (message.controversiality !== void 0) {
      obj.controversiality = message.controversiality;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.depth !== void 0) {
      obj.depth = message.depth;
    }
    if (message.distinguished !== void 0) {
      obj.distinguished = message.distinguished;
    }
    if (message.downs !== void 0) {
      obj.downs = message.downs;
    }
    if (message.edited !== void 0) {
      obj.edited = message.edited;
    }
    if (message.gilded !== void 0) {
      obj.gilded = message.gilded;
    }
    if (message.gildings !== void 0) {
      obj.gildings = Gildings.toJSON(message.gildings);
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.ignoreReports !== void 0) {
      obj.ignoreReports = message.ignoreReports;
    }
    if (message.isSubmitter !== void 0) {
      obj.isSubmitter = message.isSubmitter;
    }
    if (message.likes !== void 0) {
      obj.likes = message.likes;
    }
    if (message.linkId !== void 0) {
      obj.linkId = message.linkId;
    }
    if (message.locked !== void 0) {
      obj.locked = message.locked;
    }
    if (message.modNote !== void 0) {
      obj.modNote = message.modNote;
    }
    if (message.modReasonBy !== void 0) {
      obj.modReasonBy = message.modReasonBy;
    }
    if (message.modReasonTitle !== void 0) {
      obj.modReasonTitle = message.modReasonTitle;
    }
    if (message.modReports?.length) {
      obj.modReports = message.modReports;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.noFollow !== void 0) {
      obj.noFollow = message.noFollow;
    }
    if (message.numReports !== void 0) {
      obj.numReports = message.numReports;
    }
    if (message.parentId !== void 0) {
      obj.parentId = message.parentId;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.removalReason !== void 0) {
      obj.removalReason = message.removalReason;
    }
    if (message.removed !== void 0) {
      obj.removed = message.removed;
    }
    if (message.replies !== void 0) {
      obj.replies = message.replies;
    }
    if (message.reportReasons?.length) {
      obj.reportReasons = message.reportReasons;
    }
    if (message.rteMode !== void 0) {
      obj.rteMode = message.rteMode;
    }
    if (message.saved !== void 0) {
      obj.saved = message.saved;
    }
    if (message.score !== void 0) {
      obj.score = message.score;
    }
    if (message.scoreHidden !== void 0) {
      obj.scoreHidden = message.scoreHidden;
    }
    if (message.sendReplies !== void 0) {
      obj.sendReplies = message.sendReplies;
    }
    if (message.spam !== void 0) {
      obj.spam = message.spam;
    }
    if (message.stickied !== void 0) {
      obj.stickied = message.stickied;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.subredditNamePrefixed !== void 0) {
      obj.subredditNamePrefixed = message.subredditNamePrefixed;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.topAwardedType !== void 0) {
      obj.topAwardedType = message.topAwardedType;
    }
    if (message.totalAwardsReceived !== void 0) {
      obj.totalAwardsReceived = message.totalAwardsReceived;
    }
    if (message.treatmentTags?.length) {
      obj.treatmentTags = message.treatmentTags;
    }
    if (message.unrepliableReason !== void 0) {
      obj.unrepliableReason = message.unrepliableReason;
    }
    if (message.ups !== void 0) {
      obj.ups = message.ups;
    }
    if (message.userReports?.length) {
      obj.userReports = message.userReports;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.children?.length) {
      obj.children = message.children;
    }
    if (message.banInfo !== void 0) {
      obj.banInfo = BanInfo.toJSON(message.banInfo);
    }
    if (message.markedSpam !== void 0) {
      obj.markedSpam = message.markedSpam;
    }
    if (message.verdict !== void 0) {
      obj.verdict = message.verdict;
    }
    return obj;
  },
  create(base) {
    return Comment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseComment();
    message.allAwardings = object.allAwardings?.map((e) => Awarding.fromPartial(e)) || [];
    message.approved = object.approved ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.archived = object.archived ?? void 0;
    message.associatedAward = object.associatedAward ?? void 0;
    message.author = object.author ?? void 0;
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.awarders = object.awarders?.map((e) => e) || [];
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.body = object.body ?? void 0;
    message.bodyHtml = object.bodyHtml ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.collapsed = object.collapsed ?? void 0;
    message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? void 0;
    message.collapsedReason = object.collapsedReason ?? void 0;
    message.collapsedReasonCode = object.collapsedReasonCode ?? void 0;
    message.commentType = object.commentType ?? void 0;
    message.controversiality = object.controversiality ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.depth = object.depth ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.downs = object.downs ?? void 0;
    message.edited = object.edited ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Gildings.fromPartial(object.gildings) : void 0;
    message.id = object.id ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.isSubmitter = object.isSubmitter ?? void 0;
    message.likes = object.likes ?? void 0;
    message.linkId = object.linkId ?? void 0;
    message.locked = object.locked ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.modReports = object.modReports?.map((e) => e) || [];
    message.name = object.name ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.parentId = object.parentId ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.removed = object.removed ?? void 0;
    message.replies = object.replies ?? void 0;
    message.reportReasons = object.reportReasons?.map((e) => e) || [];
    message.rteMode = object.rteMode ?? void 0;
    message.saved = object.saved ?? void 0;
    message.score = object.score ?? void 0;
    message.scoreHidden = object.scoreHidden ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.spam = object.spam ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => e) || [];
    message.unrepliableReason = object.unrepliableReason ?? void 0;
    message.ups = object.ups ?? void 0;
    message.userReports = object.userReports?.map((e) => e) || [];
    message.count = object.count ?? void 0;
    message.children = object.children?.map((e) => e) || [];
    message.banInfo = object.banInfo !== void 0 && object.banInfo !== null ? BanInfo.fromPartial(object.banInfo) : void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.verdict = object.verdict ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Comment.$type, Comment);
function isSet20(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/options/options.js
var import_minimal23 = __toESM(require_minimal2(), 1);
var DataTier;
(function(DataTier2) {
  DataTier2[DataTier2["UNKNOWN_DATA_TIER"] = 0] = "UNKNOWN_DATA_TIER";
  DataTier2[DataTier2["FIRST_DATA_TIER"] = 1] = "FIRST_DATA_TIER";
  DataTier2[DataTier2["SECOND_DATA_TIER"] = 2] = "SECOND_DATA_TIER";
  DataTier2[DataTier2["THIRD_DATA_TIER"] = 3] = "THIRD_DATA_TIER";
  DataTier2[DataTier2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DataTier || (DataTier = {}));
function dataTierFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_DATA_TIER":
      return DataTier.UNKNOWN_DATA_TIER;
    case 1:
    case "FIRST_DATA_TIER":
      return DataTier.FIRST_DATA_TIER;
    case 2:
    case "SECOND_DATA_TIER":
      return DataTier.SECOND_DATA_TIER;
    case 3:
    case "THIRD_DATA_TIER":
      return DataTier.THIRD_DATA_TIER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataTier.UNRECOGNIZED;
  }
}
function dataTierToJSON(object) {
  switch (object) {
    case DataTier.UNKNOWN_DATA_TIER:
      return 0;
    case DataTier.FIRST_DATA_TIER:
      return 1;
    case DataTier.SECOND_DATA_TIER:
      return 2;
    case DataTier.THIRD_DATA_TIER:
      return 3;
    case DataTier.UNRECOGNIZED:
    default:
      return -1;
  }
}
var Selector;
(function(Selector2) {
  Selector2[Selector2["DEFAULT"] = 0] = "DEFAULT";
  Selector2[Selector2["TARGET_USER"] = 1] = "TARGET_USER";
  Selector2[Selector2["MOD_ACTION_TYPE"] = 2] = "MOD_ACTION_TYPE";
  Selector2[Selector2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Selector || (Selector = {}));
var DeliveryLocation;
(function(DeliveryLocation2) {
  DeliveryLocation2[DeliveryLocation2["UNKNOWN_DELIVERY_LOCATION"] = 0] = "UNKNOWN_DELIVERY_LOCATION";
  DeliveryLocation2[DeliveryLocation2["GATEWAY"] = 1] = "GATEWAY";
  DeliveryLocation2[DeliveryLocation2["FIREHOSE"] = 2] = "FIREHOSE";
  DeliveryLocation2[DeliveryLocation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DeliveryLocation || (DeliveryLocation = {}));
function deliveryLocationFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_DELIVERY_LOCATION":
      return DeliveryLocation.UNKNOWN_DELIVERY_LOCATION;
    case 1:
    case "GATEWAY":
      return DeliveryLocation.GATEWAY;
    case 2:
    case "FIREHOSE":
      return DeliveryLocation.FIREHOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeliveryLocation.UNRECOGNIZED;
  }
}
function deliveryLocationToJSON(object) {
  switch (object) {
    case DeliveryLocation.UNKNOWN_DELIVERY_LOCATION:
      return 0;
    case DeliveryLocation.GATEWAY:
      return 1;
    case DeliveryLocation.FIREHOSE:
      return 2;
    case DeliveryLocation.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FirehoseEvent;
(function(FirehoseEvent2) {
  FirehoseEvent2[FirehoseEvent2["UNKNOWN_FIREHOSE_EVENT"] = 0] = "UNKNOWN_FIREHOSE_EVENT";
  FirehoseEvent2[FirehoseEvent2["POST_CREATE"] = 1] = "POST_CREATE";
  FirehoseEvent2[FirehoseEvent2["POST_EDIT"] = 2] = "POST_EDIT";
  FirehoseEvent2[FirehoseEvent2["POST_DELETE"] = 3] = "POST_DELETE";
  FirehoseEvent2[FirehoseEvent2["COMMENT_CREATE"] = 4] = "COMMENT_CREATE";
  FirehoseEvent2[FirehoseEvent2["COMMENT_EDIT"] = 5] = "COMMENT_EDIT";
  FirehoseEvent2[FirehoseEvent2["COMMENT_DELETE"] = 6] = "COMMENT_DELETE";
  FirehoseEvent2[FirehoseEvent2["VOTE"] = 7] = "VOTE";
  FirehoseEvent2[FirehoseEvent2["MOD_ACTION"] = 8] = "MOD_ACTION";
  FirehoseEvent2[FirehoseEvent2["ACCOUNT_DELETE"] = 9] = "ACCOUNT_DELETE";
  FirehoseEvent2[FirehoseEvent2["ERROR"] = 10] = "ERROR";
  FirehoseEvent2[FirehoseEvent2["WARNING"] = 11] = "WARNING";
  FirehoseEvent2[FirehoseEvent2["POST_APPROVE"] = 12] = "POST_APPROVE";
  FirehoseEvent2[FirehoseEvent2["COMMENT_APPROVE"] = 13] = "COMMENT_APPROVE";
  FirehoseEvent2[FirehoseEvent2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FirehoseEvent || (FirehoseEvent = {}));
function firehoseEventFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_FIREHOSE_EVENT":
      return FirehoseEvent.UNKNOWN_FIREHOSE_EVENT;
    case 1:
    case "POST_CREATE":
      return FirehoseEvent.POST_CREATE;
    case 2:
    case "POST_EDIT":
      return FirehoseEvent.POST_EDIT;
    case 3:
    case "POST_DELETE":
      return FirehoseEvent.POST_DELETE;
    case 4:
    case "COMMENT_CREATE":
      return FirehoseEvent.COMMENT_CREATE;
    case 5:
    case "COMMENT_EDIT":
      return FirehoseEvent.COMMENT_EDIT;
    case 6:
    case "COMMENT_DELETE":
      return FirehoseEvent.COMMENT_DELETE;
    case 7:
    case "VOTE":
      return FirehoseEvent.VOTE;
    case 8:
    case "MOD_ACTION":
      return FirehoseEvent.MOD_ACTION;
    case 9:
    case "ACCOUNT_DELETE":
      return FirehoseEvent.ACCOUNT_DELETE;
    case 10:
    case "ERROR":
      return FirehoseEvent.ERROR;
    case 11:
    case "WARNING":
      return FirehoseEvent.WARNING;
    case 12:
    case "POST_APPROVE":
      return FirehoseEvent.POST_APPROVE;
    case 13:
    case "COMMENT_APPROVE":
      return FirehoseEvent.COMMENT_APPROVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FirehoseEvent.UNRECOGNIZED;
  }
}
function firehoseEventToJSON(object) {
  switch (object) {
    case FirehoseEvent.UNKNOWN_FIREHOSE_EVENT:
      return 0;
    case FirehoseEvent.POST_CREATE:
      return 1;
    case FirehoseEvent.POST_EDIT:
      return 2;
    case FirehoseEvent.POST_DELETE:
      return 3;
    case FirehoseEvent.COMMENT_CREATE:
      return 4;
    case FirehoseEvent.COMMENT_EDIT:
      return 5;
    case FirehoseEvent.COMMENT_DELETE:
      return 6;
    case FirehoseEvent.VOTE:
      return 7;
    case FirehoseEvent.MOD_ACTION:
      return 8;
    case FirehoseEvent.ACCOUNT_DELETE:
      return 9;
    case FirehoseEvent.ERROR:
      return 10;
    case FirehoseEvent.WARNING:
      return 11;
    case FirehoseEvent.POST_APPROVE:
      return 12;
    case FirehoseEvent.COMMENT_APPROVE:
      return 13;
    case FirehoseEvent.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseEventSpec() {
  return { source: "", action: "", noun: "" };
}
var EventSpec = {
  $type: "devvit.options.EventSpec",
  encode(message, writer = import_minimal23.default.Writer.create()) {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.noun !== "") {
      writer.uint32(26).string(message.noun);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal23.default.Reader ? input : import_minimal23.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.action = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.noun = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      source: isSet21(object.source) ? globalThis.String(object.source) : "",
      action: isSet21(object.action) ? globalThis.String(object.action) : "",
      noun: isSet21(object.noun) ? globalThis.String(object.noun) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.noun !== "") {
      obj.noun = message.noun;
    }
    return obj;
  },
  create(base) {
    return EventSpec.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEventSpec();
    message.source = object.source ?? "";
    message.action = object.action ?? "";
    message.noun = object.noun ?? "";
    return message;
  }
};
messageTypeRegistry.set(EventSpec.$type, EventSpec);
function createBaseDeliverTo() {
  return { to: [] };
}
var DeliverTo = {
  $type: "devvit.options.DeliverTo",
  encode(message, writer = import_minimal23.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.to) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal23.default.Reader ? input : import_minimal23.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeliverTo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.to.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.to.push(reader.int32());
            }
            continue;
          }
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { to: globalThis.Array.isArray(object?.to) ? object.to.map((e) => deliveryLocationFromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.to?.length) {
      obj.to = message.to.map((e) => deliveryLocationToJSON(e));
    }
    return obj;
  },
  create(base) {
    return DeliverTo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeliverTo();
    message.to = object.to?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(DeliverTo.$type, DeliverTo);
function isSet21(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gql/subreddit_metadata.js
var import_minimal42 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/reddit/context_action.js
var import_minimal41 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/common/common_msg.js
var import_minimal24 = __toESM(require_minimal2(), 1);
function createBaseListing() {
  return { kind: "", data: void 0 };
}
var Listing = {
  $type: "devvit.plugin.redditapi.common.Listing",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      Listing_ListingData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Listing_ListingData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet22(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet22(object.data) ? Listing_ListingData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = Listing_ListingData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return Listing.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListing();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? Listing_ListingData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Listing.$type, Listing);
function createBaseListing_ListingData() {
  return { after: void 0, before: void 0, children: [], dist: void 0 };
}
var Listing_ListingData = {
  $type: "devvit.plugin.redditapi.common.Listing.ListingData",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      WrappedRedditObject.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int64Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListing_ListingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.children.push(WrappedRedditObject.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.dist = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet22(object.after) ? String(object.after) : void 0,
      before: isSet22(object.before) ? String(object.before) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => WrappedRedditObject.fromJSON(e)) : [],
      dist: isSet22(object.dist) ? Number(object.dist) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => WrappedRedditObject.toJSON(e));
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    return obj;
  },
  create(base) {
    return Listing_ListingData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListing_ListingData();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.children = object.children?.map((e) => WrappedRedditObject.fromPartial(e)) || [];
    message.dist = object.dist ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Listing_ListingData.$type, Listing_ListingData);
function createBaseWrappedRedditObject() {
  return { kind: "", data: void 0 };
}
var WrappedRedditObject = {
  $type: "devvit.plugin.redditapi.common.WrappedRedditObject",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      RedditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWrappedRedditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = RedditObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet22(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet22(object.data) ? RedditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = RedditObject.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return WrappedRedditObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWrappedRedditObject();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? RedditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WrappedRedditObject.$type, WrappedRedditObject);
function createBaseJsonRedditObjects() {
  return { json: void 0 };
}
var JsonRedditObjects = {
  $type: "devvit.plugin.redditapi.common.JsonRedditObjects",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.json !== void 0) {
      JsonRedditObjects_JsonType.encode(message.json, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonRedditObjects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }
          message.json = JsonRedditObjects_JsonType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet22(object.json) ? JsonRedditObjects_JsonType.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.json !== void 0) {
      obj.json = JsonRedditObjects_JsonType.toJSON(message.json);
    }
    return obj;
  },
  create(base) {
    return JsonRedditObjects.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonRedditObjects();
    message.json = object.json !== void 0 && object.json !== null ? JsonRedditObjects_JsonType.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set(JsonRedditObjects.$type, JsonRedditObjects);
function createBaseJsonRedditObjects_JsonType() {
  return { errors: [], data: void 0 };
}
var JsonRedditObjects_JsonType = {
  $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.errors) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      JsonRedditObjects_JsonType_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonRedditObjects_JsonType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.errors.push(Any.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = JsonRedditObjects_JsonType_JsonData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => Any.fromJSON(e)) : [],
      data: isSet22(object.data) ? JsonRedditObjects_JsonType_JsonData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Any.toJSON(e));
    }
    if (message.data !== void 0) {
      obj.data = JsonRedditObjects_JsonType_JsonData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return JsonRedditObjects_JsonType.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonRedditObjects_JsonType();
    message.errors = object.errors?.map((e) => Any.fromPartial(e)) || [];
    message.data = object.data !== void 0 && object.data !== null ? JsonRedditObjects_JsonType_JsonData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(JsonRedditObjects_JsonType.$type, JsonRedditObjects_JsonType);
function createBaseJsonRedditObjects_JsonType_JsonData() {
  return { things: [] };
}
var JsonRedditObjects_JsonType_JsonData = {
  $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType.JsonData",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.things) {
      WrappedRedditObject.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonRedditObjects_JsonType_JsonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.things.push(WrappedRedditObject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      things: globalThis.Array.isArray(object?.things) ? object.things.map((e) => WrappedRedditObject.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.things?.length) {
      obj.things = message.things.map((e) => WrappedRedditObject.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return JsonRedditObjects_JsonType_JsonData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonRedditObjects_JsonType_JsonData();
    message.things = object.things?.map((e) => WrappedRedditObject.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(JsonRedditObjects_JsonType_JsonData.$type, JsonRedditObjects_JsonType_JsonData);
function createBaseRedditObject() {
  return {
    allAwardings: [],
    approved: void 0,
    approvedAtUtc: void 0,
    approvedBy: void 0,
    archived: void 0,
    associatedAward: void 0,
    author: void 0,
    authorFlairBackgroundColor: void 0,
    authorFlairCssClass: void 0,
    authorFlairRichtext: [],
    authorFlairTemplateId: void 0,
    authorFlairText: void 0,
    authorFlairTextColor: void 0,
    authorFlairType: void 0,
    authorFullname: void 0,
    authorIsBlocked: void 0,
    authorPatreonFlair: void 0,
    authorPremium: void 0,
    awarders: [],
    bannedAtUtc: void 0,
    bannedBy: void 0,
    body: void 0,
    bodyHtml: void 0,
    canGild: void 0,
    canModPost: void 0,
    collapsed: void 0,
    collapsedBecauseCrowdControl: void 0,
    collapsedReason: void 0,
    collapsedReasonCode: void 0,
    commentType: void 0,
    controversiality: void 0,
    created: void 0,
    createdUtc: void 0,
    distinguished: void 0,
    downs: void 0,
    edited: void 0,
    gilded: void 0,
    gildings: void 0,
    id: void 0,
    ignoreReports: void 0,
    isSubmitter: void 0,
    likes: void 0,
    linkId: void 0,
    locked: void 0,
    modNote: void 0,
    modReasonBy: void 0,
    modReasonTitle: void 0,
    name: void 0,
    noFollow: void 0,
    numReports: void 0,
    parentId: void 0,
    permalink: void 0,
    removalReason: void 0,
    removed: void 0,
    replies: void 0,
    reportReasons: void 0,
    rteMode: void 0,
    saved: void 0,
    score: void 0,
    scoreHidden: void 0,
    sendReplies: void 0,
    spam: void 0,
    stickied: void 0,
    subreddit: void 0,
    subredditId: void 0,
    subredditNamePrefixed: void 0,
    subredditType: void 0,
    topAwardedType: void 0,
    totalAwardsReceived: void 0,
    treatmentTags: [],
    unrepliableReason: void 0,
    ups: void 0,
    depth: void 0,
    linkTitle: void 0,
    linkAuthor: void 0,
    numComments: void 0,
    over18: void 0,
    linkPermalink: void 0,
    quarantine: void 0,
    linkUrl: void 0,
    selftext: void 0,
    selftextHtml: void 0,
    thumbnail: void 0,
    thumbnailWidth: void 0,
    thumbnailHeight: void 0,
    title: void 0,
    url: void 0,
    displayName: void 0,
    modPermissions: [],
    count: void 0,
    children: void 0,
    replyList: void 0,
    hidden: void 0,
    linkFlairBackgroundColor: void 0,
    linkFlairCssClass: void 0,
    linkFlairRichtext: [],
    linkFlairTemplateId: void 0,
    linkFlairText: void 0,
    linkFlairTextColor: void 0,
    linkFlairType: void 0,
    secureMedia: void 0,
    spoiler: false,
    modReports: [],
    userReports: [],
    removedBy: void 0,
    removedByCategory: void 0
  };
}
var RedditObject = {
  $type: "devvit.plugin.redditapi.common.RedditObject",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.allAwardings) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(18).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int64Value.encode({ value: message.approvedAtUtc }, writer.uint32(26).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(34).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(42).fork()).ldelim();
    }
    if (message.associatedAward !== void 0) {
      StringValue.encode({ value: message.associatedAward }, writer.uint32(50).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      RedditObject_AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int64Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
    }
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(178).fork()).ldelim();
    }
    if (message.bodyHtml !== void 0) {
      StringValue.encode({ value: message.bodyHtml }, writer.uint32(186).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(194).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(202).fork()).ldelim();
    }
    if (message.collapsed !== void 0) {
      BoolValue.encode({ value: message.collapsed }, writer.uint32(210).fork()).ldelim();
    }
    if (message.collapsedBecauseCrowdControl !== void 0) {
      BoolValue.encode({ value: message.collapsedBecauseCrowdControl }, writer.uint32(218).fork()).ldelim();
    }
    if (message.collapsedReason !== void 0) {
      StringValue.encode({ value: message.collapsedReason }, writer.uint32(226).fork()).ldelim();
    }
    if (message.collapsedReasonCode !== void 0) {
      StringValue.encode({ value: message.collapsedReasonCode }, writer.uint32(234).fork()).ldelim();
    }
    if (message.commentType !== void 0) {
      StringValue.encode({ value: message.commentType }, writer.uint32(242).fork()).ldelim();
    }
    if (message.controversiality !== void 0) {
      Int64Value.encode({ value: message.controversiality }, writer.uint32(250).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(258).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(266).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(274).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int64Value.encode({ value: message.downs }, writer.uint32(282).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(290).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int64Value.encode({ value: message.gilded }, writer.uint32(298).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Any.encode(message.gildings, writer.uint32(306).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(314).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(322).fork()).ldelim();
    }
    if (message.isSubmitter !== void 0) {
      BoolValue.encode({ value: message.isSubmitter }, writer.uint32(330).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(338).fork()).ldelim();
    }
    if (message.linkId !== void 0) {
      StringValue.encode({ value: message.linkId }, writer.uint32(346).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(354).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(362).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(370).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(378).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(394).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(402).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int64Value.encode({ value: message.numReports }, writer.uint32(418).fork()).ldelim();
    }
    if (message.parentId !== void 0) {
      StringValue.encode({ value: message.parentId }, writer.uint32(426).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(434).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(442).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(450).fork()).ldelim();
    }
    if (message.replies !== void 0) {
      StringValue.encode({ value: message.replies }, writer.uint32(458).fork()).ldelim();
    }
    if (message.reportReasons !== void 0) {
      ListValue.encode(ListValue.wrap(message.reportReasons), writer.uint32(466).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(474).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(482).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int64Value.encode({ value: message.score }, writer.uint32(490).fork()).ldelim();
    }
    if (message.scoreHidden !== void 0) {
      BoolValue.encode({ value: message.scoreHidden }, writer.uint32(498).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(506).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(514).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(522).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(530).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(538).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(546).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(554).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(562).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int64Value.encode({ value: message.totalAwardsReceived }, writer.uint32(570).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      Any.encode(v, writer.uint32(578).fork()).ldelim();
    }
    if (message.unrepliableReason !== void 0) {
      StringValue.encode({ value: message.unrepliableReason }, writer.uint32(586).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int64Value.encode({ value: message.ups }, writer.uint32(594).fork()).ldelim();
    }
    if (message.depth !== void 0) {
      Int64Value.encode({ value: message.depth }, writer.uint32(610).fork()).ldelim();
    }
    if (message.linkTitle !== void 0) {
      StringValue.encode({ value: message.linkTitle }, writer.uint32(618).fork()).ldelim();
    }
    if (message.linkAuthor !== void 0) {
      StringValue.encode({ value: message.linkAuthor }, writer.uint32(626).fork()).ldelim();
    }
    if (message.numComments !== void 0) {
      Int64Value.encode({ value: message.numComments }, writer.uint32(634).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(642).fork()).ldelim();
    }
    if (message.linkPermalink !== void 0) {
      StringValue.encode({ value: message.linkPermalink }, writer.uint32(650).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(658).fork()).ldelim();
    }
    if (message.linkUrl !== void 0) {
      StringValue.encode({ value: message.linkUrl }, writer.uint32(666).fork()).ldelim();
    }
    if (message.selftext !== void 0) {
      StringValue.encode({ value: message.selftext }, writer.uint32(674).fork()).ldelim();
    }
    if (message.selftextHtml !== void 0) {
      StringValue.encode({ value: message.selftextHtml }, writer.uint32(682).fork()).ldelim();
    }
    if (message.thumbnail !== void 0) {
      StringValue.encode({ value: message.thumbnail }, writer.uint32(698).fork()).ldelim();
    }
    if (message.thumbnailWidth !== void 0) {
      Int64Value.encode({ value: message.thumbnailWidth }, writer.uint32(706).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int64Value.encode({ value: message.thumbnailHeight }, writer.uint32(714).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(722).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(730).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(738).fork()).ldelim();
    }
    for (const v of message.modPermissions) {
      StringValue.encode({ value: v }, writer.uint32(746).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(754).fork()).ldelim();
    }
    if (message.children !== void 0) {
      ListValue.encode(ListValue.wrap(message.children), writer.uint32(762).fork()).ldelim();
    }
    if (message.replyList !== void 0) {
      Listing.encode(message.replyList, writer.uint32(770).fork()).ldelim();
    }
    if (message.hidden !== void 0) {
      BoolValue.encode({ value: message.hidden }, writer.uint32(778).fork()).ldelim();
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(786).fork()).ldelim();
    }
    if (message.linkFlairCssClass !== void 0) {
      StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(794).fork()).ldelim();
    }
    for (const v of message.linkFlairRichtext) {
      RedditObject_LinkFlairRichText.encode(v, writer.uint32(802).fork()).ldelim();
    }
    if (message.linkFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.linkFlairTemplateId }, writer.uint32(810).fork()).ldelim();
    }
    if (message.linkFlairText !== void 0) {
      StringValue.encode({ value: message.linkFlairText }, writer.uint32(818).fork()).ldelim();
    }
    if (message.linkFlairTextColor !== void 0) {
      StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(826).fork()).ldelim();
    }
    if (message.linkFlairType !== void 0) {
      StringValue.encode({ value: message.linkFlairType }, writer.uint32(834).fork()).ldelim();
    }
    if (message.secureMedia !== void 0) {
      RedditObject_SecureMedia.encode(message.secureMedia, writer.uint32(842).fork()).ldelim();
    }
    if (message.spoiler !== false) {
      writer.uint32(848).bool(message.spoiler);
    }
    for (const v of message.modReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(858).fork()).ldelim();
    }
    for (const v of message.userReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(866).fork()).ldelim();
    }
    if (message.removedBy !== void 0) {
      StringValue.encode({ value: message.removedBy }, writer.uint32(874).fork()).ldelim();
    }
    if (message.removedByCategory !== void 0) {
      StringValue.encode({ value: message.removedByCategory }, writer.uint32(882).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.allAwardings.push(Any.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.approvedAtUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.associatedAward = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.author = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.authorFlairRichtext.push(RedditObject_AuthorFlairRichText.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.bannedAtUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.body = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.bodyHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.collapsed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.collapsedBecauseCrowdControl = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.collapsedReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.collapsedReasonCode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.commentType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.controversiality = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.downs = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.gilded = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.gildings = Any.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.isSubmitter = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.linkId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.numReports = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.parentId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.replies = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.reportReasons = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.score = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.scoreHidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.totalAwardsReceived = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.treatmentTags.push(Any.decode(reader, reader.uint32()));
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.unrepliableReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.ups = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.depth = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.linkTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.linkAuthor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.numComments = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }
          message.linkPermalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }
          message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }
          message.selftext = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 85:
          if (tag !== 682) {
            break;
          }
          message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }
          message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 88:
          if (tag !== 706) {
            break;
          }
          message.thumbnailWidth = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 89:
          if (tag !== 714) {
            break;
          }
          message.thumbnailHeight = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 92:
          if (tag !== 738) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }
          message.modPermissions.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 94:
          if (tag !== 754) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 95:
          if (tag !== 762) {
            break;
          }
          message.children = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }
          message.replyList = Listing.decode(reader, reader.uint32());
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }
          message.hidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }
          message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }
          message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.linkFlairRichtext.push(RedditObject_LinkFlairRichText.decode(reader, reader.uint32()));
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.linkFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.secureMedia = RedditObject_SecureMedia.decode(reader, reader.uint32());
          continue;
        case 106:
          if (tag !== 848) {
            break;
          }
          message.spoiler = reader.bool();
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }
          message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }
          message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }
          message.removedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }
          message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allAwardings: globalThis.Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Any.fromJSON(e)) : [],
      approved: isSet22(object.approved) ? Boolean(object.approved) : void 0,
      approvedAtUtc: isSet22(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      approvedBy: isSet22(object.approvedBy) ? String(object.approvedBy) : void 0,
      archived: isSet22(object.archived) ? Boolean(object.archived) : void 0,
      associatedAward: isSet22(object.associatedAward) ? String(object.associatedAward) : void 0,
      author: isSet22(object.author) ? String(object.author) : void 0,
      authorFlairBackgroundColor: isSet22(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      authorFlairCssClass: isSet22(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      authorFlairRichtext: globalThis.Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => RedditObject_AuthorFlairRichText.fromJSON(e)) : [],
      authorFlairTemplateId: isSet22(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      authorFlairText: isSet22(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      authorFlairTextColor: isSet22(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      authorFlairType: isSet22(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      authorFullname: isSet22(object.authorFullname) ? String(object.authorFullname) : void 0,
      authorIsBlocked: isSet22(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      authorPatreonFlair: isSet22(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      authorPremium: isSet22(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      awarders: globalThis.Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      bannedAtUtc: isSet22(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      bannedBy: isSet22(object.bannedBy) ? String(object.bannedBy) : void 0,
      body: isSet22(object.body) ? String(object.body) : void 0,
      bodyHtml: isSet22(object.bodyHtml) ? String(object.bodyHtml) : void 0,
      canGild: isSet22(object.canGild) ? Boolean(object.canGild) : void 0,
      canModPost: isSet22(object.canModPost) ? Boolean(object.canModPost) : void 0,
      collapsed: isSet22(object.collapsed) ? Boolean(object.collapsed) : void 0,
      collapsedBecauseCrowdControl: isSet22(object.collapsedBecauseCrowdControl) ? Boolean(object.collapsedBecauseCrowdControl) : void 0,
      collapsedReason: isSet22(object.collapsedReason) ? String(object.collapsedReason) : void 0,
      collapsedReasonCode: isSet22(object.collapsedReasonCode) ? String(object.collapsedReasonCode) : void 0,
      commentType: isSet22(object.commentType) ? String(object.commentType) : void 0,
      controversiality: isSet22(object.controversiality) ? Number(object.controversiality) : void 0,
      created: isSet22(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet22(object.createdUtc) ? Number(object.createdUtc) : void 0,
      distinguished: isSet22(object.distinguished) ? String(object.distinguished) : void 0,
      downs: isSet22(object.downs) ? Number(object.downs) : void 0,
      edited: isSet22(object.edited) ? Boolean(object.edited) : void 0,
      gilded: isSet22(object.gilded) ? Number(object.gilded) : void 0,
      gildings: isSet22(object.gildings) ? Any.fromJSON(object.gildings) : void 0,
      id: isSet22(object.id) ? String(object.id) : void 0,
      ignoreReports: isSet22(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      isSubmitter: isSet22(object.isSubmitter) ? Boolean(object.isSubmitter) : void 0,
      likes: isSet22(object.likes) ? Boolean(object.likes) : void 0,
      linkId: isSet22(object.linkId) ? String(object.linkId) : void 0,
      locked: isSet22(object.locked) ? Boolean(object.locked) : void 0,
      modNote: isSet22(object.modNote) ? String(object.modNote) : void 0,
      modReasonBy: isSet22(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      modReasonTitle: isSet22(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      name: isSet22(object.name) ? String(object.name) : void 0,
      noFollow: isSet22(object.noFollow) ? Boolean(object.noFollow) : void 0,
      numReports: isSet22(object.numReports) ? Number(object.numReports) : void 0,
      parentId: isSet22(object.parentId) ? String(object.parentId) : void 0,
      permalink: isSet22(object.permalink) ? String(object.permalink) : void 0,
      removalReason: isSet22(object.removalReason) ? String(object.removalReason) : void 0,
      removed: isSet22(object.removed) ? Boolean(object.removed) : void 0,
      replies: isSet22(object.replies) ? String(object.replies) : void 0,
      reportReasons: globalThis.Array.isArray(object.reportReasons) ? [...object.reportReasons] : void 0,
      rteMode: isSet22(object.rteMode) ? String(object.rteMode) : void 0,
      saved: isSet22(object.saved) ? Boolean(object.saved) : void 0,
      score: isSet22(object.score) ? Number(object.score) : void 0,
      scoreHidden: isSet22(object.scoreHidden) ? Boolean(object.scoreHidden) : void 0,
      sendReplies: isSet22(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      spam: isSet22(object.spam) ? Boolean(object.spam) : void 0,
      stickied: isSet22(object.stickied) ? Boolean(object.stickied) : void 0,
      subreddit: isSet22(object.subreddit) ? String(object.subreddit) : void 0,
      subredditId: isSet22(object.subredditId) ? String(object.subredditId) : void 0,
      subredditNamePrefixed: isSet22(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      subredditType: isSet22(object.subredditType) ? String(object.subredditType) : void 0,
      topAwardedType: isSet22(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      totalAwardsReceived: isSet22(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      treatmentTags: globalThis.Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => Any.fromJSON(e)) : [],
      unrepliableReason: isSet22(object.unrepliableReason) ? String(object.unrepliableReason) : void 0,
      ups: isSet22(object.ups) ? Number(object.ups) : void 0,
      depth: isSet22(object.depth) ? Number(object.depth) : void 0,
      linkTitle: isSet22(object.linkTitle) ? String(object.linkTitle) : void 0,
      linkAuthor: isSet22(object.linkAuthor) ? String(object.linkAuthor) : void 0,
      numComments: isSet22(object.numComments) ? Number(object.numComments) : void 0,
      over18: isSet22(object.over18) ? Boolean(object.over18) : void 0,
      linkPermalink: isSet22(object.linkPermalink) ? String(object.linkPermalink) : void 0,
      quarantine: isSet22(object.quarantine) ? Boolean(object.quarantine) : void 0,
      linkUrl: isSet22(object.linkUrl) ? String(object.linkUrl) : void 0,
      selftext: isSet22(object.selftext) ? String(object.selftext) : void 0,
      selftextHtml: isSet22(object.selftextHtml) ? String(object.selftextHtml) : void 0,
      thumbnail: isSet22(object.thumbnail) ? String(object.thumbnail) : void 0,
      thumbnailWidth: isSet22(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      thumbnailHeight: isSet22(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      title: isSet22(object.title) ? String(object.title) : void 0,
      url: isSet22(object.url) ? String(object.url) : void 0,
      displayName: isSet22(object.displayName) ? String(object.displayName) : void 0,
      modPermissions: globalThis.Array.isArray(object?.modPermissions) ? object.modPermissions.map((e) => String(e)) : [],
      count: isSet22(object.count) ? Number(object.count) : void 0,
      children: globalThis.Array.isArray(object.children) ? [...object.children] : void 0,
      replyList: isSet22(object.replyList) ? Listing.fromJSON(object.replyList) : void 0,
      hidden: isSet22(object.hidden) ? Boolean(object.hidden) : void 0,
      linkFlairBackgroundColor: isSet22(object.linkFlairBackgroundColor) ? String(object.linkFlairBackgroundColor) : void 0,
      linkFlairCssClass: isSet22(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : void 0,
      linkFlairRichtext: globalThis.Array.isArray(object?.linkFlairRichtext) ? object.linkFlairRichtext.map((e) => RedditObject_LinkFlairRichText.fromJSON(e)) : [],
      linkFlairTemplateId: isSet22(object.linkFlairTemplateId) ? String(object.linkFlairTemplateId) : void 0,
      linkFlairText: isSet22(object.linkFlairText) ? String(object.linkFlairText) : void 0,
      linkFlairTextColor: isSet22(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : void 0,
      linkFlairType: isSet22(object.linkFlairType) ? String(object.linkFlairType) : void 0,
      secureMedia: isSet22(object.secureMedia) ? RedditObject_SecureMedia.fromJSON(object.secureMedia) : void 0,
      spoiler: isSet22(object.spoiler) ? globalThis.Boolean(object.spoiler) : false,
      modReports: globalThis.Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
      userReports: globalThis.Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
      removedBy: isSet22(object.removedBy) ? String(object.removedBy) : void 0,
      removedByCategory: isSet22(object.removedByCategory) ? String(object.removedByCategory) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allAwardings?.length) {
      obj.allAwardings = message.allAwardings.map((e) => Any.toJSON(e));
    }
    if (message.approved !== void 0) {
      obj.approved = message.approved;
    }
    if (message.approvedAtUtc !== void 0) {
      obj.approvedAtUtc = message.approvedAtUtc;
    }
    if (message.approvedBy !== void 0) {
      obj.approvedBy = message.approvedBy;
    }
    if (message.archived !== void 0) {
      obj.archived = message.archived;
    }
    if (message.associatedAward !== void 0) {
      obj.associatedAward = message.associatedAward;
    }
    if (message.author !== void 0) {
      obj.author = message.author;
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor;
    }
    if (message.authorFlairCssClass !== void 0) {
      obj.authorFlairCssClass = message.authorFlairCssClass;
    }
    if (message.authorFlairRichtext?.length) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => RedditObject_AuthorFlairRichText.toJSON(e));
    }
    if (message.authorFlairTemplateId !== void 0) {
      obj.authorFlairTemplateId = message.authorFlairTemplateId;
    }
    if (message.authorFlairText !== void 0) {
      obj.authorFlairText = message.authorFlairText;
    }
    if (message.authorFlairTextColor !== void 0) {
      obj.authorFlairTextColor = message.authorFlairTextColor;
    }
    if (message.authorFlairType !== void 0) {
      obj.authorFlairType = message.authorFlairType;
    }
    if (message.authorFullname !== void 0) {
      obj.authorFullname = message.authorFullname;
    }
    if (message.authorIsBlocked !== void 0) {
      obj.authorIsBlocked = message.authorIsBlocked;
    }
    if (message.authorPatreonFlair !== void 0) {
      obj.authorPatreonFlair = message.authorPatreonFlair;
    }
    if (message.authorPremium !== void 0) {
      obj.authorPremium = message.authorPremium;
    }
    if (message.awarders?.length) {
      obj.awarders = message.awarders;
    }
    if (message.bannedAtUtc !== void 0) {
      obj.bannedAtUtc = message.bannedAtUtc;
    }
    if (message.bannedBy !== void 0) {
      obj.bannedBy = message.bannedBy;
    }
    if (message.body !== void 0) {
      obj.body = message.body;
    }
    if (message.bodyHtml !== void 0) {
      obj.bodyHtml = message.bodyHtml;
    }
    if (message.canGild !== void 0) {
      obj.canGild = message.canGild;
    }
    if (message.canModPost !== void 0) {
      obj.canModPost = message.canModPost;
    }
    if (message.collapsed !== void 0) {
      obj.collapsed = message.collapsed;
    }
    if (message.collapsedBecauseCrowdControl !== void 0) {
      obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl;
    }
    if (message.collapsedReason !== void 0) {
      obj.collapsedReason = message.collapsedReason;
    }
    if (message.collapsedReasonCode !== void 0) {
      obj.collapsedReasonCode = message.collapsedReasonCode;
    }
    if (message.commentType !== void 0) {
      obj.commentType = message.commentType;
    }
    if (message.controversiality !== void 0) {
      obj.controversiality = message.controversiality;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.distinguished !== void 0) {
      obj.distinguished = message.distinguished;
    }
    if (message.downs !== void 0) {
      obj.downs = message.downs;
    }
    if (message.edited !== void 0) {
      obj.edited = message.edited;
    }
    if (message.gilded !== void 0) {
      obj.gilded = message.gilded;
    }
    if (message.gildings !== void 0) {
      obj.gildings = Any.toJSON(message.gildings);
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.ignoreReports !== void 0) {
      obj.ignoreReports = message.ignoreReports;
    }
    if (message.isSubmitter !== void 0) {
      obj.isSubmitter = message.isSubmitter;
    }
    if (message.likes !== void 0) {
      obj.likes = message.likes;
    }
    if (message.linkId !== void 0) {
      obj.linkId = message.linkId;
    }
    if (message.locked !== void 0) {
      obj.locked = message.locked;
    }
    if (message.modNote !== void 0) {
      obj.modNote = message.modNote;
    }
    if (message.modReasonBy !== void 0) {
      obj.modReasonBy = message.modReasonBy;
    }
    if (message.modReasonTitle !== void 0) {
      obj.modReasonTitle = message.modReasonTitle;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.noFollow !== void 0) {
      obj.noFollow = message.noFollow;
    }
    if (message.numReports !== void 0) {
      obj.numReports = message.numReports;
    }
    if (message.parentId !== void 0) {
      obj.parentId = message.parentId;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.removalReason !== void 0) {
      obj.removalReason = message.removalReason;
    }
    if (message.removed !== void 0) {
      obj.removed = message.removed;
    }
    if (message.replies !== void 0) {
      obj.replies = message.replies;
    }
    if (message.reportReasons !== void 0) {
      obj.reportReasons = message.reportReasons;
    }
    if (message.rteMode !== void 0) {
      obj.rteMode = message.rteMode;
    }
    if (message.saved !== void 0) {
      obj.saved = message.saved;
    }
    if (message.score !== void 0) {
      obj.score = message.score;
    }
    if (message.scoreHidden !== void 0) {
      obj.scoreHidden = message.scoreHidden;
    }
    if (message.sendReplies !== void 0) {
      obj.sendReplies = message.sendReplies;
    }
    if (message.spam !== void 0) {
      obj.spam = message.spam;
    }
    if (message.stickied !== void 0) {
      obj.stickied = message.stickied;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.subredditNamePrefixed !== void 0) {
      obj.subredditNamePrefixed = message.subredditNamePrefixed;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.topAwardedType !== void 0) {
      obj.topAwardedType = message.topAwardedType;
    }
    if (message.totalAwardsReceived !== void 0) {
      obj.totalAwardsReceived = message.totalAwardsReceived;
    }
    if (message.treatmentTags?.length) {
      obj.treatmentTags = message.treatmentTags.map((e) => Any.toJSON(e));
    }
    if (message.unrepliableReason !== void 0) {
      obj.unrepliableReason = message.unrepliableReason;
    }
    if (message.ups !== void 0) {
      obj.ups = message.ups;
    }
    if (message.depth !== void 0) {
      obj.depth = message.depth;
    }
    if (message.linkTitle !== void 0) {
      obj.linkTitle = message.linkTitle;
    }
    if (message.linkAuthor !== void 0) {
      obj.linkAuthor = message.linkAuthor;
    }
    if (message.numComments !== void 0) {
      obj.numComments = message.numComments;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.linkPermalink !== void 0) {
      obj.linkPermalink = message.linkPermalink;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.linkUrl !== void 0) {
      obj.linkUrl = message.linkUrl;
    }
    if (message.selftext !== void 0) {
      obj.selftext = message.selftext;
    }
    if (message.selftextHtml !== void 0) {
      obj.selftextHtml = message.selftextHtml;
    }
    if (message.thumbnail !== void 0) {
      obj.thumbnail = message.thumbnail;
    }
    if (message.thumbnailWidth !== void 0) {
      obj.thumbnailWidth = message.thumbnailWidth;
    }
    if (message.thumbnailHeight !== void 0) {
      obj.thumbnailHeight = message.thumbnailHeight;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.modPermissions?.length) {
      obj.modPermissions = message.modPermissions;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.children !== void 0) {
      obj.children = message.children;
    }
    if (message.replyList !== void 0) {
      obj.replyList = Listing.toJSON(message.replyList);
    }
    if (message.hidden !== void 0) {
      obj.hidden = message.hidden;
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor;
    }
    if (message.linkFlairCssClass !== void 0) {
      obj.linkFlairCssClass = message.linkFlairCssClass;
    }
    if (message.linkFlairRichtext?.length) {
      obj.linkFlairRichtext = message.linkFlairRichtext.map((e) => RedditObject_LinkFlairRichText.toJSON(e));
    }
    if (message.linkFlairTemplateId !== void 0) {
      obj.linkFlairTemplateId = message.linkFlairTemplateId;
    }
    if (message.linkFlairText !== void 0) {
      obj.linkFlairText = message.linkFlairText;
    }
    if (message.linkFlairTextColor !== void 0) {
      obj.linkFlairTextColor = message.linkFlairTextColor;
    }
    if (message.linkFlairType !== void 0) {
      obj.linkFlairType = message.linkFlairType;
    }
    if (message.secureMedia !== void 0) {
      obj.secureMedia = RedditObject_SecureMedia.toJSON(message.secureMedia);
    }
    if (message.spoiler !== false) {
      obj.spoiler = message.spoiler;
    }
    if (message.modReports?.length) {
      obj.modReports = message.modReports;
    }
    if (message.userReports?.length) {
      obj.userReports = message.userReports;
    }
    if (message.removedBy !== void 0) {
      obj.removedBy = message.removedBy;
    }
    if (message.removedByCategory !== void 0) {
      obj.removedByCategory = message.removedByCategory;
    }
    return obj;
  },
  create(base) {
    return RedditObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditObject();
    message.allAwardings = object.allAwardings?.map((e) => Any.fromPartial(e)) || [];
    message.approved = object.approved ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.archived = object.archived ?? void 0;
    message.associatedAward = object.associatedAward ?? void 0;
    message.author = object.author ?? void 0;
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => RedditObject_AuthorFlairRichText.fromPartial(e)) || [];
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.awarders = object.awarders?.map((e) => e) || [];
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.body = object.body ?? void 0;
    message.bodyHtml = object.bodyHtml ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.collapsed = object.collapsed ?? void 0;
    message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? void 0;
    message.collapsedReason = object.collapsedReason ?? void 0;
    message.collapsedReasonCode = object.collapsedReasonCode ?? void 0;
    message.commentType = object.commentType ?? void 0;
    message.controversiality = object.controversiality ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.downs = object.downs ?? void 0;
    message.edited = object.edited ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Any.fromPartial(object.gildings) : void 0;
    message.id = object.id ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.isSubmitter = object.isSubmitter ?? void 0;
    message.likes = object.likes ?? void 0;
    message.linkId = object.linkId ?? void 0;
    message.locked = object.locked ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.name = object.name ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.parentId = object.parentId ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.removed = object.removed ?? void 0;
    message.replies = object.replies ?? void 0;
    message.reportReasons = object.reportReasons ?? void 0;
    message.rteMode = object.rteMode ?? void 0;
    message.saved = object.saved ?? void 0;
    message.score = object.score ?? void 0;
    message.scoreHidden = object.scoreHidden ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.spam = object.spam ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => Any.fromPartial(e)) || [];
    message.unrepliableReason = object.unrepliableReason ?? void 0;
    message.ups = object.ups ?? void 0;
    message.depth = object.depth ?? void 0;
    message.linkTitle = object.linkTitle ?? void 0;
    message.linkAuthor = object.linkAuthor ?? void 0;
    message.numComments = object.numComments ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.linkPermalink = object.linkPermalink ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.linkUrl = object.linkUrl ?? void 0;
    message.selftext = object.selftext ?? void 0;
    message.selftextHtml = object.selftextHtml ?? void 0;
    message.thumbnail = object.thumbnail ?? void 0;
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.title = object.title ?? void 0;
    message.url = object.url ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.modPermissions = object.modPermissions?.map((e) => e) || [];
    message.count = object.count ?? void 0;
    message.children = object.children ?? void 0;
    message.replyList = object.replyList !== void 0 && object.replyList !== null ? Listing.fromPartial(object.replyList) : void 0;
    message.hidden = object.hidden ?? void 0;
    message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? void 0;
    message.linkFlairCssClass = object.linkFlairCssClass ?? void 0;
    message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => RedditObject_LinkFlairRichText.fromPartial(e)) || [];
    message.linkFlairTemplateId = object.linkFlairTemplateId ?? void 0;
    message.linkFlairText = object.linkFlairText ?? void 0;
    message.linkFlairTextColor = object.linkFlairTextColor ?? void 0;
    message.linkFlairType = object.linkFlairType ?? void 0;
    message.secureMedia = object.secureMedia !== void 0 && object.secureMedia !== null ? RedditObject_SecureMedia.fromPartial(object.secureMedia) : void 0;
    message.spoiler = object.spoiler ?? false;
    message.modReports = object.modReports?.map((e) => e) || [];
    message.userReports = object.userReports?.map((e) => e) || [];
    message.removedBy = object.removedBy ?? void 0;
    message.removedByCategory = object.removedByCategory ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditObject.$type, RedditObject);
function createBaseRedditObject_OEmbed() {
  return {
    type: "",
    title: void 0,
    providerName: void 0,
    providerUrl: void 0,
    version: "",
    thumbnailWidth: void 0,
    thumbnailHeight: void 0,
    thumbnailUrl: void 0,
    html: "",
    height: void 0,
    width: void 0,
    authorUrl: void 0,
    authorName: void 0
  };
}
var RedditObject_OEmbed = {
  $type: "devvit.plugin.redditapi.common.RedditObject.OEmbed",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.title !== void 0) {
      writer.uint32(18).string(message.title);
    }
    if (message.providerName !== void 0) {
      writer.uint32(26).string(message.providerName);
    }
    if (message.providerUrl !== void 0) {
      writer.uint32(34).string(message.providerUrl);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (message.thumbnailWidth !== void 0) {
      Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(50).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(58).fork()).ldelim();
    }
    if (message.thumbnailUrl !== void 0) {
      writer.uint32(66).string(message.thumbnailUrl);
    }
    if (message.html !== "") {
      writer.uint32(74).string(message.html);
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(82).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorUrl !== void 0) {
      writer.uint32(98).string(message.authorUrl);
    }
    if (message.authorName !== void 0) {
      writer.uint32(106).string(message.authorName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject_OEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.providerName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.providerUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.version = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.thumbnailUrl = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.html = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.authorUrl = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.authorName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet22(object.type) ? globalThis.String(object.type) : "",
      title: isSet22(object.title) ? globalThis.String(object.title) : void 0,
      providerName: isSet22(object.providerName) ? globalThis.String(object.providerName) : void 0,
      providerUrl: isSet22(object.providerUrl) ? globalThis.String(object.providerUrl) : void 0,
      version: isSet22(object.version) ? globalThis.String(object.version) : "",
      thumbnailWidth: isSet22(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      thumbnailHeight: isSet22(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      thumbnailUrl: isSet22(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : void 0,
      html: isSet22(object.html) ? globalThis.String(object.html) : "",
      height: isSet22(object.height) ? Number(object.height) : void 0,
      width: isSet22(object.width) ? Number(object.width) : void 0,
      authorUrl: isSet22(object.authorUrl) ? globalThis.String(object.authorUrl) : void 0,
      authorName: isSet22(object.authorName) ? globalThis.String(object.authorName) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.providerName !== void 0) {
      obj.providerName = message.providerName;
    }
    if (message.providerUrl !== void 0) {
      obj.providerUrl = message.providerUrl;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.thumbnailWidth !== void 0) {
      obj.thumbnailWidth = message.thumbnailWidth;
    }
    if (message.thumbnailHeight !== void 0) {
      obj.thumbnailHeight = message.thumbnailHeight;
    }
    if (message.thumbnailUrl !== void 0) {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.html !== "") {
      obj.html = message.html;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    if (message.authorUrl !== void 0) {
      obj.authorUrl = message.authorUrl;
    }
    if (message.authorName !== void 0) {
      obj.authorName = message.authorName;
    }
    return obj;
  },
  create(base) {
    return RedditObject_OEmbed.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditObject_OEmbed();
    message.type = object.type ?? "";
    message.title = object.title ?? void 0;
    message.providerName = object.providerName ?? void 0;
    message.providerUrl = object.providerUrl ?? void 0;
    message.version = object.version ?? "";
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.thumbnailUrl = object.thumbnailUrl ?? void 0;
    message.html = object.html ?? "";
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    message.authorUrl = object.authorUrl ?? void 0;
    message.authorName = object.authorName ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditObject_OEmbed.$type, RedditObject_OEmbed);
function createBaseRedditObject_RedditVideo() {
  return {
    bitrateKbps: void 0,
    dashUrl: void 0,
    duration: void 0,
    fallbackUrl: void 0,
    height: void 0,
    hlsUrl: void 0,
    isGif: void 0,
    scrubberMediaUrl: void 0,
    transcodingStatus: void 0,
    width: void 0
  };
}
var RedditObject_RedditVideo = {
  $type: "devvit.plugin.redditapi.common.RedditObject.RedditVideo",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.bitrateKbps !== void 0) {
      Int32Value.encode({ value: message.bitrateKbps }, writer.uint32(10).fork()).ldelim();
    }
    if (message.dashUrl !== void 0) {
      StringValue.encode({ value: message.dashUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.duration !== void 0) {
      Int32Value.encode({ value: message.duration }, writer.uint32(26).fork()).ldelim();
    }
    if (message.fallbackUrl !== void 0) {
      StringValue.encode({ value: message.fallbackUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(42).fork()).ldelim();
    }
    if (message.hlsUrl !== void 0) {
      StringValue.encode({ value: message.hlsUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isGif !== void 0) {
      BoolValue.encode({ value: message.isGif }, writer.uint32(58).fork()).ldelim();
    }
    if (message.scrubberMediaUrl !== void 0) {
      StringValue.encode({ value: message.scrubberMediaUrl }, writer.uint32(66).fork()).ldelim();
    }
    if (message.transcodingStatus !== void 0) {
      StringValue.encode({ value: message.transcodingStatus }, writer.uint32(74).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject_RedditVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bitrateKbps = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dashUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.duration = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.fallbackUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.hlsUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.isGif = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.scrubberMediaUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.transcodingStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bitrateKbps: isSet22(object.bitrateKbps) ? Number(object.bitrateKbps) : void 0,
      dashUrl: isSet22(object.dashUrl) ? String(object.dashUrl) : void 0,
      duration: isSet22(object.duration) ? Number(object.duration) : void 0,
      fallbackUrl: isSet22(object.fallbackUrl) ? String(object.fallbackUrl) : void 0,
      height: isSet22(object.height) ? Number(object.height) : void 0,
      hlsUrl: isSet22(object.hlsUrl) ? String(object.hlsUrl) : void 0,
      isGif: isSet22(object.isGif) ? Boolean(object.isGif) : void 0,
      scrubberMediaUrl: isSet22(object.scrubberMediaUrl) ? String(object.scrubberMediaUrl) : void 0,
      transcodingStatus: isSet22(object.transcodingStatus) ? String(object.transcodingStatus) : void 0,
      width: isSet22(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bitrateKbps !== void 0) {
      obj.bitrateKbps = message.bitrateKbps;
    }
    if (message.dashUrl !== void 0) {
      obj.dashUrl = message.dashUrl;
    }
    if (message.duration !== void 0) {
      obj.duration = message.duration;
    }
    if (message.fallbackUrl !== void 0) {
      obj.fallbackUrl = message.fallbackUrl;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.hlsUrl !== void 0) {
      obj.hlsUrl = message.hlsUrl;
    }
    if (message.isGif !== void 0) {
      obj.isGif = message.isGif;
    }
    if (message.scrubberMediaUrl !== void 0) {
      obj.scrubberMediaUrl = message.scrubberMediaUrl;
    }
    if (message.transcodingStatus !== void 0) {
      obj.transcodingStatus = message.transcodingStatus;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    return obj;
  },
  create(base) {
    return RedditObject_RedditVideo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditObject_RedditVideo();
    message.bitrateKbps = object.bitrateKbps ?? void 0;
    message.dashUrl = object.dashUrl ?? void 0;
    message.duration = object.duration ?? void 0;
    message.fallbackUrl = object.fallbackUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.hlsUrl = object.hlsUrl ?? void 0;
    message.isGif = object.isGif ?? void 0;
    message.scrubberMediaUrl = object.scrubberMediaUrl ?? void 0;
    message.transcodingStatus = object.transcodingStatus ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditObject_RedditVideo.$type, RedditObject_RedditVideo);
function createBaseRedditObject_AuthorFlairRichText() {
  return { e: void 0, t: void 0, a: void 0, u: void 0 };
}
var RedditObject_AuthorFlairRichText = {
  $type: "devvit.plugin.redditapi.common.RedditObject.AuthorFlairRichText",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    if (message.a !== void 0) {
      StringValue.encode({ value: message.a }, writer.uint32(26).fork()).ldelim();
    }
    if (message.u !== void 0) {
      StringValue.encode({ value: message.u }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject_AuthorFlairRichText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.e = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.t = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.a = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.u = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      e: isSet22(object.e) ? String(object.e) : void 0,
      t: isSet22(object.t) ? String(object.t) : void 0,
      a: isSet22(object.a) ? String(object.a) : void 0,
      u: isSet22(object.u) ? String(object.u) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.e !== void 0) {
      obj.e = message.e;
    }
    if (message.t !== void 0) {
      obj.t = message.t;
    }
    if (message.a !== void 0) {
      obj.a = message.a;
    }
    if (message.u !== void 0) {
      obj.u = message.u;
    }
    return obj;
  },
  create(base) {
    return RedditObject_AuthorFlairRichText.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditObject_AuthorFlairRichText();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    message.a = object.a ?? void 0;
    message.u = object.u ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditObject_AuthorFlairRichText.$type, RedditObject_AuthorFlairRichText);
function createBaseRedditObject_LinkFlairRichText() {
  return { e: void 0, t: void 0, a: void 0, u: void 0 };
}
var RedditObject_LinkFlairRichText = {
  $type: "devvit.plugin.redditapi.common.RedditObject.LinkFlairRichText",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    if (message.a !== void 0) {
      StringValue.encode({ value: message.a }, writer.uint32(26).fork()).ldelim();
    }
    if (message.u !== void 0) {
      StringValue.encode({ value: message.u }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject_LinkFlairRichText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.e = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.t = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.a = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.u = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      e: isSet22(object.e) ? String(object.e) : void 0,
      t: isSet22(object.t) ? String(object.t) : void 0,
      a: isSet22(object.a) ? String(object.a) : void 0,
      u: isSet22(object.u) ? String(object.u) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.e !== void 0) {
      obj.e = message.e;
    }
    if (message.t !== void 0) {
      obj.t = message.t;
    }
    if (message.a !== void 0) {
      obj.a = message.a;
    }
    if (message.u !== void 0) {
      obj.u = message.u;
    }
    return obj;
  },
  create(base) {
    return RedditObject_LinkFlairRichText.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditObject_LinkFlairRichText();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    message.a = object.a ?? void 0;
    message.u = object.u ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditObject_LinkFlairRichText.$type, RedditObject_LinkFlairRichText);
function createBaseRedditObject_SecureMedia() {
  return { type: "", oembed: void 0, redditVideo: void 0 };
}
var RedditObject_SecureMedia = {
  $type: "devvit.plugin.redditapi.common.RedditObject.SecureMedia",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.oembed !== void 0) {
      RedditObject_OEmbed.encode(message.oembed, writer.uint32(18).fork()).ldelim();
    }
    if (message.redditVideo !== void 0) {
      RedditObject_RedditVideo.encode(message.redditVideo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject_SecureMedia();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.oembed = RedditObject_OEmbed.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.redditVideo = RedditObject_RedditVideo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet22(object.type) ? globalThis.String(object.type) : "",
      oembed: isSet22(object.oembed) ? RedditObject_OEmbed.fromJSON(object.oembed) : void 0,
      redditVideo: isSet22(object.redditVideo) ? RedditObject_RedditVideo.fromJSON(object.redditVideo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.oembed !== void 0) {
      obj.oembed = RedditObject_OEmbed.toJSON(message.oembed);
    }
    if (message.redditVideo !== void 0) {
      obj.redditVideo = RedditObject_RedditVideo.toJSON(message.redditVideo);
    }
    return obj;
  },
  create(base) {
    return RedditObject_SecureMedia.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditObject_SecureMedia();
    message.type = object.type ?? "";
    message.oembed = object.oembed !== void 0 && object.oembed !== null ? RedditObject_OEmbed.fromPartial(object.oembed) : void 0;
    message.redditVideo = object.redditVideo !== void 0 && object.redditVideo !== null ? RedditObject_RedditVideo.fromPartial(object.redditVideo) : void 0;
    return message;
  }
};
messageTypeRegistry.set(RedditObject_SecureMedia.$type, RedditObject_SecureMedia);
function createBaseSubredditObject() {
  return {
    defaultSet: void 0,
    userIsContributor: void 0,
    bannerImg: void 0,
    restrictPosting: void 0,
    userIsBanned: void 0,
    freeFormReports: void 0,
    communityIcon: void 0,
    showMedia: void 0,
    iconColor: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    coins: void 0,
    previousNames: [],
    over18: void 0,
    iconSize: [],
    primaryColor: void 0,
    iconImg: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    headerSize: void 0,
    restrictCommenting: void 0,
    subscribers: void 0,
    submitTextLabel: void 0,
    isDefaultIcon: void 0,
    linkFlairPosition: void 0,
    displayNamePrefixed: void 0,
    keyColor: void 0,
    name: void 0,
    isDefaultBanner: void 0,
    url: void 0,
    quarantine: void 0,
    bannerSize: [],
    userIsModerator: void 0,
    acceptFollowers: void 0,
    publicDescription: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    userIsSubscriber: void 0,
    publicDescriptionHtml: void 0,
    id: void 0,
    userIsMuted: false
  };
}
var SubredditObject = {
  $type: "devvit.plugin.redditapi.common.SubredditObject",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(34).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int64Value.encode({ value: message.coins }, writer.uint32(114).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(122).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(130).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(138).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(146).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(154).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(162).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(170).fork()).ldelim();
    }
    if (message.headerSize !== void 0) {
      StringValue.encode({ value: message.headerSize }, writer.uint32(178).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(218).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(274).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(338).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(346).fork()).ldelim();
    }
    if (message.userIsMuted !== false) {
      writer.uint32(352).bool(message.userIsMuted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.coins = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.headerSize = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }
          message.userIsMuted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet22(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      userIsContributor: isSet22(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      bannerImg: isSet22(object.bannerImg) ? String(object.bannerImg) : void 0,
      restrictPosting: isSet22(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      userIsBanned: isSet22(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet22(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      communityIcon: isSet22(object.communityIcon) ? String(object.communityIcon) : void 0,
      showMedia: isSet22(object.showMedia) ? Boolean(object.showMedia) : void 0,
      iconColor: isSet22(object.iconColor) ? String(object.iconColor) : void 0,
      displayName: isSet22(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet22(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet22(object.title) ? String(object.title) : void 0,
      coins: isSet22(object.coins) ? Number(object.coins) : void 0,
      previousNames: globalThis.Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      over18: isSet22(object.over18) ? Boolean(object.over18) : void 0,
      iconSize: globalThis.Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet22(object.primaryColor) ? String(object.primaryColor) : void 0,
      iconImg: isSet22(object.iconImg) ? String(object.iconImg) : void 0,
      description: isSet22(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet22(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      headerSize: isSet22(object.headerSize) ? String(object.headerSize) : void 0,
      restrictCommenting: isSet22(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      subscribers: isSet22(object.subscribers) ? Number(object.subscribers) : void 0,
      submitTextLabel: isSet22(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      isDefaultIcon: isSet22(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      linkFlairPosition: isSet22(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      displayNamePrefixed: isSet22(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      keyColor: isSet22(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet22(object.name) ? String(object.name) : void 0,
      isDefaultBanner: isSet22(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      url: isSet22(object.url) ? String(object.url) : void 0,
      quarantine: isSet22(object.quarantine) ? Boolean(object.quarantine) : void 0,
      bannerSize: globalThis.Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      userIsModerator: isSet22(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      acceptFollowers: isSet22(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      publicDescription: isSet22(object.publicDescription) ? String(object.publicDescription) : void 0,
      linkFlairEnabled: isSet22(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet22(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet22(object.subredditType) ? String(object.subredditType) : void 0,
      userIsSubscriber: isSet22(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      publicDescriptionHtml: isSet22(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      id: isSet22(object.id) ? String(object.id) : void 0,
      userIsMuted: isSet22(object.userIsMuted) ? globalThis.Boolean(object.userIsMuted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.defaultSet !== void 0) {
      obj.defaultSet = message.defaultSet;
    }
    if (message.userIsContributor !== void 0) {
      obj.userIsContributor = message.userIsContributor;
    }
    if (message.bannerImg !== void 0) {
      obj.bannerImg = message.bannerImg;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.userIsBanned !== void 0) {
      obj.userIsBanned = message.userIsBanned;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.iconColor !== void 0) {
      obj.iconColor = message.iconColor;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.headerImg !== void 0) {
      obj.headerImg = message.headerImg;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.coins !== void 0) {
      obj.coins = message.coins;
    }
    if (message.previousNames?.length) {
      obj.previousNames = message.previousNames;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.iconSize?.length) {
      obj.iconSize = message.iconSize;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.headerSize !== void 0) {
      obj.headerSize = message.headerSize;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.isDefaultIcon !== void 0) {
      obj.isDefaultIcon = message.isDefaultIcon;
    }
    if (message.linkFlairPosition !== void 0) {
      obj.linkFlairPosition = message.linkFlairPosition;
    }
    if (message.displayNamePrefixed !== void 0) {
      obj.displayNamePrefixed = message.displayNamePrefixed;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.isDefaultBanner !== void 0) {
      obj.isDefaultBanner = message.isDefaultBanner;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.bannerSize?.length) {
      obj.bannerSize = message.bannerSize;
    }
    if (message.userIsModerator !== void 0) {
      obj.userIsModerator = message.userIsModerator;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.linkFlairEnabled !== void 0) {
      obj.linkFlairEnabled = message.linkFlairEnabled;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.userIsSubscriber !== void 0) {
      obj.userIsSubscriber = message.userIsSubscriber;
    }
    if (message.publicDescriptionHtml !== void 0) {
      obj.publicDescriptionHtml = message.publicDescriptionHtml;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.userIsMuted !== false) {
      obj.userIsMuted = message.userIsMuted;
    }
    return obj;
  },
  create(base) {
    return SubredditObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditObject();
    message.defaultSet = object.defaultSet ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.coins = object.coins ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.over18 = object.over18 ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.headerSize = object.headerSize ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.url = object.url ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.id = object.id ?? void 0;
    message.userIsMuted = object.userIsMuted ?? false;
    return message;
  }
};
messageTypeRegistry.set(SubredditObject.$type, SubredditObject);
function createBaseJsonStatus() {
  return { json: void 0 };
}
var JsonStatus = {
  $type: "devvit.plugin.redditapi.common.JsonStatus",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.json !== void 0) {
      JsonStatus_JsonErrorType.encode(message.json, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }
          message.json = JsonStatus_JsonErrorType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet22(object.json) ? JsonStatus_JsonErrorType.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.json !== void 0) {
      obj.json = JsonStatus_JsonErrorType.toJSON(message.json);
    }
    return obj;
  },
  create(base) {
    return JsonStatus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonStatus();
    message.json = object.json !== void 0 && object.json !== null ? JsonStatus_JsonErrorType.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set(JsonStatus.$type, JsonStatus);
function createBaseJsonStatus_JsonErrorType() {
  return { errors: [] };
}
var JsonStatus_JsonErrorType = {
  $type: "devvit.plugin.redditapi.common.JsonStatus.JsonErrorType",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.errors) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonStatus_JsonErrorType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.errors.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    return obj;
  },
  create(base) {
    return JsonStatus_JsonErrorType.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonStatus_JsonErrorType();
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(JsonStatus_JsonErrorType.$type, JsonStatus_JsonErrorType);
function createBaseWrappedUserObject() {
  return { id: void 0, data: void 0 };
}
var WrappedUserObject = {
  $type: "devvit.plugin.redditapi.common.WrappedUserObject",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      User.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : import_minimal24.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWrappedUserObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet22(object.id) ? String(object.id) : void 0,
      data: isSet22(object.data) ? User.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.data !== void 0) {
      obj.data = User.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return WrappedUserObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWrappedUserObject();
    message.id = object.id ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? User.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WrappedUserObject.$type, WrappedUserObject);
function isSet22(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/effect.js
var import_minimal39 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/effects/v1alpha/interval.js
var import_minimal25 = __toESM(require_minimal2(), 1);
function createBaseSetIntervalsEffect() {
  return { intervals: {} };
}
var SetIntervalsEffect = {
  $type: "devvit.ui.effects.v1alpha.SetIntervalsEffect",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    Object.entries(message.intervals).forEach(([key, value]) => {
      SetIntervalsEffect_IntervalsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : import_minimal25.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetIntervalsEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = SetIntervalsEffect_IntervalsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.intervals[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      intervals: isObject5(object.intervals) ? Object.entries(object.intervals).reduce((acc, [key, value]) => {
        acc[key] = IntervalDetails.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.intervals) {
      const entries = Object.entries(message.intervals);
      if (entries.length > 0) {
        obj.intervals = {};
        entries.forEach(([k, v]) => {
          obj.intervals[k] = IntervalDetails.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return SetIntervalsEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetIntervalsEffect();
    message.intervals = Object.entries(object.intervals ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = IntervalDetails.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(SetIntervalsEffect.$type, SetIntervalsEffect);
function createBaseSetIntervalsEffect_IntervalsEntry() {
  return { key: "", value: void 0 };
}
var SetIntervalsEffect_IntervalsEntry = {
  $type: "devvit.ui.effects.v1alpha.SetIntervalsEffect.IntervalsEntry",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      IntervalDetails.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : import_minimal25.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetIntervalsEffect_IntervalsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = IntervalDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet23(object.key) ? globalThis.String(object.key) : "",
      value: isSet23(object.value) ? IntervalDetails.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = IntervalDetails.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return SetIntervalsEffect_IntervalsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetIntervalsEffect_IntervalsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? IntervalDetails.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SetIntervalsEffect_IntervalsEntry.$type, SetIntervalsEffect_IntervalsEntry);
function createBaseIntervalDetails() {
  return { duration: void 0, queue: void 0 };
}
var IntervalDetails = {
  $type: "devvit.ui.effects.v1alpha.IntervalDetails",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.duration !== void 0) {
      Duration.encode(message.duration, writer.uint32(10).fork()).ldelim();
    }
    if (message.queue !== void 0) {
      StringValue.encode({ value: message.queue }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : import_minimal25.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIntervalDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.queue = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      duration: isSet23(object.duration) ? Duration.fromJSON(object.duration) : void 0,
      queue: isSet23(object.queue) ? String(object.queue) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.duration !== void 0) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.queue !== void 0) {
      obj.queue = message.queue;
    }
    return obj;
  },
  create(base) {
    return IntervalDetails.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseIntervalDetails();
    message.duration = object.duration !== void 0 && object.duration !== null ? Duration.fromPartial(object.duration) : void 0;
    message.queue = object.queue ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(IntervalDetails.$type, IntervalDetails);
function isObject5(value) {
  return typeof value === "object" && value !== null;
}
function isSet23(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/navigate_to_url.js
var import_minimal26 = __toESM(require_minimal2(), 1);
function createBaseNavigateToUrlEffect() {
  return { url: "", target: void 0 };
}
var NavigateToUrlEffect = {
  $type: "devvit.ui.effects.v1alpha.NavigateToUrlEffect",
  encode(message, writer = import_minimal26.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.target !== void 0) {
      writer.uint32(18).string(message.target);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : import_minimal26.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNavigateToUrlEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.target = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet24(object.url) ? globalThis.String(object.url) : "",
      target: isSet24(object.target) ? globalThis.String(object.target) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.target !== void 0) {
      obj.target = message.target;
    }
    return obj;
  },
  create(base) {
    return NavigateToUrlEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNavigateToUrlEffect();
    message.url = object.url ?? "";
    message.target = object.target ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(NavigateToUrlEffect.$type, NavigateToUrlEffect);
function isSet24(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/realtime_subscriptions.js
var import_minimal28 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/events/v1alpha/realtime.js
var import_minimal27 = __toESM(require_minimal2(), 1);
function createBaseRealtimeRequest() {
  return { channels: [] };
}
var RealtimeRequest = {
  $type: "devvit.events.v1alpha.RealtimeRequest",
  encode(message, writer = import_minimal27.default.Writer.create()) {
    for (const v of message.channels) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal27.default.Reader ? input : import_minimal27.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.channels.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      channels: globalThis.Array.isArray(object?.channels) ? object.channels.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.channels?.length) {
      obj.channels = message.channels;
    }
    return obj;
  },
  create(base) {
    return RealtimeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRealtimeRequest();
    message.channels = object.channels?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(RealtimeRequest.$type, RealtimeRequest);
function createBaseRealtimeEvent() {
  return { channel: "", data: void 0 };
}
var RealtimeEvent = {
  $type: "devvit.events.v1alpha.RealtimeEvent",
  encode(message, writer = import_minimal27.default.Writer.create()) {
    if (message.channel !== "") {
      writer.uint32(10).string(message.channel);
    }
    if (message.data !== void 0) {
      Value.encode(Value.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal27.default.Reader ? input : import_minimal27.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.channel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      channel: isSet25(object.channel) ? globalThis.String(object.channel) : "",
      data: isSet25(object?.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return RealtimeEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRealtimeEvent();
    message.channel = object.channel ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RealtimeEvent.$type, RealtimeEvent);
function isSet25(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/realtime_subscriptions.js
var RealtimeSubscriptionStatus;
(function(RealtimeSubscriptionStatus2) {
  RealtimeSubscriptionStatus2[RealtimeSubscriptionStatus2["REALTIME_SUBSCRIBED"] = 0] = "REALTIME_SUBSCRIBED";
  RealtimeSubscriptionStatus2[RealtimeSubscriptionStatus2["REALTIME_UNSUBSCRIBED"] = 1] = "REALTIME_UNSUBSCRIBED";
  RealtimeSubscriptionStatus2[RealtimeSubscriptionStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RealtimeSubscriptionStatus || (RealtimeSubscriptionStatus = {}));
function realtimeSubscriptionStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "REALTIME_SUBSCRIBED":
      return RealtimeSubscriptionStatus.REALTIME_SUBSCRIBED;
    case 1:
    case "REALTIME_UNSUBSCRIBED":
      return RealtimeSubscriptionStatus.REALTIME_UNSUBSCRIBED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RealtimeSubscriptionStatus.UNRECOGNIZED;
  }
}
function realtimeSubscriptionStatusToJSON(object) {
  switch (object) {
    case RealtimeSubscriptionStatus.REALTIME_SUBSCRIBED:
      return 0;
    case RealtimeSubscriptionStatus.REALTIME_UNSUBSCRIBED:
      return 1;
    case RealtimeSubscriptionStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseRealtimeSubscriptionsEffect() {
  return { subscriptionIds: [] };
}
var RealtimeSubscriptionsEffect = {
  $type: "devvit.ui.effects.v1alpha.RealtimeSubscriptionsEffect",
  encode(message, writer = import_minimal28.default.Writer.create()) {
    for (const v of message.subscriptionIds) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : import_minimal28.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeSubscriptionsEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subscriptionIds: globalThis.Array.isArray(object?.subscriptionIds) ? object.subscriptionIds.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionIds?.length) {
      obj.subscriptionIds = message.subscriptionIds;
    }
    return obj;
  },
  create(base) {
    return RealtimeSubscriptionsEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRealtimeSubscriptionsEffect();
    message.subscriptionIds = object.subscriptionIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(RealtimeSubscriptionsEffect.$type, RealtimeSubscriptionsEffect);
function createBaseRealtimeSubscriptionEvent() {
  return { event: void 0, status: void 0 };
}
var RealtimeSubscriptionEvent = {
  $type: "devvit.ui.effects.v1alpha.RealtimeSubscriptionEvent",
  encode(message, writer = import_minimal28.default.Writer.create()) {
    if (message.event !== void 0) {
      RealtimeEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== void 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : import_minimal28.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeSubscriptionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.event = RealtimeEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.status = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      event: isSet26(object.event) ? RealtimeEvent.fromJSON(object.event) : void 0,
      status: isSet26(object.status) ? realtimeSubscriptionStatusFromJSON(object.status) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.event !== void 0) {
      obj.event = RealtimeEvent.toJSON(message.event);
    }
    if (message.status !== void 0) {
      obj.status = realtimeSubscriptionStatusToJSON(message.status);
    }
    return obj;
  },
  create(base) {
    return RealtimeSubscriptionEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRealtimeSubscriptionEvent();
    message.event = object.event !== void 0 && object.event !== null ? RealtimeEvent.fromPartial(object.event) : void 0;
    message.status = object.status ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RealtimeSubscriptionEvent.$type, RealtimeSubscriptionEvent);
function isSet26(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/reload_part.js
var import_minimal29 = __toESM(require_minimal2(), 1);
function createBaseReloadPartEffect() {
  return { subreddit: void 0, post: void 0, comment: void 0 };
}
var ReloadPartEffect = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect",
  encode(message, writer = import_minimal29.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      ReloadPartEffect_Subreddit.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.post !== void 0) {
      ReloadPartEffect_Post.encode(message.post, writer.uint32(18).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      ReloadPartEffect_Comment.encode(message.comment, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : import_minimal29.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = ReloadPartEffect_Subreddit.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.post = ReloadPartEffect_Post.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.comment = ReloadPartEffect_Comment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet27(object.subreddit) ? ReloadPartEffect_Subreddit.fromJSON(object.subreddit) : void 0,
      post: isSet27(object.post) ? ReloadPartEffect_Post.fromJSON(object.post) : void 0,
      comment: isSet27(object.comment) ? ReloadPartEffect_Comment.fromJSON(object.comment) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = ReloadPartEffect_Subreddit.toJSON(message.subreddit);
    }
    if (message.post !== void 0) {
      obj.post = ReloadPartEffect_Post.toJSON(message.post);
    }
    if (message.comment !== void 0) {
      obj.comment = ReloadPartEffect_Comment.toJSON(message.comment);
    }
    return obj;
  },
  create(base) {
    return ReloadPartEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? ReloadPartEffect_Subreddit.fromPartial(object.subreddit) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? ReloadPartEffect_Post.fromPartial(object.post) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? ReloadPartEffect_Comment.fromPartial(object.comment) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ReloadPartEffect.$type, ReloadPartEffect);
function createBaseReloadPartEffect_Subreddit() {
  return { subredditId: "" };
}
var ReloadPartEffect_Subreddit = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Subreddit",
  encode(message, writer = import_minimal29.default.Writer.create()) {
    if (message.subredditId !== "") {
      writer.uint32(10).string(message.subredditId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : import_minimal29.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect_Subreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subredditId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subredditId: isSet27(object.subredditId) ? globalThis.String(object.subredditId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subredditId !== "") {
      obj.subredditId = message.subredditId;
    }
    return obj;
  },
  create(base) {
    return ReloadPartEffect_Subreddit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect_Subreddit();
    message.subredditId = object.subredditId ?? "";
    return message;
  }
};
messageTypeRegistry.set(ReloadPartEffect_Subreddit.$type, ReloadPartEffect_Subreddit);
function createBaseReloadPartEffect_Post() {
  return { postId: "", body: void 0, comments: void 0 };
}
var ReloadPartEffect_Post = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Post",
  encode(message, writer = import_minimal29.default.Writer.create()) {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.body !== void 0) {
      writer.uint32(16).bool(message.body);
    }
    if (message.comments !== void 0) {
      writer.uint32(24).bool(message.comments);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : import_minimal29.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect_Post();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.postId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.body = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.comments = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      postId: isSet27(object.postId) ? globalThis.String(object.postId) : "",
      body: isSet27(object.body) ? globalThis.Boolean(object.body) : void 0,
      comments: isSet27(object.comments) ? globalThis.Boolean(object.comments) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.postId !== "") {
      obj.postId = message.postId;
    }
    if (message.body !== void 0) {
      obj.body = message.body;
    }
    if (message.comments !== void 0) {
      obj.comments = message.comments;
    }
    return obj;
  },
  create(base) {
    return ReloadPartEffect_Post.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect_Post();
    message.postId = object.postId ?? "";
    message.body = object.body ?? void 0;
    message.comments = object.comments ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ReloadPartEffect_Post.$type, ReloadPartEffect_Post);
function createBaseReloadPartEffect_Comment() {
  return { postId: "", commentId: "", replies: void 0 };
}
var ReloadPartEffect_Comment = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Comment",
  encode(message, writer = import_minimal29.default.Writer.create()) {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.commentId !== "") {
      writer.uint32(18).string(message.commentId);
    }
    if (message.replies !== void 0) {
      writer.uint32(24).bool(message.replies);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : import_minimal29.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect_Comment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.postId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.commentId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.replies = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      postId: isSet27(object.postId) ? globalThis.String(object.postId) : "",
      commentId: isSet27(object.commentId) ? globalThis.String(object.commentId) : "",
      replies: isSet27(object.replies) ? globalThis.Boolean(object.replies) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.postId !== "") {
      obj.postId = message.postId;
    }
    if (message.commentId !== "") {
      obj.commentId = message.commentId;
    }
    if (message.replies !== void 0) {
      obj.replies = message.replies;
    }
    return obj;
  },
  create(base) {
    return ReloadPartEffect_Comment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect_Comment();
    message.postId = object.postId ?? "";
    message.commentId = object.commentId ?? "";
    message.replies = object.replies ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ReloadPartEffect_Comment.$type, ReloadPartEffect_Comment);
function isSet27(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/rerender_ui.js
var import_minimal30 = __toESM(require_minimal2(), 1);
function createBaseRerenderEffect() {
  return { delaySeconds: void 0 };
}
var RerenderEffect = {
  $type: "devvit.ui.effects.v1alpha.RerenderEffect",
  encode(message, writer = import_minimal30.default.Writer.create()) {
    if (message.delaySeconds !== void 0) {
      writer.uint32(13).float(message.delaySeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal30.default.Reader ? input : import_minimal30.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRerenderEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }
          message.delaySeconds = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { delaySeconds: isSet28(object.delaySeconds) ? globalThis.Number(object.delaySeconds) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.delaySeconds !== void 0) {
      obj.delaySeconds = message.delaySeconds;
    }
    return obj;
  },
  create(base) {
    return RerenderEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRerenderEffect();
    message.delaySeconds = object.delaySeconds ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RerenderEffect.$type, RerenderEffect);
function isSet28(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/send_event.js
var import_minimal38 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/events/v1alpha/event.js
var import_minimal37 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_form.js
var import_minimal34 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/form.js
var import_minimal33 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/field.js
var import_minimal32 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/type.js
var FormFieldType;
(function(FormFieldType2) {
  FormFieldType2[FormFieldType2["STRING"] = 0] = "STRING";
  FormFieldType2[FormFieldType2["PARAGRAPH"] = 1] = "PARAGRAPH";
  FormFieldType2[FormFieldType2["NUMBER"] = 2] = "NUMBER";
  FormFieldType2[FormFieldType2["BOOLEAN"] = 3] = "BOOLEAN";
  FormFieldType2[FormFieldType2["LIST"] = 4] = "LIST";
  FormFieldType2[FormFieldType2["SELECTION"] = 5] = "SELECTION";
  FormFieldType2[FormFieldType2["GROUP"] = 6] = "GROUP";
  FormFieldType2[FormFieldType2["IMAGE"] = 7] = "IMAGE";
  FormFieldType2[FormFieldType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FormFieldType || (FormFieldType = {}));
function formFieldTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return FormFieldType.STRING;
    case 1:
    case "PARAGRAPH":
      return FormFieldType.PARAGRAPH;
    case 2:
    case "NUMBER":
      return FormFieldType.NUMBER;
    case 3:
    case "BOOLEAN":
      return FormFieldType.BOOLEAN;
    case 4:
    case "LIST":
      return FormFieldType.LIST;
    case 5:
    case "SELECTION":
      return FormFieldType.SELECTION;
    case 6:
    case "GROUP":
      return FormFieldType.GROUP;
    case 7:
    case "IMAGE":
      return FormFieldType.IMAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FormFieldType.UNRECOGNIZED;
  }
}
function formFieldTypeToJSON(object) {
  switch (object) {
    case FormFieldType.STRING:
      return 0;
    case FormFieldType.PARAGRAPH:
      return 1;
    case FormFieldType.NUMBER:
      return 2;
    case FormFieldType.BOOLEAN:
      return 3;
    case FormFieldType.LIST:
      return 4;
    case FormFieldType.SELECTION:
      return 5;
    case FormFieldType.GROUP:
      return 6;
    case FormFieldType.IMAGE:
      return 7;
    case FormFieldType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/value.js
var import_minimal31 = __toESM(require_minimal2(), 1);
function createBaseFormFieldValue() {
  return {
    fieldType: 0,
    isSecret: void 0,
    stringValue: void 0,
    numberValue: void 0,
    boolValue: void 0,
    listValue: void 0,
    selectionValue: void 0,
    groupValue: void 0
  };
}
var FormFieldValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.fieldType !== 0) {
      writer.uint32(8).int32(message.fieldType);
    }
    if (message.isSecret !== void 0) {
      writer.uint32(800).bool(message.isSecret);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(25).double(message.numberValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.listValue !== void 0) {
      FormFieldValue_ListValue.encode(message.listValue, writer.uint32(42).fork()).ldelim();
    }
    if (message.selectionValue !== void 0) {
      FormFieldValue_SelectionValue.encode(message.selectionValue, writer.uint32(50).fork()).ldelim();
    }
    if (message.groupValue !== void 0) {
      FormFieldValue_GroupValue.encode(message.groupValue, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : import_minimal31.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.fieldType = reader.int32();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.isSecret = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }
          message.numberValue = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.listValue = FormFieldValue_ListValue.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.selectionValue = FormFieldValue_SelectionValue.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.groupValue = FormFieldValue_GroupValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldType: isSet29(object.fieldType) ? formFieldTypeFromJSON(object.fieldType) : 0,
      isSecret: isSet29(object.isSecret) ? globalThis.Boolean(object.isSecret) : void 0,
      stringValue: isSet29(object.stringValue) ? globalThis.String(object.stringValue) : void 0,
      numberValue: isSet29(object.numberValue) ? globalThis.Number(object.numberValue) : void 0,
      boolValue: isSet29(object.boolValue) ? globalThis.Boolean(object.boolValue) : void 0,
      listValue: isSet29(object.listValue) ? FormFieldValue_ListValue.fromJSON(object.listValue) : void 0,
      selectionValue: isSet29(object.selectionValue) ? FormFieldValue_SelectionValue.fromJSON(object.selectionValue) : void 0,
      groupValue: isSet29(object.groupValue) ? FormFieldValue_GroupValue.fromJSON(object.groupValue) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fieldType !== 0) {
      obj.fieldType = formFieldTypeToJSON(message.fieldType);
    }
    if (message.isSecret !== void 0) {
      obj.isSecret = message.isSecret;
    }
    if (message.stringValue !== void 0) {
      obj.stringValue = message.stringValue;
    }
    if (message.numberValue !== void 0) {
      obj.numberValue = message.numberValue;
    }
    if (message.boolValue !== void 0) {
      obj.boolValue = message.boolValue;
    }
    if (message.listValue !== void 0) {
      obj.listValue = FormFieldValue_ListValue.toJSON(message.listValue);
    }
    if (message.selectionValue !== void 0) {
      obj.selectionValue = FormFieldValue_SelectionValue.toJSON(message.selectionValue);
    }
    if (message.groupValue !== void 0) {
      obj.groupValue = FormFieldValue_GroupValue.toJSON(message.groupValue);
    }
    return obj;
  },
  create(base) {
    return FormFieldValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormFieldValue();
    message.fieldType = object.fieldType ?? 0;
    message.isSecret = object.isSecret ?? void 0;
    message.stringValue = object.stringValue ?? void 0;
    message.numberValue = object.numberValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    message.listValue = object.listValue !== void 0 && object.listValue !== null ? FormFieldValue_ListValue.fromPartial(object.listValue) : void 0;
    message.selectionValue = object.selectionValue !== void 0 && object.selectionValue !== null ? FormFieldValue_SelectionValue.fromPartial(object.selectionValue) : void 0;
    message.groupValue = object.groupValue !== void 0 && object.groupValue !== null ? FormFieldValue_GroupValue.fromPartial(object.groupValue) : void 0;
    return message;
  }
};
messageTypeRegistry.set(FormFieldValue.$type, FormFieldValue);
function createBaseFormFieldValue_ListValue() {
  return { itemType: 0, items: [] };
}
var FormFieldValue_ListValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.ListValue",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.itemType !== 0) {
      writer.uint32(8).int32(message.itemType);
    }
    for (const v of message.items) {
      FormFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : import_minimal31.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue_ListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.itemType = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.items.push(FormFieldValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      itemType: isSet29(object.itemType) ? formFieldTypeFromJSON(object.itemType) : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => FormFieldValue.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.itemType !== 0) {
      obj.itemType = formFieldTypeToJSON(message.itemType);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => FormFieldValue.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FormFieldValue_ListValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormFieldValue_ListValue();
    message.itemType = object.itemType ?? 0;
    message.items = object.items?.map((e) => FormFieldValue.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FormFieldValue_ListValue.$type, FormFieldValue_ListValue);
function createBaseFormFieldValue_SelectionValue() {
  return { values: [] };
}
var FormFieldValue_SelectionValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.SelectionValue",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    for (const v of message.values) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : import_minimal31.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue_SelectionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return FormFieldValue_SelectionValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormFieldValue_SelectionValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(FormFieldValue_SelectionValue.$type, FormFieldValue_SelectionValue);
function createBaseFormFieldValue_GroupValue() {
  return {};
}
var FormFieldValue_GroupValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.GroupValue",
  encode(_, writer = import_minimal31.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : import_minimal31.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue_GroupValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return FormFieldValue_GroupValue.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseFormFieldValue_GroupValue();
    return message;
  }
};
messageTypeRegistry.set(FormFieldValue_GroupValue.$type, FormFieldValue_GroupValue);
function isSet29(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/field.js
function createBaseFormField() {
  return {
    fieldId: "",
    fieldType: 0,
    label: "",
    helpText: void 0,
    defaultValue: void 0,
    required: void 0,
    disabled: void 0,
    fieldConfig: void 0,
    isSecret: void 0
  };
}
var FormField = {
  $type: "devvit.ui.form_builder.v1alpha.FormField",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.fieldId !== "") {
      writer.uint32(10).string(message.fieldId);
    }
    if (message.fieldType !== 0) {
      writer.uint32(16).int32(message.fieldType);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.helpText !== void 0) {
      writer.uint32(34).string(message.helpText);
    }
    if (message.defaultValue !== void 0) {
      FormFieldValue.encode(message.defaultValue, writer.uint32(42).fork()).ldelim();
    }
    if (message.required !== void 0) {
      writer.uint32(48).bool(message.required);
    }
    if (message.disabled !== void 0) {
      writer.uint32(56).bool(message.disabled);
    }
    if (message.fieldConfig !== void 0) {
      FieldConfig.encode(message.fieldConfig, writer.uint32(66).fork()).ldelim();
    }
    if (message.isSecret !== void 0) {
      writer.uint32(72).bool(message.isSecret);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fieldId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.fieldType = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.helpText = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.defaultValue = FormFieldValue.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.required = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.disabled = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.fieldConfig = FieldConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.isSecret = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldId: isSet30(object.fieldId) ? globalThis.String(object.fieldId) : "",
      fieldType: isSet30(object.fieldType) ? formFieldTypeFromJSON(object.fieldType) : 0,
      label: isSet30(object.label) ? globalThis.String(object.label) : "",
      helpText: isSet30(object.helpText) ? globalThis.String(object.helpText) : void 0,
      defaultValue: isSet30(object.defaultValue) ? FormFieldValue.fromJSON(object.defaultValue) : void 0,
      required: isSet30(object.required) ? globalThis.Boolean(object.required) : void 0,
      disabled: isSet30(object.disabled) ? globalThis.Boolean(object.disabled) : void 0,
      fieldConfig: isSet30(object.fieldConfig) ? FieldConfig.fromJSON(object.fieldConfig) : void 0,
      isSecret: isSet30(object.isSecret) ? globalThis.Boolean(object.isSecret) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fieldId !== "") {
      obj.fieldId = message.fieldId;
    }
    if (message.fieldType !== 0) {
      obj.fieldType = formFieldTypeToJSON(message.fieldType);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.helpText !== void 0) {
      obj.helpText = message.helpText;
    }
    if (message.defaultValue !== void 0) {
      obj.defaultValue = FormFieldValue.toJSON(message.defaultValue);
    }
    if (message.required !== void 0) {
      obj.required = message.required;
    }
    if (message.disabled !== void 0) {
      obj.disabled = message.disabled;
    }
    if (message.fieldConfig !== void 0) {
      obj.fieldConfig = FieldConfig.toJSON(message.fieldConfig);
    }
    if (message.isSecret !== void 0) {
      obj.isSecret = message.isSecret;
    }
    return obj;
  },
  create(base) {
    return FormField.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormField();
    message.fieldId = object.fieldId ?? "";
    message.fieldType = object.fieldType ?? 0;
    message.label = object.label ?? "";
    message.helpText = object.helpText ?? void 0;
    message.defaultValue = object.defaultValue !== void 0 && object.defaultValue !== null ? FormFieldValue.fromPartial(object.defaultValue) : void 0;
    message.required = object.required ?? void 0;
    message.disabled = object.disabled ?? void 0;
    message.fieldConfig = object.fieldConfig !== void 0 && object.fieldConfig !== null ? FieldConfig.fromPartial(object.fieldConfig) : void 0;
    message.isSecret = object.isSecret ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FormField.$type, FormField);
function createBaseFieldConfig() {
  return {
    stringConfig: void 0,
    paragraphConfig: void 0,
    numberConfig: void 0,
    booleanConfig: void 0,
    listConfig: void 0,
    selectionConfig: void 0,
    groupConfig: void 0
  };
}
var FieldConfig = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.stringConfig !== void 0) {
      FieldConfig_String.encode(message.stringConfig, writer.uint32(10).fork()).ldelim();
    }
    if (message.paragraphConfig !== void 0) {
      FieldConfig_Paragraph.encode(message.paragraphConfig, writer.uint32(18).fork()).ldelim();
    }
    if (message.numberConfig !== void 0) {
      FieldConfig_Number.encode(message.numberConfig, writer.uint32(26).fork()).ldelim();
    }
    if (message.booleanConfig !== void 0) {
      FieldConfig_Boolean.encode(message.booleanConfig, writer.uint32(34).fork()).ldelim();
    }
    if (message.listConfig !== void 0) {
      FieldConfig_List.encode(message.listConfig, writer.uint32(42).fork()).ldelim();
    }
    if (message.selectionConfig !== void 0) {
      FieldConfig_Selection.encode(message.selectionConfig, writer.uint32(50).fork()).ldelim();
    }
    if (message.groupConfig !== void 0) {
      FieldConfig_Group.encode(message.groupConfig, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.stringConfig = FieldConfig_String.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.paragraphConfig = FieldConfig_Paragraph.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.numberConfig = FieldConfig_Number.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.booleanConfig = FieldConfig_Boolean.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.listConfig = FieldConfig_List.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.selectionConfig = FieldConfig_Selection.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.groupConfig = FieldConfig_Group.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      stringConfig: isSet30(object.stringConfig) ? FieldConfig_String.fromJSON(object.stringConfig) : void 0,
      paragraphConfig: isSet30(object.paragraphConfig) ? FieldConfig_Paragraph.fromJSON(object.paragraphConfig) : void 0,
      numberConfig: isSet30(object.numberConfig) ? FieldConfig_Number.fromJSON(object.numberConfig) : void 0,
      booleanConfig: isSet30(object.booleanConfig) ? FieldConfig_Boolean.fromJSON(object.booleanConfig) : void 0,
      listConfig: isSet30(object.listConfig) ? FieldConfig_List.fromJSON(object.listConfig) : void 0,
      selectionConfig: isSet30(object.selectionConfig) ? FieldConfig_Selection.fromJSON(object.selectionConfig) : void 0,
      groupConfig: isSet30(object.groupConfig) ? FieldConfig_Group.fromJSON(object.groupConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.stringConfig !== void 0) {
      obj.stringConfig = FieldConfig_String.toJSON(message.stringConfig);
    }
    if (message.paragraphConfig !== void 0) {
      obj.paragraphConfig = FieldConfig_Paragraph.toJSON(message.paragraphConfig);
    }
    if (message.numberConfig !== void 0) {
      obj.numberConfig = FieldConfig_Number.toJSON(message.numberConfig);
    }
    if (message.booleanConfig !== void 0) {
      obj.booleanConfig = FieldConfig_Boolean.toJSON(message.booleanConfig);
    }
    if (message.listConfig !== void 0) {
      obj.listConfig = FieldConfig_List.toJSON(message.listConfig);
    }
    if (message.selectionConfig !== void 0) {
      obj.selectionConfig = FieldConfig_Selection.toJSON(message.selectionConfig);
    }
    if (message.groupConfig !== void 0) {
      obj.groupConfig = FieldConfig_Group.toJSON(message.groupConfig);
    }
    return obj;
  },
  create(base) {
    return FieldConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig();
    message.stringConfig = object.stringConfig !== void 0 && object.stringConfig !== null ? FieldConfig_String.fromPartial(object.stringConfig) : void 0;
    message.paragraphConfig = object.paragraphConfig !== void 0 && object.paragraphConfig !== null ? FieldConfig_Paragraph.fromPartial(object.paragraphConfig) : void 0;
    message.numberConfig = object.numberConfig !== void 0 && object.numberConfig !== null ? FieldConfig_Number.fromPartial(object.numberConfig) : void 0;
    message.booleanConfig = object.booleanConfig !== void 0 && object.booleanConfig !== null ? FieldConfig_Boolean.fromPartial(object.booleanConfig) : void 0;
    message.listConfig = object.listConfig !== void 0 && object.listConfig !== null ? FieldConfig_List.fromPartial(object.listConfig) : void 0;
    message.selectionConfig = object.selectionConfig !== void 0 && object.selectionConfig !== null ? FieldConfig_Selection.fromPartial(object.selectionConfig) : void 0;
    message.groupConfig = object.groupConfig !== void 0 && object.groupConfig !== null ? FieldConfig_Group.fromPartial(object.groupConfig) : void 0;
    return message;
  }
};
messageTypeRegistry.set(FieldConfig.$type, FieldConfig);
function createBaseFieldConfig_String() {
  return { minLength: void 0, maxLength: void 0, placeholder: void 0 };
}
var FieldConfig_String = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.String",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.minLength !== void 0) {
      writer.uint32(8).int32(message.minLength);
    }
    if (message.maxLength !== void 0) {
      writer.uint32(16).int32(message.maxLength);
    }
    if (message.placeholder !== void 0) {
      writer.uint32(26).string(message.placeholder);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_String();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.minLength = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.maxLength = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.placeholder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      minLength: isSet30(object.minLength) ? globalThis.Number(object.minLength) : void 0,
      maxLength: isSet30(object.maxLength) ? globalThis.Number(object.maxLength) : void 0,
      placeholder: isSet30(object.placeholder) ? globalThis.String(object.placeholder) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.minLength !== void 0) {
      obj.minLength = Math.round(message.minLength);
    }
    if (message.maxLength !== void 0) {
      obj.maxLength = Math.round(message.maxLength);
    }
    if (message.placeholder !== void 0) {
      obj.placeholder = message.placeholder;
    }
    return obj;
  },
  create(base) {
    return FieldConfig_String.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_String();
    message.minLength = object.minLength ?? void 0;
    message.maxLength = object.maxLength ?? void 0;
    message.placeholder = object.placeholder ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_String.$type, FieldConfig_String);
function createBaseFieldConfig_Paragraph() {
  return { maxCharacters: void 0, lineHeight: void 0, placeholder: void 0 };
}
var FieldConfig_Paragraph = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Paragraph",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.maxCharacters !== void 0) {
      writer.uint32(8).int32(message.maxCharacters);
    }
    if (message.lineHeight !== void 0) {
      writer.uint32(16).int32(message.lineHeight);
    }
    if (message.placeholder !== void 0) {
      writer.uint32(26).string(message.placeholder);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Paragraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.maxCharacters = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.lineHeight = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.placeholder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxCharacters: isSet30(object.maxCharacters) ? globalThis.Number(object.maxCharacters) : void 0,
      lineHeight: isSet30(object.lineHeight) ? globalThis.Number(object.lineHeight) : void 0,
      placeholder: isSet30(object.placeholder) ? globalThis.String(object.placeholder) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.maxCharacters !== void 0) {
      obj.maxCharacters = Math.round(message.maxCharacters);
    }
    if (message.lineHeight !== void 0) {
      obj.lineHeight = Math.round(message.lineHeight);
    }
    if (message.placeholder !== void 0) {
      obj.placeholder = message.placeholder;
    }
    return obj;
  },
  create(base) {
    return FieldConfig_Paragraph.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Paragraph();
    message.maxCharacters = object.maxCharacters ?? void 0;
    message.lineHeight = object.lineHeight ?? void 0;
    message.placeholder = object.placeholder ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_Paragraph.$type, FieldConfig_Paragraph);
function createBaseFieldConfig_Number() {
  return { step: void 0, min: void 0, max: void 0 };
}
var FieldConfig_Number = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Number",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.step !== void 0) {
      writer.uint32(9).double(message.step);
    }
    if (message.min !== void 0) {
      writer.uint32(17).double(message.min);
    }
    if (message.max !== void 0) {
      writer.uint32(25).double(message.max);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Number();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }
          message.step = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.min = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }
          message.max = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      step: isSet30(object.step) ? globalThis.Number(object.step) : void 0,
      min: isSet30(object.min) ? globalThis.Number(object.min) : void 0,
      max: isSet30(object.max) ? globalThis.Number(object.max) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.step !== void 0) {
      obj.step = message.step;
    }
    if (message.min !== void 0) {
      obj.min = message.min;
    }
    if (message.max !== void 0) {
      obj.max = message.max;
    }
    return obj;
  },
  create(base) {
    return FieldConfig_Number.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Number();
    message.step = object.step ?? void 0;
    message.min = object.min ?? void 0;
    message.max = object.max ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_Number.$type, FieldConfig_Number);
function createBaseFieldConfig_Boolean() {
  return {};
}
var FieldConfig_Boolean = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Boolean",
  encode(_, writer = import_minimal32.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Boolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return FieldConfig_Boolean.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseFieldConfig_Boolean();
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_Boolean.$type, FieldConfig_Boolean);
function createBaseFieldConfig_List() {
  return { itemType: 0, itemConfig: void 0, minEntries: void 0, maxEntries: void 0, entryLabel: void 0 };
}
var FieldConfig_List = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.List",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.itemType !== 0) {
      writer.uint32(8).int32(message.itemType);
    }
    if (message.itemConfig !== void 0) {
      FieldConfig.encode(message.itemConfig, writer.uint32(18).fork()).ldelim();
    }
    if (message.minEntries !== void 0) {
      writer.uint32(24).int32(message.minEntries);
    }
    if (message.maxEntries !== void 0) {
      writer.uint32(32).int32(message.maxEntries);
    }
    if (message.entryLabel !== void 0) {
      writer.uint32(42).string(message.entryLabel);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_List();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.itemType = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.itemConfig = FieldConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.minEntries = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.maxEntries = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.entryLabel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      itemType: isSet30(object.itemType) ? formFieldTypeFromJSON(object.itemType) : 0,
      itemConfig: isSet30(object.itemConfig) ? FieldConfig.fromJSON(object.itemConfig) : void 0,
      minEntries: isSet30(object.minEntries) ? globalThis.Number(object.minEntries) : void 0,
      maxEntries: isSet30(object.maxEntries) ? globalThis.Number(object.maxEntries) : void 0,
      entryLabel: isSet30(object.entryLabel) ? globalThis.String(object.entryLabel) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.itemType !== 0) {
      obj.itemType = formFieldTypeToJSON(message.itemType);
    }
    if (message.itemConfig !== void 0) {
      obj.itemConfig = FieldConfig.toJSON(message.itemConfig);
    }
    if (message.minEntries !== void 0) {
      obj.minEntries = Math.round(message.minEntries);
    }
    if (message.maxEntries !== void 0) {
      obj.maxEntries = Math.round(message.maxEntries);
    }
    if (message.entryLabel !== void 0) {
      obj.entryLabel = message.entryLabel;
    }
    return obj;
  },
  create(base) {
    return FieldConfig_List.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_List();
    message.itemType = object.itemType ?? 0;
    message.itemConfig = object.itemConfig !== void 0 && object.itemConfig !== null ? FieldConfig.fromPartial(object.itemConfig) : void 0;
    message.minEntries = object.minEntries ?? void 0;
    message.maxEntries = object.maxEntries ?? void 0;
    message.entryLabel = object.entryLabel ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_List.$type, FieldConfig_List);
function createBaseFieldConfig_Selection() {
  return {
    choices: [],
    multiSelect: void 0,
    minSelections: void 0,
    maxSelections: void 0,
    renderAsList: void 0
  };
}
var FieldConfig_Selection = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Selection",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    for (const v of message.choices) {
      FieldConfig_Selection_Item.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.multiSelect !== void 0) {
      writer.uint32(16).bool(message.multiSelect);
    }
    if (message.minSelections !== void 0) {
      writer.uint32(24).int32(message.minSelections);
    }
    if (message.maxSelections !== void 0) {
      writer.uint32(32).int32(message.maxSelections);
    }
    if (message.renderAsList !== void 0) {
      writer.uint32(40).bool(message.renderAsList);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Selection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.choices.push(FieldConfig_Selection_Item.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.multiSelect = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.minSelections = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.maxSelections = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.renderAsList = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      choices: globalThis.Array.isArray(object?.choices) ? object.choices.map((e) => FieldConfig_Selection_Item.fromJSON(e)) : [],
      multiSelect: isSet30(object.multiSelect) ? globalThis.Boolean(object.multiSelect) : void 0,
      minSelections: isSet30(object.minSelections) ? globalThis.Number(object.minSelections) : void 0,
      maxSelections: isSet30(object.maxSelections) ? globalThis.Number(object.maxSelections) : void 0,
      renderAsList: isSet30(object.renderAsList) ? globalThis.Boolean(object.renderAsList) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => FieldConfig_Selection_Item.toJSON(e));
    }
    if (message.multiSelect !== void 0) {
      obj.multiSelect = message.multiSelect;
    }
    if (message.minSelections !== void 0) {
      obj.minSelections = Math.round(message.minSelections);
    }
    if (message.maxSelections !== void 0) {
      obj.maxSelections = Math.round(message.maxSelections);
    }
    if (message.renderAsList !== void 0) {
      obj.renderAsList = message.renderAsList;
    }
    return obj;
  },
  create(base) {
    return FieldConfig_Selection.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Selection();
    message.choices = object.choices?.map((e) => FieldConfig_Selection_Item.fromPartial(e)) || [];
    message.multiSelect = object.multiSelect ?? void 0;
    message.minSelections = object.minSelections ?? void 0;
    message.maxSelections = object.maxSelections ?? void 0;
    message.renderAsList = object.renderAsList ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_Selection.$type, FieldConfig_Selection);
function createBaseFieldConfig_Selection_Item() {
  return { label: "", value: "" };
}
var FieldConfig_Selection_Item = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Selection.Item",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Selection_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet30(object.label) ? globalThis.String(object.label) : "",
      value: isSet30(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FieldConfig_Selection_Item.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Selection_Item();
    message.label = object.label ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_Selection_Item.$type, FieldConfig_Selection_Item);
function createBaseFieldConfig_Group() {
  return { fields: [] };
}
var FieldConfig_Group = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Group",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    for (const v of message.fields) {
      FormField.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : import_minimal32.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Group();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fields.push(FormField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => FormField.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => FormField.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FieldConfig_Group.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Group();
    message.fields = object.fields?.map((e) => FormField.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FieldConfig_Group.$type, FieldConfig_Group);
function isSet30(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/form.js
function createBaseForm() {
  return {
    fields: [],
    title: void 0,
    shortDescription: void 0,
    acceptLabel: void 0,
    cancelLabel: void 0,
    id: void 0
  };
}
var Form = {
  $type: "devvit.ui.form_builder.v1alpha.Form",
  encode(message, writer = import_minimal33.default.Writer.create()) {
    for (const v of message.fields) {
      FormField.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.title !== void 0) {
      writer.uint32(18).string(message.title);
    }
    if (message.shortDescription !== void 0) {
      writer.uint32(26).string(message.shortDescription);
    }
    if (message.acceptLabel !== void 0) {
      writer.uint32(34).string(message.acceptLabel);
    }
    if (message.cancelLabel !== void 0) {
      writer.uint32(42).string(message.cancelLabel);
    }
    if (message.id !== void 0) {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal33.default.Reader ? input : import_minimal33.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fields.push(FormField.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.acceptLabel = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.cancelLabel = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => FormField.fromJSON(e)) : [],
      title: isSet31(object.title) ? globalThis.String(object.title) : void 0,
      shortDescription: isSet31(object.shortDescription) ? globalThis.String(object.shortDescription) : void 0,
      acceptLabel: isSet31(object.acceptLabel) ? globalThis.String(object.acceptLabel) : void 0,
      cancelLabel: isSet31(object.cancelLabel) ? globalThis.String(object.cancelLabel) : void 0,
      id: isSet31(object.id) ? globalThis.String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => FormField.toJSON(e));
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.shortDescription !== void 0) {
      obj.shortDescription = message.shortDescription;
    }
    if (message.acceptLabel !== void 0) {
      obj.acceptLabel = message.acceptLabel;
    }
    if (message.cancelLabel !== void 0) {
      obj.cancelLabel = message.cancelLabel;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return Form.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseForm();
    message.fields = object.fields?.map((e) => FormField.fromPartial(e)) || [];
    message.title = object.title ?? void 0;
    message.shortDescription = object.shortDescription ?? void 0;
    message.acceptLabel = object.acceptLabel ?? void 0;
    message.cancelLabel = object.cancelLabel ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Form.$type, Form);
function isSet31(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_form.js
function createBaseShowFormEffect() {
  return { form: void 0 };
}
var ShowFormEffect = {
  $type: "devvit.ui.effects.v1alpha.ShowFormEffect",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    if (message.form !== void 0) {
      Form.encode(message.form, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : import_minimal34.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShowFormEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.form = Form.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { form: isSet32(object.form) ? Form.fromJSON(object.form) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.form !== void 0) {
      obj.form = Form.toJSON(message.form);
    }
    return obj;
  },
  create(base) {
    return ShowFormEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseShowFormEffect();
    message.form = object.form !== void 0 && object.form !== null ? Form.fromPartial(object.form) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ShowFormEffect.$type, ShowFormEffect);
function createBaseFormSubmittedEvent() {
  return { results: {}, formId: void 0 };
}
var FormSubmittedEvent = {
  $type: "devvit.ui.effects.v1alpha.FormSubmittedEvent",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    Object.entries(message.results).forEach(([key, value]) => {
      FormSubmittedEvent_ResultsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.formId !== void 0) {
      writer.uint32(18).string(message.formId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : import_minimal34.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormSubmittedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = FormSubmittedEvent_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.formId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      results: isObject6(object.results) ? Object.entries(object.results).reduce((acc, [key, value]) => {
        acc[key] = FormFieldValue.fromJSON(value);
        return acc;
      }, {}) : {},
      formId: isSet32(object.formId) ? globalThis.String(object.formId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = FormFieldValue.toJSON(v);
        });
      }
    }
    if (message.formId !== void 0) {
      obj.formId = message.formId;
    }
    return obj;
  },
  create(base) {
    return FormSubmittedEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormSubmittedEvent();
    message.results = Object.entries(object.results ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FormFieldValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.formId = object.formId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FormSubmittedEvent.$type, FormSubmittedEvent);
function createBaseFormSubmittedEvent_ResultsEntry() {
  return { key: "", value: void 0 };
}
var FormSubmittedEvent_ResultsEntry = {
  $type: "devvit.ui.effects.v1alpha.FormSubmittedEvent.ResultsEntry",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FormFieldValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : import_minimal34.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormSubmittedEvent_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = FormFieldValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet32(object.key) ? globalThis.String(object.key) : "",
      value: isSet32(object.value) ? FormFieldValue.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = FormFieldValue.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return FormSubmittedEvent_ResultsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormSubmittedEvent_ResultsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FormFieldValue.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(FormSubmittedEvent_ResultsEntry.$type, FormSubmittedEvent_ResultsEntry);
function isObject6(value) {
  return typeof value === "object" && value !== null;
}
function isSet32(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_toast.js
var import_minimal36 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/toast/toast.js
var import_minimal35 = __toESM(require_minimal2(), 1);
var ToastAppearance;
(function(ToastAppearance2) {
  ToastAppearance2[ToastAppearance2["NEUTRAL"] = 0] = "NEUTRAL";
  ToastAppearance2[ToastAppearance2["SUCCESS"] = 1] = "SUCCESS";
  ToastAppearance2[ToastAppearance2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ToastAppearance || (ToastAppearance = {}));
function toastAppearanceFromJSON(object) {
  switch (object) {
    case 0:
    case "NEUTRAL":
      return ToastAppearance.NEUTRAL;
    case 1:
    case "SUCCESS":
      return ToastAppearance.SUCCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ToastAppearance.UNRECOGNIZED;
  }
}
function toastAppearanceToJSON(object) {
  switch (object) {
    case ToastAppearance.NEUTRAL:
      return 0;
    case ToastAppearance.SUCCESS:
      return 1;
    case ToastAppearance.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseToastLeadingElement() {
  return { icon: void 0, emoji: void 0, avatar: void 0 };
}
var ToastLeadingElement = {
  $type: "devvit.ui.toast.ToastLeadingElement",
  encode(message, writer = import_minimal35.default.Writer.create()) {
    if (message.icon !== void 0) {
      writer.uint32(10).string(message.icon);
    }
    if (message.emoji !== void 0) {
      writer.uint32(18).string(message.emoji);
    }
    if (message.avatar !== void 0) {
      writer.uint32(26).string(message.avatar);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal35.default.Reader ? input : import_minimal35.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToastLeadingElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.icon = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.emoji = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      icon: isSet33(object.icon) ? globalThis.String(object.icon) : void 0,
      emoji: isSet33(object.emoji) ? globalThis.String(object.emoji) : void 0,
      avatar: isSet33(object.avatar) ? globalThis.String(object.avatar) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    if (message.emoji !== void 0) {
      obj.emoji = message.emoji;
    }
    if (message.avatar !== void 0) {
      obj.avatar = message.avatar;
    }
    return obj;
  },
  create(base) {
    return ToastLeadingElement.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseToastLeadingElement();
    message.icon = object.icon ?? void 0;
    message.emoji = object.emoji ?? void 0;
    message.avatar = object.avatar ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ToastLeadingElement.$type, ToastLeadingElement);
function createBaseToastTrailingElement() {
  return { label: void 0, icon: void 0 };
}
var ToastTrailingElement = {
  $type: "devvit.ui.toast.ToastTrailingElement",
  encode(message, writer = import_minimal35.default.Writer.create()) {
    if (message.label !== void 0) {
      writer.uint32(10).string(message.label);
    }
    if (message.icon !== void 0) {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal35.default.Reader ? input : import_minimal35.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToastTrailingElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet33(object.label) ? globalThis.String(object.label) : void 0,
      icon: isSet33(object.icon) ? globalThis.String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.label !== void 0) {
      obj.label = message.label;
    }
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    return obj;
  },
  create(base) {
    return ToastTrailingElement.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseToastTrailingElement();
    message.label = object.label ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ToastTrailingElement.$type, ToastTrailingElement);
function createBaseToast() {
  return { text: "", appearance: void 0, leadingElement: void 0, trailingElement: void 0 };
}
var Toast = {
  $type: "devvit.ui.toast.Toast",
  encode(message, writer = import_minimal35.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.appearance !== void 0) {
      writer.uint32(16).int32(message.appearance);
    }
    if (message.leadingElement !== void 0) {
      ToastLeadingElement.encode(message.leadingElement, writer.uint32(26).fork()).ldelim();
    }
    if (message.trailingElement !== void 0) {
      ToastTrailingElement.encode(message.trailingElement, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal35.default.Reader ? input : import_minimal35.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.appearance = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.leadingElement = ToastLeadingElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.trailingElement = ToastTrailingElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet33(object.text) ? globalThis.String(object.text) : "",
      appearance: isSet33(object.appearance) ? toastAppearanceFromJSON(object.appearance) : void 0,
      leadingElement: isSet33(object.leadingElement) ? ToastLeadingElement.fromJSON(object.leadingElement) : void 0,
      trailingElement: isSet33(object.trailingElement) ? ToastTrailingElement.fromJSON(object.trailingElement) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.appearance !== void 0) {
      obj.appearance = toastAppearanceToJSON(message.appearance);
    }
    if (message.leadingElement !== void 0) {
      obj.leadingElement = ToastLeadingElement.toJSON(message.leadingElement);
    }
    if (message.trailingElement !== void 0) {
      obj.trailingElement = ToastTrailingElement.toJSON(message.trailingElement);
    }
    return obj;
  },
  create(base) {
    return Toast.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseToast();
    message.text = object.text ?? "";
    message.appearance = object.appearance ?? void 0;
    message.leadingElement = object.leadingElement !== void 0 && object.leadingElement !== null ? ToastLeadingElement.fromPartial(object.leadingElement) : void 0;
    message.trailingElement = object.trailingElement !== void 0 && object.trailingElement !== null ? ToastTrailingElement.fromPartial(object.trailingElement) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Toast.$type, Toast);
function isSet33(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_toast.js
function createBaseShowToastEffect() {
  return { toast: void 0 };
}
var ShowToastEffect = {
  $type: "devvit.ui.effects.v1alpha.ShowToastEffect",
  encode(message, writer = import_minimal36.default.Writer.create()) {
    if (message.toast !== void 0) {
      Toast.encode(message.toast, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal36.default.Reader ? input : import_minimal36.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShowToastEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.toast = Toast.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { toast: isSet34(object.toast) ? Toast.fromJSON(object.toast) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.toast !== void 0) {
      obj.toast = Toast.toJSON(message.toast);
    }
    return obj;
  },
  create(base) {
    return ShowToastEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseShowToastEffect();
    message.toast = object.toast !== void 0 && object.toast !== null ? Toast.fromPartial(object.toast) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ShowToastEffect.$type, ShowToastEffect);
function createBaseToastActionEvent() {
  return {};
}
var ToastActionEvent = {
  $type: "devvit.ui.effects.v1alpha.ToastActionEvent",
  encode(_, writer = import_minimal36.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal36.default.Reader ? input : import_minimal36.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToastActionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ToastActionEvent.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseToastActionEvent();
    return message;
  }
};
messageTypeRegistry.set(ToastActionEvent.$type, ToastActionEvent);
function isSet34(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/events/v1alpha/event.js
function createBaseUIEvent() {
  return {
    realtimeEvent: void 0,
    formSubmitted: void 0,
    toastAction: void 0,
    userAction: void 0,
    asyncRequest: void 0,
    asyncResponse: void 0,
    timer: void 0,
    blocking: void 0,
    resize: void 0,
    async: void 0,
    remoteOnly: void 0,
    hook: void 0
  };
}
var UIEvent = {
  $type: "devvit.ui.events.v1alpha.UIEvent",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.realtimeEvent !== void 0) {
      RealtimeSubscriptionEvent.encode(message.realtimeEvent, writer.uint32(18).fork()).ldelim();
    }
    if (message.formSubmitted !== void 0) {
      FormSubmittedEvent.encode(message.formSubmitted, writer.uint32(26).fork()).ldelim();
    }
    if (message.toastAction !== void 0) {
      ToastActionEvent.encode(message.toastAction, writer.uint32(34).fork()).ldelim();
    }
    if (message.userAction !== void 0) {
      UserAction.encode(message.userAction, writer.uint32(50).fork()).ldelim();
    }
    if (message.asyncRequest !== void 0) {
      AsyncRequest.encode(message.asyncRequest, writer.uint32(58).fork()).ldelim();
    }
    if (message.asyncResponse !== void 0) {
      AsyncResponse.encode(message.asyncResponse, writer.uint32(66).fork()).ldelim();
    }
    if (message.timer !== void 0) {
      TimerEvent.encode(message.timer, writer.uint32(98).fork()).ldelim();
    }
    if (message.blocking !== void 0) {
      BlockingRenderEvent.encode(message.blocking, writer.uint32(106).fork()).ldelim();
    }
    if (message.resize !== void 0) {
      ResizeEvent.encode(message.resize, writer.uint32(114).fork()).ldelim();
    }
    if (message.async !== void 0) {
      BoolValue.encode({ value: message.async }, writer.uint32(122).fork()).ldelim();
    }
    if (message.remoteOnly !== void 0) {
      BoolValue.encode({ value: message.remoteOnly }, writer.uint32(130).fork()).ldelim();
    }
    if (message.hook !== void 0) {
      StringValue.encode({ value: message.hook }, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }
          message.realtimeEvent = RealtimeSubscriptionEvent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.formSubmitted = FormSubmittedEvent.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.toastAction = ToastActionEvent.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.userAction = UserAction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.asyncRequest = AsyncRequest.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.asyncResponse = AsyncResponse.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.timer = TimerEvent.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.blocking = BlockingRenderEvent.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.resize = ResizeEvent.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.async = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.remoteOnly = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.hook = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      realtimeEvent: isSet35(object.realtimeEvent) ? RealtimeSubscriptionEvent.fromJSON(object.realtimeEvent) : void 0,
      formSubmitted: isSet35(object.formSubmitted) ? FormSubmittedEvent.fromJSON(object.formSubmitted) : void 0,
      toastAction: isSet35(object.toastAction) ? ToastActionEvent.fromJSON(object.toastAction) : void 0,
      userAction: isSet35(object.userAction) ? UserAction.fromJSON(object.userAction) : void 0,
      asyncRequest: isSet35(object.asyncRequest) ? AsyncRequest.fromJSON(object.asyncRequest) : void 0,
      asyncResponse: isSet35(object.asyncResponse) ? AsyncResponse.fromJSON(object.asyncResponse) : void 0,
      timer: isSet35(object.timer) ? TimerEvent.fromJSON(object.timer) : void 0,
      blocking: isSet35(object.blocking) ? BlockingRenderEvent.fromJSON(object.blocking) : void 0,
      resize: isSet35(object.resize) ? ResizeEvent.fromJSON(object.resize) : void 0,
      async: isSet35(object.async) ? Boolean(object.async) : void 0,
      remoteOnly: isSet35(object.remoteOnly) ? Boolean(object.remoteOnly) : void 0,
      hook: isSet35(object.hook) ? String(object.hook) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.realtimeEvent !== void 0) {
      obj.realtimeEvent = RealtimeSubscriptionEvent.toJSON(message.realtimeEvent);
    }
    if (message.formSubmitted !== void 0) {
      obj.formSubmitted = FormSubmittedEvent.toJSON(message.formSubmitted);
    }
    if (message.toastAction !== void 0) {
      obj.toastAction = ToastActionEvent.toJSON(message.toastAction);
    }
    if (message.userAction !== void 0) {
      obj.userAction = UserAction.toJSON(message.userAction);
    }
    if (message.asyncRequest !== void 0) {
      obj.asyncRequest = AsyncRequest.toJSON(message.asyncRequest);
    }
    if (message.asyncResponse !== void 0) {
      obj.asyncResponse = AsyncResponse.toJSON(message.asyncResponse);
    }
    if (message.timer !== void 0) {
      obj.timer = TimerEvent.toJSON(message.timer);
    }
    if (message.blocking !== void 0) {
      obj.blocking = BlockingRenderEvent.toJSON(message.blocking);
    }
    if (message.resize !== void 0) {
      obj.resize = ResizeEvent.toJSON(message.resize);
    }
    if (message.async !== void 0) {
      obj.async = message.async;
    }
    if (message.remoteOnly !== void 0) {
      obj.remoteOnly = message.remoteOnly;
    }
    if (message.hook !== void 0) {
      obj.hook = message.hook;
    }
    return obj;
  },
  create(base) {
    return UIEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUIEvent();
    message.realtimeEvent = object.realtimeEvent !== void 0 && object.realtimeEvent !== null ? RealtimeSubscriptionEvent.fromPartial(object.realtimeEvent) : void 0;
    message.formSubmitted = object.formSubmitted !== void 0 && object.formSubmitted !== null ? FormSubmittedEvent.fromPartial(object.formSubmitted) : void 0;
    message.toastAction = object.toastAction !== void 0 && object.toastAction !== null ? ToastActionEvent.fromPartial(object.toastAction) : void 0;
    message.userAction = object.userAction !== void 0 && object.userAction !== null ? UserAction.fromPartial(object.userAction) : void 0;
    message.asyncRequest = object.asyncRequest !== void 0 && object.asyncRequest !== null ? AsyncRequest.fromPartial(object.asyncRequest) : void 0;
    message.asyncResponse = object.asyncResponse !== void 0 && object.asyncResponse !== null ? AsyncResponse.fromPartial(object.asyncResponse) : void 0;
    message.timer = object.timer !== void 0 && object.timer !== null ? TimerEvent.fromPartial(object.timer) : void 0;
    message.blocking = object.blocking !== void 0 && object.blocking !== null ? BlockingRenderEvent.fromPartial(object.blocking) : void 0;
    message.resize = object.resize !== void 0 && object.resize !== null ? ResizeEvent.fromPartial(object.resize) : void 0;
    message.async = object.async ?? void 0;
    message.remoteOnly = object.remoteOnly ?? void 0;
    message.hook = object.hook ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UIEvent.$type, UIEvent);
function createBaseBlockingRenderEvent() {
  return {};
}
var BlockingRenderEvent = {
  $type: "devvit.ui.events.v1alpha.BlockingRenderEvent",
  encode(_, writer = import_minimal37.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockingRenderEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return BlockingRenderEvent.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseBlockingRenderEvent();
    return message;
  }
};
messageTypeRegistry.set(BlockingRenderEvent.$type, BlockingRenderEvent);
function createBaseResizeEvent() {
  return {};
}
var ResizeEvent = {
  $type: "devvit.ui.events.v1alpha.ResizeEvent",
  encode(_, writer = import_minimal37.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResizeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ResizeEvent.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseResizeEvent();
    return message;
  }
};
messageTypeRegistry.set(ResizeEvent.$type, ResizeEvent);
function createBaseTimerEvent() {
  return {};
}
var TimerEvent = {
  $type: "devvit.ui.events.v1alpha.TimerEvent",
  encode(_, writer = import_minimal37.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return TimerEvent.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseTimerEvent();
    return message;
  }
};
messageTypeRegistry.set(TimerEvent.$type, TimerEvent);
function createBaseAsyncError() {
  return { message: "", details: "" };
}
var AsyncError = {
  $type: "devvit.ui.events.v1alpha.AsyncError",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAsyncError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.details = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet35(object.message) ? globalThis.String(object.message) : "",
      details: isSet35(object.details) ? globalThis.String(object.details) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },
  create(base) {
    return AsyncError.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAsyncError();
    message.message = object.message ?? "";
    message.details = object.details ?? "";
    return message;
  }
};
messageTypeRegistry.set(AsyncError.$type, AsyncError);
function createBaseAsyncRequest() {
  return { requestId: "", data: void 0 };
}
var AsyncRequest = {
  $type: "devvit.ui.events.v1alpha.AsyncRequest",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAsyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestId: isSet35(object.requestId) ? globalThis.String(object.requestId) : "",
      data: isObject7(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return AsyncRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAsyncRequest();
    message.requestId = object.requestId ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AsyncRequest.$type, AsyncRequest);
function createBaseAsyncResponse() {
  return { requestId: "", data: void 0, error: void 0 };
}
var AsyncResponse = {
  $type: "devvit.ui.events.v1alpha.AsyncResponse",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== void 0) {
      AsyncError.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAsyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.error = AsyncError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestId: isSet35(object.requestId) ? globalThis.String(object.requestId) : "",
      data: isObject7(object.data) ? object.data : void 0,
      error: isSet35(object.error) ? AsyncError.fromJSON(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    if (message.error !== void 0) {
      obj.error = AsyncError.toJSON(message.error);
    }
    return obj;
  },
  create(base) {
    return AsyncResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAsyncResponse();
    message.requestId = object.requestId ?? "";
    message.data = object.data ?? void 0;
    message.error = object.error !== void 0 && object.error !== null ? AsyncError.fromPartial(object.error) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AsyncResponse.$type, AsyncResponse);
function createBaseUserAction() {
  return { actionId: "", data: void 0 };
}
var UserAction = {
  $type: "devvit.ui.events.v1alpha.UserAction",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : import_minimal37.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet35(object.actionId) ? globalThis.String(object.actionId) : "",
      data: isObject7(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return UserAction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserAction();
    message.actionId = object.actionId ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserAction.$type, UserAction);
function isObject7(value) {
  return typeof value === "object" && value !== null;
}
function isSet35(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/send_event.js
function createBaseSendEventEffect() {
  return { event: void 0, jumpsQueue: void 0 };
}
var SendEventEffect = {
  $type: "devvit.ui.effects.v1alpha.SendEventEffect",
  encode(message, writer = import_minimal38.default.Writer.create()) {
    if (message.event !== void 0) {
      UIEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    if (message.jumpsQueue !== void 0) {
      BoolValue.encode({ value: message.jumpsQueue }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal38.default.Reader ? input : import_minimal38.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSendEventEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.event = UIEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.jumpsQueue = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      event: isSet36(object.event) ? UIEvent.fromJSON(object.event) : void 0,
      jumpsQueue: isSet36(object.jumpsQueue) ? Boolean(object.jumpsQueue) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.event !== void 0) {
      obj.event = UIEvent.toJSON(message.event);
    }
    if (message.jumpsQueue !== void 0) {
      obj.jumpsQueue = message.jumpsQueue;
    }
    return obj;
  },
  create(base) {
    return SendEventEffect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSendEventEffect();
    message.event = object.event !== void 0 && object.event !== null ? UIEvent.fromPartial(object.event) : void 0;
    message.jumpsQueue = object.jumpsQueue ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SendEventEffect.$type, SendEventEffect);
function isSet36(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/effect.js
var EffectType;
(function(EffectType2) {
  EffectType2[EffectType2["EFFECT_REALTIME_SUB"] = 0] = "EFFECT_REALTIME_SUB";
  EffectType2[EffectType2["EFFECT_RERENDER_UI"] = 1] = "EFFECT_RERENDER_UI";
  EffectType2[EffectType2["EFFECT_RELOAD_PART"] = 2] = "EFFECT_RELOAD_PART";
  EffectType2[EffectType2["EFFECT_SHOW_FORM"] = 3] = "EFFECT_SHOW_FORM";
  EffectType2[EffectType2["EFFECT_SHOW_TOAST"] = 4] = "EFFECT_SHOW_TOAST";
  EffectType2[EffectType2["EFFECT_NAVIGATE_TO_URL"] = 5] = "EFFECT_NAVIGATE_TO_URL";
  EffectType2[EffectType2["EFFECT_SEND_EVENT"] = 6] = "EFFECT_SEND_EVENT";
  EffectType2[EffectType2["EFFECT_SET_INTERVALS"] = 7] = "EFFECT_SET_INTERVALS";
  EffectType2[EffectType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EffectType || (EffectType = {}));
function effectTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "EFFECT_REALTIME_SUB":
      return EffectType.EFFECT_REALTIME_SUB;
    case 1:
    case "EFFECT_RERENDER_UI":
      return EffectType.EFFECT_RERENDER_UI;
    case 2:
    case "EFFECT_RELOAD_PART":
      return EffectType.EFFECT_RELOAD_PART;
    case 3:
    case "EFFECT_SHOW_FORM":
      return EffectType.EFFECT_SHOW_FORM;
    case 4:
    case "EFFECT_SHOW_TOAST":
      return EffectType.EFFECT_SHOW_TOAST;
    case 5:
    case "EFFECT_NAVIGATE_TO_URL":
      return EffectType.EFFECT_NAVIGATE_TO_URL;
    case 6:
    case "EFFECT_SEND_EVENT":
      return EffectType.EFFECT_SEND_EVENT;
    case 7:
    case "EFFECT_SET_INTERVALS":
      return EffectType.EFFECT_SET_INTERVALS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectType.UNRECOGNIZED;
  }
}
function effectTypeToJSON(object) {
  switch (object) {
    case EffectType.EFFECT_REALTIME_SUB:
      return 0;
    case EffectType.EFFECT_RERENDER_UI:
      return 1;
    case EffectType.EFFECT_RELOAD_PART:
      return 2;
    case EffectType.EFFECT_SHOW_FORM:
      return 3;
    case EffectType.EFFECT_SHOW_TOAST:
      return 4;
    case EffectType.EFFECT_NAVIGATE_TO_URL:
      return 5;
    case EffectType.EFFECT_SEND_EVENT:
      return 6;
    case EffectType.EFFECT_SET_INTERVALS:
      return 7;
    case EffectType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseEffect() {
  return {
    realtimeSubscriptions: void 0,
    rerenderUi: void 0,
    reloadPart: void 0,
    showForm: void 0,
    showToast: void 0,
    navigateToUrl: void 0,
    sendEvent: void 0,
    interval: void 0,
    type: 0
  };
}
var Effect = {
  $type: "devvit.ui.effects.v1alpha.Effect",
  encode(message, writer = import_minimal39.default.Writer.create()) {
    if (message.realtimeSubscriptions !== void 0) {
      RealtimeSubscriptionsEffect.encode(message.realtimeSubscriptions, writer.uint32(10).fork()).ldelim();
    }
    if (message.rerenderUi !== void 0) {
      RerenderEffect.encode(message.rerenderUi, writer.uint32(18).fork()).ldelim();
    }
    if (message.reloadPart !== void 0) {
      ReloadPartEffect.encode(message.reloadPart, writer.uint32(26).fork()).ldelim();
    }
    if (message.showForm !== void 0) {
      ShowFormEffect.encode(message.showForm, writer.uint32(34).fork()).ldelim();
    }
    if (message.showToast !== void 0) {
      ShowToastEffect.encode(message.showToast, writer.uint32(42).fork()).ldelim();
    }
    if (message.navigateToUrl !== void 0) {
      NavigateToUrlEffect.encode(message.navigateToUrl, writer.uint32(50).fork()).ldelim();
    }
    if (message.sendEvent !== void 0) {
      SendEventEffect.encode(message.sendEvent, writer.uint32(66).fork()).ldelim();
    }
    if (message.interval !== void 0) {
      SetIntervalsEffect.encode(message.interval, writer.uint32(74).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal39.default.Reader ? input : import_minimal39.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.realtimeSubscriptions = RealtimeSubscriptionsEffect.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.rerenderUi = RerenderEffect.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.reloadPart = ReloadPartEffect.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.showForm = ShowFormEffect.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.showToast = ShowToastEffect.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.navigateToUrl = NavigateToUrlEffect.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.sendEvent = SendEventEffect.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.interval = SetIntervalsEffect.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      realtimeSubscriptions: isSet37(object.realtimeSubscriptions) ? RealtimeSubscriptionsEffect.fromJSON(object.realtimeSubscriptions) : void 0,
      rerenderUi: isSet37(object.rerenderUi) ? RerenderEffect.fromJSON(object.rerenderUi) : void 0,
      reloadPart: isSet37(object.reloadPart) ? ReloadPartEffect.fromJSON(object.reloadPart) : void 0,
      showForm: isSet37(object.showForm) ? ShowFormEffect.fromJSON(object.showForm) : void 0,
      showToast: isSet37(object.showToast) ? ShowToastEffect.fromJSON(object.showToast) : void 0,
      navigateToUrl: isSet37(object.navigateToUrl) ? NavigateToUrlEffect.fromJSON(object.navigateToUrl) : void 0,
      sendEvent: isSet37(object.sendEvent) ? SendEventEffect.fromJSON(object.sendEvent) : void 0,
      interval: isSet37(object.interval) ? SetIntervalsEffect.fromJSON(object.interval) : void 0,
      type: isSet37(object.type) ? effectTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.realtimeSubscriptions !== void 0) {
      obj.realtimeSubscriptions = RealtimeSubscriptionsEffect.toJSON(message.realtimeSubscriptions);
    }
    if (message.rerenderUi !== void 0) {
      obj.rerenderUi = RerenderEffect.toJSON(message.rerenderUi);
    }
    if (message.reloadPart !== void 0) {
      obj.reloadPart = ReloadPartEffect.toJSON(message.reloadPart);
    }
    if (message.showForm !== void 0) {
      obj.showForm = ShowFormEffect.toJSON(message.showForm);
    }
    if (message.showToast !== void 0) {
      obj.showToast = ShowToastEffect.toJSON(message.showToast);
    }
    if (message.navigateToUrl !== void 0) {
      obj.navigateToUrl = NavigateToUrlEffect.toJSON(message.navigateToUrl);
    }
    if (message.sendEvent !== void 0) {
      obj.sendEvent = SendEventEffect.toJSON(message.sendEvent);
    }
    if (message.interval !== void 0) {
      obj.interval = SetIntervalsEffect.toJSON(message.interval);
    }
    if (message.type !== 0) {
      obj.type = effectTypeToJSON(message.type);
    }
    return obj;
  },
  create(base) {
    return Effect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEffect();
    message.realtimeSubscriptions = object.realtimeSubscriptions !== void 0 && object.realtimeSubscriptions !== null ? RealtimeSubscriptionsEffect.fromPartial(object.realtimeSubscriptions) : void 0;
    message.rerenderUi = object.rerenderUi !== void 0 && object.rerenderUi !== null ? RerenderEffect.fromPartial(object.rerenderUi) : void 0;
    message.reloadPart = object.reloadPart !== void 0 && object.reloadPart !== null ? ReloadPartEffect.fromPartial(object.reloadPart) : void 0;
    message.showForm = object.showForm !== void 0 && object.showForm !== null ? ShowFormEffect.fromPartial(object.showForm) : void 0;
    message.showToast = object.showToast !== void 0 && object.showToast !== null ? ShowToastEffect.fromPartial(object.showToast) : void 0;
    message.navigateToUrl = object.navigateToUrl !== void 0 && object.navigateToUrl !== null ? NavigateToUrlEffect.fromPartial(object.navigateToUrl) : void 0;
    message.sendEvent = object.sendEvent !== void 0 && object.sendEvent !== null ? SendEventEffect.fromPartial(object.sendEvent) : void 0;
    message.interval = object.interval !== void 0 && object.interval !== null ? SetIntervalsEffect.fromPartial(object.interval) : void 0;
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Effect.$type, Effect);
function isSet37(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/user_configurable/user_configurable.js
var import_minimal40 = __toESM(require_minimal2(), 1);
var ConfigFieldType;
(function(ConfigFieldType2) {
  ConfigFieldType2[ConfigFieldType2["STRING"] = 0] = "STRING";
  ConfigFieldType2[ConfigFieldType2["PARAGRAPH"] = 1] = "PARAGRAPH";
  ConfigFieldType2[ConfigFieldType2["NUMBER"] = 2] = "NUMBER";
  ConfigFieldType2[ConfigFieldType2["BOOLEAN"] = 3] = "BOOLEAN";
  ConfigFieldType2[ConfigFieldType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigFieldType || (ConfigFieldType = {}));
function configFieldTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return ConfigFieldType.STRING;
    case 1:
    case "PARAGRAPH":
      return ConfigFieldType.PARAGRAPH;
    case 2:
    case "NUMBER":
      return ConfigFieldType.NUMBER;
    case 3:
    case "BOOLEAN":
      return ConfigFieldType.BOOLEAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigFieldType.UNRECOGNIZED;
  }
}
function configFieldTypeToJSON(object) {
  switch (object) {
    case ConfigFieldType.STRING:
      return 0;
    case ConfigFieldType.PARAGRAPH:
      return 1;
    case ConfigFieldType.NUMBER:
      return 2;
    case ConfigFieldType.BOOLEAN:
      return 3;
    case ConfigFieldType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseConfigForm() {
  return { fields: [] };
}
var ConfigForm = {
  $type: "devvit.actor.user_configurable.ConfigForm",
  encode(message, writer = import_minimal40.default.Writer.create()) {
    for (const v of message.fields) {
      ConfigField.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal40.default.Reader ? input : import_minimal40.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fields.push(ConfigField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => ConfigField.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => ConfigField.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ConfigForm.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConfigForm();
    message.fields = object.fields?.map((e) => ConfigField.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ConfigForm.$type, ConfigForm);
function createBaseConfigField() {
  return { fieldType: 0, key: "", prompt: "", response: "" };
}
var ConfigField = {
  $type: "devvit.actor.user_configurable.ConfigField",
  encode(message, writer = import_minimal40.default.Writer.create()) {
    if (message.fieldType !== 0) {
      writer.uint32(8).int32(message.fieldType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.prompt !== "") {
      writer.uint32(26).string(message.prompt);
    }
    if (message.response !== "") {
      writer.uint32(34).string(message.response);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal40.default.Reader ? input : import_minimal40.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.fieldType = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.prompt = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.response = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldType: isSet38(object.fieldType) ? configFieldTypeFromJSON(object.fieldType) : 0,
      key: isSet38(object.key) ? globalThis.String(object.key) : "",
      prompt: isSet38(object.prompt) ? globalThis.String(object.prompt) : "",
      response: isSet38(object.response) ? globalThis.String(object.response) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fieldType !== 0) {
      obj.fieldType = configFieldTypeToJSON(message.fieldType);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.response !== "") {
      obj.response = message.response;
    }
    return obj;
  },
  create(base) {
    return ConfigField.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConfigField();
    message.fieldType = object.fieldType ?? 0;
    message.key = object.key ?? "";
    message.prompt = object.prompt ?? "";
    message.response = object.response ?? "";
    return message;
  }
};
messageTypeRegistry.set(ConfigField.$type, ConfigField);
function createBaseFormResponse() {
  return { success: false, messages: [] };
}
var FormResponse = {
  $type: "devvit.actor.user_configurable.FormResponse",
  encode(message, writer = import_minimal40.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal40.default.Reader ? input : import_minimal40.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.messages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet38(object.success) ? globalThis.Boolean(object.success) : false,
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.messages?.length) {
      obj.messages = message.messages;
    }
    return obj;
  },
  create(base) {
    return FormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFormResponse();
    message.success = object.success ?? false;
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(FormResponse.$type, FormResponse);
function isSet38(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/reddit/context_type.js
var ContextType;
(function(ContextType2) {
  ContextType2[ContextType2["POST"] = 0] = "POST";
  ContextType2[ContextType2["COMMENT"] = 1] = "COMMENT";
  ContextType2[ContextType2["SUBREDDIT"] = 2] = "SUBREDDIT";
  ContextType2[ContextType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ContextType || (ContextType = {}));
function contextTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "POST":
      return ContextType.POST;
    case 1:
    case "COMMENT":
      return ContextType.COMMENT;
    case 2:
    case "SUBREDDIT":
      return ContextType.SUBREDDIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContextType.UNRECOGNIZED;
  }
}
function contextTypeToJSON(object) {
  switch (object) {
    case ContextType.POST:
      return 0;
    case ContextType.COMMENT:
      return 1;
    case ContextType.SUBREDDIT:
      return 2;
    case ContextType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/actor/reddit/context_action.js
function createBaseContextActionAllowedContexts() {
  return { post: false, comment: false, subreddit: false };
}
var ContextActionAllowedContexts = {
  $type: "devvit.actor.reddit.ContextActionAllowedContexts",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.post !== false) {
      writer.uint32(8).bool(message.post);
    }
    if (message.comment !== false) {
      writer.uint32(16).bool(message.comment);
    }
    if (message.subreddit !== false) {
      writer.uint32(24).bool(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionAllowedContexts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.post = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.comment = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.subreddit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet39(object.post) ? globalThis.Boolean(object.post) : false,
      comment: isSet39(object.comment) ? globalThis.Boolean(object.comment) : false,
      subreddit: isSet39(object.subreddit) ? globalThis.Boolean(object.subreddit) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== false) {
      obj.post = message.post;
    }
    if (message.comment !== false) {
      obj.comment = message.comment;
    }
    if (message.subreddit !== false) {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return ContextActionAllowedContexts.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionAllowedContexts();
    message.post = object.post ?? false;
    message.comment = object.comment ?? false;
    message.subreddit = object.subreddit ?? false;
    return message;
  }
};
messageTypeRegistry.set(ContextActionAllowedContexts.$type, ContextActionAllowedContexts);
function createBaseContextActionAllowedUsers() {
  return { moderator: false, member: false, loggedOut: false };
}
var ContextActionAllowedUsers = {
  $type: "devvit.actor.reddit.ContextActionAllowedUsers",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.moderator !== false) {
      writer.uint32(8).bool(message.moderator);
    }
    if (message.member !== false) {
      writer.uint32(16).bool(message.member);
    }
    if (message.loggedOut !== false) {
      writer.uint32(24).bool(message.loggedOut);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionAllowedUsers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.moderator = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.member = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.loggedOut = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      moderator: isSet39(object.moderator) ? globalThis.Boolean(object.moderator) : false,
      member: isSet39(object.member) ? globalThis.Boolean(object.member) : false,
      loggedOut: isSet39(object.loggedOut) ? globalThis.Boolean(object.loggedOut) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.moderator !== false) {
      obj.moderator = message.moderator;
    }
    if (message.member !== false) {
      obj.member = message.member;
    }
    if (message.loggedOut !== false) {
      obj.loggedOut = message.loggedOut;
    }
    return obj;
  },
  create(base) {
    return ContextActionAllowedUsers.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionAllowedUsers();
    message.moderator = object.moderator ?? false;
    message.member = object.member ?? false;
    message.loggedOut = object.loggedOut ?? false;
    return message;
  }
};
messageTypeRegistry.set(ContextActionAllowedUsers.$type, ContextActionAllowedUsers);
function createBaseContextActionPostFilters() {
  return { currentApp: void 0 };
}
var ContextActionPostFilters = {
  $type: "devvit.actor.reddit.ContextActionPostFilters",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.currentApp !== void 0) {
      writer.uint32(8).bool(message.currentApp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionPostFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.currentApp = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { currentApp: isSet39(object.currentApp) ? globalThis.Boolean(object.currentApp) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.currentApp !== void 0) {
      obj.currentApp = message.currentApp;
    }
    return obj;
  },
  create(base) {
    return ContextActionPostFilters.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionPostFilters();
    message.currentApp = object.currentApp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ContextActionPostFilters.$type, ContextActionPostFilters);
function createBaseContextActionDescription() {
  return {
    actionId: "",
    name: "",
    description: "",
    contexts: void 0,
    users: void 0,
    userInput: void 0,
    postFilters: void 0
  };
}
var ContextActionDescription = {
  $type: "devvit.actor.reddit.ContextActionDescription",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.contexts !== void 0) {
      ContextActionAllowedContexts.encode(message.contexts, writer.uint32(34).fork()).ldelim();
    }
    if (message.users !== void 0) {
      ContextActionAllowedUsers.encode(message.users, writer.uint32(42).fork()).ldelim();
    }
    if (message.userInput !== void 0) {
      ConfigForm.encode(message.userInput, writer.uint32(50).fork()).ldelim();
    }
    if (message.postFilters !== void 0) {
      ContextActionPostFilters.encode(message.postFilters, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.contexts = ContextActionAllowedContexts.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.users = ContextActionAllowedUsers.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.userInput = ConfigForm.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.postFilters = ContextActionPostFilters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet39(object.actionId) ? globalThis.String(object.actionId) : "",
      name: isSet39(object.name) ? globalThis.String(object.name) : "",
      description: isSet39(object.description) ? globalThis.String(object.description) : "",
      contexts: isSet39(object.contexts) ? ContextActionAllowedContexts.fromJSON(object.contexts) : void 0,
      users: isSet39(object.users) ? ContextActionAllowedUsers.fromJSON(object.users) : void 0,
      userInput: isSet39(object.userInput) ? ConfigForm.fromJSON(object.userInput) : void 0,
      postFilters: isSet39(object.postFilters) ? ContextActionPostFilters.fromJSON(object.postFilters) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.contexts !== void 0) {
      obj.contexts = ContextActionAllowedContexts.toJSON(message.contexts);
    }
    if (message.users !== void 0) {
      obj.users = ContextActionAllowedUsers.toJSON(message.users);
    }
    if (message.userInput !== void 0) {
      obj.userInput = ConfigForm.toJSON(message.userInput);
    }
    if (message.postFilters !== void 0) {
      obj.postFilters = ContextActionPostFilters.toJSON(message.postFilters);
    }
    return obj;
  },
  create(base) {
    return ContextActionDescription.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionDescription();
    message.actionId = object.actionId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.contexts = object.contexts !== void 0 && object.contexts !== null ? ContextActionAllowedContexts.fromPartial(object.contexts) : void 0;
    message.users = object.users !== void 0 && object.users !== null ? ContextActionAllowedUsers.fromPartial(object.users) : void 0;
    message.userInput = object.userInput !== void 0 && object.userInput !== null ? ConfigForm.fromPartial(object.userInput) : void 0;
    message.postFilters = object.postFilters !== void 0 && object.postFilters !== null ? ContextActionPostFilters.fromPartial(object.postFilters) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ContextActionDescription.$type, ContextActionDescription);
function createBaseContextActionList() {
  return { actions: [] };
}
var ContextActionList = {
  $type: "devvit.actor.reddit.ContextActionList",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    for (const v of message.actions) {
      ContextActionDescription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actions.push(ContextActionDescription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e) => ContextActionDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => ContextActionDescription.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ContextActionList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionList();
    message.actions = object.actions?.map((e) => ContextActionDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ContextActionList.$type, ContextActionList);
function createBaseContextActionRequest() {
  return { actionId: "", context: 0, post: void 0, comment: void 0, subreddit: void 0, userInput: void 0 };
}
var ContextActionRequest = {
  $type: "devvit.actor.reddit.ContextActionRequest",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.context !== 0) {
      writer.uint32(16).int32(message.context);
    }
    if (message.post !== void 0) {
      RedditObject.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      RedditObject.encode(message.comment, writer.uint32(34).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditObject.encode(message.subreddit, writer.uint32(42).fork()).ldelim();
    }
    if (message.userInput !== void 0) {
      ConfigForm.encode(message.userInput, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.context = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.post = RedditObject.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.comment = RedditObject.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.subreddit = SubredditObject.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.userInput = ConfigForm.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet39(object.actionId) ? globalThis.String(object.actionId) : "",
      context: isSet39(object.context) ? contextTypeFromJSON(object.context) : 0,
      post: isSet39(object.post) ? RedditObject.fromJSON(object.post) : void 0,
      comment: isSet39(object.comment) ? RedditObject.fromJSON(object.comment) : void 0,
      subreddit: isSet39(object.subreddit) ? SubredditObject.fromJSON(object.subreddit) : void 0,
      userInput: isSet39(object.userInput) ? ConfigForm.fromJSON(object.userInput) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.context !== 0) {
      obj.context = contextTypeToJSON(message.context);
    }
    if (message.post !== void 0) {
      obj.post = RedditObject.toJSON(message.post);
    }
    if (message.comment !== void 0) {
      obj.comment = RedditObject.toJSON(message.comment);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditObject.toJSON(message.subreddit);
    }
    if (message.userInput !== void 0) {
      obj.userInput = ConfigForm.toJSON(message.userInput);
    }
    return obj;
  },
  create(base) {
    return ContextActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionRequest();
    message.actionId = object.actionId ?? "";
    message.context = object.context ?? 0;
    message.post = object.post !== void 0 && object.post !== null ? RedditObject.fromPartial(object.post) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? RedditObject.fromPartial(object.comment) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditObject.fromPartial(object.subreddit) : void 0;
    message.userInput = object.userInput !== void 0 && object.userInput !== null ? ConfigForm.fromPartial(object.userInput) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ContextActionRequest.$type, ContextActionRequest);
function createBaseContextActionResponse() {
  return { success: false, message: "", effects: [] };
}
var ContextActionResponse = {
  $type: "devvit.actor.reddit.ContextActionResponse",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : import_minimal41.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet39(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet39(object.message) ? globalThis.String(object.message) : "",
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ContextActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContextActionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ContextActionResponse.$type, ContextActionResponse);
function isSet39(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gql/subreddit_metadata.js
function createBaseSubredditContextActions() {
  return { actorHostname: "", actions: void 0 };
}
var SubredditContextActions = {
  $type: "devvit.gql.SubredditContextActions",
  encode(message, writer = import_minimal42.default.Writer.create()) {
    if (message.actorHostname !== "") {
      writer.uint32(10).string(message.actorHostname);
    }
    if (message.actions !== void 0) {
      ContextActionList.encode(message.actions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal42.default.Reader ? input : import_minimal42.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditContextActions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actorHostname = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.actions = ContextActionList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actorHostname: isSet40(object.actorHostname) ? globalThis.String(object.actorHostname) : "",
      actions: isSet40(object.actions) ? ContextActionList.fromJSON(object.actions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actorHostname !== "") {
      obj.actorHostname = message.actorHostname;
    }
    if (message.actions !== void 0) {
      obj.actions = ContextActionList.toJSON(message.actions);
    }
    return obj;
  },
  create(base) {
    return SubredditContextActions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditContextActions();
    message.actorHostname = object.actorHostname ?? "";
    message.actions = object.actions !== void 0 && object.actions !== null ? ContextActionList.fromPartial(object.actions) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditContextActions.$type, SubredditContextActions);
function createBaseDevvitSubredditMetadata() {
  return { installedRemoteApps: [], contextActions: [], errors: [], installedAppsInfo: [] };
}
var DevvitSubredditMetadata = {
  $type: "devvit.gql.DevvitSubredditMetadata",
  encode(message, writer = import_minimal42.default.Writer.create()) {
    for (const v of message.installedRemoteApps) {
      LinkedBundle.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.contextActions) {
      SubredditContextActions.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.errors) {
      ErrorMessage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.installedAppsInfo) {
      DevvitSubredditMetadata_AppInfo.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal42.default.Reader ? input : import_minimal42.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevvitSubredditMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installedRemoteApps.push(LinkedBundle.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contextActions.push(SubredditContextActions.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.errors.push(ErrorMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.installedAppsInfo.push(DevvitSubredditMetadata_AppInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installedRemoteApps: globalThis.Array.isArray(object?.installedRemoteApps) ? object.installedRemoteApps.map((e) => LinkedBundle.fromJSON(e)) : [],
      contextActions: globalThis.Array.isArray(object?.contextActions) ? object.contextActions.map((e) => SubredditContextActions.fromJSON(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => ErrorMessage.fromJSON(e)) : [],
      installedAppsInfo: globalThis.Array.isArray(object?.installedAppsInfo) ? object.installedAppsInfo.map((e) => DevvitSubredditMetadata_AppInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installedRemoteApps?.length) {
      obj.installedRemoteApps = message.installedRemoteApps.map((e) => LinkedBundle.toJSON(e));
    }
    if (message.contextActions?.length) {
      obj.contextActions = message.contextActions.map((e) => SubredditContextActions.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ErrorMessage.toJSON(e));
    }
    if (message.installedAppsInfo?.length) {
      obj.installedAppsInfo = message.installedAppsInfo.map((e) => DevvitSubredditMetadata_AppInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return DevvitSubredditMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevvitSubredditMetadata();
    message.installedRemoteApps = object.installedRemoteApps?.map((e) => LinkedBundle.fromPartial(e)) || [];
    message.contextActions = object.contextActions?.map((e) => SubredditContextActions.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => ErrorMessage.fromPartial(e)) || [];
    message.installedAppsInfo = object.installedAppsInfo?.map((e) => DevvitSubredditMetadata_AppInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(DevvitSubredditMetadata.$type, DevvitSubredditMetadata);
function createBaseDevvitSubredditMetadata_AppInfo() {
  return { slug: "", name: "" };
}
var DevvitSubredditMetadata_AppInfo = {
  $type: "devvit.gql.DevvitSubredditMetadata.AppInfo",
  encode(message, writer = import_minimal42.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal42.default.Reader ? input : import_minimal42.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevvitSubredditMetadata_AppInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet40(object.slug) ? globalThis.String(object.slug) : "",
      name: isSet40(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return DevvitSubredditMetadata_AppInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevvitSubredditMetadata_AppInfo();
    message.slug = object.slug ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(DevvitSubredditMetadata_AppInfo.$type, DevvitSubredditMetadata_AppInfo);
function createBaseErrorMessage() {
  return { message: "" };
}
var ErrorMessage = {
  $type: "devvit.gql.ErrorMessage",
  encode(message, writer = import_minimal42.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal42.default.Reader ? input : import_minimal42.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseErrorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet40(object.message) ? globalThis.String(object.message) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return ErrorMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseErrorMessage();
    message.message = object.message ?? "";
    return message;
  }
};
messageTypeRegistry.set(ErrorMessage.$type, ErrorMessage);
function isSet40(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gql/snapshot.js
var import_minimal43 = __toESM(require_minimal2(), 1);
function createBaseCustomPostSnapshot() {
  return { snapshotId: "", renderConfig: "" };
}
var CustomPostSnapshot = {
  $type: "devvit.gql.CustomPostSnapshot",
  encode(message, writer = import_minimal43.default.Writer.create()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    if (message.renderConfig !== "") {
      writer.uint32(18).string(message.renderConfig);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal43.default.Reader ? input : import_minimal43.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomPostSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.renderConfig = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      snapshotId: isSet41(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      renderConfig: isSet41(object.renderConfig) ? globalThis.String(object.renderConfig) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.renderConfig !== "") {
      obj.renderConfig = message.renderConfig;
    }
    return obj;
  },
  create(base) {
    return CustomPostSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomPostSnapshot();
    message.snapshotId = object.snapshotId ?? "";
    message.renderConfig = object.renderConfig ?? "";
    return message;
  }
};
messageTypeRegistry.set(CustomPostSnapshot.$type, CustomPostSnapshot);
function isSet41(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/resolvers.js
var import_minimal44 = __toESM(require_minimal2(), 1);
function createBaseSubredditMetadataRequest() {
  return { subreddit: "" };
}
var SubredditMetadataRequest = {
  $type: "devvit.gateway.SubredditMetadataRequest",
  encode(message, writer = import_minimal44.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal44.default.Reader ? input : import_minimal44.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet42(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return SubredditMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditMetadataRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditMetadataRequest.$type, SubredditMetadataRequest);
function isSet42(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/custom_post_snapshot.js
var import_minimal45 = __toESM(require_minimal2(), 1);
function createBaseCustomPostSnapshotRequest() {
  return { snapshotId: "" };
}
var CustomPostSnapshotRequest = {
  $type: "devvit.gateway.CustomPostSnapshotRequest",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : import_minimal45.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomPostSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { snapshotId: isSet43(object.snapshotId) ? globalThis.String(object.snapshotId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    return obj;
  },
  create(base) {
    return CustomPostSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomPostSnapshotRequest();
    message.snapshotId = object.snapshotId ?? "";
    return message;
  }
};
messageTypeRegistry.set(CustomPostSnapshotRequest.$type, CustomPostSnapshotRequest);
function isSet43(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/automod.js
var import_minimal46 = __toESM(require_minimal2(), 1);
function createBaseAutomodInvocation() {
  return {
    yamlText: void 0,
    comment: void 0,
    post: void 0,
    author: void 0,
    parentPost: void 0,
    subreddit: void 0,
    crosspost: void 0,
    crosspostSubreddit: void 0,
    crosspostAuthor: void 0,
    poll: void 0
  };
}
var AutomodInvocation = {
  $type: "devvit.gateway.AutomodInvocation",
  encode(message, writer = import_minimal46.default.Writer.create()) {
    if (message.yamlText !== void 0) {
      StringValue.encode({ value: message.yamlText }, writer.uint32(10).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.author !== void 0) {
      User.encode(message.author, writer.uint32(34).fork()).ldelim();
    }
    if (message.parentPost !== void 0) {
      Post.encode(message.parentPost, writer.uint32(42).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      Subreddit.encode(message.subreddit, writer.uint32(50).fork()).ldelim();
    }
    if (message.crosspost !== void 0) {
      Post.encode(message.crosspost, writer.uint32(58).fork()).ldelim();
    }
    if (message.crosspostSubreddit !== void 0) {
      Subreddit.encode(message.crosspostSubreddit, writer.uint32(66).fork()).ldelim();
    }
    if (message.crosspostAuthor !== void 0) {
      User.encode(message.crosspostAuthor, writer.uint32(74).fork()).ldelim();
    }
    if (message.poll !== void 0) {
      Poll.encode(message.poll, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal46.default.Reader ? input : import_minimal46.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.yamlText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.comment = Comment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.post = Post.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.author = User.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.parentPost = Post.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.subreddit = Subreddit.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.crosspost = Post.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.crosspostSubreddit = Subreddit.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.crosspostAuthor = User.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.poll = Poll.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      yamlText: isSet44(object.yamlText) ? String(object.yamlText) : void 0,
      comment: isSet44(object.comment) ? Comment.fromJSON(object.comment) : void 0,
      post: isSet44(object.post) ? Post.fromJSON(object.post) : void 0,
      author: isSet44(object.author) ? User.fromJSON(object.author) : void 0,
      parentPost: isSet44(object.parentPost) ? Post.fromJSON(object.parentPost) : void 0,
      subreddit: isSet44(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : void 0,
      crosspost: isSet44(object.crosspost) ? Post.fromJSON(object.crosspost) : void 0,
      crosspostSubreddit: isSet44(object.crosspostSubreddit) ? Subreddit.fromJSON(object.crosspostSubreddit) : void 0,
      crosspostAuthor: isSet44(object.crosspostAuthor) ? User.fromJSON(object.crosspostAuthor) : void 0,
      poll: isSet44(object.poll) ? Poll.fromJSON(object.poll) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.yamlText !== void 0) {
      obj.yamlText = message.yamlText;
    }
    if (message.comment !== void 0) {
      obj.comment = Comment.toJSON(message.comment);
    }
    if (message.post !== void 0) {
      obj.post = Post.toJSON(message.post);
    }
    if (message.author !== void 0) {
      obj.author = User.toJSON(message.author);
    }
    if (message.parentPost !== void 0) {
      obj.parentPost = Post.toJSON(message.parentPost);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = Subreddit.toJSON(message.subreddit);
    }
    if (message.crosspost !== void 0) {
      obj.crosspost = Post.toJSON(message.crosspost);
    }
    if (message.crosspostSubreddit !== void 0) {
      obj.crosspostSubreddit = Subreddit.toJSON(message.crosspostSubreddit);
    }
    if (message.crosspostAuthor !== void 0) {
      obj.crosspostAuthor = User.toJSON(message.crosspostAuthor);
    }
    if (message.poll !== void 0) {
      obj.poll = Poll.toJSON(message.poll);
    }
    return obj;
  },
  create(base) {
    return AutomodInvocation.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomodInvocation();
    message.yamlText = object.yamlText ?? void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? Comment.fromPartial(object.comment) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? User.fromPartial(object.author) : void 0;
    message.parentPost = object.parentPost !== void 0 && object.parentPost !== null ? Post.fromPartial(object.parentPost) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? Subreddit.fromPartial(object.subreddit) : void 0;
    message.crosspost = object.crosspost !== void 0 && object.crosspost !== null ? Post.fromPartial(object.crosspost) : void 0;
    message.crosspostSubreddit = object.crosspostSubreddit !== void 0 && object.crosspostSubreddit !== null ? Subreddit.fromPartial(object.crosspostSubreddit) : void 0;
    message.crosspostAuthor = object.crosspostAuthor !== void 0 && object.crosspostAuthor !== null ? User.fromPartial(object.crosspostAuthor) : void 0;
    message.poll = object.poll !== void 0 && object.poll !== null ? Poll.fromPartial(object.poll) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AutomodInvocation.$type, AutomodInvocation);
function createBasePoll() {
  return {
    isPrediction: void 0,
    options: [],
    predictionStatus: void 0,
    resolvedOptionId: void 0,
    totalStakeAmount: void 0,
    totalVoteCount: void 0,
    tournamentId: void 0,
    userSelection: void 0,
    userWonAmount: void 0,
    voteUpdatesRemained: void 0,
    votingEndTimestamp: void 0
  };
}
var Poll = {
  $type: "devvit.gateway.Poll",
  encode(message, writer = import_minimal46.default.Writer.create()) {
    if (message.isPrediction !== void 0) {
      BoolValue.encode({ value: message.isPrediction }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.options) {
      Struct.encode(Struct.wrap(v), writer.uint32(18).fork()).ldelim();
    }
    if (message.predictionStatus !== void 0) {
      StringValue.encode({ value: message.predictionStatus }, writer.uint32(26).fork()).ldelim();
    }
    if (message.resolvedOptionId !== void 0) {
      StringValue.encode({ value: message.resolvedOptionId }, writer.uint32(34).fork()).ldelim();
    }
    if (message.totalStakeAmount !== void 0) {
      Int32Value.encode({ value: message.totalStakeAmount }, writer.uint32(42).fork()).ldelim();
    }
    if (message.totalVoteCount !== void 0) {
      Int32Value.encode({ value: message.totalVoteCount }, writer.uint32(50).fork()).ldelim();
    }
    if (message.tournamentId !== void 0) {
      StringValue.encode({ value: message.tournamentId }, writer.uint32(58).fork()).ldelim();
    }
    if (message.userSelection !== void 0) {
      StringValue.encode({ value: message.userSelection }, writer.uint32(66).fork()).ldelim();
    }
    if (message.userWonAmount !== void 0) {
      Int32Value.encode({ value: message.userWonAmount }, writer.uint32(74).fork()).ldelim();
    }
    if (message.voteUpdatesRemained !== void 0) {
      Int32Value.encode({ value: message.voteUpdatesRemained }, writer.uint32(82).fork()).ldelim();
    }
    if (message.votingEndTimestamp !== void 0) {
      Int32Value.encode({ value: message.votingEndTimestamp }, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal46.default.Reader ? input : import_minimal46.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePoll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isPrediction = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.options.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.predictionStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.resolvedOptionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.totalStakeAmount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.totalVoteCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.tournamentId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.userSelection = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.userWonAmount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.voteUpdatesRemained = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.votingEndTimestamp = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isPrediction: isSet44(object.isPrediction) ? Boolean(object.isPrediction) : void 0,
      options: globalThis.Array.isArray(object?.options) ? [...object.options] : [],
      predictionStatus: isSet44(object.predictionStatus) ? String(object.predictionStatus) : void 0,
      resolvedOptionId: isSet44(object.resolvedOptionId) ? String(object.resolvedOptionId) : void 0,
      totalStakeAmount: isSet44(object.totalStakeAmount) ? Number(object.totalStakeAmount) : void 0,
      totalVoteCount: isSet44(object.totalVoteCount) ? Number(object.totalVoteCount) : void 0,
      tournamentId: isSet44(object.tournamentId) ? String(object.tournamentId) : void 0,
      userSelection: isSet44(object.userSelection) ? String(object.userSelection) : void 0,
      userWonAmount: isSet44(object.userWonAmount) ? Number(object.userWonAmount) : void 0,
      voteUpdatesRemained: isSet44(object.voteUpdatesRemained) ? Number(object.voteUpdatesRemained) : void 0,
      votingEndTimestamp: isSet44(object.votingEndTimestamp) ? Number(object.votingEndTimestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isPrediction !== void 0) {
      obj.isPrediction = message.isPrediction;
    }
    if (message.options?.length) {
      obj.options = message.options;
    }
    if (message.predictionStatus !== void 0) {
      obj.predictionStatus = message.predictionStatus;
    }
    if (message.resolvedOptionId !== void 0) {
      obj.resolvedOptionId = message.resolvedOptionId;
    }
    if (message.totalStakeAmount !== void 0) {
      obj.totalStakeAmount = message.totalStakeAmount;
    }
    if (message.totalVoteCount !== void 0) {
      obj.totalVoteCount = message.totalVoteCount;
    }
    if (message.tournamentId !== void 0) {
      obj.tournamentId = message.tournamentId;
    }
    if (message.userSelection !== void 0) {
      obj.userSelection = message.userSelection;
    }
    if (message.userWonAmount !== void 0) {
      obj.userWonAmount = message.userWonAmount;
    }
    if (message.voteUpdatesRemained !== void 0) {
      obj.voteUpdatesRemained = message.voteUpdatesRemained;
    }
    if (message.votingEndTimestamp !== void 0) {
      obj.votingEndTimestamp = message.votingEndTimestamp;
    }
    return obj;
  },
  create(base) {
    return Poll.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePoll();
    message.isPrediction = object.isPrediction ?? void 0;
    message.options = object.options?.map((e) => e) || [];
    message.predictionStatus = object.predictionStatus ?? void 0;
    message.resolvedOptionId = object.resolvedOptionId ?? void 0;
    message.totalStakeAmount = object.totalStakeAmount ?? void 0;
    message.totalVoteCount = object.totalVoteCount ?? void 0;
    message.tournamentId = object.tournamentId ?? void 0;
    message.userSelection = object.userSelection ?? void 0;
    message.userWonAmount = object.userWonAmount ?? void 0;
    message.voteUpdatesRemained = object.voteUpdatesRemained ?? void 0;
    message.votingEndTimestamp = object.votingEndTimestamp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Poll.$type, Poll);
function createBaseAutomodResult() {
  return { result: "", errors: "" };
}
var AutomodResult = {
  $type: "devvit.gateway.AutomodResult",
  encode(message, writer = import_minimal46.default.Writer.create()) {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.errors !== "") {
      writer.uint32(18).string(message.errors);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal46.default.Reader ? input : import_minimal46.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.errors = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      result: isSet44(object.result) ? globalThis.String(object.result) : "",
      errors: isSet44(object.errors) ? globalThis.String(object.errors) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.errors !== "") {
      obj.errors = message.errors;
    }
    return obj;
  },
  create(base) {
    return AutomodResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomodResult();
    message.result = object.result ?? "";
    message.errors = object.errors ?? "";
    return message;
  }
};
messageTypeRegistry.set(AutomodResult.$type, AutomodResult);
function isSet44(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/app.js
var import_minimal50 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/dev_portal/app_version/info/app_version_info.js
var import_minimal47 = __toESM(require_minimal2(), 1);
var VersionVisibility;
(function(VersionVisibility2) {
  VersionVisibility2[VersionVisibility2["PUBLIC"] = 0] = "PUBLIC";
  VersionVisibility2[VersionVisibility2["PRIVATE"] = 1] = "PRIVATE";
  VersionVisibility2[VersionVisibility2["UNLISTED"] = 2] = "UNLISTED";
  VersionVisibility2[VersionVisibility2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VersionVisibility || (VersionVisibility = {}));
function versionVisibilityFromJSON(object) {
  switch (object) {
    case 0:
    case "PUBLIC":
      return VersionVisibility.PUBLIC;
    case 1:
    case "PRIVATE":
      return VersionVisibility.PRIVATE;
    case 2:
    case "UNLISTED":
      return VersionVisibility.UNLISTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VersionVisibility.UNRECOGNIZED;
  }
}
function versionVisibilityToJSON(object) {
  switch (object) {
    case VersionVisibility.PUBLIC:
      return 0;
    case VersionVisibility.PRIVATE:
      return 1;
    case VersionVisibility.UNLISTED:
      return 2;
    case VersionVisibility.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BuildStatus;
(function(BuildStatus2) {
  BuildStatus2[BuildStatus2["BUILDING"] = 0] = "BUILDING";
  BuildStatus2[BuildStatus2["READY"] = 1] = "READY";
  BuildStatus2[BuildStatus2["FAILED"] = 2] = "FAILED";
  BuildStatus2[BuildStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BuildStatus || (BuildStatus = {}));
function buildStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "BUILDING":
      return BuildStatus.BUILDING;
    case 1:
    case "READY":
      return BuildStatus.READY;
    case 2:
    case "FAILED":
      return BuildStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildStatus.UNRECOGNIZED;
  }
}
function buildStatusToJSON(object) {
  switch (object) {
    case BuildStatus.BUILDING:
      return 0;
    case BuildStatus.READY:
      return 1;
    case BuildStatus.FAILED:
      return 2;
    case BuildStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
var ReviewStatus;
(function(ReviewStatus2) {
  ReviewStatus2[ReviewStatus2["NOT_SUBMITTED"] = 0] = "NOT_SUBMITTED";
  ReviewStatus2[ReviewStatus2["PENDING"] = 1] = "PENDING";
  ReviewStatus2[ReviewStatus2["APPROVED"] = 2] = "APPROVED";
  ReviewStatus2[ReviewStatus2["DENIED"] = 3] = "DENIED";
  ReviewStatus2[ReviewStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ReviewStatus || (ReviewStatus = {}));
function reviewStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "NOT_SUBMITTED":
      return ReviewStatus.NOT_SUBMITTED;
    case 1:
    case "PENDING":
      return ReviewStatus.PENDING;
    case 2:
    case "APPROVED":
      return ReviewStatus.APPROVED;
    case 3:
    case "DENIED":
      return ReviewStatus.DENIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReviewStatus.UNRECOGNIZED;
  }
}
function reviewStatusToJSON(object) {
  switch (object) {
    case ReviewStatus.NOT_SUBMITTED:
      return 0;
    case ReviewStatus.PENDING:
      return 1;
    case ReviewStatus.APPROVED:
      return 2;
    case ReviewStatus.DENIED:
      return 3;
    case ReviewStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
var InstallationType;
(function(InstallationType2) {
  InstallationType2[InstallationType2["USER"] = 0] = "USER";
  InstallationType2[InstallationType2["SUBREDDIT"] = 1] = "SUBREDDIT";
  InstallationType2[InstallationType2["SUBREDDIT_GLOBAL"] = 2] = "SUBREDDIT_GLOBAL";
  InstallationType2[InstallationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InstallationType || (InstallationType = {}));
function installationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "USER":
      return InstallationType.USER;
    case 1:
    case "SUBREDDIT":
      return InstallationType.SUBREDDIT;
    case 2:
    case "SUBREDDIT_GLOBAL":
      return InstallationType.SUBREDDIT_GLOBAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstallationType.UNRECOGNIZED;
  }
}
function installationTypeToJSON(object) {
  switch (object) {
    case InstallationType.USER:
      return 0;
    case InstallationType.SUBREDDIT:
      return 1;
    case InstallationType.SUBREDDIT_GLOBAL:
      return 2;
    case InstallationType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var ComputePool;
(function(ComputePool2) {
  ComputePool2[ComputePool2["LOW"] = 0] = "LOW";
  ComputePool2[ComputePool2["MEDIUM"] = 1] = "MEDIUM";
  ComputePool2[ComputePool2["HIGH"] = 2] = "HIGH";
  ComputePool2[ComputePool2["RESTRICTED"] = 3] = "RESTRICTED";
  ComputePool2[ComputePool2["INTERNAL"] = 4] = "INTERNAL";
  ComputePool2[ComputePool2["BETA"] = 5] = "BETA";
  ComputePool2[ComputePool2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ComputePool || (ComputePool = {}));
function computePoolFromJSON(object) {
  switch (object) {
    case 0:
    case "LOW":
      return ComputePool.LOW;
    case 1:
    case "MEDIUM":
      return ComputePool.MEDIUM;
    case 2:
    case "HIGH":
      return ComputePool.HIGH;
    case 3:
    case "RESTRICTED":
      return ComputePool.RESTRICTED;
    case 4:
    case "INTERNAL":
      return ComputePool.INTERNAL;
    case 5:
    case "BETA":
      return ComputePool.BETA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputePool.UNRECOGNIZED;
  }
}
function computePoolToJSON(object) {
  switch (object) {
    case ComputePool.LOW:
      return 0;
    case ComputePool.MEDIUM:
      return 1;
    case ComputePool.HIGH:
      return 2;
    case ComputePool.RESTRICTED:
      return 3;
    case ComputePool.INTERNAL:
      return 4;
    case ComputePool.BETA:
      return 5;
    case ComputePool.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseOptionalVersionVisibility() {
  return { value: 0 };
}
var OptionalVersionVisibility = {
  $type: "devvit.dev_portal.app_version.info.OptionalVersionVisibility",
  encode(message, writer = import_minimal47.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal47.default.Reader ? input : import_minimal47.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOptionalVersionVisibility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet45(object.value) ? versionVisibilityFromJSON(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = versionVisibilityToJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return OptionalVersionVisibility.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOptionalVersionVisibility();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(OptionalVersionVisibility.$type, OptionalVersionVisibility);
function createBaseAppVersionInfo() {
  return {
    id: "",
    visibility: 0,
    validInstallTypes: [],
    majorVersion: 0,
    minorVersion: 0,
    patchVersion: 0,
    prereleaseVersion: void 0,
    uploadedAt: void 0,
    buildStatus: 0,
    builtAt: void 0,
    about: "",
    hasCustomSettings: false,
    pool: 0,
    reviewStatus: void 0
  };
}
var AppVersionInfo = {
  $type: "devvit.dev_portal.app_version.info.AppVersionInfo",
  encode(message, writer = import_minimal47.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.visibility !== 0) {
      writer.uint32(16).int32(message.visibility);
    }
    writer.uint32(34).fork();
    for (const v of message.validInstallTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.majorVersion !== 0) {
      writer.uint32(40).int32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(48).int32(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      writer.uint32(56).int32(message.patchVersion);
    }
    if (message.prereleaseVersion !== void 0) {
      Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(66).fork()).ldelim();
    }
    if (message.uploadedAt !== void 0) {
      Timestamp.encode(toTimestamp4(message.uploadedAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.buildStatus !== 0) {
      writer.uint32(80).int32(message.buildStatus);
    }
    if (message.builtAt !== void 0) {
      Timestamp.encode(toTimestamp4(message.builtAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.about !== "") {
      writer.uint32(98).string(message.about);
    }
    if (message.hasCustomSettings !== false) {
      writer.uint32(104).bool(message.hasCustomSettings);
    }
    if (message.pool !== 0) {
      writer.uint32(112).int32(message.pool);
    }
    if (message.reviewStatus !== void 0) {
      writer.uint32(120).int32(message.reviewStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal47.default.Reader ? input : import_minimal47.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.visibility = reader.int32();
          continue;
        case 4:
          if (tag === 32) {
            message.validInstallTypes.push(reader.int32());
            continue;
          }
          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validInstallTypes.push(reader.int32());
            }
            continue;
          }
          break;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.majorVersion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.minorVersion = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.patchVersion = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.uploadedAt = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.buildStatus = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.builtAt = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.about = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }
          message.hasCustomSettings = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }
          message.pool = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }
          message.reviewStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet45(object.id) ? globalThis.String(object.id) : "",
      visibility: isSet45(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
      validInstallTypes: globalThis.Array.isArray(object?.validInstallTypes) ? object.validInstallTypes.map((e) => installationTypeFromJSON(e)) : [],
      majorVersion: isSet45(object.majorVersion) ? globalThis.Number(object.majorVersion) : 0,
      minorVersion: isSet45(object.minorVersion) ? globalThis.Number(object.minorVersion) : 0,
      patchVersion: isSet45(object.patchVersion) ? globalThis.Number(object.patchVersion) : 0,
      prereleaseVersion: isSet45(object.prereleaseVersion) ? Number(object.prereleaseVersion) : void 0,
      uploadedAt: isSet45(object.uploadedAt) ? fromJsonTimestamp4(object.uploadedAt) : void 0,
      buildStatus: isSet45(object.buildStatus) ? buildStatusFromJSON(object.buildStatus) : 0,
      builtAt: isSet45(object.builtAt) ? fromJsonTimestamp4(object.builtAt) : void 0,
      about: isSet45(object.about) ? globalThis.String(object.about) : "",
      hasCustomSettings: isSet45(object.hasCustomSettings) ? globalThis.Boolean(object.hasCustomSettings) : false,
      pool: isSet45(object.pool) ? computePoolFromJSON(object.pool) : 0,
      reviewStatus: isSet45(object.reviewStatus) ? reviewStatusFromJSON(object.reviewStatus) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.visibility !== 0) {
      obj.visibility = versionVisibilityToJSON(message.visibility);
    }
    if (message.validInstallTypes?.length) {
      obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
    }
    if (message.majorVersion !== 0) {
      obj.majorVersion = Math.round(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      obj.minorVersion = Math.round(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      obj.patchVersion = Math.round(message.patchVersion);
    }
    if (message.prereleaseVersion !== void 0) {
      obj.prereleaseVersion = message.prereleaseVersion;
    }
    if (message.uploadedAt !== void 0) {
      obj.uploadedAt = message.uploadedAt.toISOString();
    }
    if (message.buildStatus !== 0) {
      obj.buildStatus = buildStatusToJSON(message.buildStatus);
    }
    if (message.builtAt !== void 0) {
      obj.builtAt = message.builtAt.toISOString();
    }
    if (message.about !== "") {
      obj.about = message.about;
    }
    if (message.hasCustomSettings !== false) {
      obj.hasCustomSettings = message.hasCustomSettings;
    }
    if (message.pool !== 0) {
      obj.pool = computePoolToJSON(message.pool);
    }
    if (message.reviewStatus !== void 0) {
      obj.reviewStatus = reviewStatusToJSON(message.reviewStatus);
    }
    return obj;
  },
  create(base) {
    return AppVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppVersionInfo();
    message.id = object.id ?? "";
    message.visibility = object.visibility ?? 0;
    message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.patchVersion = object.patchVersion ?? 0;
    message.prereleaseVersion = object.prereleaseVersion ?? void 0;
    message.uploadedAt = object.uploadedAt ?? void 0;
    message.buildStatus = object.buildStatus ?? 0;
    message.builtAt = object.builtAt ?? void 0;
    message.about = object.about ?? "";
    message.hasCustomSettings = object.hasCustomSettings ?? false;
    message.pool = object.pool ?? 0;
    message.reviewStatus = object.reviewStatus ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AppVersionInfo.$type, AppVersionInfo);
function toTimestamp4(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp4(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp4(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp4(Timestamp.fromJSON(o));
  }
}
function isSet45(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/categories/categories.js
var Categories;
(function(Categories2) {
  Categories2[Categories2["MODERATION"] = 0] = "MODERATION";
  Categories2[Categories2["CUSTOM_POSTS"] = 1] = "CUSTOM_POSTS";
  Categories2[Categories2["UTILITIES"] = 2] = "UTILITIES";
  Categories2[Categories2["OTHER_SITES"] = 3] = "OTHER_SITES";
  Categories2[Categories2["FUNNY"] = 4] = "FUNNY";
  Categories2[Categories2["WEIRD"] = 5] = "WEIRD";
  Categories2[Categories2["AWW"] = 6] = "AWW";
  Categories2[Categories2["LEARNING"] = 7] = "LEARNING";
  Categories2[Categories2["FINANCIAL"] = 8] = "FINANCIAL";
  Categories2[Categories2["SPORTS"] = 9] = "SPORTS";
  Categories2[Categories2["GAMES"] = 10] = "GAMES";
  Categories2[Categories2["MOVIES"] = 11] = "MOVIES";
  Categories2[Categories2["MUSIC"] = 12] = "MUSIC";
  Categories2[Categories2["TV"] = 13] = "TV";
  Categories2[Categories2["BOOKS"] = 14] = "BOOKS";
  Categories2[Categories2["ANIME"] = 15] = "ANIME";
  Categories2[Categories2["PROGRAMMING"] = 16] = "PROGRAMMING";
  Categories2[Categories2["COOKING"] = 17] = "COOKING";
  Categories2[Categories2["FITNESS"] = 18] = "FITNESS";
  Categories2[Categories2["TRAVEL"] = 19] = "TRAVEL";
  Categories2[Categories2["CONTEXT_MENU"] = 20] = "CONTEXT_MENU";
  Categories2[Categories2["MOD_CONTEXT"] = 21] = "MOD_CONTEXT";
  Categories2[Categories2["FILTER"] = 22] = "FILTER";
  Categories2[Categories2["POST_FILTER"] = 23] = "POST_FILTER";
  Categories2[Categories2["COMMENT_FILTER"] = 24] = "COMMENT_FILTER";
  Categories2[Categories2["ANTI_SPAM"] = 25] = "ANTI_SPAM";
  Categories2[Categories2["ANTI_HARASSMENT"] = 26] = "ANTI_HARASSMENT";
  Categories2[Categories2["NSFW_FILTER"] = 27] = "NSFW_FILTER";
  Categories2[Categories2["CITIZEN_FILTER"] = 28] = "CITIZEN_FILTER";
  Categories2[Categories2["POST_FLAIR"] = 29] = "POST_FLAIR";
  Categories2[Categories2["COMMENT_FLAIR"] = 30] = "COMMENT_FLAIR";
  Categories2[Categories2["USER_FLAIR"] = 31] = "USER_FLAIR";
  Categories2[Categories2["MESSAGING"] = 32] = "MESSAGING";
  Categories2[Categories2["MISCHIEF"] = 420] = "MISCHIEF";
  Categories2[Categories2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Categories || (Categories = {}));
function categoriesFromJSON(object) {
  switch (object) {
    case 0:
    case "MODERATION":
      return Categories.MODERATION;
    case 1:
    case "CUSTOM_POSTS":
      return Categories.CUSTOM_POSTS;
    case 2:
    case "UTILITIES":
      return Categories.UTILITIES;
    case 3:
    case "OTHER_SITES":
      return Categories.OTHER_SITES;
    case 4:
    case "FUNNY":
      return Categories.FUNNY;
    case 5:
    case "WEIRD":
      return Categories.WEIRD;
    case 6:
    case "AWW":
      return Categories.AWW;
    case 7:
    case "LEARNING":
      return Categories.LEARNING;
    case 8:
    case "FINANCIAL":
      return Categories.FINANCIAL;
    case 9:
    case "SPORTS":
      return Categories.SPORTS;
    case 10:
    case "GAMES":
      return Categories.GAMES;
    case 11:
    case "MOVIES":
      return Categories.MOVIES;
    case 12:
    case "MUSIC":
      return Categories.MUSIC;
    case 13:
    case "TV":
      return Categories.TV;
    case 14:
    case "BOOKS":
      return Categories.BOOKS;
    case 15:
    case "ANIME":
      return Categories.ANIME;
    case 16:
    case "PROGRAMMING":
      return Categories.PROGRAMMING;
    case 17:
    case "COOKING":
      return Categories.COOKING;
    case 18:
    case "FITNESS":
      return Categories.FITNESS;
    case 19:
    case "TRAVEL":
      return Categories.TRAVEL;
    case 20:
    case "CONTEXT_MENU":
      return Categories.CONTEXT_MENU;
    case 21:
    case "MOD_CONTEXT":
      return Categories.MOD_CONTEXT;
    case 22:
    case "FILTER":
      return Categories.FILTER;
    case 23:
    case "POST_FILTER":
      return Categories.POST_FILTER;
    case 24:
    case "COMMENT_FILTER":
      return Categories.COMMENT_FILTER;
    case 25:
    case "ANTI_SPAM":
      return Categories.ANTI_SPAM;
    case 26:
    case "ANTI_HARASSMENT":
      return Categories.ANTI_HARASSMENT;
    case 27:
    case "NSFW_FILTER":
      return Categories.NSFW_FILTER;
    case 28:
    case "CITIZEN_FILTER":
      return Categories.CITIZEN_FILTER;
    case 29:
    case "POST_FLAIR":
      return Categories.POST_FLAIR;
    case 30:
    case "COMMENT_FLAIR":
      return Categories.COMMENT_FLAIR;
    case 31:
    case "USER_FLAIR":
      return Categories.USER_FLAIR;
    case 32:
    case "MESSAGING":
      return Categories.MESSAGING;
    case 420:
    case "MISCHIEF":
      return Categories.MISCHIEF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Categories.UNRECOGNIZED;
  }
}
function categoriesToJSON(object) {
  switch (object) {
    case Categories.MODERATION:
      return 0;
    case Categories.CUSTOM_POSTS:
      return 1;
    case Categories.UTILITIES:
      return 2;
    case Categories.OTHER_SITES:
      return 3;
    case Categories.FUNNY:
      return 4;
    case Categories.WEIRD:
      return 5;
    case Categories.AWW:
      return 6;
    case Categories.LEARNING:
      return 7;
    case Categories.FINANCIAL:
      return 8;
    case Categories.SPORTS:
      return 9;
    case Categories.GAMES:
      return 10;
    case Categories.MOVIES:
      return 11;
    case Categories.MUSIC:
      return 12;
    case Categories.TV:
      return 13;
    case Categories.BOOKS:
      return 14;
    case Categories.ANIME:
      return 15;
    case Categories.PROGRAMMING:
      return 16;
    case Categories.COOKING:
      return 17;
    case Categories.FITNESS:
      return 18;
    case Categories.TRAVEL:
      return 19;
    case Categories.CONTEXT_MENU:
      return 20;
    case Categories.MOD_CONTEXT:
      return 21;
    case Categories.FILTER:
      return 22;
    case Categories.POST_FILTER:
      return 23;
    case Categories.COMMENT_FILTER:
      return 24;
    case Categories.ANTI_SPAM:
      return 25;
    case Categories.ANTI_HARASSMENT:
      return 26;
    case Categories.NSFW_FILTER:
      return 27;
    case Categories.CITIZEN_FILTER:
      return 28;
    case Categories.POST_FLAIR:
      return 29;
    case Categories.COMMENT_FLAIR:
      return 30;
    case Categories.USER_FLAIR:
      return 31;
    case Categories.MESSAGING:
      return 32;
    case Categories.MISCHIEF:
      return 420;
    case Categories.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/dev_portal/app/info/app_info.js
var import_minimal49 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/dev_portal/reddit/redditor.js
var import_minimal48 = __toESM(require_minimal2(), 1);
function createBaseRedditor() {
  return { id: "", displayName: "", snoovatarIconUrl: "" };
}
var Redditor = {
  $type: "devvit.dev_portal.reddit.Redditor",
  encode(message, writer = import_minimal48.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.snoovatarIconUrl !== "") {
      writer.uint32(26).string(message.snoovatarIconUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal48.default.Reader ? input : import_minimal48.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.snoovatarIconUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet46(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet46(object.displayName) ? globalThis.String(object.displayName) : "",
      snoovatarIconUrl: isSet46(object.snoovatarIconUrl) ? globalThis.String(object.snoovatarIconUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.snoovatarIconUrl !== "") {
      obj.snoovatarIconUrl = message.snoovatarIconUrl;
    }
    return obj;
  },
  create(base) {
    return Redditor.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditor();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.snoovatarIconUrl = object.snoovatarIconUrl ?? "";
    return message;
  }
};
messageTypeRegistry.set(Redditor.$type, Redditor);
function isSet46(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/info/app_info.js
function createBaseAppInfo() {
  return {
    id: "",
    slug: "",
    name: "",
    description: "",
    appAccount: void 0,
    isNsfw: false,
    isDelisted: false,
    isFirstParty: false,
    isArchived: false,
    createdAt: void 0,
    owner: void 0,
    categories: [],
    stats: void 0,
    termsAndConditions: "",
    privacyPolicy: "",
    defaultPool: 0
  };
}
var AppInfo = {
  $type: "devvit.dev_portal.app.info.AppInfo",
  encode(message, writer = import_minimal49.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.appAccount !== void 0) {
      Redditor.encode(message.appAccount, writer.uint32(122).fork()).ldelim();
    }
    if (message.isNsfw !== false) {
      writer.uint32(40).bool(message.isNsfw);
    }
    if (message.isDelisted !== false) {
      writer.uint32(48).bool(message.isDelisted);
    }
    if (message.isFirstParty !== false) {
      writer.uint32(104).bool(message.isFirstParty);
    }
    if (message.isArchived !== false) {
      writer.uint32(112).bool(message.isArchived);
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp5(message.createdAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      Redditor.encode(message.owner, writer.uint32(66).fork()).ldelim();
    }
    writer.uint32(74).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.stats !== void 0) {
      AppStats.encode(message.stats, writer.uint32(82).fork()).ldelim();
    }
    if (message.termsAndConditions !== "") {
      writer.uint32(90).string(message.termsAndConditions);
    }
    if (message.privacyPolicy !== "") {
      writer.uint32(98).string(message.privacyPolicy);
    }
    if (message.defaultPool !== 0) {
      writer.uint32(128).int32(message.defaultPool);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal49.default.Reader ? input : import_minimal49.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.appAccount = Redditor.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.isNsfw = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.isDelisted = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }
          message.isFirstParty = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }
          message.isArchived = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.createdAt = fromTimestamp5(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.owner = Redditor.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag === 72) {
            message.categories.push(reader.int32());
            continue;
          }
          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
            continue;
          }
          break;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.stats = AppStats.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.termsAndConditions = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.privacyPolicy = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }
          message.defaultPool = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet47(object.id) ? globalThis.String(object.id) : "",
      slug: isSet47(object.slug) ? globalThis.String(object.slug) : "",
      name: isSet47(object.name) ? globalThis.String(object.name) : "",
      description: isSet47(object.description) ? globalThis.String(object.description) : "",
      appAccount: isSet47(object.appAccount) ? Redditor.fromJSON(object.appAccount) : void 0,
      isNsfw: isSet47(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false,
      isDelisted: isSet47(object.isDelisted) ? globalThis.Boolean(object.isDelisted) : false,
      isFirstParty: isSet47(object.isFirstParty) ? globalThis.Boolean(object.isFirstParty) : false,
      isArchived: isSet47(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
      createdAt: isSet47(object.createdAt) ? fromJsonTimestamp5(object.createdAt) : void 0,
      owner: isSet47(object.owner) ? Redditor.fromJSON(object.owner) : void 0,
      categories: globalThis.Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      stats: isSet47(object.stats) ? AppStats.fromJSON(object.stats) : void 0,
      termsAndConditions: isSet47(object.termsAndConditions) ? globalThis.String(object.termsAndConditions) : "",
      privacyPolicy: isSet47(object.privacyPolicy) ? globalThis.String(object.privacyPolicy) : "",
      defaultPool: isSet47(object.defaultPool) ? computePoolFromJSON(object.defaultPool) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.appAccount !== void 0) {
      obj.appAccount = Redditor.toJSON(message.appAccount);
    }
    if (message.isNsfw !== false) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.isDelisted !== false) {
      obj.isDelisted = message.isDelisted;
    }
    if (message.isFirstParty !== false) {
      obj.isFirstParty = message.isFirstParty;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.owner !== void 0) {
      obj.owner = Redditor.toJSON(message.owner);
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    }
    if (message.stats !== void 0) {
      obj.stats = AppStats.toJSON(message.stats);
    }
    if (message.termsAndConditions !== "") {
      obj.termsAndConditions = message.termsAndConditions;
    }
    if (message.privacyPolicy !== "") {
      obj.privacyPolicy = message.privacyPolicy;
    }
    if (message.defaultPool !== 0) {
      obj.defaultPool = computePoolToJSON(message.defaultPool);
    }
    return obj;
  },
  create(base) {
    return AppInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppInfo();
    message.id = object.id ?? "";
    message.slug = object.slug ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.appAccount = object.appAccount !== void 0 && object.appAccount !== null ? Redditor.fromPartial(object.appAccount) : void 0;
    message.isNsfw = object.isNsfw ?? false;
    message.isDelisted = object.isDelisted ?? false;
    message.isFirstParty = object.isFirstParty ?? false;
    message.isArchived = object.isArchived ?? false;
    message.createdAt = object.createdAt ?? void 0;
    message.owner = object.owner !== void 0 && object.owner !== null ? Redditor.fromPartial(object.owner) : void 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.stats = object.stats !== void 0 && object.stats !== null ? AppStats.fromPartial(object.stats) : void 0;
    message.termsAndConditions = object.termsAndConditions ?? "";
    message.privacyPolicy = object.privacyPolicy ?? "";
    message.defaultPool = object.defaultPool ?? 0;
    return message;
  }
};
messageTypeRegistry.set(AppInfo.$type, AppInfo);
function createBaseMultipleAppInfos() {
  return { apps: [] };
}
var MultipleAppInfos = {
  $type: "devvit.dev_portal.app.info.MultipleAppInfos",
  encode(message, writer = import_minimal49.default.Writer.create()) {
    for (const v of message.apps) {
      AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal49.default.Reader ? input : import_minimal49.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultipleAppInfos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.apps.push(AppInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => AppInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MultipleAppInfos.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMultipleAppInfos();
    message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(MultipleAppInfos.$type, MultipleAppInfos);
function createBaseAppStats() {
  return { installCount: 0 };
}
var AppStats = {
  $type: "devvit.dev_portal.app.info.AppStats",
  encode(message, writer = import_minimal49.default.Writer.create()) {
    if (message.installCount !== 0) {
      writer.uint32(8).int32(message.installCount);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal49.default.Reader ? input : import_minimal49.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.installCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { installCount: isSet47(object.installCount) ? globalThis.Number(object.installCount) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.installCount !== 0) {
      obj.installCount = Math.round(message.installCount);
    }
    return obj;
  },
  create(base) {
    return AppStats.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppStats();
    message.installCount = object.installCount ?? 0;
    return message;
  }
};
messageTypeRegistry.set(AppStats.$type, AppStats);
function toTimestamp5(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp5(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp5(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp5(Timestamp.fromJSON(o));
  }
}
function isSet47(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/app.js
var OrderBy;
(function(OrderBy2) {
  OrderBy2[OrderBy2["DATE_CREATED"] = 0] = "DATE_CREATED";
  OrderBy2[OrderBy2["NAME"] = 1] = "NAME";
  OrderBy2[OrderBy2["POPULARITY"] = 2] = "POPULARITY";
  OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderBy || (OrderBy = {}));
function orderByFromJSON(object) {
  switch (object) {
    case 0:
    case "DATE_CREATED":
      return OrderBy.DATE_CREATED;
    case 1:
    case "NAME":
      return OrderBy.NAME;
    case 2:
    case "POPULARITY":
      return OrderBy.POPULARITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderBy.UNRECOGNIZED;
  }
}
function orderByToJSON(object) {
  switch (object) {
    case OrderBy.DATE_CREATED:
      return 0;
    case OrderBy.NAME:
      return 1;
    case OrderBy.POPULARITY:
      return 2;
    case OrderBy.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAppSearchRequest() {
  return {
    searchTerm: void 0,
    categories: [],
    page: void 0,
    pageSize: void 0,
    orderBy: 0,
    isAscending: void 0
  };
}
var AppSearchRequest = {
  $type: "devvit.dev_portal.app.AppSearchRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.searchTerm !== void 0) {
      StringValue.encode({ value: message.searchTerm }, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.page !== void 0) {
      Int32Value.encode({ value: message.page }, writer.uint32(26).fork()).ldelim();
    }
    if (message.pageSize !== void 0) {
      Int32Value.encode({ value: message.pageSize }, writer.uint32(34).fork()).ldelim();
    }
    if (message.orderBy !== 0) {
      writer.uint32(40).int32(message.orderBy);
    }
    if (message.isAscending !== void 0) {
      BoolValue.encode({ value: message.isAscending }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.searchTerm = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag === 16) {
            message.categories.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
            continue;
          }
          break;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.page = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.pageSize = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.orderBy = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isAscending = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      searchTerm: isSet48(object.searchTerm) ? String(object.searchTerm) : void 0,
      categories: globalThis.Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      page: isSet48(object.page) ? Number(object.page) : void 0,
      pageSize: isSet48(object.pageSize) ? Number(object.pageSize) : void 0,
      orderBy: isSet48(object.orderBy) ? orderByFromJSON(object.orderBy) : 0,
      isAscending: isSet48(object.isAscending) ? Boolean(object.isAscending) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.searchTerm !== void 0) {
      obj.searchTerm = message.searchTerm;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    }
    if (message.page !== void 0) {
      obj.page = message.page;
    }
    if (message.pageSize !== void 0) {
      obj.pageSize = message.pageSize;
    }
    if (message.orderBy !== 0) {
      obj.orderBy = orderByToJSON(message.orderBy);
    }
    if (message.isAscending !== void 0) {
      obj.isAscending = message.isAscending;
    }
    return obj;
  },
  create(base) {
    return AppSearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppSearchRequest();
    message.searchTerm = object.searchTerm ?? void 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.page = object.page ?? void 0;
    message.pageSize = object.pageSize ?? void 0;
    message.orderBy = object.orderBy ?? 0;
    message.isAscending = object.isAscending ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AppSearchRequest.$type, AppSearchRequest);
function createBaseGetAppBySlugRequest() {
  return { slug: "" };
}
var GetAppBySlugRequest = {
  $type: "devvit.dev_portal.app.GetAppBySlugRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppBySlugRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { slug: isSet48(object.slug) ? globalThis.String(object.slug) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    return obj;
  },
  create(base) {
    return GetAppBySlugRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppBySlugRequest();
    message.slug = object.slug ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAppBySlugRequest.$type, GetAppBySlugRequest);
function createBaseGetAllWithOwnerRequest() {
  return { owner: "" };
}
var GetAllWithOwnerRequest = {
  $type: "devvit.dev_portal.app.GetAllWithOwnerRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.owner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { owner: isSet48(object.owner) ? globalThis.String(object.owner) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },
  create(base) {
    return GetAllWithOwnerRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAllWithOwnerRequest();
    message.owner = object.owner ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAllWithOwnerRequest.$type, GetAllWithOwnerRequest);
function createBaseAppCreationRequest() {
  return { name: "", description: "", isNsfw: false, categories: [], autogenerateName: false, captcha: "" };
}
var AppCreationRequest = {
  $type: "devvit.dev_portal.app.AppCreationRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.isNsfw !== false) {
      writer.uint32(24).bool(message.isNsfw);
    }
    writer.uint32(34).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.autogenerateName !== false) {
      writer.uint32(40).bool(message.autogenerateName);
    }
    if (message.captcha !== "") {
      writer.uint32(50).string(message.captcha);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.isNsfw = reader.bool();
          continue;
        case 4:
          if (tag === 32) {
            message.categories.push(reader.int32());
            continue;
          }
          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
            continue;
          }
          break;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.autogenerateName = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.captcha = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet48(object.name) ? globalThis.String(object.name) : "",
      description: isSet48(object.description) ? globalThis.String(object.description) : "",
      isNsfw: isSet48(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false,
      categories: globalThis.Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      autogenerateName: isSet48(object.autogenerateName) ? globalThis.Boolean(object.autogenerateName) : false,
      captcha: isSet48(object.captcha) ? globalThis.String(object.captcha) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isNsfw !== false) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    }
    if (message.autogenerateName !== false) {
      obj.autogenerateName = message.autogenerateName;
    }
    if (message.captcha !== "") {
      obj.captcha = message.captcha;
    }
    return obj;
  },
  create(base) {
    return AppCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppCreationRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.isNsfw = object.isNsfw ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.autogenerateName = object.autogenerateName ?? false;
    message.captcha = object.captcha ?? "";
    return message;
  }
};
messageTypeRegistry.set(AppCreationRequest.$type, AppCreationRequest);
function createBaseGetPopularAppsRequest() {
  return { limit: 0 };
}
var GetPopularAppsRequest = {
  $type: "devvit.dev_portal.app.GetPopularAppsRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPopularAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { limit: isSet48(object.limit) ? globalThis.Number(object.limit) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },
  create(base) {
    return GetPopularAppsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetPopularAppsRequest();
    message.limit = object.limit ?? 0;
    return message;
  }
};
messageTypeRegistry.set(GetPopularAppsRequest.$type, GetPopularAppsRequest);
function createBaseMediaSignature() {
  return { filePath: "", size: 0, hash: "" };
}
var MediaSignature = {
  $type: "devvit.dev_portal.app.MediaSignature",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.size !== 0) {
      writer.uint32(16).int32(message.size);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.filePath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.size = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filePath: isSet48(object.filePath) ? globalThis.String(object.filePath) : "",
      size: isSet48(object.size) ? globalThis.Number(object.size) : 0,
      hash: isSet48(object.hash) ? globalThis.String(object.hash) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },
  create(base) {
    return MediaSignature.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMediaSignature();
    message.filePath = object.filePath ?? "";
    message.size = object.size ?? 0;
    message.hash = object.hash ?? "";
    return message;
  }
};
messageTypeRegistry.set(MediaSignature.$type, MediaSignature);
function createBaseCheckIfMediaExistsRequest() {
  return { id: void 0, slug: void 0, signatures: [] };
}
var CheckIfMediaExistsRequest = {
  $type: "devvit.dev_portal.app.CheckIfMediaExistsRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.id !== void 0) {
      writer.uint32(10).string(message.id);
    }
    if (message.slug !== void 0) {
      writer.uint32(18).string(message.slug);
    }
    for (const v of message.signatures) {
      MediaSignature.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCheckIfMediaExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.signatures.push(MediaSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet48(object.id) ? globalThis.String(object.id) : void 0,
      slug: isSet48(object.slug) ? globalThis.String(object.slug) : void 0,
      signatures: globalThis.Array.isArray(object?.signatures) ? object.signatures.map((e) => MediaSignature.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.slug !== void 0) {
      obj.slug = message.slug;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => MediaSignature.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return CheckIfMediaExistsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCheckIfMediaExistsRequest();
    message.id = object.id ?? void 0;
    message.slug = object.slug ?? void 0;
    message.signatures = object.signatures?.map((e) => MediaSignature.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(CheckIfMediaExistsRequest.$type, CheckIfMediaExistsRequest);
function createBaseUploadNewMediaRequest() {
  return { id: void 0, slug: void 0, size: 0, hash: "", contents: new Uint8Array(0) };
}
var UploadNewMediaRequest = {
  $type: "devvit.dev_portal.app.UploadNewMediaRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.id !== void 0) {
      writer.uint32(10).string(message.id);
    }
    if (message.slug !== void 0) {
      writer.uint32(18).string(message.slug);
    }
    if (message.size !== 0) {
      writer.uint32(24).int32(message.size);
    }
    if (message.hash !== "") {
      writer.uint32(34).string(message.hash);
    }
    if (message.contents.length !== 0) {
      writer.uint32(42).bytes(message.contents);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadNewMediaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.size = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.hash = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.contents = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet48(object.id) ? globalThis.String(object.id) : void 0,
      slug: isSet48(object.slug) ? globalThis.String(object.slug) : void 0,
      size: isSet48(object.size) ? globalThis.Number(object.size) : 0,
      hash: isSet48(object.hash) ? globalThis.String(object.hash) : "",
      contents: isSet48(object.contents) ? bytesFromBase644(object.contents) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.slug !== void 0) {
      obj.slug = message.slug;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes4(message.contents);
    }
    return obj;
  },
  create(base) {
    return UploadNewMediaRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUploadNewMediaRequest();
    message.id = object.id ?? void 0;
    message.slug = object.slug ?? void 0;
    message.size = object.size ?? 0;
    message.hash = object.hash ?? "";
    message.contents = object.contents ?? new Uint8Array(0);
    return message;
  }
};
messageTypeRegistry.set(UploadNewMediaRequest.$type, UploadNewMediaRequest);
function createBaseAppUpdateRequest() {
  return {
    id: "",
    slug: void 0,
    name: void 0,
    description: void 0,
    isNsfw: void 0,
    isDelisted: void 0,
    categories: [],
    termsAndConditions: void 0,
    privacyPolicy: void 0,
    defaultPool: void 0
  };
}
var AppUpdateRequest = {
  $type: "devvit.dev_portal.app.AppUpdateRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.slug !== void 0) {
      StringValue.encode({ value: message.slug }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isNsfw !== void 0) {
      BoolValue.encode({ value: message.isNsfw }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isDelisted !== void 0) {
      BoolValue.encode({ value: message.isDelisted }, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(58).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.termsAndConditions !== void 0) {
      StringValue.encode({ value: message.termsAndConditions }, writer.uint32(66).fork()).ldelim();
    }
    if (message.privacyPolicy !== void 0) {
      StringValue.encode({ value: message.privacyPolicy }, writer.uint32(74).fork()).ldelim();
    }
    if (message.defaultPool !== void 0) {
      writer.uint32(80).int32(message.defaultPool);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.slug = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isDelisted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag === 56) {
            message.categories.push(reader.int32());
            continue;
          }
          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
            continue;
          }
          break;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.termsAndConditions = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.privacyPolicy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.defaultPool = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet48(object.id) ? globalThis.String(object.id) : "",
      slug: isSet48(object.slug) ? String(object.slug) : void 0,
      name: isSet48(object.name) ? String(object.name) : void 0,
      description: isSet48(object.description) ? String(object.description) : void 0,
      isNsfw: isSet48(object.isNsfw) ? Boolean(object.isNsfw) : void 0,
      isDelisted: isSet48(object.isDelisted) ? Boolean(object.isDelisted) : void 0,
      categories: globalThis.Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      termsAndConditions: isSet48(object.termsAndConditions) ? String(object.termsAndConditions) : void 0,
      privacyPolicy: isSet48(object.privacyPolicy) ? String(object.privacyPolicy) : void 0,
      defaultPool: isSet48(object.defaultPool) ? computePoolFromJSON(object.defaultPool) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.slug !== void 0) {
      obj.slug = message.slug;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.isNsfw !== void 0) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.isDelisted !== void 0) {
      obj.isDelisted = message.isDelisted;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    }
    if (message.termsAndConditions !== void 0) {
      obj.termsAndConditions = message.termsAndConditions;
    }
    if (message.privacyPolicy !== void 0) {
      obj.privacyPolicy = message.privacyPolicy;
    }
    if (message.defaultPool !== void 0) {
      obj.defaultPool = computePoolToJSON(message.defaultPool);
    }
    return obj;
  },
  create(base) {
    return AppUpdateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppUpdateRequest();
    message.id = object.id ?? "";
    message.slug = object.slug ?? void 0;
    message.name = object.name ?? void 0;
    message.description = object.description ?? void 0;
    message.isNsfw = object.isNsfw ?? void 0;
    message.isDelisted = object.isDelisted ?? void 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.termsAndConditions = object.termsAndConditions ?? void 0;
    message.privacyPolicy = object.privacyPolicy ?? void 0;
    message.defaultPool = object.defaultPool ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AppUpdateRequest.$type, AppUpdateRequest);
function createBaseFullAppInfo() {
  return { app: void 0, versions: [] };
}
var FullAppInfo = {
  $type: "devvit.dev_portal.app.FullAppInfo",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.app !== void 0) {
      AppInfo.encode(message.app, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.versions) {
      AppVersionInfo.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullAppInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.app = AppInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.versions.push(AppVersionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      app: isSet48(object.app) ? AppInfo.fromJSON(object.app) : void 0,
      versions: globalThis.Array.isArray(object?.versions) ? object.versions.map((e) => AppVersionInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.app !== void 0) {
      obj.app = AppInfo.toJSON(message.app);
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => AppVersionInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FullAppInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFullAppInfo();
    message.app = object.app !== void 0 && object.app !== null ? AppInfo.fromPartial(object.app) : void 0;
    message.versions = object.versions?.map((e) => AppVersionInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FullAppInfo.$type, FullAppInfo);
function createBaseMediaSignatureStatus() {
  return { filePath: "", isNew: false, existingMediaId: void 0 };
}
var MediaSignatureStatus = {
  $type: "devvit.dev_portal.app.MediaSignatureStatus",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.isNew !== false) {
      writer.uint32(16).bool(message.isNew);
    }
    if (message.existingMediaId !== void 0) {
      writer.uint32(26).string(message.existingMediaId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaSignatureStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.filePath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.isNew = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.existingMediaId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filePath: isSet48(object.filePath) ? globalThis.String(object.filePath) : "",
      isNew: isSet48(object.isNew) ? globalThis.Boolean(object.isNew) : false,
      existingMediaId: isSet48(object.existingMediaId) ? globalThis.String(object.existingMediaId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.isNew !== false) {
      obj.isNew = message.isNew;
    }
    if (message.existingMediaId !== void 0) {
      obj.existingMediaId = message.existingMediaId;
    }
    return obj;
  },
  create(base) {
    return MediaSignatureStatus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMediaSignatureStatus();
    message.filePath = object.filePath ?? "";
    message.isNew = object.isNew ?? false;
    message.existingMediaId = object.existingMediaId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(MediaSignatureStatus.$type, MediaSignatureStatus);
function createBaseCheckIfMediaExistsResponse() {
  return { statuses: [] };
}
var CheckIfMediaExistsResponse = {
  $type: "devvit.dev_portal.app.CheckIfMediaExistsResponse",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    for (const v of message.statuses) {
      MediaSignatureStatus.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCheckIfMediaExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.statuses.push(MediaSignatureStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e) => MediaSignatureStatus.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => MediaSignatureStatus.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return CheckIfMediaExistsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCheckIfMediaExistsResponse();
    message.statuses = object.statuses?.map((e) => MediaSignatureStatus.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(CheckIfMediaExistsResponse.$type, CheckIfMediaExistsResponse);
function createBaseUploadNewMediaResponse() {
  return { assetId: "", mediaId: "" };
}
var UploadNewMediaResponse = {
  $type: "devvit.dev_portal.app.UploadNewMediaResponse",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.mediaId !== "") {
      writer.uint32(18).string(message.mediaId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadNewMediaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.assetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.mediaId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      assetId: isSet48(object.assetId) ? globalThis.String(object.assetId) : "",
      mediaId: isSet48(object.mediaId) ? globalThis.String(object.mediaId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.mediaId !== "") {
      obj.mediaId = message.mediaId;
    }
    return obj;
  },
  create(base) {
    return UploadNewMediaResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUploadNewMediaResponse();
    message.assetId = object.assetId ?? "";
    message.mediaId = object.mediaId ?? "";
    return message;
  }
};
messageTypeRegistry.set(UploadNewMediaResponse.$type, UploadNewMediaResponse);
function createBaseAppSearchResponse() {
  return { apps: [], totalResults: 0, pageNumber: 0, pageSize: 0 };
}
var AppSearchResponse = {
  $type: "devvit.dev_portal.app.AppSearchResponse",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    for (const v of message.apps) {
      AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalResults !== 0) {
      writer.uint32(16).int32(message.totalResults);
    }
    if (message.pageNumber !== 0) {
      writer.uint32(24).int32(message.pageNumber);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.apps.push(AppInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.totalResults = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.pageNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [],
      totalResults: isSet48(object.totalResults) ? globalThis.Number(object.totalResults) : 0,
      pageNumber: isSet48(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
      pageSize: isSet48(object.pageSize) ? globalThis.Number(object.pageSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => AppInfo.toJSON(e));
    }
    if (message.totalResults !== 0) {
      obj.totalResults = Math.round(message.totalResults);
    }
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },
  create(base) {
    return AppSearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppSearchResponse();
    message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
    message.totalResults = object.totalResults ?? 0;
    message.pageNumber = object.pageNumber ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  }
};
messageTypeRegistry.set(AppSearchResponse.$type, AppSearchResponse);
function createBaseUnpublishAppRequest() {
  return { slug: void 0, shouldDelist: false };
}
var UnpublishAppRequest = {
  $type: "devvit.dev_portal.app.UnpublishAppRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.slug !== void 0) {
      StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
    }
    if (message.shouldDelist !== false) {
      writer.uint32(16).bool(message.shouldDelist);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpublishAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.shouldDelist = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet48(object.slug) ? String(object.slug) : void 0,
      shouldDelist: isSet48(object.shouldDelist) ? globalThis.Boolean(object.shouldDelist) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== void 0) {
      obj.slug = message.slug;
    }
    if (message.shouldDelist !== false) {
      obj.shouldDelist = message.shouldDelist;
    }
    return obj;
  },
  create(base) {
    return UnpublishAppRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUnpublishAppRequest();
    message.slug = object.slug ?? void 0;
    message.shouldDelist = object.shouldDelist ?? false;
    return message;
  }
};
messageTypeRegistry.set(UnpublishAppRequest.$type, UnpublishAppRequest);
function createBaseAppExistsRequest() {
  return { slug: void 0 };
}
var AppExistsRequest = {
  $type: "devvit.dev_portal.app.AppExistsRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.slug !== void 0) {
      StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { slug: isSet48(object.slug) ? String(object.slug) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== void 0) {
      obj.slug = message.slug;
    }
    return obj;
  },
  create(base) {
    return AppExistsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppExistsRequest();
    message.slug = object.slug ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AppExistsRequest.$type, AppExistsRequest);
function createBaseAppExistsResponse() {
  return { exists: false };
}
var AppExistsResponse = {
  $type: "devvit.dev_portal.app.AppExistsResponse",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.exists = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { exists: isSet48(object.exists) ? globalThis.Boolean(object.exists) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },
  create(base) {
    return AppExistsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  }
};
messageTypeRegistry.set(AppExistsResponse.$type, AppExistsResponse);
function createBaseAppAccountExistsRequest() {
  return { accountName: "" };
}
var AppAccountExistsRequest = {
  $type: "devvit.dev_portal.app.AppAccountExistsRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.accountName !== "") {
      writer.uint32(10).string(message.accountName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppAccountExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.accountName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { accountName: isSet48(object.accountName) ? globalThis.String(object.accountName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    return obj;
  },
  create(base) {
    return AppAccountExistsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppAccountExistsRequest();
    message.accountName = object.accountName ?? "";
    return message;
  }
};
messageTypeRegistry.set(AppAccountExistsRequest.$type, AppAccountExistsRequest);
function createBaseAppAccountExistsResponse() {
  return { exists: false, suggestions: [] };
}
var AppAccountExistsResponse = {
  $type: "devvit.dev_portal.app.AppAccountExistsResponse",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    for (const v of message.suggestions) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppAccountExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.exists = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.suggestions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      exists: isSet48(object.exists) ? globalThis.Boolean(object.exists) : false,
      suggestions: globalThis.Array.isArray(object?.suggestions) ? object.suggestions.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions;
    }
    return obj;
  },
  create(base) {
    return AppAccountExistsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppAccountExistsResponse();
    message.exists = object.exists ?? false;
    message.suggestions = object.suggestions?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(AppAccountExistsResponse.$type, AppAccountExistsResponse);
function createBaseCreateAppAccountRequest() {
  return { slug: "", accountName: void 0, captcha: "" };
}
var CreateAppAccountRequest = {
  $type: "devvit.dev_portal.app.CreateAppAccountRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.accountName !== void 0) {
      writer.uint32(18).string(message.accountName);
    }
    if (message.captcha !== "") {
      writer.uint32(26).string(message.captcha);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateAppAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.accountName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.captcha = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet48(object.slug) ? globalThis.String(object.slug) : "",
      accountName: isSet48(object.accountName) ? globalThis.String(object.accountName) : void 0,
      captcha: isSet48(object.captcha) ? globalThis.String(object.captcha) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.accountName !== void 0) {
      obj.accountName = message.accountName;
    }
    if (message.captcha !== "") {
      obj.captcha = message.captcha;
    }
    return obj;
  },
  create(base) {
    return CreateAppAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateAppAccountRequest();
    message.slug = object.slug ?? "";
    message.accountName = object.accountName ?? void 0;
    message.captcha = object.captcha ?? "";
    return message;
  }
};
messageTypeRegistry.set(CreateAppAccountRequest.$type, CreateAppAccountRequest);
function createBaseCreateAppAccountResponse() {
  return { created: false, errors: void 0 };
}
var CreateAppAccountResponse = {
  $type: "devvit.dev_portal.app.CreateAppAccountResponse",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.created !== false) {
      writer.uint32(8).bool(message.created);
    }
    if (message.errors !== void 0) {
      writer.uint32(18).string(message.errors);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateAppAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.created = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.errors = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      created: isSet48(object.created) ? globalThis.Boolean(object.created) : false,
      errors: isSet48(object.errors) ? globalThis.String(object.errors) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.created !== false) {
      obj.created = message.created;
    }
    if (message.errors !== void 0) {
      obj.errors = message.errors;
    }
    return obj;
  },
  create(base) {
    return CreateAppAccountResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateAppAccountResponse();
    message.created = object.created ?? false;
    message.errors = object.errors ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateAppAccountResponse.$type, CreateAppAccountResponse);
function createBaseRecoverAppAccountRequest() {
  return {
    name: "",
    slug: "",
    description: "",
    isNsfw: false,
    categories: [],
    ownerId: "",
    username: "",
    password: ""
  };
}
var RecoverAppAccountRequest = {
  $type: "devvit.dev_portal.app.RecoverAppAccountRequest",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.isNsfw !== false) {
      writer.uint32(32).bool(message.isNsfw);
    }
    writer.uint32(42).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.ownerId !== "") {
      writer.uint32(50).string(message.ownerId);
    }
    if (message.username !== "") {
      writer.uint32(58).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(66).string(message.password);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : import_minimal50.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecoverAppAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.isNsfw = reader.bool();
          continue;
        case 5:
          if (tag === 40) {
            message.categories.push(reader.int32());
            continue;
          }
          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
            continue;
          }
          break;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.ownerId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.username = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet48(object.name) ? globalThis.String(object.name) : "",
      slug: isSet48(object.slug) ? globalThis.String(object.slug) : "",
      description: isSet48(object.description) ? globalThis.String(object.description) : "",
      isNsfw: isSet48(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false,
      categories: globalThis.Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      ownerId: isSet48(object.ownerId) ? globalThis.String(object.ownerId) : "",
      username: isSet48(object.username) ? globalThis.String(object.username) : "",
      password: isSet48(object.password) ? globalThis.String(object.password) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isNsfw !== false) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },
  create(base) {
    return RecoverAppAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRecoverAppAccountRequest();
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.description = object.description ?? "";
    message.isNsfw = object.isNsfw ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.ownerId = object.ownerId ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  }
};
messageTypeRegistry.set(RecoverAppAccountRequest.$type, RecoverAppAccountRequest);
function bytesFromBase644(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes4(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isSet48(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation/installation.js
var import_minimal51 = __toESM(require_minimal2(), 1);
var UpgradeStrategy;
(function(UpgradeStrategy2) {
  UpgradeStrategy2[UpgradeStrategy2["MANUAL"] = 0] = "MANUAL";
  UpgradeStrategy2[UpgradeStrategy2["AUTOMATIC"] = 1] = "AUTOMATIC";
  UpgradeStrategy2[UpgradeStrategy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(UpgradeStrategy || (UpgradeStrategy = {}));
function upgradeStrategyFromJSON(object) {
  switch (object) {
    case 0:
    case "MANUAL":
      return UpgradeStrategy.MANUAL;
    case 1:
    case "AUTOMATIC":
      return UpgradeStrategy.AUTOMATIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpgradeStrategy.UNRECOGNIZED;
  }
}
function upgradeStrategyToJSON(object) {
  switch (object) {
    case UpgradeStrategy.MANUAL:
      return 0;
    case UpgradeStrategy.AUTOMATIC:
      return 1;
    case UpgradeStrategy.UNRECOGNIZED:
    default:
      return -1;
  }
}
var InstallationHistoryEventName;
(function(InstallationHistoryEventName2) {
  InstallationHistoryEventName2[InstallationHistoryEventName2["INSTALLED"] = 0] = "INSTALLED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UNINSTALLED"] = 1] = "UNINSTALLED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UPGRADED"] = 2] = "UPGRADED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UPDATED"] = 3] = "UPDATED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["BANNED"] = 4] = "BANNED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UNBANNED"] = 5] = "UNBANNED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InstallationHistoryEventName || (InstallationHistoryEventName = {}));
function installationHistoryEventNameFromJSON(object) {
  switch (object) {
    case 0:
    case "INSTALLED":
      return InstallationHistoryEventName.INSTALLED;
    case 1:
    case "UNINSTALLED":
      return InstallationHistoryEventName.UNINSTALLED;
    case 2:
    case "UPGRADED":
      return InstallationHistoryEventName.UPGRADED;
    case 3:
    case "UPDATED":
      return InstallationHistoryEventName.UPDATED;
    case 4:
    case "BANNED":
      return InstallationHistoryEventName.BANNED;
    case 5:
    case "UNBANNED":
      return InstallationHistoryEventName.UNBANNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstallationHistoryEventName.UNRECOGNIZED;
  }
}
function installationHistoryEventNameToJSON(object) {
  switch (object) {
    case InstallationHistoryEventName.INSTALLED:
      return 0;
    case InstallationHistoryEventName.UNINSTALLED:
      return 1;
    case InstallationHistoryEventName.UPGRADED:
      return 2;
    case InstallationHistoryEventName.UPDATED:
      return 3;
    case InstallationHistoryEventName.BANNED:
      return 4;
    case InstallationHistoryEventName.UNBANNED:
      return 5;
    case InstallationHistoryEventName.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseOptionalUpgradeStrategy() {
  return { value: 0 };
}
var OptionalUpgradeStrategy = {
  $type: "devvit.dev_portal.installation.OptionalUpgradeStrategy",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOptionalUpgradeStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet49(object.value) ? upgradeStrategyFromJSON(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = upgradeStrategyToJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return OptionalUpgradeStrategy.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOptionalUpgradeStrategy();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(OptionalUpgradeStrategy.$type, OptionalUpgradeStrategy);
function createBaseInstallationCreationRequest() {
  return {
    appVersionId: "",
    runAs: void 0,
    type: 0,
    location: "",
    upgradeStrategy: 0,
    upgradeStrategyConfig: void 0
  };
}
var InstallationCreationRequest = {
  $type: "devvit.dev_portal.installation.InstallationCreationRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.appVersionId !== "") {
      writer.uint32(10).string(message.appVersionId);
    }
    if (message.runAs !== void 0) {
      StringValue.encode({ value: message.runAs }, writer.uint32(26).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(42).string(message.location);
    }
    if (message.upgradeStrategy !== 0) {
      writer.uint32(48).int32(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appVersionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.runAs = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.location = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.upgradeStrategy = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appVersionId: isSet49(object.appVersionId) ? globalThis.String(object.appVersionId) : "",
      runAs: isSet49(object.runAs) ? String(object.runAs) : void 0,
      type: isSet49(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet49(object.location) ? globalThis.String(object.location) : "",
      upgradeStrategy: isSet49(object.upgradeStrategy) ? upgradeStrategyFromJSON(object.upgradeStrategy) : 0,
      upgradeStrategyConfig: isObject8(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appVersionId !== "") {
      obj.appVersionId = message.appVersionId;
    }
    if (message.runAs !== void 0) {
      obj.runAs = message.runAs;
    }
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.upgradeStrategy !== 0) {
      obj.upgradeStrategy = upgradeStrategyToJSON(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      obj.upgradeStrategyConfig = message.upgradeStrategyConfig;
    }
    return obj;
  },
  create(base) {
    return InstallationCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationCreationRequest();
    message.appVersionId = object.appVersionId ?? "";
    message.runAs = object.runAs ?? void 0;
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    message.upgradeStrategy = object.upgradeStrategy ?? 0;
    message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallationCreationRequest.$type, InstallationCreationRequest);
function createBaseInstallationUpdateRequest() {
  return {
    id: "",
    runAs: void 0,
    upgradeStrategy: void 0,
    upgradeStrategyConfig: void 0,
    isEnabled: void 0
  };
}
var InstallationUpdateRequest = {
  $type: "devvit.dev_portal.installation.InstallationUpdateRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.runAs !== void 0) {
      StringValue.encode({ value: message.runAs }, writer.uint32(26).fork()).ldelim();
    }
    if (message.upgradeStrategy !== void 0) {
      OptionalUpgradeStrategy.encode(message.upgradeStrategy, writer.uint32(34).fork()).ldelim();
    }
    if (message.upgradeStrategyConfig !== void 0) {
      Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(42).fork()).ldelim();
    }
    if (message.isEnabled !== void 0) {
      BoolValue.encode({ value: message.isEnabled }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.runAs = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.upgradeStrategy = OptionalUpgradeStrategy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet49(object.id) ? globalThis.String(object.id) : "",
      runAs: isSet49(object.runAs) ? String(object.runAs) : void 0,
      upgradeStrategy: isSet49(object.upgradeStrategy) ? OptionalUpgradeStrategy.fromJSON(object.upgradeStrategy) : void 0,
      upgradeStrategyConfig: isObject8(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : void 0,
      isEnabled: isSet49(object.isEnabled) ? Boolean(object.isEnabled) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.runAs !== void 0) {
      obj.runAs = message.runAs;
    }
    if (message.upgradeStrategy !== void 0) {
      obj.upgradeStrategy = OptionalUpgradeStrategy.toJSON(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      obj.upgradeStrategyConfig = message.upgradeStrategyConfig;
    }
    if (message.isEnabled !== void 0) {
      obj.isEnabled = message.isEnabled;
    }
    return obj;
  },
  create(base) {
    return InstallationUpdateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationUpdateRequest();
    message.id = object.id ?? "";
    message.runAs = object.runAs ?? void 0;
    message.upgradeStrategy = object.upgradeStrategy !== void 0 && object.upgradeStrategy !== null ? OptionalUpgradeStrategy.fromPartial(object.upgradeStrategy) : void 0;
    message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? void 0;
    message.isEnabled = object.isEnabled ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallationUpdateRequest.$type, InstallationUpdateRequest);
function createBaseInstallationUpgradeRequest() {
  return { id: "", appVersionId: void 0 };
}
var InstallationUpgradeRequest = {
  $type: "devvit.dev_portal.installation.InstallationUpgradeRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appVersionId !== void 0) {
      StringValue.encode({ value: message.appVersionId }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpgradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.appVersionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet49(object.id) ? globalThis.String(object.id) : "",
      appVersionId: isSet49(object.appVersionId) ? String(object.appVersionId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appVersionId !== void 0) {
      obj.appVersionId = message.appVersionId;
    }
    return obj;
  },
  create(base) {
    return InstallationUpgradeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationUpgradeRequest();
    message.id = object.id ?? "";
    message.appVersionId = object.appVersionId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallationUpgradeRequest.$type, InstallationUpgradeRequest);
function createBaseInstallationUpgradeManyRequest() {
  return { ids: [], appVersionId: "" };
}
var InstallationUpgradeManyRequest = {
  $type: "devvit.dev_portal.installation.InstallationUpgradeManyRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    for (const v of message.ids) {
      writer.uint32(10).string(v);
    }
    if (message.appVersionId !== "") {
      writer.uint32(18).string(message.appVersionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpgradeManyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.appVersionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.String(e)) : [],
      appVersionId: isSet49(object.appVersionId) ? globalThis.String(object.appVersionId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.appVersionId !== "") {
      obj.appVersionId = message.appVersionId;
    }
    return obj;
  },
  create(base) {
    return InstallationUpgradeManyRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationUpgradeManyRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.appVersionId = object.appVersionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(InstallationUpgradeManyRequest.$type, InstallationUpgradeManyRequest);
function createBaseGetByAppNameAndInstallLocationRequest() {
  return { slug: "", type: 0, location: "" };
}
var GetByAppNameAndInstallLocationRequest = {
  $type: "devvit.dev_portal.installation.GetByAppNameAndInstallLocationRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetByAppNameAndInstallLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet49(object.slug) ? globalThis.String(object.slug) : "",
      type: isSet49(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet49(object.location) ? globalThis.String(object.location) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },
  create(base) {
    return GetByAppNameAndInstallLocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetByAppNameAndInstallLocationRequest();
    message.slug = object.slug ?? "";
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetByAppNameAndInstallLocationRequest.$type, GetByAppNameAndInstallLocationRequest);
function createBaseGetAllWithInstallLocationRequest() {
  return { type: 0, location: "" };
}
var GetAllWithInstallLocationRequest = {
  $type: "devvit.dev_portal.installation.GetAllWithInstallLocationRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithInstallLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet49(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet49(object.location) ? globalThis.String(object.location) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },
  create(base) {
    return GetAllWithInstallLocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAllWithInstallLocationRequest();
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAllWithInstallLocationRequest.$type, GetAllWithInstallLocationRequest);
function createBaseGetAllWithInstallerRequest() {
  return { installedBy: "" };
}
var GetAllWithInstallerRequest = {
  $type: "devvit.dev_portal.installation.GetAllWithInstallerRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.installedBy !== "") {
      writer.uint32(10).string(message.installedBy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithInstallerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { installedBy: isSet49(object.installedBy) ? globalThis.String(object.installedBy) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.installedBy !== "") {
      obj.installedBy = message.installedBy;
    }
    return obj;
  },
  create(base) {
    return GetAllWithInstallerRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAllWithInstallerRequest();
    message.installedBy = object.installedBy ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAllWithInstallerRequest.$type, GetAllWithInstallerRequest);
function createBaseGetInstallationHistoryRequest() {
  return { type: 0, location: "", slug: "", from: void 0, to: void 0, take: void 0, desc: void 0 };
}
var GetInstallationHistoryRequest = {
  $type: "devvit.dev_portal.installation.GetInstallationHistoryRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.from !== void 0) {
      Timestamp.encode(toTimestamp6(message.from), writer.uint32(34).fork()).ldelim();
    }
    if (message.to !== void 0) {
      Timestamp.encode(toTimestamp6(message.to), writer.uint32(42).fork()).ldelim();
    }
    if (message.take !== void 0) {
      writer.uint32(48).uint32(message.take);
    }
    if (message.desc !== void 0) {
      writer.uint32(56).bool(message.desc);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.from = fromTimestamp6(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.to = fromTimestamp6(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.take = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.desc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet49(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet49(object.location) ? globalThis.String(object.location) : "",
      slug: isSet49(object.slug) ? globalThis.String(object.slug) : "",
      from: isSet49(object.from) ? fromJsonTimestamp6(object.from) : void 0,
      to: isSet49(object.to) ? fromJsonTimestamp6(object.to) : void 0,
      take: isSet49(object.take) ? globalThis.Number(object.take) : void 0,
      desc: isSet49(object.desc) ? globalThis.Boolean(object.desc) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.from !== void 0) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== void 0) {
      obj.to = message.to.toISOString();
    }
    if (message.take !== void 0) {
      obj.take = Math.round(message.take);
    }
    if (message.desc !== void 0) {
      obj.desc = message.desc;
    }
    return obj;
  },
  create(base) {
    return GetInstallationHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationHistoryRequest();
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    message.slug = object.slug ?? "";
    message.from = object.from ?? void 0;
    message.to = object.to ?? void 0;
    message.take = object.take ?? void 0;
    message.desc = object.desc ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetInstallationHistoryRequest.$type, GetInstallationHistoryRequest);
function createBaseInstallationInfo() {
  return {
    id: "",
    upgradeStrategy: 0,
    upgradeStrategyConfig: void 0,
    runAs: void 0,
    type: 0,
    location: void 0,
    isEnabled: false
  };
}
var InstallationInfo = {
  $type: "devvit.dev_portal.installation.InstallationInfo",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.upgradeStrategy !== 0) {
      writer.uint32(24).int32(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(34).fork()).ldelim();
    }
    if (message.runAs !== void 0) {
      StringValue.encode({ value: message.runAs }, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.location !== void 0) {
      InstallationLocationInfo.encode(message.location, writer.uint32(66).fork()).ldelim();
    }
    if (message.isEnabled !== false) {
      writer.uint32(72).bool(message.isEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.upgradeStrategy = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.runAs = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.location = InstallationLocationInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.isEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet49(object.id) ? globalThis.String(object.id) : "",
      upgradeStrategy: isSet49(object.upgradeStrategy) ? upgradeStrategyFromJSON(object.upgradeStrategy) : 0,
      upgradeStrategyConfig: isObject8(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : void 0,
      runAs: isSet49(object.runAs) ? String(object.runAs) : void 0,
      type: isSet49(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet49(object.location) ? InstallationLocationInfo.fromJSON(object.location) : void 0,
      isEnabled: isSet49(object.isEnabled) ? globalThis.Boolean(object.isEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.upgradeStrategy !== 0) {
      obj.upgradeStrategy = upgradeStrategyToJSON(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      obj.upgradeStrategyConfig = message.upgradeStrategyConfig;
    }
    if (message.runAs !== void 0) {
      obj.runAs = message.runAs;
    }
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.location !== void 0) {
      obj.location = InstallationLocationInfo.toJSON(message.location);
    }
    if (message.isEnabled !== false) {
      obj.isEnabled = message.isEnabled;
    }
    return obj;
  },
  create(base) {
    return InstallationInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationInfo();
    message.id = object.id ?? "";
    message.upgradeStrategy = object.upgradeStrategy ?? 0;
    message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? void 0;
    message.runAs = object.runAs ?? void 0;
    message.type = object.type ?? 0;
    message.location = object.location !== void 0 && object.location !== null ? InstallationLocationInfo.fromPartial(object.location) : void 0;
    message.isEnabled = object.isEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set(InstallationInfo.$type, InstallationInfo);
function createBaseInstallationLocationInfo() {
  return { id: "", name: "", type: 0, icon: void 0, isNsfw: false, isUnavailable: false };
}
var InstallationLocationInfo = {
  $type: "devvit.dev_portal.installation.InstallationLocationInfo",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.icon !== void 0) {
      StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isNsfw !== false) {
      writer.uint32(40).bool(message.isNsfw);
    }
    if (message.isUnavailable !== false) {
      writer.uint32(48).bool(message.isUnavailable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.icon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.isNsfw = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.isUnavailable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet49(object.id) ? globalThis.String(object.id) : "",
      name: isSet49(object.name) ? globalThis.String(object.name) : "",
      type: isSet49(object.type) ? thingTypeFromJSON(object.type) : 0,
      icon: isSet49(object.icon) ? String(object.icon) : void 0,
      isNsfw: isSet49(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false,
      isUnavailable: isSet49(object.isUnavailable) ? globalThis.Boolean(object.isUnavailable) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = thingTypeToJSON(message.type);
    }
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    if (message.isNsfw !== false) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.isUnavailable !== false) {
      obj.isUnavailable = message.isUnavailable;
    }
    return obj;
  },
  create(base) {
    return InstallationLocationInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationLocationInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.icon = object.icon ?? void 0;
    message.isNsfw = object.isNsfw ?? false;
    message.isUnavailable = object.isUnavailable ?? false;
    return message;
  }
};
messageTypeRegistry.set(InstallationLocationInfo.$type, InstallationLocationInfo);
function createBaseFullInstallationInfo() {
  return { installation: void 0, appVersion: void 0, app: void 0 };
}
var FullInstallationInfo = {
  $type: "devvit.dev_portal.installation.FullInstallationInfo",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.installation !== void 0) {
      InstallationInfo.encode(message.installation, writer.uint32(10).fork()).ldelim();
    }
    if (message.appVersion !== void 0) {
      AppVersionInfo.encode(message.appVersion, writer.uint32(18).fork()).ldelim();
    }
    if (message.app !== void 0) {
      AppInfo.encode(message.app, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullInstallationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installation = InstallationInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.app = AppInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installation: isSet49(object.installation) ? InstallationInfo.fromJSON(object.installation) : void 0,
      appVersion: isSet49(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : void 0,
      app: isSet49(object.app) ? AppInfo.fromJSON(object.app) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installation !== void 0) {
      obj.installation = InstallationInfo.toJSON(message.installation);
    }
    if (message.appVersion !== void 0) {
      obj.appVersion = AppVersionInfo.toJSON(message.appVersion);
    }
    if (message.app !== void 0) {
      obj.app = AppInfo.toJSON(message.app);
    }
    return obj;
  },
  create(base) {
    return FullInstallationInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFullInstallationInfo();
    message.installation = object.installation !== void 0 && object.installation !== null ? InstallationInfo.fromPartial(object.installation) : void 0;
    message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? AppVersionInfo.fromPartial(object.appVersion) : void 0;
    message.app = object.app !== void 0 && object.app !== null ? AppInfo.fromPartial(object.app) : void 0;
    return message;
  }
};
messageTypeRegistry.set(FullInstallationInfo.$type, FullInstallationInfo);
function createBaseMultipleInstallationsResponse() {
  return { installations: [] };
}
var MultipleInstallationsResponse = {
  $type: "devvit.dev_portal.installation.MultipleInstallationsResponse",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    for (const v of message.installations) {
      InstallationInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultipleInstallationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installations: globalThis.Array.isArray(object?.installations) ? object.installations.map((e) => InstallationInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installations?.length) {
      obj.installations = message.installations.map((e) => InstallationInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MultipleInstallationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMultipleInstallationsResponse();
    message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(MultipleInstallationsResponse.$type, MultipleInstallationsResponse);
function createBaseGetAllWithAppResponse() {
  return { installations: [] };
}
var GetAllWithAppResponse = {
  $type: "devvit.dev_portal.installation.GetAllWithAppResponse",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    for (const v of message.installations) {
      InstallationWithAppVersion.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithAppResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installations.push(InstallationWithAppVersion.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installations: globalThis.Array.isArray(object?.installations) ? object.installations.map((e) => InstallationWithAppVersion.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installations?.length) {
      obj.installations = message.installations.map((e) => InstallationWithAppVersion.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetAllWithAppResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAllWithAppResponse();
    message.installations = object.installations?.map((e) => InstallationWithAppVersion.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetAllWithAppResponse.$type, GetAllWithAppResponse);
function createBaseInstallationWithAppVersion() {
  return { installation: void 0, appVersion: void 0 };
}
var InstallationWithAppVersion = {
  $type: "devvit.dev_portal.installation.InstallationWithAppVersion",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.installation !== void 0) {
      InstallationInfo.encode(message.installation, writer.uint32(10).fork()).ldelim();
    }
    if (message.appVersion !== void 0) {
      AppVersionInfo.encode(message.appVersion, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationWithAppVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installation = InstallationInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installation: isSet49(object.installation) ? InstallationInfo.fromJSON(object.installation) : void 0,
      appVersion: isSet49(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installation !== void 0) {
      obj.installation = InstallationInfo.toJSON(message.installation);
    }
    if (message.appVersion !== void 0) {
      obj.appVersion = AppVersionInfo.toJSON(message.appVersion);
    }
    return obj;
  },
  create(base) {
    return InstallationWithAppVersion.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationWithAppVersion();
    message.installation = object.installation !== void 0 && object.installation !== null ? InstallationInfo.fromPartial(object.installation) : void 0;
    message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? AppVersionInfo.fromPartial(object.appVersion) : void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallationWithAppVersion.$type, InstallationWithAppVersion);
function createBaseInstallationUpgradeManyResponse() {
  return { details: [] };
}
var InstallationUpgradeManyResponse = {
  $type: "devvit.dev_portal.installation.InstallationUpgradeManyResponse",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    for (const v of message.details) {
      InstallationUpgradeManyResponse_InstallationUpgradeDetails.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpgradeManyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.details.push(InstallationUpgradeManyResponse_InstallationUpgradeDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e) => InstallationUpgradeManyResponse_InstallationUpgradeDetails.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.details?.length) {
      obj.details = message.details.map((e) => InstallationUpgradeManyResponse_InstallationUpgradeDetails.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return InstallationUpgradeManyResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationUpgradeManyResponse();
    message.details = object.details?.map((e) => InstallationUpgradeManyResponse_InstallationUpgradeDetails.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(InstallationUpgradeManyResponse.$type, InstallationUpgradeManyResponse);
function createBaseInstallationUpgradeManyResponse_InstallationUpgradeDetails() {
  return { id: "", success: false, error: void 0 };
}
var InstallationUpgradeManyResponse_InstallationUpgradeDetails = {
  $type: "devvit.dev_portal.installation.InstallationUpgradeManyResponse.InstallationUpgradeDetails",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== void 0) {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpgradeManyResponse_InstallationUpgradeDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet49(object.id) ? globalThis.String(object.id) : "",
      success: isSet49(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet49(object.error) ? globalThis.String(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== void 0) {
      obj.error = message.error;
    }
    return obj;
  },
  create(base) {
    return InstallationUpgradeManyResponse_InstallationUpgradeDetails.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationUpgradeManyResponse_InstallationUpgradeDetails();
    message.id = object.id ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallationUpgradeManyResponse_InstallationUpgradeDetails.$type, InstallationUpgradeManyResponse_InstallationUpgradeDetails);
function createBaseInstallationLocationDetails() {
  return { type: 0, thingId: "", name: "" };
}
var InstallationLocationDetails = {
  $type: "devvit.dev_portal.installation.InstallationLocationDetails",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.thingId !== "") {
      writer.uint32(18).string(message.thingId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationLocationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.thingId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet49(object.type) ? installationTypeFromJSON(object.type) : 0,
      thingId: isSet49(object.thingId) ? globalThis.String(object.thingId) : "",
      name: isSet49(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.thingId !== "") {
      obj.thingId = message.thingId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return InstallationLocationDetails.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationLocationDetails();
    message.type = object.type ?? 0;
    message.thingId = object.thingId ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(InstallationLocationDetails.$type, InstallationLocationDetails);
function createBaseInstallationHistoryEvent() {
  return { userId: "", name: 0, details: {}, createdAt: void 0 };
}
var InstallationHistoryEvent = {
  $type: "devvit.dev_portal.installation.InstallationHistoryEvent",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== 0) {
      writer.uint32(16).int32(message.name);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      InstallationHistoryEvent_DetailsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp6(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationHistoryEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.name = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = InstallationHistoryEvent_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.createdAt = fromTimestamp6(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet49(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet49(object.name) ? installationHistoryEventNameFromJSON(object.name) : 0,
      details: isObject8(object.details) ? Object.entries(object.details).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      createdAt: isSet49(object.createdAt) ? fromJsonTimestamp6(object.createdAt) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== 0) {
      obj.name = installationHistoryEventNameToJSON(message.name);
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },
  create(base) {
    return InstallationHistoryEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationHistoryEvent();
    message.userId = object.userId ?? "";
    message.name = object.name ?? 0;
    message.details = Object.entries(object.details ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createdAt = object.createdAt ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallationHistoryEvent.$type, InstallationHistoryEvent);
function createBaseInstallationHistoryEvent_DetailsEntry() {
  return { key: "", value: "" };
}
var InstallationHistoryEvent_DetailsEntry = {
  $type: "devvit.dev_portal.installation.InstallationHistoryEvent.DetailsEntry",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationHistoryEvent_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet49(object.key) ? globalThis.String(object.key) : "",
      value: isSet49(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return InstallationHistoryEvent_DetailsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationHistoryEvent_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(InstallationHistoryEvent_DetailsEntry.$type, InstallationHistoryEvent_DetailsEntry);
function createBaseGetInstallationHistoryResponse() {
  return { events: [], totalEvents: 0 };
}
var GetInstallationHistoryResponse = {
  $type: "devvit.dev_portal.installation.GetInstallationHistoryResponse",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    for (const v of message.events) {
      InstallationHistoryEvent.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalEvents !== 0) {
      writer.uint32(64).uint32(message.totalEvents);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : import_minimal51.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.events.push(InstallationHistoryEvent.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.totalEvents = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => InstallationHistoryEvent.fromJSON(e)) : [],
      totalEvents: isSet49(object.totalEvents) ? globalThis.Number(object.totalEvents) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => InstallationHistoryEvent.toJSON(e));
    }
    if (message.totalEvents !== 0) {
      obj.totalEvents = Math.round(message.totalEvents);
    }
    return obj;
  },
  create(base) {
    return GetInstallationHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationHistoryResponse();
    message.events = object.events?.map((e) => InstallationHistoryEvent.fromPartial(e)) || [];
    message.totalEvents = object.totalEvents ?? 0;
    return message;
  }
};
messageTypeRegistry.set(GetInstallationHistoryResponse.$type, GetInstallationHistoryResponse);
function toTimestamp6(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp6(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp6(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp6(Timestamp.fromJSON(o));
  }
}
function isObject8(value) {
  return typeof value === "object" && value !== null;
}
function isSet49(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app_version/app_version.js
var import_minimal55 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/buildpack/buildpack_common.js
var import_minimal53 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/buildpack/filesystem.js
var import_minimal52 = __toESM(require_minimal2(), 1);
function createBaseFile() {
  return { path: "", content: "", isDirectory: false, isBase64: false };
}
var File = {
  $type: "devvit.plugin.buildpack.File",
  encode(message, writer = import_minimal52.default.Writer.create()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.isDirectory !== false) {
      writer.uint32(24).bool(message.isDirectory);
    }
    if (message.isBase64 !== false) {
      writer.uint32(32).bool(message.isBase64);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal52.default.Reader ? input : import_minimal52.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.isDirectory = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.isBase64 = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet50(object.path) ? globalThis.String(object.path) : "",
      content: isSet50(object.content) ? globalThis.String(object.content) : "",
      isDirectory: isSet50(object.isDirectory) ? globalThis.Boolean(object.isDirectory) : false,
      isBase64: isSet50(object.isBase64) ? globalThis.Boolean(object.isBase64) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isDirectory !== false) {
      obj.isDirectory = message.isDirectory;
    }
    if (message.isBase64 !== false) {
      obj.isBase64 = message.isBase64;
    }
    return obj;
  },
  create(base) {
    return File.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFile();
    message.path = object.path ?? "";
    message.content = object.content ?? "";
    message.isDirectory = object.isDirectory ?? false;
    message.isBase64 = object.isBase64 ?? false;
    return message;
  }
};
messageTypeRegistry.set(File.$type, File);
function createBaseFileSystem() {
  return { files: [] };
}
var FileSystem = {
  $type: "devvit.plugin.buildpack.FileSystem",
  encode(message, writer = import_minimal52.default.Writer.create()) {
    for (const v of message.files) {
      File.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal52.default.Reader ? input : import_minimal52.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.files.push(File.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => File.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FileSystem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFileSystem();
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FileSystem.$type, FileSystem);
function isSet50(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/buildpack/buildpack_common.js
var Minify;
(function(Minify2) {
  Minify2[Minify2["NONE"] = 0] = "NONE";
  Minify2[Minify2["ALL"] = 1] = "ALL";
  Minify2[Minify2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Minify || (Minify = {}));
function minifyFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return Minify.NONE;
    case 1:
    case "ALL":
      return Minify.ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Minify.UNRECOGNIZED;
  }
}
function minifyToJSON(object) {
  switch (object) {
    case Minify.NONE:
      return 0;
    case Minify.ALL:
      return 1;
    case Minify.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseBundle() {
  return { code: "", dependencies: void 0, buildInfo: void 0, assets: void 0, assetIds: {} };
}
var Bundle = {
  $type: "devvit.plugin.buildpack.Bundle",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.dependencies !== void 0) {
      DependencySpec.encode(message.dependencies, writer.uint32(18).fork()).ldelim();
    }
    if (message.buildInfo !== void 0) {
      BuildInfo.encode(message.buildInfo, writer.uint32(26).fork()).ldelim();
    }
    if (message.assets !== void 0) {
      FileSystem.encode(message.assets, writer.uint32(34).fork()).ldelim();
    }
    Object.entries(message.assetIds).forEach(([key, value]) => {
      Bundle_AssetIdsEntry.encode({ key, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : import_minimal53.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dependencies = DependencySpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.assets = FileSystem.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          const entry5 = Bundle_AssetIdsEntry.decode(reader, reader.uint32());
          if (entry5.value !== void 0) {
            message.assetIds[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      code: isSet51(object.code) ? globalThis.String(object.code) : "",
      dependencies: isSet51(object.dependencies) ? DependencySpec.fromJSON(object.dependencies) : void 0,
      buildInfo: isSet51(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : void 0,
      assets: isSet51(object.assets) ? FileSystem.fromJSON(object.assets) : void 0,
      assetIds: isObject9(object.assetIds) ? Object.entries(object.assetIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.dependencies !== void 0) {
      obj.dependencies = DependencySpec.toJSON(message.dependencies);
    }
    if (message.buildInfo !== void 0) {
      obj.buildInfo = BuildInfo.toJSON(message.buildInfo);
    }
    if (message.assets !== void 0) {
      obj.assets = FileSystem.toJSON(message.assets);
    }
    if (message.assetIds) {
      const entries = Object.entries(message.assetIds);
      if (entries.length > 0) {
        obj.assetIds = {};
        entries.forEach(([k, v]) => {
          obj.assetIds[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return Bundle.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBundle();
    message.code = object.code ?? "";
    message.dependencies = object.dependencies !== void 0 && object.dependencies !== null ? DependencySpec.fromPartial(object.dependencies) : void 0;
    message.buildInfo = object.buildInfo !== void 0 && object.buildInfo !== null ? BuildInfo.fromPartial(object.buildInfo) : void 0;
    message.assets = object.assets !== void 0 && object.assets !== null ? FileSystem.fromPartial(object.assets) : void 0;
    message.assetIds = Object.entries(object.assetIds ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(Bundle.$type, Bundle);
function createBaseBundle_AssetIdsEntry() {
  return { key: "", value: "" };
}
var Bundle_AssetIdsEntry = {
  $type: "devvit.plugin.buildpack.Bundle.AssetIdsEntry",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : import_minimal53.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBundle_AssetIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet51(object.key) ? globalThis.String(object.key) : "",
      value: isSet51(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Bundle_AssetIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBundle_AssetIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(Bundle_AssetIdsEntry.$type, Bundle_AssetIdsEntry);
function createBaseCompileParams() {
  return { virtualFileSystem: void 0, filename: void 0, minify: 0, info: void 0, includeAssets: false };
}
var CompileParams = {
  $type: "devvit.plugin.buildpack.CompileParams",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.virtualFileSystem !== void 0) {
      FileSystem.encode(message.virtualFileSystem, writer.uint32(10).fork()).ldelim();
    }
    if (message.filename !== void 0) {
      writer.uint32(18).string(message.filename);
    }
    if (message.minify !== 0) {
      writer.uint32(24).int32(message.minify);
    }
    if (message.info !== void 0) {
      ActorSpec.encode(message.info, writer.uint32(34).fork()).ldelim();
    }
    if (message.includeAssets !== false) {
      writer.uint32(40).bool(message.includeAssets);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : import_minimal53.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.virtualFileSystem = FileSystem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.filename = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.minify = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.info = ActorSpec.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.includeAssets = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      virtualFileSystem: isSet51(object.virtualFileSystem) ? FileSystem.fromJSON(object.virtualFileSystem) : void 0,
      filename: isSet51(object.filename) ? globalThis.String(object.filename) : void 0,
      minify: isSet51(object.minify) ? minifyFromJSON(object.minify) : 0,
      info: isSet51(object.info) ? ActorSpec.fromJSON(object.info) : void 0,
      includeAssets: isSet51(object.includeAssets) ? globalThis.Boolean(object.includeAssets) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.virtualFileSystem !== void 0) {
      obj.virtualFileSystem = FileSystem.toJSON(message.virtualFileSystem);
    }
    if (message.filename !== void 0) {
      obj.filename = message.filename;
    }
    if (message.minify !== 0) {
      obj.minify = minifyToJSON(message.minify);
    }
    if (message.info !== void 0) {
      obj.info = ActorSpec.toJSON(message.info);
    }
    if (message.includeAssets !== false) {
      obj.includeAssets = message.includeAssets;
    }
    return obj;
  },
  create(base) {
    return CompileParams.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCompileParams();
    message.virtualFileSystem = object.virtualFileSystem !== void 0 && object.virtualFileSystem !== null ? FileSystem.fromPartial(object.virtualFileSystem) : void 0;
    message.filename = object.filename ?? void 0;
    message.minify = object.minify ?? 0;
    message.info = object.info !== void 0 && object.info !== null ? ActorSpec.fromPartial(object.info) : void 0;
    message.includeAssets = object.includeAssets ?? false;
    return message;
  }
};
messageTypeRegistry.set(CompileParams.$type, CompileParams);
function createBaseCompileLog() {
  return { detail: void 0, text: "" };
}
var CompileLog = {
  $type: "devvit.plugin.buildpack.CompileLog",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.detail !== void 0) {
      CompileLogLineDetail.encode(message.detail, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : import_minimal53.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.detail = CompileLogLineDetail.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      detail: isSet51(object.detail) ? CompileLogLineDetail.fromJSON(object.detail) : void 0,
      text: isSet51(object.text) ? globalThis.String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.detail !== void 0) {
      obj.detail = CompileLogLineDetail.toJSON(message.detail);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return CompileLog.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCompileLog();
    message.detail = object.detail !== void 0 && object.detail !== null ? CompileLogLineDetail.fromPartial(object.detail) : void 0;
    message.text = object.text ?? "";
    return message;
  }
};
messageTypeRegistry.set(CompileLog.$type, CompileLog);
function createBaseCompileLogLineDetail() {
  return { column: 0, filename: "", line: 0, suggestion: "", text: "" };
}
var CompileLogLineDetail = {
  $type: "devvit.plugin.buildpack.CompileLogLineDetail",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.column !== 0) {
      writer.uint32(8).uint32(message.column);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.line !== 0) {
      writer.uint32(24).uint32(message.line);
    }
    if (message.suggestion !== "") {
      writer.uint32(34).string(message.suggestion);
    }
    if (message.text !== "") {
      writer.uint32(42).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : import_minimal53.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileLogLineDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.column = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.filename = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.line = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.suggestion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      column: isSet51(object.column) ? globalThis.Number(object.column) : 0,
      filename: isSet51(object.filename) ? globalThis.String(object.filename) : "",
      line: isSet51(object.line) ? globalThis.Number(object.line) : 0,
      suggestion: isSet51(object.suggestion) ? globalThis.String(object.suggestion) : "",
      text: isSet51(object.text) ? globalThis.String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return CompileLogLineDetail.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCompileLogLineDetail();
    message.column = object.column ?? 0;
    message.filename = object.filename ?? "";
    message.line = object.line ?? 0;
    message.suggestion = object.suggestion ?? "";
    message.text = object.text ?? "";
    return message;
  }
};
messageTypeRegistry.set(CompileLogLineDetail.$type, CompileLogLineDetail);
function createBaseCompileResponse() {
  return { bundle: void 0, errors: [], warnings: [] };
}
var CompileResponse = {
  $type: "devvit.plugin.buildpack.CompileResponse",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.bundle !== void 0) {
      Bundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.warnings) {
      CompileLog.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : import_minimal53.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bundle = Bundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.errors.push(CompileLog.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.warnings.push(CompileLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet51(object.bundle) ? Bundle.fromJSON(object.bundle) : void 0,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : [],
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e) => CompileLog.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bundle !== void 0) {
      obj.bundle = Bundle.toJSON(message.bundle);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => CompileLog.toJSON(e));
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => CompileLog.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return CompileResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCompileResponse();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? Bundle.fromPartial(object.bundle) : void 0;
    message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(CompileResponse.$type, CompileResponse);
function isObject9(value) {
  return typeof value === "object" && value !== null;
}
function isSet51(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/actor/actor_type.js
var import_minimal54 = __toESM(require_minimal2(), 1);
function createBaseActorTypeInfo() {
  return { id: "", name: "", isEnabled: false };
}
var ActorTypeInfo = {
  $type: "devvit.dev_portal.actor.ActorTypeInfo",
  encode(message, writer = import_minimal54.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isEnabled !== false) {
      writer.uint32(24).bool(message.isEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal54.default.Reader ? input : import_minimal54.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActorTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.isEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet52(object.id) ? globalThis.String(object.id) : "",
      name: isSet52(object.name) ? globalThis.String(object.name) : "",
      isEnabled: isSet52(object.isEnabled) ? globalThis.Boolean(object.isEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isEnabled !== false) {
      obj.isEnabled = message.isEnabled;
    }
    return obj;
  },
  create(base) {
    return ActorTypeInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseActorTypeInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isEnabled = object.isEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set(ActorTypeInfo.$type, ActorTypeInfo);
function isSet52(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app_version/app_version.js
function createBaseAppVersionCreationRequest() {
  return {
    appId: "",
    visibility: 0,
    validInstallTypes: [],
    majorVersion: 0,
    minorVersion: 0,
    patchVersion: 0,
    prereleaseVersion: void 0,
    actorBundles: [],
    about: ""
  };
}
var AppVersionCreationRequest = {
  $type: "devvit.dev_portal.app_version.AppVersionCreationRequest",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.visibility !== 0) {
      writer.uint32(16).int32(message.visibility);
    }
    writer.uint32(26).fork();
    for (const v of message.validInstallTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.majorVersion !== 0) {
      writer.uint32(32).int32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(40).int32(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      writer.uint32(48).int32(message.patchVersion);
    }
    if (message.prereleaseVersion !== void 0) {
      Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.actorBundles) {
      Bundle.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.about !== "") {
      writer.uint32(74).string(message.about);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.visibility = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.validInstallTypes.push(reader.int32());
            continue;
          }
          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validInstallTypes.push(reader.int32());
            }
            continue;
          }
          break;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.majorVersion = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.minorVersion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.patchVersion = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.actorBundles.push(Bundle.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.about = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet53(object.appId) ? globalThis.String(object.appId) : "",
      visibility: isSet53(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
      validInstallTypes: globalThis.Array.isArray(object?.validInstallTypes) ? object.validInstallTypes.map((e) => installationTypeFromJSON(e)) : [],
      majorVersion: isSet53(object.majorVersion) ? globalThis.Number(object.majorVersion) : 0,
      minorVersion: isSet53(object.minorVersion) ? globalThis.Number(object.minorVersion) : 0,
      patchVersion: isSet53(object.patchVersion) ? globalThis.Number(object.patchVersion) : 0,
      prereleaseVersion: isSet53(object.prereleaseVersion) ? Number(object.prereleaseVersion) : void 0,
      actorBundles: globalThis.Array.isArray(object?.actorBundles) ? object.actorBundles.map((e) => Bundle.fromJSON(e)) : [],
      about: isSet53(object.about) ? globalThis.String(object.about) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.visibility !== 0) {
      obj.visibility = versionVisibilityToJSON(message.visibility);
    }
    if (message.validInstallTypes?.length) {
      obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
    }
    if (message.majorVersion !== 0) {
      obj.majorVersion = Math.round(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      obj.minorVersion = Math.round(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      obj.patchVersion = Math.round(message.patchVersion);
    }
    if (message.prereleaseVersion !== void 0) {
      obj.prereleaseVersion = message.prereleaseVersion;
    }
    if (message.actorBundles?.length) {
      obj.actorBundles = message.actorBundles.map((e) => Bundle.toJSON(e));
    }
    if (message.about !== "") {
      obj.about = message.about;
    }
    return obj;
  },
  create(base) {
    return AppVersionCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppVersionCreationRequest();
    message.appId = object.appId ?? "";
    message.visibility = object.visibility ?? 0;
    message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.patchVersion = object.patchVersion ?? 0;
    message.prereleaseVersion = object.prereleaseVersion ?? void 0;
    message.actorBundles = object.actorBundles?.map((e) => Bundle.fromPartial(e)) || [];
    message.about = object.about ?? "";
    return message;
  }
};
messageTypeRegistry.set(AppVersionCreationRequest.$type, AppVersionCreationRequest);
function createBaseAppSlugAndVersion() {
  return { slug: "", version: "" };
}
var AppSlugAndVersion = {
  $type: "devvit.dev_portal.app_version.AppSlugAndVersion",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSlugAndVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.slug = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet53(object.slug) ? globalThis.String(object.slug) : "",
      version: isSet53(object.version) ? globalThis.String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },
  create(base) {
    return AppSlugAndVersion.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppSlugAndVersion();
    message.slug = object.slug ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set(AppSlugAndVersion.$type, AppSlugAndVersion);
function createBaseAppVersionUpdateRequest() {
  return { id: "", visibility: void 0, validInstallTypes: [], about: void 0, pool: 0, reviewStatus: void 0 };
}
var AppVersionUpdateRequest = {
  $type: "devvit.dev_portal.app_version.AppVersionUpdateRequest",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.visibility !== void 0) {
      OptionalVersionVisibility.encode(message.visibility, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.validInstallTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.about !== void 0) {
      StringValue.encode({ value: message.about }, writer.uint32(42).fork()).ldelim();
    }
    if (message.pool !== 0) {
      writer.uint32(48).int32(message.pool);
    }
    if (message.reviewStatus !== void 0) {
      writer.uint32(56).int32(message.reviewStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.visibility = OptionalVersionVisibility.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag === 32) {
            message.validInstallTypes.push(reader.int32());
            continue;
          }
          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validInstallTypes.push(reader.int32());
            }
            continue;
          }
          break;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.about = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.pool = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.reviewStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet53(object.id) ? globalThis.String(object.id) : "",
      visibility: isSet53(object.visibility) ? OptionalVersionVisibility.fromJSON(object.visibility) : void 0,
      validInstallTypes: globalThis.Array.isArray(object?.validInstallTypes) ? object.validInstallTypes.map((e) => installationTypeFromJSON(e)) : [],
      about: isSet53(object.about) ? String(object.about) : void 0,
      pool: isSet53(object.pool) ? computePoolFromJSON(object.pool) : 0,
      reviewStatus: isSet53(object.reviewStatus) ? reviewStatusFromJSON(object.reviewStatus) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.visibility !== void 0) {
      obj.visibility = OptionalVersionVisibility.toJSON(message.visibility);
    }
    if (message.validInstallTypes?.length) {
      obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
    }
    if (message.about !== void 0) {
      obj.about = message.about;
    }
    if (message.pool !== 0) {
      obj.pool = computePoolToJSON(message.pool);
    }
    if (message.reviewStatus !== void 0) {
      obj.reviewStatus = reviewStatusToJSON(message.reviewStatus);
    }
    return obj;
  },
  create(base) {
    return AppVersionUpdateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppVersionUpdateRequest();
    message.id = object.id ?? "";
    message.visibility = object.visibility !== void 0 && object.visibility !== null ? OptionalVersionVisibility.fromPartial(object.visibility) : void 0;
    message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
    message.about = object.about ?? void 0;
    message.pool = object.pool ?? 0;
    message.reviewStatus = object.reviewStatus ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AppVersionUpdateRequest.$type, AppVersionUpdateRequest);
function createBaseValidInstallLocationsRequest() {
  return { id: "", pageInfo: [] };
}
var ValidInstallLocationsRequest = {
  $type: "devvit.dev_portal.app_version.ValidInstallLocationsRequest",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.pageInfo) {
      InstallLocationPageInfo.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidInstallLocationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.pageInfo.push(InstallLocationPageInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet53(object.id) ? globalThis.String(object.id) : "",
      pageInfo: globalThis.Array.isArray(object?.pageInfo) ? object.pageInfo.map((e) => InstallLocationPageInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pageInfo?.length) {
      obj.pageInfo = message.pageInfo.map((e) => InstallLocationPageInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ValidInstallLocationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidInstallLocationsRequest();
    message.id = object.id ?? "";
    message.pageInfo = object.pageInfo?.map((e) => InstallLocationPageInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ValidInstallLocationsRequest.$type, ValidInstallLocationsRequest);
function createBaseInstallLocationPageInfo() {
  return { type: 0, before: void 0, after: void 0 };
}
var InstallLocationPageInfo = {
  $type: "devvit.dev_portal.app_version.InstallLocationPageInfo",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.before !== void 0) {
      writer.uint32(18).string(message.before);
    }
    if (message.after !== void 0) {
      writer.uint32(26).string(message.after);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallLocationPageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.after = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet53(object.type) ? installationTypeFromJSON(object.type) : 0,
      before: isSet53(object.before) ? globalThis.String(object.before) : void 0,
      after: isSet53(object.after) ? globalThis.String(object.after) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    return obj;
  },
  create(base) {
    return InstallLocationPageInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallLocationPageInfo();
    message.type = object.type ?? 0;
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallLocationPageInfo.$type, InstallLocationPageInfo);
function createBaseFullAppVersionInfo() {
  return { appVersion: void 0, app: void 0, actorTypes: [], installations: [] };
}
var FullAppVersionInfo = {
  $type: "devvit.dev_portal.app_version.FullAppVersionInfo",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.appVersion !== void 0) {
      AppVersionInfo.encode(message.appVersion, writer.uint32(10).fork()).ldelim();
    }
    if (message.app !== void 0) {
      AppInfo.encode(message.app, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.actorTypes) {
      ActorTypeInfo.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.installations) {
      InstallationInfo.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullAppVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.app = AppInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.actorTypes.push(ActorTypeInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appVersion: isSet53(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : void 0,
      app: isSet53(object.app) ? AppInfo.fromJSON(object.app) : void 0,
      actorTypes: globalThis.Array.isArray(object?.actorTypes) ? object.actorTypes.map((e) => ActorTypeInfo.fromJSON(e)) : [],
      installations: globalThis.Array.isArray(object?.installations) ? object.installations.map((e) => InstallationInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appVersion !== void 0) {
      obj.appVersion = AppVersionInfo.toJSON(message.appVersion);
    }
    if (message.app !== void 0) {
      obj.app = AppInfo.toJSON(message.app);
    }
    if (message.actorTypes?.length) {
      obj.actorTypes = message.actorTypes.map((e) => ActorTypeInfo.toJSON(e));
    }
    if (message.installations?.length) {
      obj.installations = message.installations.map((e) => InstallationInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FullAppVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFullAppVersionInfo();
    message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? AppVersionInfo.fromPartial(object.appVersion) : void 0;
    message.app = object.app !== void 0 && object.app !== null ? AppInfo.fromPartial(object.app) : void 0;
    message.actorTypes = object.actorTypes?.map((e) => ActorTypeInfo.fromPartial(e)) || [];
    message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FullAppVersionInfo.$type, FullAppVersionInfo);
function createBaseValidInstallLocationsResponse() {
  return { locations: [] };
}
var ValidInstallLocationsResponse = {
  $type: "devvit.dev_portal.app_version.ValidInstallLocationsResponse",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    for (const v of message.locations) {
      InstallLocationInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidInstallLocationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.locations.push(InstallLocationInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      locations: globalThis.Array.isArray(object?.locations) ? object.locations.map((e) => InstallLocationInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => InstallLocationInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ValidInstallLocationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidInstallLocationsResponse();
    message.locations = object.locations?.map((e) => InstallLocationInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ValidInstallLocationsResponse.$type, ValidInstallLocationsResponse);
function createBaseInstallLocationInfo() {
  return { type: 0, locations: [], pageInfo: void 0 };
}
var InstallLocationInfo = {
  $type: "devvit.dev_portal.app_version.InstallLocationInfo",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.locations) {
      InstallLocationDetails.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.pageInfo !== void 0) {
      PageInfo.encode(message.pageInfo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.locations.push(InstallLocationDetails.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.pageInfo = PageInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet53(object.type) ? installationTypeFromJSON(object.type) : 0,
      locations: globalThis.Array.isArray(object?.locations) ? object.locations.map((e) => InstallLocationDetails.fromJSON(e)) : [],
      pageInfo: isSet53(object.pageInfo) ? PageInfo.fromJSON(object.pageInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = installationTypeToJSON(message.type);
    }
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => InstallLocationDetails.toJSON(e));
    }
    if (message.pageInfo !== void 0) {
      obj.pageInfo = PageInfo.toJSON(message.pageInfo);
    }
    return obj;
  },
  create(base) {
    return InstallLocationInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallLocationInfo();
    message.type = object.type ?? 0;
    message.locations = object.locations?.map((e) => InstallLocationDetails.fromPartial(e)) || [];
    message.pageInfo = object.pageInfo !== void 0 && object.pageInfo !== null ? PageInfo.fromPartial(object.pageInfo) : void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallLocationInfo.$type, InstallLocationInfo);
function createBaseInstallLocationDetails() {
  return { thingId: "", name: "", existingInstallId: void 0, icon: void 0 };
}
var InstallLocationDetails = {
  $type: "devvit.dev_portal.app_version.InstallLocationDetails",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.thingId !== "") {
      writer.uint32(10).string(message.thingId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.existingInstallId !== void 0) {
      StringValue.encode({ value: message.existingInstallId }, writer.uint32(26).fork()).ldelim();
    }
    if (message.icon !== void 0) {
      StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallLocationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.thingId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.existingInstallId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.icon = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      thingId: isSet53(object.thingId) ? globalThis.String(object.thingId) : "",
      name: isSet53(object.name) ? globalThis.String(object.name) : "",
      existingInstallId: isSet53(object.existingInstallId) ? String(object.existingInstallId) : void 0,
      icon: isSet53(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.thingId !== "") {
      obj.thingId = message.thingId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.existingInstallId !== void 0) {
      obj.existingInstallId = message.existingInstallId;
    }
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    return obj;
  },
  create(base) {
    return InstallLocationDetails.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallLocationDetails();
    message.thingId = object.thingId ?? "";
    message.name = object.name ?? "";
    message.existingInstallId = object.existingInstallId ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InstallLocationDetails.$type, InstallLocationDetails);
function createBasePageInfo() {
  return { hasNextPage: false, hasPreviousPage: false, startCursor: "", endCursor: "" };
}
var PageInfo = {
  $type: "devvit.dev_portal.app_version.PageInfo",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.hasNextPage !== false) {
      writer.uint32(8).bool(message.hasNextPage);
    }
    if (message.hasPreviousPage !== false) {
      writer.uint32(16).bool(message.hasPreviousPage);
    }
    if (message.startCursor !== "") {
      writer.uint32(26).string(message.startCursor);
    }
    if (message.endCursor !== "") {
      writer.uint32(34).string(message.endCursor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.hasNextPage = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.hasPreviousPage = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.startCursor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.endCursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      hasNextPage: isSet53(object.hasNextPage) ? globalThis.Boolean(object.hasNextPage) : false,
      hasPreviousPage: isSet53(object.hasPreviousPage) ? globalThis.Boolean(object.hasPreviousPage) : false,
      startCursor: isSet53(object.startCursor) ? globalThis.String(object.startCursor) : "",
      endCursor: isSet53(object.endCursor) ? globalThis.String(object.endCursor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.hasNextPage !== false) {
      obj.hasNextPage = message.hasNextPage;
    }
    if (message.hasPreviousPage !== false) {
      obj.hasPreviousPage = message.hasPreviousPage;
    }
    if (message.startCursor !== "") {
      obj.startCursor = message.startCursor;
    }
    if (message.endCursor !== "") {
      obj.endCursor = message.endCursor;
    }
    return obj;
  },
  create(base) {
    return PageInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePageInfo();
    message.hasNextPage = object.hasNextPage ?? false;
    message.hasPreviousPage = object.hasPreviousPage ?? false;
    message.startCursor = object.startCursor ?? "";
    message.endCursor = object.endCursor ?? "";
    return message;
  }
};
messageTypeRegistry.set(PageInfo.$type, PageInfo);
function createBaseGetAppVersionBundleResponse() {
  return { actorBundles: [] };
}
var GetAppVersionBundleResponse = {
  $type: "devvit.dev_portal.app_version.GetAppVersionBundleResponse",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    for (const v of message.actorBundles) {
      GetAppVersionBundleResponse_BundleInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppVersionBundleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actorBundles.push(GetAppVersionBundleResponse_BundleInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actorBundles: globalThis.Array.isArray(object?.actorBundles) ? object.actorBundles.map((e) => GetAppVersionBundleResponse_BundleInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actorBundles?.length) {
      obj.actorBundles = message.actorBundles.map((e) => GetAppVersionBundleResponse_BundleInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetAppVersionBundleResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppVersionBundleResponse();
    message.actorBundles = object.actorBundles?.map((e) => GetAppVersionBundleResponse_BundleInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetAppVersionBundleResponse.$type, GetAppVersionBundleResponse);
function createBaseGetAppVersionBundleResponse_BundleInfo() {
  return { actor: "", bundle: void 0 };
}
var GetAppVersionBundleResponse_BundleInfo = {
  $type: "devvit.dev_portal.app_version.GetAppVersionBundleResponse.BundleInfo",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.bundle !== void 0) {
      LinkedBundle.encode(message.bundle, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : import_minimal55.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppVersionBundleResponse_BundleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.bundle = LinkedBundle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet53(object.actor) ? globalThis.String(object.actor) : "",
      bundle: isSet53(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.bundle !== void 0) {
      obj.bundle = LinkedBundle.toJSON(message.bundle);
    }
    return obj;
  },
  create(base) {
    return GetAppVersionBundleResponse_BundleInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppVersionBundleResponse_BundleInfo();
    message.actor = object.actor ?? "";
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? LinkedBundle.fromPartial(object.bundle) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetAppVersionBundleResponse_BundleInfo.$type, GetAppVersionBundleResponse_BundleInfo);
function isSet53(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/nutrition/nutrition.js
var import_minimal56 = __toESM(require_minimal2(), 1);
var NutritionCategory;
(function(NutritionCategory2) {
  NutritionCategory2[NutritionCategory2["UNCATEGORIZED"] = 0] = "UNCATEGORIZED";
  NutritionCategory2[NutritionCategory2["APP_TRIGGERS"] = 1] = "APP_TRIGGERS";
  NutritionCategory2[NutritionCategory2["ASSETS"] = 2] = "ASSETS";
  NutritionCategory2[NutritionCategory2["DATA"] = 3] = "DATA";
  NutritionCategory2[NutritionCategory2["HTTP"] = 4] = "HTTP";
  NutritionCategory2[NutritionCategory2["MODLOG"] = 5] = "MODLOG";
  NutritionCategory2[NutritionCategory2["REDDIT_API"] = 6] = "REDDIT_API";
  NutritionCategory2[NutritionCategory2["REDDIT_TRIGGERS"] = 7] = "REDDIT_TRIGGERS";
  NutritionCategory2[NutritionCategory2["SCHEDULER"] = 8] = "SCHEDULER";
  NutritionCategory2[NutritionCategory2["UI"] = 9] = "UI";
  NutritionCategory2[NutritionCategory2["MODERATOR"] = 10] = "MODERATOR";
  NutritionCategory2[NutritionCategory2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NutritionCategory || (NutritionCategory = {}));
function nutritionCategoryFromJSON(object) {
  switch (object) {
    case 0:
    case "UNCATEGORIZED":
      return NutritionCategory.UNCATEGORIZED;
    case 1:
    case "APP_TRIGGERS":
      return NutritionCategory.APP_TRIGGERS;
    case 2:
    case "ASSETS":
      return NutritionCategory.ASSETS;
    case 3:
    case "DATA":
      return NutritionCategory.DATA;
    case 4:
    case "HTTP":
      return NutritionCategory.HTTP;
    case 5:
    case "MODLOG":
      return NutritionCategory.MODLOG;
    case 6:
    case "REDDIT_API":
      return NutritionCategory.REDDIT_API;
    case 7:
    case "REDDIT_TRIGGERS":
      return NutritionCategory.REDDIT_TRIGGERS;
    case 8:
    case "SCHEDULER":
      return NutritionCategory.SCHEDULER;
    case 9:
    case "UI":
      return NutritionCategory.UI;
    case 10:
    case "MODERATOR":
      return NutritionCategory.MODERATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NutritionCategory.UNRECOGNIZED;
  }
}
function nutritionCategoryToJSON(object) {
  switch (object) {
    case NutritionCategory.UNCATEGORIZED:
      return 0;
    case NutritionCategory.APP_TRIGGERS:
      return 1;
    case NutritionCategory.ASSETS:
      return 2;
    case NutritionCategory.DATA:
      return 3;
    case NutritionCategory.HTTP:
      return 4;
    case NutritionCategory.MODLOG:
      return 5;
    case NutritionCategory.REDDIT_API:
      return 6;
    case NutritionCategory.REDDIT_TRIGGERS:
      return 7;
    case NutritionCategory.SCHEDULER:
      return 8;
    case NutritionCategory.UI:
      return 9;
    case NutritionCategory.MODERATOR:
      return 10;
    case NutritionCategory.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseGetNutritionByNameVersionRequest() {
  return { name: "", version: void 0 };
}
var GetNutritionByNameVersionRequest = {
  $type: "devvit.dev_portal.nutrition.GetNutritionByNameVersionRequest",
  encode(message, writer = import_minimal56.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== void 0) {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal56.default.Reader ? input : import_minimal56.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetNutritionByNameVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet54(object.name) ? globalThis.String(object.name) : "",
      version: isSet54(object.version) ? globalThis.String(object.version) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== void 0) {
      obj.version = message.version;
    }
    return obj;
  },
  create(base) {
    return GetNutritionByNameVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetNutritionByNameVersionRequest();
    message.name = object.name ?? "";
    message.version = object.version ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetNutritionByNameVersionRequest.$type, GetNutritionByNameVersionRequest);
function createBaseMultipleNutritionCategories() {
  return { categories: [] };
}
var MultipleNutritionCategories = {
  $type: "devvit.dev_portal.nutrition.MultipleNutritionCategories",
  encode(message, writer = import_minimal56.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal56.default.Reader ? input : import_minimal56.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultipleNutritionCategories();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.categories.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
            continue;
          }
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      categories: globalThis.Array.isArray(object?.categories) ? object.categories.map((e) => nutritionCategoryFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => nutritionCategoryToJSON(e));
    }
    return obj;
  },
  create(base) {
    return MultipleNutritionCategories.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMultipleNutritionCategories();
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(MultipleNutritionCategories.$type, MultipleNutritionCategories);
function isSet54(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/feedback/feedback.js
var import_minimal57 = __toESM(require_minimal2(), 1);
function createBaseCreateFeedbackRequest() {
  return { content: "" };
}
var CreateFeedbackRequest = {
  $type: "devvit.dev_portal.feedback.CreateFeedbackRequest",
  encode(message, writer = import_minimal57.default.Writer.create()) {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal57.default.Reader ? input : import_minimal57.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { content: isSet55(object.content) ? globalThis.String(object.content) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },
  create(base) {
    return CreateFeedbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateFeedbackRequest();
    message.content = object.content ?? "";
    return message;
  }
};
messageTypeRegistry.set(CreateFeedbackRequest.$type, CreateFeedbackRequest);
function isSet55(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/data_api/admin/auth/auth.js
var import_minimal60 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/data/api/v1alpha/admin.js
var import_minimal59 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/v2alpha/subredditv2.js
var import_minimal58 = __toESM(require_minimal2(), 1);
var SubredditType;
(function(SubredditType2) {
  SubredditType2[SubredditType2["ARCHIVED"] = 0] = "ARCHIVED";
  SubredditType2[SubredditType2["EMPLOYEES_ONLY"] = 1] = "EMPLOYEES_ONLY";
  SubredditType2[SubredditType2["GOLD_ONLY"] = 2] = "GOLD_ONLY";
  SubredditType2[SubredditType2["GOLD_RESTRICTED"] = 3] = "GOLD_RESTRICTED";
  SubredditType2[SubredditType2["PRIVATE"] = 4] = "PRIVATE";
  SubredditType2[SubredditType2["PUBLIC"] = 5] = "PUBLIC";
  SubredditType2[SubredditType2["RESTRICTED"] = 6] = "RESTRICTED";
  SubredditType2[SubredditType2["USER"] = 7] = "USER";
  SubredditType2[SubredditType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SubredditType || (SubredditType = {}));
function subredditTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ARCHIVED":
      return SubredditType.ARCHIVED;
    case 1:
    case "EMPLOYEES_ONLY":
      return SubredditType.EMPLOYEES_ONLY;
    case 2:
    case "GOLD_ONLY":
      return SubredditType.GOLD_ONLY;
    case 3:
    case "GOLD_RESTRICTED":
      return SubredditType.GOLD_RESTRICTED;
    case 4:
    case "PRIVATE":
      return SubredditType.PRIVATE;
    case 5:
    case "PUBLIC":
      return SubredditType.PUBLIC;
    case 6:
    case "RESTRICTED":
      return SubredditType.RESTRICTED;
    case 7:
    case "USER":
      return SubredditType.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubredditType.UNRECOGNIZED;
  }
}
function subredditTypeToJSON(object) {
  switch (object) {
    case SubredditType.ARCHIVED:
      return 0;
    case SubredditType.EMPLOYEES_ONLY:
      return 1;
    case SubredditType.GOLD_ONLY:
      return 2;
    case SubredditType.GOLD_RESTRICTED:
      return 3;
    case SubredditType.PRIVATE:
      return 4;
    case SubredditType.PUBLIC:
      return 5;
    case SubredditType.RESTRICTED:
      return 6;
    case SubredditType.USER:
      return 7;
    case SubredditType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var SubredditRating;
(function(SubredditRating2) {
  SubredditRating2[SubredditRating2["UNKNOWN_SUBREDDIT_RATING"] = 0] = "UNKNOWN_SUBREDDIT_RATING";
  SubredditRating2[SubredditRating2["E"] = 1] = "E";
  SubredditRating2[SubredditRating2["M1"] = 2] = "M1";
  SubredditRating2[SubredditRating2["M2"] = 3] = "M2";
  SubredditRating2[SubredditRating2["D"] = 4] = "D";
  SubredditRating2[SubredditRating2["V"] = 5] = "V";
  SubredditRating2[SubredditRating2["X"] = 6] = "X";
  SubredditRating2[SubredditRating2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SubredditRating || (SubredditRating = {}));
function subredditRatingFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_SUBREDDIT_RATING":
      return SubredditRating.UNKNOWN_SUBREDDIT_RATING;
    case 1:
    case "E":
      return SubredditRating.E;
    case 2:
    case "M1":
      return SubredditRating.M1;
    case 3:
    case "M2":
      return SubredditRating.M2;
    case 4:
    case "D":
      return SubredditRating.D;
    case 5:
    case "V":
      return SubredditRating.V;
    case 6:
    case "X":
      return SubredditRating.X;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubredditRating.UNRECOGNIZED;
  }
}
function subredditRatingToJSON(object) {
  switch (object) {
    case SubredditRating.UNKNOWN_SUBREDDIT_RATING:
      return 0;
    case SubredditRating.E:
      return 1;
    case SubredditRating.M1:
      return 2;
    case SubredditRating.M2:
      return 3;
    case SubredditRating.D:
      return 4;
    case SubredditRating.V:
      return 5;
    case SubredditRating.X:
      return 6;
    case SubredditRating.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseSubredditV2() {
  return {
    id: "",
    name: "",
    nsfw: false,
    type: 0,
    spam: false,
    quarantined: false,
    topics: [],
    rating: 0,
    subscribersCount: 0,
    permalink: ""
  };
}
var SubredditV2 = {
  $type: "devvit.reddit.v2alpha.SubredditV2",
  encode(message, writer = import_minimal58.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nsfw !== false) {
      writer.uint32(24).bool(message.nsfw);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.spam !== false) {
      writer.uint32(40).bool(message.spam);
    }
    if (message.quarantined !== false) {
      writer.uint32(48).bool(message.quarantined);
    }
    for (const v of message.topics) {
      writer.uint32(58).string(v);
    }
    if (message.rating !== 0) {
      writer.uint32(64).int32(message.rating);
    }
    if (message.subscribersCount !== 0) {
      writer.uint32(72).int32(message.subscribersCount);
    }
    if (message.permalink !== "") {
      writer.uint32(82).string(message.permalink);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal58.default.Reader ? input : import_minimal58.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.nsfw = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.spam = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.quarantined = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.topics.push(reader.string());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.rating = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.subscribersCount = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.permalink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet56(object.id) ? globalThis.String(object.id) : "",
      name: isSet56(object.name) ? globalThis.String(object.name) : "",
      nsfw: isSet56(object.nsfw) ? globalThis.Boolean(object.nsfw) : false,
      type: isSet56(object.type) ? subredditTypeFromJSON(object.type) : 0,
      spam: isSet56(object.spam) ? globalThis.Boolean(object.spam) : false,
      quarantined: isSet56(object.quarantined) ? globalThis.Boolean(object.quarantined) : false,
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e) => globalThis.String(e)) : [],
      rating: isSet56(object.rating) ? subredditRatingFromJSON(object.rating) : 0,
      subscribersCount: isSet56(object.subscribersCount) ? globalThis.Number(object.subscribersCount) : 0,
      permalink: isSet56(object.permalink) ? globalThis.String(object.permalink) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nsfw !== false) {
      obj.nsfw = message.nsfw;
    }
    if (message.type !== 0) {
      obj.type = subredditTypeToJSON(message.type);
    }
    if (message.spam !== false) {
      obj.spam = message.spam;
    }
    if (message.quarantined !== false) {
      obj.quarantined = message.quarantined;
    }
    if (message.topics?.length) {
      obj.topics = message.topics;
    }
    if (message.rating !== 0) {
      obj.rating = subredditRatingToJSON(message.rating);
    }
    if (message.subscribersCount !== 0) {
      obj.subscribersCount = Math.round(message.subscribersCount);
    }
    if (message.permalink !== "") {
      obj.permalink = message.permalink;
    }
    return obj;
  },
  create(base) {
    return SubredditV2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditV2();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nsfw = object.nsfw ?? false;
    message.type = object.type ?? 0;
    message.spam = object.spam ?? false;
    message.quarantined = object.quarantined ?? false;
    message.topics = object.topics?.map((e) => e) || [];
    message.rating = object.rating ?? 0;
    message.subscribersCount = object.subscribersCount ?? 0;
    message.permalink = object.permalink ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditV2.$type, SubredditV2);
function isSet56(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/api/v1alpha/admin.js
function createBaseDataToken() {
  return { id: "", organizationId: "", createdAt: void 0, expiresAt: void 0, isRevoked: false };
}
var DataToken = {
  $type: "devvit.data.api.v1alpha.DataToken",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organizationId !== "") {
      writer.uint32(18).string(message.organizationId);
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp7(message.createdAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.expiresAt !== void 0) {
      Timestamp.encode(toTimestamp7(message.expiresAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.isRevoked !== false) {
      writer.uint32(40).bool(message.isRevoked);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : import_minimal59.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.organizationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.createdAt = fromTimestamp7(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.expiresAt = fromTimestamp7(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.isRevoked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet57(object.id) ? globalThis.String(object.id) : "",
      organizationId: isSet57(object.organizationId) ? globalThis.String(object.organizationId) : "",
      createdAt: isSet57(object.createdAt) ? fromJsonTimestamp7(object.createdAt) : void 0,
      expiresAt: isSet57(object.expiresAt) ? fromJsonTimestamp7(object.expiresAt) : void 0,
      isRevoked: isSet57(object.isRevoked) ? globalThis.Boolean(object.isRevoked) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== void 0) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.isRevoked !== false) {
      obj.isRevoked = message.isRevoked;
    }
    return obj;
  },
  create(base) {
    return DataToken.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataToken();
    message.id = object.id ?? "";
    message.organizationId = object.organizationId ?? "";
    message.createdAt = object.createdAt ?? void 0;
    message.expiresAt = object.expiresAt ?? void 0;
    message.isRevoked = object.isRevoked ?? false;
    return message;
  }
};
messageTypeRegistry.set(DataToken.$type, DataToken);
function createBaseDataSubscription() {
  return {
    id: "",
    tier: 0,
    events: [],
    subreddits: [],
    subredditRatings: [],
    organizationId: "",
    name: "",
    description: void 0
  };
}
var DataSubscription = {
  $type: "devvit.data.api.v1alpha.DataSubscription",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.tier !== 0) {
      writer.uint32(16).int32(message.tier);
    }
    writer.uint32(26).fork();
    for (const v of message.events) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.subreddits) {
      writer.uint32(34).string(v);
    }
    writer.uint32(42).fork();
    for (const v of message.subredditRatings) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.organizationId !== "") {
      writer.uint32(50).string(message.organizationId);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.description !== void 0) {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : import_minimal59.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.tier = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.events.push(reader.int32());
            continue;
          }
          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events.push(reader.int32());
            }
            continue;
          }
          break;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.subreddits.push(reader.string());
          continue;
        case 5:
          if (tag === 40) {
            message.subredditRatings.push(reader.int32());
            continue;
          }
          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.subredditRatings.push(reader.int32());
            }
            continue;
          }
          break;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.organizationId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet57(object.id) ? globalThis.String(object.id) : "",
      tier: isSet57(object.tier) ? dataTierFromJSON(object.tier) : 0,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => firehoseEventFromJSON(e)) : [],
      subreddits: globalThis.Array.isArray(object?.subreddits) ? object.subreddits.map((e) => globalThis.String(e)) : [],
      subredditRatings: globalThis.Array.isArray(object?.subredditRatings) ? object.subredditRatings.map((e) => subredditRatingFromJSON(e)) : [],
      organizationId: isSet57(object.organizationId) ? globalThis.String(object.organizationId) : "",
      name: isSet57(object.name) ? globalThis.String(object.name) : "",
      description: isSet57(object.description) ? globalThis.String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tier !== 0) {
      obj.tier = dataTierToJSON(message.tier);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => firehoseEventToJSON(e));
    }
    if (message.subreddits?.length) {
      obj.subreddits = message.subreddits;
    }
    if (message.subredditRatings?.length) {
      obj.subredditRatings = message.subredditRatings.map((e) => subredditRatingToJSON(e));
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return DataSubscription.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataSubscription();
    message.id = object.id ?? "";
    message.tier = object.tier ?? 0;
    message.events = object.events?.map((e) => e) || [];
    message.subreddits = object.subreddits?.map((e) => e) || [];
    message.subredditRatings = object.subredditRatings?.map((e) => e) || [];
    message.organizationId = object.organizationId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(DataSubscription.$type, DataSubscription);
function createBaseOrganization() {
  return { id: "", name: "", subscriptions: [], tokens: [] };
}
var Organization = {
  $type: "devvit.data.api.v1alpha.Organization",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.subscriptions) {
      DataSubscription.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.tokens) {
      DataToken.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : import_minimal59.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOrganization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.subscriptions.push(DataSubscription.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.tokens.push(DataToken.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet57(object.id) ? globalThis.String(object.id) : "",
      name: isSet57(object.name) ? globalThis.String(object.name) : "",
      subscriptions: globalThis.Array.isArray(object?.subscriptions) ? object.subscriptions.map((e) => DataSubscription.fromJSON(e)) : [],
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e) => DataToken.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => DataSubscription.toJSON(e));
    }
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => DataToken.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Organization.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOrganization();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.subscriptions = object.subscriptions?.map((e) => DataSubscription.fromPartial(e)) || [];
    message.tokens = object.tokens?.map((e) => DataToken.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(Organization.$type, Organization);
function createBaseDataApiAuthTokenRequest() {
  return { customer: "", expiresIn: void 0 };
}
var DataApiAuthTokenRequest = {
  $type: "devvit.data.api.v1alpha.DataApiAuthTokenRequest",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.customer !== "") {
      writer.uint32(10).string(message.customer);
    }
    if (message.expiresIn !== void 0) {
      Duration.encode(message.expiresIn, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : import_minimal59.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataApiAuthTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.customer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.expiresIn = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      customer: isSet57(object.customer) ? globalThis.String(object.customer) : "",
      expiresIn: isSet57(object.expiresIn) ? Duration.fromJSON(object.expiresIn) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.expiresIn !== void 0) {
      obj.expiresIn = Duration.toJSON(message.expiresIn);
    }
    return obj;
  },
  create(base) {
    return DataApiAuthTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataApiAuthTokenRequest();
    message.customer = object.customer ?? "";
    message.expiresIn = object.expiresIn !== void 0 && object.expiresIn !== null ? Duration.fromPartial(object.expiresIn) : void 0;
    return message;
  }
};
messageTypeRegistry.set(DataApiAuthTokenRequest.$type, DataApiAuthTokenRequest);
function createBaseDataApiAuthTokenResponse() {
  return { id: "", token: "", expiresAt: void 0 };
}
var DataApiAuthTokenResponse = {
  $type: "devvit.data.api.v1alpha.DataApiAuthTokenResponse",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.expiresAt !== void 0) {
      Timestamp.encode(toTimestamp7(message.expiresAt), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : import_minimal59.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataApiAuthTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.expiresAt = fromTimestamp7(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet57(object.id) ? globalThis.String(object.id) : "",
      token: isSet57(object.token) ? globalThis.String(object.token) : "",
      expiresAt: isSet57(object.expiresAt) ? fromJsonTimestamp7(object.expiresAt) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiresAt !== void 0) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },
  create(base) {
    return DataApiAuthTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataApiAuthTokenResponse();
    message.id = object.id ?? "";
    message.token = object.token ?? "";
    message.expiresAt = object.expiresAt ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(DataApiAuthTokenResponse.$type, DataApiAuthTokenResponse);
function toTimestamp7(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp7(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp7(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp7(Timestamp.fromJSON(o));
  }
}
function isSet57(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/data_api/admin/auth/auth.js
function createBaseCreateDataTokenRequest() {
  return { organizationName: "", expiresIn: void 0 };
}
var CreateDataTokenRequest = {
  $type: "devvit.dev_portal.data_api.admin.auth.CreateDataTokenRequest",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.organizationName !== "") {
      writer.uint32(10).string(message.organizationName);
    }
    if (message.expiresIn !== void 0) {
      Duration.encode(message.expiresIn, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateDataTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizationName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.expiresIn = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      organizationName: isSet58(object.organizationName) ? globalThis.String(object.organizationName) : "",
      expiresIn: isSet58(object.expiresIn) ? Duration.fromJSON(object.expiresIn) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizationName !== "") {
      obj.organizationName = message.organizationName;
    }
    if (message.expiresIn !== void 0) {
      obj.expiresIn = Duration.toJSON(message.expiresIn);
    }
    return obj;
  },
  create(base) {
    return CreateDataTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateDataTokenRequest();
    message.organizationName = object.organizationName ?? "";
    message.expiresIn = object.expiresIn !== void 0 && object.expiresIn !== null ? Duration.fromPartial(object.expiresIn) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateDataTokenRequest.$type, CreateDataTokenRequest);
function createBaseCreateDataTokenResponse() {
  return { token: "", expiresAt: void 0 };
}
var CreateDataTokenResponse = {
  $type: "devvit.dev_portal.data_api.admin.auth.CreateDataTokenResponse",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expiresAt !== void 0) {
      Timestamp.encode(toTimestamp8(message.expiresAt), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateDataTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.expiresAt = fromTimestamp8(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      token: isSet58(object.token) ? globalThis.String(object.token) : "",
      expiresAt: isSet58(object.expiresAt) ? fromJsonTimestamp8(object.expiresAt) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiresAt !== void 0) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },
  create(base) {
    return CreateDataTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateDataTokenResponse();
    message.token = object.token ?? "";
    message.expiresAt = object.expiresAt ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateDataTokenResponse.$type, CreateDataTokenResponse);
function createBaseGetDataTokenByIdRequest() {
  return { id: "" };
}
var GetDataTokenByIdRequest = {
  $type: "devvit.dev_portal.data_api.admin.auth.GetDataTokenByIdRequest",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataTokenByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet58(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return GetDataTokenByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataTokenByIdRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetDataTokenByIdRequest.$type, GetDataTokenByIdRequest);
function createBaseGetDataTokenByIdResponse() {
  return { token: void 0 };
}
var GetDataTokenByIdResponse = {
  $type: "devvit.dev_portal.data_api.admin.auth.GetDataTokenByIdResponse",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.token !== void 0) {
      DataToken.encode(message.token, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataTokenByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.token = DataToken.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { token: isSet58(object.token) ? DataToken.fromJSON(object.token) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.token !== void 0) {
      obj.token = DataToken.toJSON(message.token);
    }
    return obj;
  },
  create(base) {
    return GetDataTokenByIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataTokenByIdResponse();
    message.token = object.token !== void 0 && object.token !== null ? DataToken.fromPartial(object.token) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetDataTokenByIdResponse.$type, GetDataTokenByIdResponse);
function createBaseGetDataTokensByOrganizationNameRequest() {
  return { organizationName: "" };
}
var GetDataTokensByOrganizationNameRequest = {
  $type: "devvit.dev_portal.data_api.admin.auth.GetDataTokensByOrganizationNameRequest",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.organizationName !== "") {
      writer.uint32(10).string(message.organizationName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataTokensByOrganizationNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizationName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { organizationName: isSet58(object.organizationName) ? globalThis.String(object.organizationName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizationName !== "") {
      obj.organizationName = message.organizationName;
    }
    return obj;
  },
  create(base) {
    return GetDataTokensByOrganizationNameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataTokensByOrganizationNameRequest();
    message.organizationName = object.organizationName ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetDataTokensByOrganizationNameRequest.$type, GetDataTokensByOrganizationNameRequest);
function createBaseGetDataTokensByOrganizationNameResponse() {
  return { tokens: [] };
}
var GetDataTokensByOrganizationNameResponse = {
  $type: "devvit.dev_portal.data_api.admin.auth.GetDataTokensByOrganizationNameResponse",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    for (const v of message.tokens) {
      DataToken.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataTokensByOrganizationNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.tokens.push(DataToken.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e) => DataToken.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => DataToken.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetDataTokensByOrganizationNameResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataTokensByOrganizationNameResponse();
    message.tokens = object.tokens?.map((e) => DataToken.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetDataTokensByOrganizationNameResponse.$type, GetDataTokensByOrganizationNameResponse);
function createBaseRevokeDataTokenByIdRequest() {
  return { tokenId: "" };
}
var RevokeDataTokenByIdRequest = {
  $type: "devvit.dev_portal.data_api.admin.auth.RevokeDataTokenByIdRequest",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevokeDataTokenByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { tokenId: isSet58(object.tokenId) ? globalThis.String(object.tokenId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },
  create(base) {
    return RevokeDataTokenByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRevokeDataTokenByIdRequest();
    message.tokenId = object.tokenId ?? "";
    return message;
  }
};
messageTypeRegistry.set(RevokeDataTokenByIdRequest.$type, RevokeDataTokenByIdRequest);
function createBaseRevokeDataTokenByIdResponse() {
  return {};
}
var RevokeDataTokenByIdResponse = {
  $type: "devvit.dev_portal.data_api.admin.auth.RevokeDataTokenByIdResponse",
  encode(_, writer = import_minimal60.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : import_minimal60.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevokeDataTokenByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return RevokeDataTokenByIdResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseRevokeDataTokenByIdResponse();
    return message;
  }
};
messageTypeRegistry.set(RevokeDataTokenByIdResponse.$type, RevokeDataTokenByIdResponse);
function toTimestamp8(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp8(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp8(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp8(Timestamp.fromJSON(o));
  }
}
function isSet58(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/data_api/admin/subscription/subscription.js
var import_minimal61 = __toESM(require_minimal2(), 1);
function createBaseCreateDataSubscriptionRequest() {
  return { tier: 0, events: [], subreddits: [], subredditRatings: [], customer: "", name: "", description: void 0 };
}
var CreateDataSubscriptionRequest = {
  $type: "devvit.dev_portal.data_api.admin.subscription.CreateDataSubscriptionRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.tier !== 0) {
      writer.uint32(8).int32(message.tier);
    }
    writer.uint32(18).fork();
    for (const v of message.events) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.subreddits) {
      writer.uint32(26).string(v);
    }
    writer.uint32(34).fork();
    for (const v of message.subredditRatings) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.customer !== "") {
      writer.uint32(42).string(message.customer);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.description !== void 0) {
      writer.uint32(58).string(message.description);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateDataSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.tier = reader.int32();
          continue;
        case 2:
          if (tag === 16) {
            message.events.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events.push(reader.int32());
            }
            continue;
          }
          break;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.subreddits.push(reader.string());
          continue;
        case 4:
          if (tag === 32) {
            message.subredditRatings.push(reader.int32());
            continue;
          }
          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.subredditRatings.push(reader.int32());
            }
            continue;
          }
          break;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.customer = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tier: isSet59(object.tier) ? dataTierFromJSON(object.tier) : 0,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => firehoseEventFromJSON(e)) : [],
      subreddits: globalThis.Array.isArray(object?.subreddits) ? object.subreddits.map((e) => globalThis.String(e)) : [],
      subredditRatings: globalThis.Array.isArray(object?.subredditRatings) ? object.subredditRatings.map((e) => subredditRatingFromJSON(e)) : [],
      customer: isSet59(object.customer) ? globalThis.String(object.customer) : "",
      name: isSet59(object.name) ? globalThis.String(object.name) : "",
      description: isSet59(object.description) ? globalThis.String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tier !== 0) {
      obj.tier = dataTierToJSON(message.tier);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => firehoseEventToJSON(e));
    }
    if (message.subreddits?.length) {
      obj.subreddits = message.subreddits;
    }
    if (message.subredditRatings?.length) {
      obj.subredditRatings = message.subredditRatings.map((e) => subredditRatingToJSON(e));
    }
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return CreateDataSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateDataSubscriptionRequest();
    message.tier = object.tier ?? 0;
    message.events = object.events?.map((e) => e) || [];
    message.subreddits = object.subreddits?.map((e) => e) || [];
    message.subredditRatings = object.subredditRatings?.map((e) => e) || [];
    message.customer = object.customer ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateDataSubscriptionRequest.$type, CreateDataSubscriptionRequest);
function createBaseCreateDataSubscriptionResponse() {
  return { subscription: void 0 };
}
var CreateDataSubscriptionResponse = {
  $type: "devvit.dev_portal.data_api.admin.subscription.CreateDataSubscriptionResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.subscription !== void 0) {
      DataSubscription.encode(message.subscription, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateDataSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscription = DataSubscription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscription: isSet59(object.subscription) ? DataSubscription.fromJSON(object.subscription) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscription !== void 0) {
      obj.subscription = DataSubscription.toJSON(message.subscription);
    }
    return obj;
  },
  create(base) {
    return CreateDataSubscriptionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateDataSubscriptionResponse();
    message.subscription = object.subscription !== void 0 && object.subscription !== null ? DataSubscription.fromPartial(object.subscription) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateDataSubscriptionResponse.$type, CreateDataSubscriptionResponse);
function createBaseGetDataSubscriptionByIdRequest() {
  return { subscriptionId: "" };
}
var GetDataSubscriptionByIdRequest = {
  $type: "devvit.dev_portal.data_api.admin.subscription.GetDataSubscriptionByIdRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataSubscriptionByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscriptionId: isSet59(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },
  create(base) {
    return GetDataSubscriptionByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataSubscriptionByIdRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetDataSubscriptionByIdRequest.$type, GetDataSubscriptionByIdRequest);
function createBaseGetDataSubscriptionByIdResponse() {
  return { subscription: void 0 };
}
var GetDataSubscriptionByIdResponse = {
  $type: "devvit.dev_portal.data_api.admin.subscription.GetDataSubscriptionByIdResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.subscription !== void 0) {
      DataSubscription.encode(message.subscription, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataSubscriptionByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscription = DataSubscription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscription: isSet59(object.subscription) ? DataSubscription.fromJSON(object.subscription) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscription !== void 0) {
      obj.subscription = DataSubscription.toJSON(message.subscription);
    }
    return obj;
  },
  create(base) {
    return GetDataSubscriptionByIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataSubscriptionByIdResponse();
    message.subscription = object.subscription !== void 0 && object.subscription !== null ? DataSubscription.fromPartial(object.subscription) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetDataSubscriptionByIdResponse.$type, GetDataSubscriptionByIdResponse);
function createBaseDataSubscriptionSubredditInfo() {
  return { id: "", name: "", icon: "", isNsfw: false };
}
var DataSubscriptionSubredditInfo = {
  $type: "devvit.dev_portal.data_api.admin.subscription.DataSubscriptionSubredditInfo",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.icon !== "") {
      writer.uint32(26).string(message.icon);
    }
    if (message.isNsfw !== false) {
      writer.uint32(32).bool(message.isNsfw);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataSubscriptionSubredditInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.icon = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.isNsfw = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet59(object.id) ? globalThis.String(object.id) : "",
      name: isSet59(object.name) ? globalThis.String(object.name) : "",
      icon: isSet59(object.icon) ? globalThis.String(object.icon) : "",
      isNsfw: isSet59(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.isNsfw !== false) {
      obj.isNsfw = message.isNsfw;
    }
    return obj;
  },
  create(base) {
    return DataSubscriptionSubredditInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataSubscriptionSubredditInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.icon = object.icon ?? "";
    message.isNsfw = object.isNsfw ?? false;
    return message;
  }
};
messageTypeRegistry.set(DataSubscriptionSubredditInfo.$type, DataSubscriptionSubredditInfo);
function createBaseUIDataSubscription() {
  return { id: "", name: "", description: void 0, events: [], subreddits: [], subredditRatings: [] };
}
var UIDataSubscription = {
  $type: "devvit.dev_portal.data_api.admin.subscription.UIDataSubscription",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== void 0) {
      writer.uint32(26).string(message.description);
    }
    writer.uint32(34).fork();
    for (const v of message.events) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.subreddits) {
      DataSubscriptionSubredditInfo.encode(v, writer.uint32(42).fork()).ldelim();
    }
    writer.uint32(50).fork();
    for (const v of message.subredditRatings) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIDataSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.events.push(reader.int32());
            continue;
          }
          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events.push(reader.int32());
            }
            continue;
          }
          break;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.subreddits.push(DataSubscriptionSubredditInfo.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag === 48) {
            message.subredditRatings.push(reader.int32());
            continue;
          }
          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.subredditRatings.push(reader.int32());
            }
            continue;
          }
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet59(object.id) ? globalThis.String(object.id) : "",
      name: isSet59(object.name) ? globalThis.String(object.name) : "",
      description: isSet59(object.description) ? globalThis.String(object.description) : void 0,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => firehoseEventFromJSON(e)) : [],
      subreddits: globalThis.Array.isArray(object?.subreddits) ? object.subreddits.map((e) => DataSubscriptionSubredditInfo.fromJSON(e)) : [],
      subredditRatings: globalThis.Array.isArray(object?.subredditRatings) ? object.subredditRatings.map((e) => subredditRatingFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => firehoseEventToJSON(e));
    }
    if (message.subreddits?.length) {
      obj.subreddits = message.subreddits.map((e) => DataSubscriptionSubredditInfo.toJSON(e));
    }
    if (message.subredditRatings?.length) {
      obj.subredditRatings = message.subredditRatings.map((e) => subredditRatingToJSON(e));
    }
    return obj;
  },
  create(base) {
    return UIDataSubscription.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUIDataSubscription();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? void 0;
    message.events = object.events?.map((e) => e) || [];
    message.subreddits = object.subreddits?.map((e) => DataSubscriptionSubredditInfo.fromPartial(e)) || [];
    message.subredditRatings = object.subredditRatings?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(UIDataSubscription.$type, UIDataSubscription);
function createBaseGetDataSubscriptionsByOrganizationNameRequest() {
  return { organizationName: "" };
}
var GetDataSubscriptionsByOrganizationNameRequest = {
  $type: "devvit.dev_portal.data_api.admin.subscription.GetDataSubscriptionsByOrganizationNameRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.organizationName !== "") {
      writer.uint32(10).string(message.organizationName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataSubscriptionsByOrganizationNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizationName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { organizationName: isSet59(object.organizationName) ? globalThis.String(object.organizationName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizationName !== "") {
      obj.organizationName = message.organizationName;
    }
    return obj;
  },
  create(base) {
    return GetDataSubscriptionsByOrganizationNameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataSubscriptionsByOrganizationNameRequest();
    message.organizationName = object.organizationName ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetDataSubscriptionsByOrganizationNameRequest.$type, GetDataSubscriptionsByOrganizationNameRequest);
function createBaseGetDataSubscriptionsByOrganizationNameResponse() {
  return { subscriptions: [] };
}
var GetDataSubscriptionsByOrganizationNameResponse = {
  $type: "devvit.dev_portal.data_api.admin.subscription.GetDataSubscriptionsByOrganizationNameResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    for (const v of message.subscriptions) {
      UIDataSubscription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDataSubscriptionsByOrganizationNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptions.push(UIDataSubscription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions) ? object.subscriptions.map((e) => UIDataSubscription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => UIDataSubscription.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetDataSubscriptionsByOrganizationNameResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDataSubscriptionsByOrganizationNameResponse();
    message.subscriptions = object.subscriptions?.map((e) => UIDataSubscription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetDataSubscriptionsByOrganizationNameResponse.$type, GetDataSubscriptionsByOrganizationNameResponse);
function createBaseUpdateDataSubscriptionRequest() {
  return {
    subscriptionId: "",
    name: void 0,
    description: void 0,
    tier: void 0,
    events: [],
    subreddits: [],
    subredditRatings: []
  };
}
var UpdateDataSubscriptionRequest = {
  $type: "devvit.dev_portal.data_api.admin.subscription.UpdateDataSubscriptionRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.name !== void 0) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== void 0) {
      writer.uint32(26).string(message.description);
    }
    if (message.tier !== void 0) {
      writer.uint32(32).int32(message.tier);
    }
    writer.uint32(42).fork();
    for (const v of message.events) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.subreddits) {
      writer.uint32(50).string(v);
    }
    writer.uint32(58).fork();
    for (const v of message.subredditRatings) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.tier = reader.int32();
          continue;
        case 5:
          if (tag === 40) {
            message.events.push(reader.int32());
            continue;
          }
          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events.push(reader.int32());
            }
            continue;
          }
          break;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.subreddits.push(reader.string());
          continue;
        case 7:
          if (tag === 56) {
            message.subredditRatings.push(reader.int32());
            continue;
          }
          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.subredditRatings.push(reader.int32());
            }
            continue;
          }
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subscriptionId: isSet59(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      name: isSet59(object.name) ? globalThis.String(object.name) : void 0,
      description: isSet59(object.description) ? globalThis.String(object.description) : void 0,
      tier: isSet59(object.tier) ? dataTierFromJSON(object.tier) : void 0,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => firehoseEventFromJSON(e)) : [],
      subreddits: globalThis.Array.isArray(object?.subreddits) ? object.subreddits.map((e) => globalThis.String(e)) : [],
      subredditRatings: globalThis.Array.isArray(object?.subredditRatings) ? object.subredditRatings.map((e) => subredditRatingFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.tier !== void 0) {
      obj.tier = dataTierToJSON(message.tier);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => firehoseEventToJSON(e));
    }
    if (message.subreddits?.length) {
      obj.subreddits = message.subreddits;
    }
    if (message.subredditRatings?.length) {
      obj.subredditRatings = message.subredditRatings.map((e) => subredditRatingToJSON(e));
    }
    return obj;
  },
  create(base) {
    return UpdateDataSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateDataSubscriptionRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    message.name = object.name ?? void 0;
    message.description = object.description ?? void 0;
    message.tier = object.tier ?? void 0;
    message.events = object.events?.map((e) => e) || [];
    message.subreddits = object.subreddits?.map((e) => e) || [];
    message.subredditRatings = object.subredditRatings?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(UpdateDataSubscriptionRequest.$type, UpdateDataSubscriptionRequest);
function createBaseUpdateDataSubscriptionResponse() {
  return { subscription: void 0 };
}
var UpdateDataSubscriptionResponse = {
  $type: "devvit.dev_portal.data_api.admin.subscription.UpdateDataSubscriptionResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.subscription !== void 0) {
      DataSubscription.encode(message.subscription, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscription = DataSubscription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscription: isSet59(object.subscription) ? DataSubscription.fromJSON(object.subscription) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscription !== void 0) {
      obj.subscription = DataSubscription.toJSON(message.subscription);
    }
    return obj;
  },
  create(base) {
    return UpdateDataSubscriptionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateDataSubscriptionResponse();
    message.subscription = object.subscription !== void 0 && object.subscription !== null ? DataSubscription.fromPartial(object.subscription) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateDataSubscriptionResponse.$type, UpdateDataSubscriptionResponse);
function createBaseDeleteDataSubscriptionRequest() {
  return { subscriptionId: "" };
}
var DeleteDataSubscriptionRequest = {
  $type: "devvit.dev_portal.data_api.admin.subscription.DeleteDataSubscriptionRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteDataSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscriptionId: isSet59(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },
  create(base) {
    return DeleteDataSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteDataSubscriptionRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(DeleteDataSubscriptionRequest.$type, DeleteDataSubscriptionRequest);
function createBaseDeleteDataSubscriptionResponse() {
  return {};
}
var DeleteDataSubscriptionResponse = {
  $type: "devvit.dev_portal.data_api.admin.subscription.DeleteDataSubscriptionResponse",
  encode(_, writer = import_minimal61.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : import_minimal61.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteDataSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeleteDataSubscriptionResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeleteDataSubscriptionResponse();
    return message;
  }
};
messageTypeRegistry.set(DeleteDataSubscriptionResponse.$type, DeleteDataSubscriptionResponse);
function isSet59(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/data_api/admin/organization/organization.js
var import_minimal62 = __toESM(require_minimal2(), 1);
function createBaseCreateOrganizationRequest() {
  return { name: "" };
}
var CreateOrganizationRequest = {
  $type: "devvit.dev_portal.data_api.admin.organization.CreateOrganizationRequest",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : import_minimal62.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet60(object.name) ? globalThis.String(object.name) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return CreateOrganizationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateOrganizationRequest();
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(CreateOrganizationRequest.$type, CreateOrganizationRequest);
function createBaseCreateOrganizationResponse() {
  return { organizationId: "", name: "" };
}
var CreateOrganizationResponse = {
  $type: "devvit.dev_portal.data_api.admin.organization.CreateOrganizationResponse",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.organizationId !== "") {
      writer.uint32(10).string(message.organizationId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : import_minimal62.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      organizationId: isSet60(object.organizationId) ? globalThis.String(object.organizationId) : "",
      name: isSet60(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return CreateOrganizationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateOrganizationResponse();
    message.organizationId = object.organizationId ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(CreateOrganizationResponse.$type, CreateOrganizationResponse);
function createBaseGetOrganizationByNameRequest() {
  return { name: "" };
}
var GetOrganizationByNameRequest = {
  $type: "devvit.dev_portal.data_api.admin.organization.GetOrganizationByNameRequest",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : import_minimal62.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationByNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet60(object.name) ? globalThis.String(object.name) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return GetOrganizationByNameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetOrganizationByNameRequest();
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetOrganizationByNameRequest.$type, GetOrganizationByNameRequest);
function createBaseGetOrganizationByNameResponse() {
  return { organizationId: "", isInternal: false };
}
var GetOrganizationByNameResponse = {
  $type: "devvit.dev_portal.data_api.admin.organization.GetOrganizationByNameResponse",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.organizationId !== "") {
      writer.uint32(10).string(message.organizationId);
    }
    if (message.isInternal !== false) {
      writer.uint32(16).bool(message.isInternal);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : import_minimal62.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationByNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.isInternal = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      organizationId: isSet60(object.organizationId) ? globalThis.String(object.organizationId) : "",
      isInternal: isSet60(object.isInternal) ? globalThis.Boolean(object.isInternal) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.isInternal !== false) {
      obj.isInternal = message.isInternal;
    }
    return obj;
  },
  create(base) {
    return GetOrganizationByNameResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetOrganizationByNameResponse();
    message.organizationId = object.organizationId ?? "";
    message.isInternal = object.isInternal ?? false;
    return message;
  }
};
messageTypeRegistry.set(GetOrganizationByNameResponse.$type, GetOrganizationByNameResponse);
function createBaseGetOrganizationsRequest() {
  return {};
}
var GetOrganizationsRequest = {
  $type: "devvit.dev_portal.data_api.admin.organization.GetOrganizationsRequest",
  encode(_, writer = import_minimal62.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : import_minimal62.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetOrganizationsRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetOrganizationsRequest();
    return message;
  }
};
messageTypeRegistry.set(GetOrganizationsRequest.$type, GetOrganizationsRequest);
function createBaseGetOrganizationsResponse() {
  return { organizations: [] };
}
var GetOrganizationsResponse = {
  $type: "devvit.dev_portal.data_api.admin.organization.GetOrganizationsResponse",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    for (const v of message.organizations) {
      Organization.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : import_minimal62.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizations.push(Organization.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      organizations: globalThis.Array.isArray(object?.organizations) ? object.organizations.map((e) => Organization.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizations?.length) {
      obj.organizations = message.organizations.map((e) => Organization.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetOrganizationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetOrganizationsResponse();
    message.organizations = object.organizations?.map((e) => Organization.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetOrganizationsResponse.$type, GetOrganizationsResponse);
function isSet60(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/data_api/admin/audit/audit.js
var import_minimal63 = __toESM(require_minimal2(), 1);
var AuditLogEventType;
(function(AuditLogEventType2) {
  AuditLogEventType2[AuditLogEventType2["DATA_SUBSCRIPTION_CREATE"] = 0] = "DATA_SUBSCRIPTION_CREATE";
  AuditLogEventType2[AuditLogEventType2["DATA_SUBSCRIPTION_UPDATE"] = 1] = "DATA_SUBSCRIPTION_UPDATE";
  AuditLogEventType2[AuditLogEventType2["DATA_SUBSCRIPTION_DELETE"] = 2] = "DATA_SUBSCRIPTION_DELETE";
  AuditLogEventType2[AuditLogEventType2["DATA_TOKEN_CREATE"] = 3] = "DATA_TOKEN_CREATE";
  AuditLogEventType2[AuditLogEventType2["DATA_TOKEN_REVOKE"] = 4] = "DATA_TOKEN_REVOKE";
  AuditLogEventType2[AuditLogEventType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AuditLogEventType || (AuditLogEventType = {}));
function auditLogEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "DATA_SUBSCRIPTION_CREATE":
      return AuditLogEventType.DATA_SUBSCRIPTION_CREATE;
    case 1:
    case "DATA_SUBSCRIPTION_UPDATE":
      return AuditLogEventType.DATA_SUBSCRIPTION_UPDATE;
    case 2:
    case "DATA_SUBSCRIPTION_DELETE":
      return AuditLogEventType.DATA_SUBSCRIPTION_DELETE;
    case 3:
    case "DATA_TOKEN_CREATE":
      return AuditLogEventType.DATA_TOKEN_CREATE;
    case 4:
    case "DATA_TOKEN_REVOKE":
      return AuditLogEventType.DATA_TOKEN_REVOKE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditLogEventType.UNRECOGNIZED;
  }
}
function auditLogEventTypeToJSON(object) {
  switch (object) {
    case AuditLogEventType.DATA_SUBSCRIPTION_CREATE:
      return 0;
    case AuditLogEventType.DATA_SUBSCRIPTION_UPDATE:
      return 1;
    case AuditLogEventType.DATA_SUBSCRIPTION_DELETE:
      return 2;
    case AuditLogEventType.DATA_TOKEN_CREATE:
      return 3;
    case AuditLogEventType.DATA_TOKEN_REVOKE:
      return 4;
    case AuditLogEventType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAuditLogEvent() {
  return {
    id: "",
    createdAt: void 0,
    userId: "",
    type: 0,
    organizationId: "",
    dataTokenCreatePayload: void 0,
    dataTokenRevokePayload: void 0,
    dataSubscriptionCreatePayload: void 0,
    dataSubscriptionUpdatePayload: void 0,
    dataSubscriptionDeletePayload: void 0,
    username: ""
  };
}
var AuditLogEvent = {
  $type: "devvit.dev_portal.data_api.admin.audit.AuditLogEvent",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp9(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.organizationId !== "") {
      writer.uint32(42).string(message.organizationId);
    }
    if (message.dataTokenCreatePayload !== void 0) {
      DataTokenCreateAuditLogEventPayload.encode(message.dataTokenCreatePayload, writer.uint32(50).fork()).ldelim();
    }
    if (message.dataTokenRevokePayload !== void 0) {
      DataTokenRevokeAuditLogEventPayload.encode(message.dataTokenRevokePayload, writer.uint32(58).fork()).ldelim();
    }
    if (message.dataSubscriptionCreatePayload !== void 0) {
      DataSubscriptionCreateAuditLogEventPayload.encode(message.dataSubscriptionCreatePayload, writer.uint32(66).fork()).ldelim();
    }
    if (message.dataSubscriptionUpdatePayload !== void 0) {
      DataSubscriptionUpdateAuditLogEventPayload.encode(message.dataSubscriptionUpdatePayload, writer.uint32(74).fork()).ldelim();
    }
    if (message.dataSubscriptionDeletePayload !== void 0) {
      DataSubscriptionDeleteAuditLogEventPayload.encode(message.dataSubscriptionDeletePayload, writer.uint32(82).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(90).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.createdAt = fromTimestamp9(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.organizationId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.dataTokenCreatePayload = DataTokenCreateAuditLogEventPayload.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.dataTokenRevokePayload = DataTokenRevokeAuditLogEventPayload.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.dataSubscriptionCreatePayload = DataSubscriptionCreateAuditLogEventPayload.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.dataSubscriptionUpdatePayload = DataSubscriptionUpdateAuditLogEventPayload.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.dataSubscriptionDeletePayload = DataSubscriptionDeleteAuditLogEventPayload.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet61(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet61(object.createdAt) ? fromJsonTimestamp9(object.createdAt) : void 0,
      userId: isSet61(object.userId) ? globalThis.String(object.userId) : "",
      type: isSet61(object.type) ? auditLogEventTypeFromJSON(object.type) : 0,
      organizationId: isSet61(object.organizationId) ? globalThis.String(object.organizationId) : "",
      dataTokenCreatePayload: isSet61(object.dataTokenCreatePayload) ? DataTokenCreateAuditLogEventPayload.fromJSON(object.dataTokenCreatePayload) : void 0,
      dataTokenRevokePayload: isSet61(object.dataTokenRevokePayload) ? DataTokenRevokeAuditLogEventPayload.fromJSON(object.dataTokenRevokePayload) : void 0,
      dataSubscriptionCreatePayload: isSet61(object.dataSubscriptionCreatePayload) ? DataSubscriptionCreateAuditLogEventPayload.fromJSON(object.dataSubscriptionCreatePayload) : void 0,
      dataSubscriptionUpdatePayload: isSet61(object.dataSubscriptionUpdatePayload) ? DataSubscriptionUpdateAuditLogEventPayload.fromJSON(object.dataSubscriptionUpdatePayload) : void 0,
      dataSubscriptionDeletePayload: isSet61(object.dataSubscriptionDeletePayload) ? DataSubscriptionDeleteAuditLogEventPayload.fromJSON(object.dataSubscriptionDeletePayload) : void 0,
      username: isSet61(object.username) ? globalThis.String(object.username) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.type !== 0) {
      obj.type = auditLogEventTypeToJSON(message.type);
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.dataTokenCreatePayload !== void 0) {
      obj.dataTokenCreatePayload = DataTokenCreateAuditLogEventPayload.toJSON(message.dataTokenCreatePayload);
    }
    if (message.dataTokenRevokePayload !== void 0) {
      obj.dataTokenRevokePayload = DataTokenRevokeAuditLogEventPayload.toJSON(message.dataTokenRevokePayload);
    }
    if (message.dataSubscriptionCreatePayload !== void 0) {
      obj.dataSubscriptionCreatePayload = DataSubscriptionCreateAuditLogEventPayload.toJSON(message.dataSubscriptionCreatePayload);
    }
    if (message.dataSubscriptionUpdatePayload !== void 0) {
      obj.dataSubscriptionUpdatePayload = DataSubscriptionUpdateAuditLogEventPayload.toJSON(message.dataSubscriptionUpdatePayload);
    }
    if (message.dataSubscriptionDeletePayload !== void 0) {
      obj.dataSubscriptionDeletePayload = DataSubscriptionDeleteAuditLogEventPayload.toJSON(message.dataSubscriptionDeletePayload);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },
  create(base) {
    return AuditLogEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAuditLogEvent();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? void 0;
    message.userId = object.userId ?? "";
    message.type = object.type ?? 0;
    message.organizationId = object.organizationId ?? "";
    message.dataTokenCreatePayload = object.dataTokenCreatePayload !== void 0 && object.dataTokenCreatePayload !== null ? DataTokenCreateAuditLogEventPayload.fromPartial(object.dataTokenCreatePayload) : void 0;
    message.dataTokenRevokePayload = object.dataTokenRevokePayload !== void 0 && object.dataTokenRevokePayload !== null ? DataTokenRevokeAuditLogEventPayload.fromPartial(object.dataTokenRevokePayload) : void 0;
    message.dataSubscriptionCreatePayload = object.dataSubscriptionCreatePayload !== void 0 && object.dataSubscriptionCreatePayload !== null ? DataSubscriptionCreateAuditLogEventPayload.fromPartial(object.dataSubscriptionCreatePayload) : void 0;
    message.dataSubscriptionUpdatePayload = object.dataSubscriptionUpdatePayload !== void 0 && object.dataSubscriptionUpdatePayload !== null ? DataSubscriptionUpdateAuditLogEventPayload.fromPartial(object.dataSubscriptionUpdatePayload) : void 0;
    message.dataSubscriptionDeletePayload = object.dataSubscriptionDeletePayload !== void 0 && object.dataSubscriptionDeletePayload !== null ? DataSubscriptionDeleteAuditLogEventPayload.fromPartial(object.dataSubscriptionDeletePayload) : void 0;
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set(AuditLogEvent.$type, AuditLogEvent);
function createBaseDataTokenCreateAuditLogEventPayload() {
  return { tokenId: "", expiration: void 0 };
}
var DataTokenCreateAuditLogEventPayload = {
  $type: "devvit.dev_portal.data_api.admin.audit.DataTokenCreateAuditLogEventPayload",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    if (message.expiration !== void 0) {
      Timestamp.encode(toTimestamp9(message.expiration), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataTokenCreateAuditLogEventPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.tokenId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.expiration = fromTimestamp9(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tokenId: isSet61(object.tokenId) ? globalThis.String(object.tokenId) : "",
      expiration: isSet61(object.expiration) ? fromJsonTimestamp9(object.expiration) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.expiration !== void 0) {
      obj.expiration = message.expiration.toISOString();
    }
    return obj;
  },
  create(base) {
    return DataTokenCreateAuditLogEventPayload.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataTokenCreateAuditLogEventPayload();
    message.tokenId = object.tokenId ?? "";
    message.expiration = object.expiration ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(DataTokenCreateAuditLogEventPayload.$type, DataTokenCreateAuditLogEventPayload);
function createBaseDataTokenRevokeAuditLogEventPayload() {
  return { tokenId: "" };
}
var DataTokenRevokeAuditLogEventPayload = {
  $type: "devvit.dev_portal.data_api.admin.audit.DataTokenRevokeAuditLogEventPayload",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataTokenRevokeAuditLogEventPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { tokenId: isSet61(object.tokenId) ? globalThis.String(object.tokenId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },
  create(base) {
    return DataTokenRevokeAuditLogEventPayload.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataTokenRevokeAuditLogEventPayload();
    message.tokenId = object.tokenId ?? "";
    return message;
  }
};
messageTypeRegistry.set(DataTokenRevokeAuditLogEventPayload.$type, DataTokenRevokeAuditLogEventPayload);
function createBaseDataSubscriptionCreateAuditLogEventPayload() {
  return { subscriptionId: "" };
}
var DataSubscriptionCreateAuditLogEventPayload = {
  $type: "devvit.dev_portal.data_api.admin.audit.DataSubscriptionCreateAuditLogEventPayload",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataSubscriptionCreateAuditLogEventPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscriptionId: isSet61(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },
  create(base) {
    return DataSubscriptionCreateAuditLogEventPayload.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataSubscriptionCreateAuditLogEventPayload();
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(DataSubscriptionCreateAuditLogEventPayload.$type, DataSubscriptionCreateAuditLogEventPayload);
function createBaseDataSubscriptionUpdateAuditLogEventPayload() {
  return { subscriptionId: "" };
}
var DataSubscriptionUpdateAuditLogEventPayload = {
  $type: "devvit.dev_portal.data_api.admin.audit.DataSubscriptionUpdateAuditLogEventPayload",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataSubscriptionUpdateAuditLogEventPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscriptionId: isSet61(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },
  create(base) {
    return DataSubscriptionUpdateAuditLogEventPayload.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataSubscriptionUpdateAuditLogEventPayload();
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(DataSubscriptionUpdateAuditLogEventPayload.$type, DataSubscriptionUpdateAuditLogEventPayload);
function createBaseDataSubscriptionDeleteAuditLogEventPayload() {
  return { subscriptionId: "" };
}
var DataSubscriptionDeleteAuditLogEventPayload = {
  $type: "devvit.dev_portal.data_api.admin.audit.DataSubscriptionDeleteAuditLogEventPayload",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataSubscriptionDeleteAuditLogEventPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subscriptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subscriptionId: isSet61(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },
  create(base) {
    return DataSubscriptionDeleteAuditLogEventPayload.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataSubscriptionDeleteAuditLogEventPayload();
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(DataSubscriptionDeleteAuditLogEventPayload.$type, DataSubscriptionDeleteAuditLogEventPayload);
function createBaseGetAuditLogEventsRequest() {
  return { organizationName: "" };
}
var GetAuditLogEventsRequest = {
  $type: "devvit.dev_portal.data_api.admin.audit.GetAuditLogEventsRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.organizationName !== "") {
      writer.uint32(10).string(message.organizationName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.organizationName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { organizationName: isSet61(object.organizationName) ? globalThis.String(object.organizationName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.organizationName !== "") {
      obj.organizationName = message.organizationName;
    }
    return obj;
  },
  create(base) {
    return GetAuditLogEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAuditLogEventsRequest();
    message.organizationName = object.organizationName ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAuditLogEventsRequest.$type, GetAuditLogEventsRequest);
function createBaseGetAuditLogEventsResponse() {
  return { events: [] };
}
var GetAuditLogEventsResponse = {
  $type: "devvit.dev_portal.data_api.admin.audit.GetAuditLogEventsResponse",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    for (const v of message.events) {
      AuditLogEvent.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : import_minimal63.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.events.push(AuditLogEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => AuditLogEvent.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => AuditLogEvent.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetAuditLogEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAuditLogEventsResponse();
    message.events = object.events?.map((e) => AuditLogEvent.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetAuditLogEventsResponse.$type, GetAuditLogEventsResponse);
function toTimestamp9(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp9(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp9(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp9(Timestamp.fromJSON(o));
  }
}
function isSet61(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation_settings/installation_settings.js
var import_minimal65 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/settings/v1alpha/settings.js
var import_minimal64 = __toESM(require_minimal2(), 1);
function createBaseSettingsValues() {
  return { version: "", settings: {}, timestamp: void 0 };
}
var SettingsValues = {
  $type: "devvit.plugin.settings.v1alpha.SettingsValues",
  encode(message, writer = import_minimal64.default.Writer.create()) {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    Object.entries(message.settings).forEach(([key, value]) => {
      SettingsValues_SettingsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp10(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal64.default.Reader ? input : import_minimal64.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = SettingsValues_SettingsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.settings[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.timestamp = fromTimestamp10(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet62(object.version) ? globalThis.String(object.version) : "",
      settings: isObject10(object.settings) ? Object.entries(object.settings).reduce((acc, [key, value]) => {
        acc[key] = FormFieldValue.fromJSON(value);
        return acc;
      }, {}) : {},
      timestamp: isSet62(object.timestamp) ? fromJsonTimestamp10(object.timestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = FormFieldValue.toJSON(v);
        });
      }
    }
    if (message.timestamp !== void 0) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },
  create(base) {
    return SettingsValues.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSettingsValues();
    message.version = object.version ?? "";
    message.settings = Object.entries(object.settings ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FormFieldValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.timestamp = object.timestamp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SettingsValues.$type, SettingsValues);
function createBaseSettingsValues_SettingsEntry() {
  return { key: "", value: void 0 };
}
var SettingsValues_SettingsEntry = {
  $type: "devvit.plugin.settings.v1alpha.SettingsValues.SettingsEntry",
  encode(message, writer = import_minimal64.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FormFieldValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal64.default.Reader ? input : import_minimal64.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsValues_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = FormFieldValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet62(object.key) ? globalThis.String(object.key) : "",
      value: isSet62(object.value) ? FormFieldValue.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = FormFieldValue.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return SettingsValues_SettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSettingsValues_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FormFieldValue.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SettingsValues_SettingsEntry.$type, SettingsValues_SettingsEntry);
function createBaseSettingsRequest() {
  return {};
}
var SettingsRequest = {
  $type: "devvit.plugin.settings.v1alpha.SettingsRequest",
  encode(_, writer = import_minimal64.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal64.default.Reader ? input : import_minimal64.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return SettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseSettingsRequest();
    return message;
  }
};
messageTypeRegistry.set(SettingsRequest.$type, SettingsRequest);
function createBaseSettingsResponse() {
  return { installationSettings: void 0, instanceSettings: void 0, appSettings: void 0 };
}
var SettingsResponse = {
  $type: "devvit.plugin.settings.v1alpha.SettingsResponse",
  encode(message, writer = import_minimal64.default.Writer.create()) {
    if (message.installationSettings !== void 0) {
      SettingsValues.encode(message.installationSettings, writer.uint32(10).fork()).ldelim();
    }
    if (message.instanceSettings !== void 0) {
      SettingsValues.encode(message.instanceSettings, writer.uint32(18).fork()).ldelim();
    }
    if (message.appSettings !== void 0) {
      SettingsValues.encode(message.appSettings, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal64.default.Reader ? input : import_minimal64.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationSettings = SettingsValues.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.instanceSettings = SettingsValues.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.appSettings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationSettings: isSet62(object.installationSettings) ? SettingsValues.fromJSON(object.installationSettings) : void 0,
      instanceSettings: isSet62(object.instanceSettings) ? SettingsValues.fromJSON(object.instanceSettings) : void 0,
      appSettings: isSet62(object.appSettings) ? SettingsValues.fromJSON(object.appSettings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationSettings !== void 0) {
      obj.installationSettings = SettingsValues.toJSON(message.installationSettings);
    }
    if (message.instanceSettings !== void 0) {
      obj.instanceSettings = SettingsValues.toJSON(message.instanceSettings);
    }
    if (message.appSettings !== void 0) {
      obj.appSettings = SettingsValues.toJSON(message.appSettings);
    }
    return obj;
  },
  create(base) {
    return SettingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSettingsResponse();
    message.installationSettings = object.installationSettings !== void 0 && object.installationSettings !== null ? SettingsValues.fromPartial(object.installationSettings) : void 0;
    message.instanceSettings = object.instanceSettings !== void 0 && object.instanceSettings !== null ? SettingsValues.fromPartial(object.instanceSettings) : void 0;
    message.appSettings = object.appSettings !== void 0 && object.appSettings !== null ? SettingsValues.fromPartial(object.appSettings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SettingsResponse.$type, SettingsResponse);
function toTimestamp10(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp10(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp10(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp10(Timestamp.fromJSON(o));
  }
}
function isObject10(value) {
  return typeof value === "object" && value !== null;
}
function isSet62(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation_settings/installation_settings.js
function createBaseGetInstallationSettingsFormRequest() {
  return { installationId: "" };
}
var GetInstallationSettingsFormRequest = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsFormRequest",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet63(object.installationId) ? globalThis.String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    return obj;
  },
  create(base) {
    return GetInstallationSettingsFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsFormRequest();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetInstallationSettingsFormRequest.$type, GetInstallationSettingsFormRequest);
function createBaseGetInstallationSettingsFormResponse() {
  return { form: {} };
}
var GetInstallationSettingsFormResponse = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsFormResponse",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    Object.entries(message.form).forEach(([key, value]) => {
      GetInstallationSettingsFormResponse_FormEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = GetInstallationSettingsFormResponse_FormEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.form[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      form: isObject11(object.form) ? Object.entries(object.form).reduce((acc, [key, value]) => {
        acc[key] = Form.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.form) {
      const entries = Object.entries(message.form);
      if (entries.length > 0) {
        obj.form = {};
        entries.forEach(([k, v]) => {
          obj.form[k] = Form.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return GetInstallationSettingsFormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsFormResponse();
    message.form = Object.entries(object.form ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Form.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(GetInstallationSettingsFormResponse.$type, GetInstallationSettingsFormResponse);
function createBaseGetInstallationSettingsFormResponse_FormEntry() {
  return { key: "", value: void 0 };
}
var GetInstallationSettingsFormResponse_FormEntry = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsFormResponse.FormEntry",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Form.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsFormResponse_FormEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = Form.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet63(object.key) ? globalThis.String(object.key) : "",
      value: isSet63(object.value) ? Form.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = Form.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetInstallationSettingsFormResponse_FormEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsFormResponse_FormEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Form.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetInstallationSettingsFormResponse_FormEntry.$type, GetInstallationSettingsFormResponse_FormEntry);
function createBaseValidateInstallationSettingsFormRequest() {
  return { installationId: "", settings: void 0 };
}
var ValidateInstallationSettingsFormRequest = {
  $type: "devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormRequest",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateInstallationSettingsFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.settings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationId: isSet63(object.installationId) ? globalThis.String(object.installationId) : "",
      settings: isSet63(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    if (message.settings !== void 0) {
      obj.settings = SettingsValues.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return ValidateInstallationSettingsFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateInstallationSettingsFormRequest();
    message.installationId = object.installationId ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ValidateInstallationSettingsFormRequest.$type, ValidateInstallationSettingsFormRequest);
function createBaseValidateInstallationSettingsFormResponse() {
  return { success: false, errors: {} };
}
var ValidateInstallationSettingsFormResponse = {
  $type: "devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormResponse",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      ValidateInstallationSettingsFormResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateInstallationSettingsFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = ValidateInstallationSettingsFormResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet63(object.success) ? globalThis.Boolean(object.success) : false,
      errors: isObject11(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errors) {
      const entries = Object.entries(message.errors);
      if (entries.length > 0) {
        obj.errors = {};
        entries.forEach(([k, v]) => {
          obj.errors[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return ValidateInstallationSettingsFormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateInstallationSettingsFormResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ValidateInstallationSettingsFormResponse.$type, ValidateInstallationSettingsFormResponse);
function createBaseValidateInstallationSettingsFormResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var ValidateInstallationSettingsFormResponse_ErrorsEntry = {
  $type: "devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormResponse.ErrorsEntry",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateInstallationSettingsFormResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet63(object.key) ? globalThis.String(object.key) : "",
      value: isSet63(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ValidateInstallationSettingsFormResponse_ErrorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateInstallationSettingsFormResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(ValidateInstallationSettingsFormResponse_ErrorsEntry.$type, ValidateInstallationSettingsFormResponse_ErrorsEntry);
function createBaseGetInstallationSettingsRequest() {
  return { installationId: "" };
}
var GetInstallationSettingsRequest = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsRequest",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet63(object.installationId) ? globalThis.String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    return obj;
  },
  create(base) {
    return GetInstallationSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsRequest();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetInstallationSettingsRequest.$type, GetInstallationSettingsRequest);
function createBaseGetInstallationSettingsResponse() {
  return { settings: void 0 };
}
var GetInstallationSettingsResponse = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsResponse",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.settings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { settings: isSet63(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.settings !== void 0) {
      obj.settings = SettingsValues.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return GetInstallationSettingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsResponse();
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetInstallationSettingsResponse.$type, GetInstallationSettingsResponse);
function createBaseUpdateInstallationSettingsRequest() {
  return { installationId: "", settings: void 0 };
}
var UpdateInstallationSettingsRequest = {
  $type: "devvit.dev_portal.installation_settings.UpdateInstallationSettingsRequest",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstallationSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.settings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationId: isSet63(object.installationId) ? globalThis.String(object.installationId) : "",
      settings: isSet63(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    if (message.settings !== void 0) {
      obj.settings = SettingsValues.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return UpdateInstallationSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateInstallationSettingsRequest();
    message.installationId = object.installationId ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateInstallationSettingsRequest.$type, UpdateInstallationSettingsRequest);
function createBaseUpdateInstallationSettingsResponse() {
  return { success: false, errors: {} };
}
var UpdateInstallationSettingsResponse = {
  $type: "devvit.dev_portal.installation_settings.UpdateInstallationSettingsResponse",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      UpdateInstallationSettingsResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstallationSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = UpdateInstallationSettingsResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet63(object.success) ? globalThis.Boolean(object.success) : false,
      errors: isObject11(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errors) {
      const entries = Object.entries(message.errors);
      if (entries.length > 0) {
        obj.errors = {};
        entries.forEach(([k, v]) => {
          obj.errors[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return UpdateInstallationSettingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateInstallationSettingsResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(UpdateInstallationSettingsResponse.$type, UpdateInstallationSettingsResponse);
function createBaseUpdateInstallationSettingsResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var UpdateInstallationSettingsResponse_ErrorsEntry = {
  $type: "devvit.dev_portal.installation_settings.UpdateInstallationSettingsResponse.ErrorsEntry",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : import_minimal65.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstallationSettingsResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet63(object.key) ? globalThis.String(object.key) : "",
      value: isSet63(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return UpdateInstallationSettingsResponse_ErrorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateInstallationSettingsResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(UpdateInstallationSettingsResponse_ErrorsEntry.$type, UpdateInstallationSettingsResponse_ErrorsEntry);
function isObject11(value) {
  return typeof value === "object" && value !== null;
}
function isSet63(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app_settings/app_settings.js
var import_minimal66 = __toESM(require_minimal2(), 1);
function createBaseGetAppSettingsRequest() {
  return { appId: "" };
}
var GetAppSettingsRequest = {
  $type: "devvit.dev_portal.app_settings.GetAppSettingsRequest",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet64(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return GetAppSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppSettingsRequest();
    message.appId = object.appId ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAppSettingsRequest.$type, GetAppSettingsRequest);
function createBaseGetAppSettingsResponse() {
  return { settings: void 0 };
}
var GetAppSettingsResponse = {
  $type: "devvit.dev_portal.app_settings.GetAppSettingsResponse",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.settings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { settings: isSet64(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.settings !== void 0) {
      obj.settings = SettingsValues.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return GetAppSettingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppSettingsResponse();
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetAppSettingsResponse.$type, GetAppSettingsResponse);
function createBaseUpdateAppSettingsRequest() {
  return { appId: "", settings: void 0 };
}
var UpdateAppSettingsRequest = {
  $type: "devvit.dev_portal.app_settings.UpdateAppSettingsRequest",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAppSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.settings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet64(object.appId) ? globalThis.String(object.appId) : "",
      settings: isSet64(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.settings !== void 0) {
      obj.settings = SettingsValues.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return UpdateAppSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateAppSettingsRequest();
    message.appId = object.appId ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateAppSettingsRequest.$type, UpdateAppSettingsRequest);
function createBaseUpdateAppSettingsResponse() {
  return { success: false, errors: {} };
}
var UpdateAppSettingsResponse = {
  $type: "devvit.dev_portal.app_settings.UpdateAppSettingsResponse",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      UpdateAppSettingsResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAppSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = UpdateAppSettingsResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet64(object.success) ? globalThis.Boolean(object.success) : false,
      errors: isObject12(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errors) {
      const entries = Object.entries(message.errors);
      if (entries.length > 0) {
        obj.errors = {};
        entries.forEach(([k, v]) => {
          obj.errors[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return UpdateAppSettingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateAppSettingsResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(UpdateAppSettingsResponse.$type, UpdateAppSettingsResponse);
function createBaseUpdateAppSettingsResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var UpdateAppSettingsResponse_ErrorsEntry = {
  $type: "devvit.dev_portal.app_settings.UpdateAppSettingsResponse.ErrorsEntry",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAppSettingsResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet64(object.key) ? globalThis.String(object.key) : "",
      value: isSet64(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return UpdateAppSettingsResponse_ErrorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateAppSettingsResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(UpdateAppSettingsResponse_ErrorsEntry.$type, UpdateAppSettingsResponse_ErrorsEntry);
function createBaseGetAppSettingsFormRequest() {
  return { appId: "" };
}
var GetAppSettingsFormRequest = {
  $type: "devvit.dev_portal.app_settings.GetAppSettingsFormRequest",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppSettingsFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet64(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return GetAppSettingsFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppSettingsFormRequest();
    message.appId = object.appId ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAppSettingsFormRequest.$type, GetAppSettingsFormRequest);
function createBaseGetAppSettingsFormResponse() {
  return { form: {} };
}
var GetAppSettingsFormResponse = {
  $type: "devvit.dev_portal.app_settings.GetAppSettingsFormResponse",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    Object.entries(message.form).forEach(([key, value]) => {
      GetAppSettingsFormResponse_FormEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppSettingsFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = GetAppSettingsFormResponse_FormEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.form[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      form: isObject12(object.form) ? Object.entries(object.form).reduce((acc, [key, value]) => {
        acc[key] = Form.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.form) {
      const entries = Object.entries(message.form);
      if (entries.length > 0) {
        obj.form = {};
        entries.forEach(([k, v]) => {
          obj.form[k] = Form.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return GetAppSettingsFormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppSettingsFormResponse();
    message.form = Object.entries(object.form ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Form.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(GetAppSettingsFormResponse.$type, GetAppSettingsFormResponse);
function createBaseGetAppSettingsFormResponse_FormEntry() {
  return { key: "", value: void 0 };
}
var GetAppSettingsFormResponse_FormEntry = {
  $type: "devvit.dev_portal.app_settings.GetAppSettingsFormResponse.FormEntry",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Form.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppSettingsFormResponse_FormEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = Form.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet64(object.key) ? globalThis.String(object.key) : "",
      value: isSet64(object.value) ? Form.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = Form.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetAppSettingsFormResponse_FormEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAppSettingsFormResponse_FormEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Form.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetAppSettingsFormResponse_FormEntry.$type, GetAppSettingsFormResponse_FormEntry);
function createBaseValidateAppSettingsFormRequest() {
  return { appId: "", settings: void 0 };
}
var ValidateAppSettingsFormRequest = {
  $type: "devvit.dev_portal.app_settings.ValidateAppSettingsFormRequest",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateAppSettingsFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.settings = SettingsValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet64(object.appId) ? globalThis.String(object.appId) : "",
      settings: isSet64(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.settings !== void 0) {
      obj.settings = SettingsValues.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return ValidateAppSettingsFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateAppSettingsFormRequest();
    message.appId = object.appId ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ValidateAppSettingsFormRequest.$type, ValidateAppSettingsFormRequest);
function createBaseValidateAppSettingsFormResponse() {
  return { success: false, errors: {} };
}
var ValidateAppSettingsFormResponse = {
  $type: "devvit.dev_portal.app_settings.ValidateAppSettingsFormResponse",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      ValidateAppSettingsFormResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateAppSettingsFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = ValidateAppSettingsFormResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet64(object.success) ? globalThis.Boolean(object.success) : false,
      errors: isObject12(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errors) {
      const entries = Object.entries(message.errors);
      if (entries.length > 0) {
        obj.errors = {};
        entries.forEach(([k, v]) => {
          obj.errors[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return ValidateAppSettingsFormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateAppSettingsFormResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ValidateAppSettingsFormResponse.$type, ValidateAppSettingsFormResponse);
function createBaseValidateAppSettingsFormResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var ValidateAppSettingsFormResponse_ErrorsEntry = {
  $type: "devvit.dev_portal.app_settings.ValidateAppSettingsFormResponse.ErrorsEntry",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : import_minimal66.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateAppSettingsFormResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet64(object.key) ? globalThis.String(object.key) : "",
      value: isSet64(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ValidateAppSettingsFormResponse_ErrorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateAppSettingsFormResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(ValidateAppSettingsFormResponse_ErrorsEntry.$type, ValidateAppSettingsFormResponse_ErrorsEntry);
function isObject12(value) {
  return typeof value === "object" && value !== null;
}
function isSet64(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/dev_portal.js
var import_minimal67 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/cli/playtest.js
var import_minimal68 = __toESM(require_minimal2(), 1);
function createBasePlaytestProviderMessage() {
  return { callState: void 0, connect: void 0 };
}
var PlaytestProviderMessage = {
  $type: "devvit.cli.PlaytestProviderMessage",
  encode(message, writer = import_minimal68.default.Writer.create()) {
    if (message.callState !== void 0) {
      PlaytestCallState.encode(message.callState, writer.uint32(10).fork()).ldelim();
    }
    if (message.connect !== void 0) {
      PlaytestConnect.encode(message.connect, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal68.default.Reader ? input : import_minimal68.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlaytestProviderMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.callState = PlaytestCallState.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.connect = PlaytestConnect.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      callState: isSet65(object.callState) ? PlaytestCallState.fromJSON(object.callState) : void 0,
      connect: isSet65(object.connect) ? PlaytestConnect.fromJSON(object.connect) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.callState !== void 0) {
      obj.callState = PlaytestCallState.toJSON(message.callState);
    }
    if (message.connect !== void 0) {
      obj.connect = PlaytestConnect.toJSON(message.connect);
    }
    return obj;
  },
  create(base) {
    return PlaytestProviderMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePlaytestProviderMessage();
    message.callState = object.callState !== void 0 && object.callState !== null ? PlaytestCallState.fromPartial(object.callState) : void 0;
    message.connect = object.connect !== void 0 && object.connect !== null ? PlaytestConnect.fromPartial(object.connect) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PlaytestProviderMessage.$type, PlaytestProviderMessage);
function createBasePlaytestSubscriberMessage() {
  return { appInstalled: void 0 };
}
var PlaytestSubscriberMessage = {
  $type: "devvit.cli.PlaytestSubscriberMessage",
  encode(message, writer = import_minimal68.default.Writer.create()) {
    if (message.appInstalled !== void 0) {
      PlaytestAppInstalled.encode(message.appInstalled, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal68.default.Reader ? input : import_minimal68.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlaytestSubscriberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appInstalled = PlaytestAppInstalled.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appInstalled: isSet65(object.appInstalled) ? PlaytestAppInstalled.fromJSON(object.appInstalled) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appInstalled !== void 0) {
      obj.appInstalled = PlaytestAppInstalled.toJSON(message.appInstalled);
    }
    return obj;
  },
  create(base) {
    return PlaytestSubscriberMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePlaytestSubscriberMessage();
    message.appInstalled = object.appInstalled !== void 0 && object.appInstalled !== null ? PlaytestAppInstalled.fromPartial(object.appInstalled) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PlaytestSubscriberMessage.$type, PlaytestSubscriberMessage);
function createBasePlaytestAppInstalled() {
  return {};
}
var PlaytestAppInstalled = {
  $type: "devvit.cli.PlaytestAppInstalled",
  encode(_, writer = import_minimal68.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal68.default.Reader ? input : import_minimal68.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlaytestAppInstalled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return PlaytestAppInstalled.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBasePlaytestAppInstalled();
    return message;
  }
};
messageTypeRegistry.set(PlaytestAppInstalled.$type, PlaytestAppInstalled);
function createBasePlaytestCallState() {
  return { logs: [] };
}
var PlaytestCallState = {
  $type: "devvit.cli.PlaytestCallState",
  encode(message, writer = import_minimal68.default.Writer.create()) {
    for (const v of message.logs) {
      LogMessage.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal68.default.Reader ? input : import_minimal68.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlaytestCallState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.logs.push(LogMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e) => LogMessage.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => LogMessage.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return PlaytestCallState.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePlaytestCallState();
    message.logs = object.logs?.map((e) => LogMessage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(PlaytestCallState.$type, PlaytestCallState);
function createBasePlaytestConnect() {
  return { url: "" };
}
var PlaytestConnect = {
  $type: "devvit.cli.PlaytestConnect",
  encode(message, writer = import_minimal68.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal68.default.Reader ? input : import_minimal68.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlaytestConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { url: isSet65(object.url) ? globalThis.String(object.url) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return PlaytestConnect.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePlaytestConnect();
    message.url = object.url ?? "";
    return message;
  }
};
messageTypeRegistry.set(PlaytestConnect.$type, PlaytestConnect);
function isSet65(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/supervisor.js
var import_minimal69 = __toESM(require_minimal2(), 1);
function createBaseUnloadRequest() {
  return { force: false, hostname: "" };
}
var UnloadRequest = {
  $type: "devvit.runtime.actor.UnloadRequest",
  encode(message, writer = import_minimal69.default.Writer.create()) {
    if (message.force !== false) {
      writer.uint32(8).bool(message.force);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : import_minimal69.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.force = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      force: isSet66(object.force) ? globalThis.Boolean(object.force) : false,
      hostname: isSet66(object.hostname) ? globalThis.String(object.hostname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },
  create(base) {
    return UnloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUnloadRequest();
    message.force = object.force ?? false;
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set(UnloadRequest.$type, UnloadRequest);
var SupervisorDefinition = {
  name: "Supervisor",
  fullName: "devvit.runtime.actor.Supervisor",
  methods: {
    /**
     * Transform an incoming envelope.
     *
     * Because the input and outputs are Envelopes, they are actually Envelopes
     * wrapped in Envelopes. That is, Envelope.message is an Envelope. The outer
     * Envelope.success flag indicates filter status.
     */
    filter: {
      name: "Filter",
      requestType: Envelope,
      requestStream: false,
      responseType: Envelope,
      responseStream: false,
      options: {}
    },
    /** Unpacks and loads each bundled Actor into their own Workers */
    load: {
      name: "Load",
      requestType: LinkedBundle,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Unloads the actor at the provided URI, and unloads dependencies if needed */
    unload: {
      name: "Unload",
      requestType: UnloadRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    }
  }
};
function isSet66(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/runtime.js
var import_minimal70 = __toESM(require_minimal2(), 1);
function createBaseWorkerQuery() {
  return { hostname: "" };
}
var WorkerQuery = {
  $type: "devvit.runtime.actor.WorkerQuery",
  encode(message, writer = import_minimal70.default.Writer.create()) {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : import_minimal70.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWorkerQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { hostname: isSet67(object.hostname) ? globalThis.String(object.hostname) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },
  create(base) {
    return WorkerQuery.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWorkerQuery();
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set(WorkerQuery.$type, WorkerQuery);
var RuntimeActorDefinition = {
  name: "RuntimeActor",
  fullName: "devvit.runtime.actor.RuntimeActor",
  methods: {
    newWorker: {
      name: "NewWorker",
      requestType: LinkedBundle,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    terminateWorker: {
      name: "TerminateWorker",
      requestType: WorkerQuery,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    }
  }
};
function isSet67(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/echo.js
var import_minimal71 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/actor/bootstrap.js
var import_minimal72 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/v2alpha/userv2.js
var import_long5 = __toESM(require_long(), 1);
var import_minimal74 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/v2alpha/flair.js
var import_minimal73 = __toESM(require_minimal2(), 1);
function createBaseLinkFlairV2() {
  return { text: "", cssClass: "", backgroundColor: "", templateId: "", textColor: "" };
}
var LinkFlairV2 = {
  $type: "devvit.reddit.v2alpha.LinkFlairV2",
  encode(message, writer = import_minimal73.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.cssClass !== "") {
      writer.uint32(18).string(message.cssClass);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(26).string(message.backgroundColor);
    }
    if (message.templateId !== "") {
      writer.uint32(34).string(message.templateId);
    }
    if (message.textColor !== "") {
      writer.uint32(42).string(message.textColor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal73.default.Reader ? input : import_minimal73.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkFlairV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.cssClass = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.templateId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.textColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet68(object.text) ? globalThis.String(object.text) : "",
      cssClass: isSet68(object.cssClass) ? globalThis.String(object.cssClass) : "",
      backgroundColor: isSet68(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
      templateId: isSet68(object.templateId) ? globalThis.String(object.templateId) : "",
      textColor: isSet68(object.textColor) ? globalThis.String(object.textColor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.cssClass !== "") {
      obj.cssClass = message.cssClass;
    }
    if (message.backgroundColor !== "") {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.templateId !== "") {
      obj.templateId = message.templateId;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    return obj;
  },
  create(base) {
    return LinkFlairV2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLinkFlairV2();
    message.text = object.text ?? "";
    message.cssClass = object.cssClass ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.templateId = object.templateId ?? "";
    message.textColor = object.textColor ?? "";
    return message;
  }
};
messageTypeRegistry.set(LinkFlairV2.$type, LinkFlairV2);
function createBaseUserFlairV2() {
  return {
    userId: "",
    subredditId: "",
    text: "",
    cssClass: "",
    templateId: "",
    textColor: "",
    backgroundColor: "",
    enabled: false
  };
}
var UserFlairV2 = {
  $type: "devvit.reddit.v2alpha.UserFlairV2",
  encode(message, writer = import_minimal73.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.subredditId !== "") {
      writer.uint32(18).string(message.subredditId);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.cssClass !== "") {
      writer.uint32(34).string(message.cssClass);
    }
    if (message.templateId !== "") {
      writer.uint32(42).string(message.templateId);
    }
    if (message.textColor !== "") {
      writer.uint32(50).string(message.textColor);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(58).string(message.backgroundColor);
    }
    if (message.enabled !== false) {
      writer.uint32(64).bool(message.enabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal73.default.Reader ? input : import_minimal73.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFlairV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subredditId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.cssClass = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.templateId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.textColor = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet68(object.userId) ? globalThis.String(object.userId) : "",
      subredditId: isSet68(object.subredditId) ? globalThis.String(object.subredditId) : "",
      text: isSet68(object.text) ? globalThis.String(object.text) : "",
      cssClass: isSet68(object.cssClass) ? globalThis.String(object.cssClass) : "",
      templateId: isSet68(object.templateId) ? globalThis.String(object.templateId) : "",
      textColor: isSet68(object.textColor) ? globalThis.String(object.textColor) : "",
      backgroundColor: isSet68(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
      enabled: isSet68(object.enabled) ? globalThis.Boolean(object.enabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.subredditId !== "") {
      obj.subredditId = message.subredditId;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.cssClass !== "") {
      obj.cssClass = message.cssClass;
    }
    if (message.templateId !== "") {
      obj.templateId = message.templateId;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.backgroundColor !== "") {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },
  create(base) {
    return UserFlairV2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserFlairV2();
    message.userId = object.userId ?? "";
    message.subredditId = object.subredditId ?? "";
    message.text = object.text ?? "";
    message.cssClass = object.cssClass ?? "";
    message.templateId = object.templateId ?? "";
    message.textColor = object.textColor ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  }
};
messageTypeRegistry.set(UserFlairV2.$type, UserFlairV2);
function isSet68(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/userv2.js
function createBaseUserV2() {
  return {
    id: "",
    name: "",
    isGold: false,
    snoovatarImage: "",
    url: "",
    spam: false,
    banned: false,
    flair: void 0,
    karma: 0,
    iconImage: ""
  };
}
var UserV2 = {
  $type: "devvit.reddit.v2alpha.UserV2",
  encode(message, writer = import_minimal74.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isGold !== false) {
      writer.uint32(24).bool(message.isGold);
    }
    if (message.snoovatarImage !== "") {
      writer.uint32(34).string(message.snoovatarImage);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.spam !== false) {
      writer.uint32(48).bool(message.spam);
    }
    if (message.banned !== false) {
      writer.uint32(56).bool(message.banned);
    }
    if (message.flair !== void 0) {
      UserFlairV2.encode(message.flair, writer.uint32(66).fork()).ldelim();
    }
    if (message.karma !== 0) {
      writer.uint32(72).int64(message.karma);
    }
    if (message.iconImage !== "") {
      writer.uint32(82).string(message.iconImage);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal74.default.Reader ? input : import_minimal74.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.isGold = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.snoovatarImage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.url = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.spam = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.banned = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.flair = UserFlairV2.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.karma = longToNumber5(reader.int64());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.iconImage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet69(object.id) ? globalThis.String(object.id) : "",
      name: isSet69(object.name) ? globalThis.String(object.name) : "",
      isGold: isSet69(object.isGold) ? globalThis.Boolean(object.isGold) : false,
      snoovatarImage: isSet69(object.snoovatarImage) ? globalThis.String(object.snoovatarImage) : "",
      url: isSet69(object.url) ? globalThis.String(object.url) : "",
      spam: isSet69(object.spam) ? globalThis.Boolean(object.spam) : false,
      banned: isSet69(object.banned) ? globalThis.Boolean(object.banned) : false,
      flair: isSet69(object.flair) ? UserFlairV2.fromJSON(object.flair) : void 0,
      karma: isSet69(object.karma) ? globalThis.Number(object.karma) : 0,
      iconImage: isSet69(object.iconImage) ? globalThis.String(object.iconImage) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isGold !== false) {
      obj.isGold = message.isGold;
    }
    if (message.snoovatarImage !== "") {
      obj.snoovatarImage = message.snoovatarImage;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.spam !== false) {
      obj.spam = message.spam;
    }
    if (message.banned !== false) {
      obj.banned = message.banned;
    }
    if (message.flair !== void 0) {
      obj.flair = UserFlairV2.toJSON(message.flair);
    }
    if (message.karma !== 0) {
      obj.karma = Math.round(message.karma);
    }
    if (message.iconImage !== "") {
      obj.iconImage = message.iconImage;
    }
    return obj;
  },
  create(base) {
    return UserV2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserV2();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isGold = object.isGold ?? false;
    message.snoovatarImage = object.snoovatarImage ?? "";
    message.url = object.url ?? "";
    message.spam = object.spam ?? false;
    message.banned = object.banned ?? false;
    message.flair = object.flair !== void 0 && object.flair !== null ? UserFlairV2.fromPartial(object.flair) : void 0;
    message.karma = object.karma ?? 0;
    message.iconImage = object.iconImage ?? "";
    return message;
  }
};
messageTypeRegistry.set(UserV2.$type, UserV2);
function longToNumber5(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal74.default.util.Long !== import_long5.default) {
  import_minimal74.default.util.Long = import_long5.default;
  import_minimal74.default.configure();
}
function isSet69(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/postv2.js
var import_long6 = __toESM(require_long(), 1);
var import_minimal75 = __toESM(require_minimal2(), 1);
var CrowdControlLevel;
(function(CrowdControlLevel2) {
  CrowdControlLevel2[CrowdControlLevel2["OFF"] = 0] = "OFF";
  CrowdControlLevel2[CrowdControlLevel2["LENIENT"] = 1] = "LENIENT";
  CrowdControlLevel2[CrowdControlLevel2["MEDIUM"] = 2] = "MEDIUM";
  CrowdControlLevel2[CrowdControlLevel2["STRICT"] = 3] = "STRICT";
  CrowdControlLevel2[CrowdControlLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CrowdControlLevel || (CrowdControlLevel = {}));
function crowdControlLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "OFF":
      return CrowdControlLevel.OFF;
    case 1:
    case "LENIENT":
      return CrowdControlLevel.LENIENT;
    case 2:
    case "MEDIUM":
      return CrowdControlLevel.MEDIUM;
    case 3:
    case "STRICT":
      return CrowdControlLevel.STRICT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CrowdControlLevel.UNRECOGNIZED;
  }
}
function crowdControlLevelToJSON(object) {
  switch (object) {
    case CrowdControlLevel.OFF:
      return 0;
    case CrowdControlLevel.LENIENT:
      return 1;
    case CrowdControlLevel.MEDIUM:
      return 2;
    case CrowdControlLevel.STRICT:
      return 3;
    case CrowdControlLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}
var DistinguishType;
(function(DistinguishType2) {
  DistinguishType2[DistinguishType2["NULL_VALUE"] = 0] = "NULL_VALUE";
  DistinguishType2[DistinguishType2["ADMIN"] = 1] = "ADMIN";
  DistinguishType2[DistinguishType2["GOLD"] = 2] = "GOLD";
  DistinguishType2[DistinguishType2["GOLD_AUTO"] = 3] = "GOLD_AUTO";
  DistinguishType2[DistinguishType2["YES"] = 4] = "YES";
  DistinguishType2[DistinguishType2["SPECIAL"] = 5] = "SPECIAL";
  DistinguishType2[DistinguishType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DistinguishType || (DistinguishType = {}));
function distinguishTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return DistinguishType.NULL_VALUE;
    case 1:
    case "ADMIN":
      return DistinguishType.ADMIN;
    case 2:
    case "GOLD":
      return DistinguishType.GOLD;
    case 3:
    case "GOLD_AUTO":
      return DistinguishType.GOLD_AUTO;
    case 4:
    case "YES":
      return DistinguishType.YES;
    case 5:
    case "SPECIAL":
      return DistinguishType.SPECIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DistinguishType.UNRECOGNIZED;
  }
}
function distinguishTypeToJSON(object) {
  switch (object) {
    case DistinguishType.NULL_VALUE:
      return 0;
    case DistinguishType.ADMIN:
      return 1;
    case DistinguishType.GOLD:
      return 2;
    case DistinguishType.GOLD_AUTO:
      return 3;
    case DistinguishType.YES:
      return 4;
    case DistinguishType.SPECIAL:
      return 5;
    case DistinguishType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBasePostV2() {
  return {
    id: "",
    title: "",
    selftext: "",
    nsfw: false,
    authorId: "",
    crowdControlLevel: 0,
    numReports: 0,
    isGallery: false,
    isMeta: false,
    createdAt: 0,
    isApproved: false,
    isArchived: false,
    distinguished: 0,
    ignoreReports: false,
    isSelf: false,
    isVideo: false,
    isLocked: false,
    isSpoiler: false,
    subredditId: "",
    upvotes: 0,
    downvotes: 0,
    url: "",
    isSticky: false,
    linkFlair: void 0,
    authorFlair: void 0,
    spam: false,
    deleted: false,
    languageCode: "",
    updatedAt: 0,
    gildings: 0,
    score: 0,
    numComments: 0,
    thumbnail: "",
    media: void 0,
    crosspostParentId: "",
    permalink: "",
    isPoll: false,
    isPromoted: false,
    isMultiMedia: false,
    type: "",
    unlisted: false
  };
}
var PostV2 = {
  $type: "devvit.reddit.v2alpha.PostV2",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.selftext !== "") {
      writer.uint32(26).string(message.selftext);
    }
    if (message.nsfw !== false) {
      writer.uint32(32).bool(message.nsfw);
    }
    if (message.authorId !== "") {
      writer.uint32(42).string(message.authorId);
    }
    if (message.crowdControlLevel !== 0) {
      writer.uint32(48).int32(message.crowdControlLevel);
    }
    if (message.numReports !== 0) {
      writer.uint32(56).int32(message.numReports);
    }
    if (message.isGallery !== false) {
      writer.uint32(64).bool(message.isGallery);
    }
    if (message.isMeta !== false) {
      writer.uint32(72).bool(message.isMeta);
    }
    if (message.createdAt !== 0) {
      writer.uint32(80).int64(message.createdAt);
    }
    if (message.isApproved !== false) {
      writer.uint32(88).bool(message.isApproved);
    }
    if (message.isArchived !== false) {
      writer.uint32(96).bool(message.isArchived);
    }
    if (message.distinguished !== 0) {
      writer.uint32(104).int32(message.distinguished);
    }
    if (message.ignoreReports !== false) {
      writer.uint32(112).bool(message.ignoreReports);
    }
    if (message.isSelf !== false) {
      writer.uint32(120).bool(message.isSelf);
    }
    if (message.isVideo !== false) {
      writer.uint32(128).bool(message.isVideo);
    }
    if (message.isLocked !== false) {
      writer.uint32(136).bool(message.isLocked);
    }
    if (message.isSpoiler !== false) {
      writer.uint32(144).bool(message.isSpoiler);
    }
    if (message.subredditId !== "") {
      writer.uint32(154).string(message.subredditId);
    }
    if (message.upvotes !== 0) {
      writer.uint32(160).int32(message.upvotes);
    }
    if (message.downvotes !== 0) {
      writer.uint32(168).int32(message.downvotes);
    }
    if (message.url !== "") {
      writer.uint32(178).string(message.url);
    }
    if (message.isSticky !== false) {
      writer.uint32(184).bool(message.isSticky);
    }
    if (message.linkFlair !== void 0) {
      LinkFlairV2.encode(message.linkFlair, writer.uint32(194).fork()).ldelim();
    }
    if (message.authorFlair !== void 0) {
      UserFlairV2.encode(message.authorFlair, writer.uint32(202).fork()).ldelim();
    }
    if (message.spam !== false) {
      writer.uint32(208).bool(message.spam);
    }
    if (message.deleted !== false) {
      writer.uint32(216).bool(message.deleted);
    }
    if (message.languageCode !== "") {
      writer.uint32(226).string(message.languageCode);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(232).int64(message.updatedAt);
    }
    if (message.gildings !== 0) {
      writer.uint32(240).int32(message.gildings);
    }
    if (message.score !== 0) {
      writer.uint32(248).int32(message.score);
    }
    if (message.numComments !== 0) {
      writer.uint32(256).int32(message.numComments);
    }
    if (message.thumbnail !== "") {
      writer.uint32(266).string(message.thumbnail);
    }
    if (message.media !== void 0) {
      MediaObject.encode(message.media, writer.uint32(274).fork()).ldelim();
    }
    if (message.crosspostParentId !== "") {
      writer.uint32(282).string(message.crosspostParentId);
    }
    if (message.permalink !== "") {
      writer.uint32(290).string(message.permalink);
    }
    if (message.isPoll !== false) {
      writer.uint32(296).bool(message.isPoll);
    }
    if (message.isPromoted !== false) {
      writer.uint32(304).bool(message.isPromoted);
    }
    if (message.isMultiMedia !== false) {
      writer.uint32(312).bool(message.isMultiMedia);
    }
    if (message.type !== "") {
      writer.uint32(322).string(message.type);
    }
    if (message.unlisted !== false) {
      writer.uint32(328).bool(message.unlisted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : import_minimal75.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.selftext = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.nsfw = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.authorId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.crowdControlLevel = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.numReports = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.isGallery = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.isMeta = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.createdAt = longToNumber6(reader.int64());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.isApproved = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }
          message.isArchived = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }
          message.distinguished = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }
          message.ignoreReports = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }
          message.isSelf = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }
          message.isVideo = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }
          message.isLocked = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }
          message.isSpoiler = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.subredditId = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }
          message.upvotes = reader.int32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }
          message.downvotes = reader.int32();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.url = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }
          message.isSticky = reader.bool();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.linkFlair = LinkFlairV2.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.authorFlair = UserFlairV2.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }
          message.spam = reader.bool();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }
          message.deleted = reader.bool();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.languageCode = reader.string();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }
          message.updatedAt = longToNumber6(reader.int64());
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }
          message.gildings = reader.int32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }
          message.score = reader.int32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }
          message.numComments = reader.int32();
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.thumbnail = reader.string();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.media = MediaObject.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.crosspostParentId = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.permalink = reader.string();
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }
          message.isPoll = reader.bool();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }
          message.isPromoted = reader.bool();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }
          message.isMultiMedia = reader.bool();
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.type = reader.string();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }
          message.unlisted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet70(object.id) ? globalThis.String(object.id) : "",
      title: isSet70(object.title) ? globalThis.String(object.title) : "",
      selftext: isSet70(object.selftext) ? globalThis.String(object.selftext) : "",
      nsfw: isSet70(object.nsfw) ? globalThis.Boolean(object.nsfw) : false,
      authorId: isSet70(object.authorId) ? globalThis.String(object.authorId) : "",
      crowdControlLevel: isSet70(object.crowdControlLevel) ? crowdControlLevelFromJSON(object.crowdControlLevel) : 0,
      numReports: isSet70(object.numReports) ? globalThis.Number(object.numReports) : 0,
      isGallery: isSet70(object.isGallery) ? globalThis.Boolean(object.isGallery) : false,
      isMeta: isSet70(object.isMeta) ? globalThis.Boolean(object.isMeta) : false,
      createdAt: isSet70(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      isApproved: isSet70(object.isApproved) ? globalThis.Boolean(object.isApproved) : false,
      isArchived: isSet70(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
      distinguished: isSet70(object.distinguished) ? distinguishTypeFromJSON(object.distinguished) : 0,
      ignoreReports: isSet70(object.ignoreReports) ? globalThis.Boolean(object.ignoreReports) : false,
      isSelf: isSet70(object.isSelf) ? globalThis.Boolean(object.isSelf) : false,
      isVideo: isSet70(object.isVideo) ? globalThis.Boolean(object.isVideo) : false,
      isLocked: isSet70(object.isLocked) ? globalThis.Boolean(object.isLocked) : false,
      isSpoiler: isSet70(object.isSpoiler) ? globalThis.Boolean(object.isSpoiler) : false,
      subredditId: isSet70(object.subredditId) ? globalThis.String(object.subredditId) : "",
      upvotes: isSet70(object.upvotes) ? globalThis.Number(object.upvotes) : 0,
      downvotes: isSet70(object.downvotes) ? globalThis.Number(object.downvotes) : 0,
      url: isSet70(object.url) ? globalThis.String(object.url) : "",
      isSticky: isSet70(object.isSticky) ? globalThis.Boolean(object.isSticky) : false,
      linkFlair: isSet70(object.linkFlair) ? LinkFlairV2.fromJSON(object.linkFlair) : void 0,
      authorFlair: isSet70(object.authorFlair) ? UserFlairV2.fromJSON(object.authorFlair) : void 0,
      spam: isSet70(object.spam) ? globalThis.Boolean(object.spam) : false,
      deleted: isSet70(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      languageCode: isSet70(object.languageCode) ? globalThis.String(object.languageCode) : "",
      updatedAt: isSet70(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      gildings: isSet70(object.gildings) ? globalThis.Number(object.gildings) : 0,
      score: isSet70(object.score) ? globalThis.Number(object.score) : 0,
      numComments: isSet70(object.numComments) ? globalThis.Number(object.numComments) : 0,
      thumbnail: isSet70(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      media: isSet70(object.media) ? MediaObject.fromJSON(object.media) : void 0,
      crosspostParentId: isSet70(object.crosspostParentId) ? globalThis.String(object.crosspostParentId) : "",
      permalink: isSet70(object.permalink) ? globalThis.String(object.permalink) : "",
      isPoll: isSet70(object.isPoll) ? globalThis.Boolean(object.isPoll) : false,
      isPromoted: isSet70(object.isPromoted) ? globalThis.Boolean(object.isPromoted) : false,
      isMultiMedia: isSet70(object.isMultiMedia) ? globalThis.Boolean(object.isMultiMedia) : false,
      type: isSet70(object.type) ? globalThis.String(object.type) : "",
      unlisted: isSet70(object.unlisted) ? globalThis.Boolean(object.unlisted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.selftext !== "") {
      obj.selftext = message.selftext;
    }
    if (message.nsfw !== false) {
      obj.nsfw = message.nsfw;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.crowdControlLevel !== 0) {
      obj.crowdControlLevel = crowdControlLevelToJSON(message.crowdControlLevel);
    }
    if (message.numReports !== 0) {
      obj.numReports = Math.round(message.numReports);
    }
    if (message.isGallery !== false) {
      obj.isGallery = message.isGallery;
    }
    if (message.isMeta !== false) {
      obj.isMeta = message.isMeta;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.isApproved !== false) {
      obj.isApproved = message.isApproved;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.distinguished !== 0) {
      obj.distinguished = distinguishTypeToJSON(message.distinguished);
    }
    if (message.ignoreReports !== false) {
      obj.ignoreReports = message.ignoreReports;
    }
    if (message.isSelf !== false) {
      obj.isSelf = message.isSelf;
    }
    if (message.isVideo !== false) {
      obj.isVideo = message.isVideo;
    }
    if (message.isLocked !== false) {
      obj.isLocked = message.isLocked;
    }
    if (message.isSpoiler !== false) {
      obj.isSpoiler = message.isSpoiler;
    }
    if (message.subredditId !== "") {
      obj.subredditId = message.subredditId;
    }
    if (message.upvotes !== 0) {
      obj.upvotes = Math.round(message.upvotes);
    }
    if (message.downvotes !== 0) {
      obj.downvotes = Math.round(message.downvotes);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.isSticky !== false) {
      obj.isSticky = message.isSticky;
    }
    if (message.linkFlair !== void 0) {
      obj.linkFlair = LinkFlairV2.toJSON(message.linkFlair);
    }
    if (message.authorFlair !== void 0) {
      obj.authorFlair = UserFlairV2.toJSON(message.authorFlair);
    }
    if (message.spam !== false) {
      obj.spam = message.spam;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.gildings !== 0) {
      obj.gildings = Math.round(message.gildings);
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.numComments !== 0) {
      obj.numComments = Math.round(message.numComments);
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.media !== void 0) {
      obj.media = MediaObject.toJSON(message.media);
    }
    if (message.crosspostParentId !== "") {
      obj.crosspostParentId = message.crosspostParentId;
    }
    if (message.permalink !== "") {
      obj.permalink = message.permalink;
    }
    if (message.isPoll !== false) {
      obj.isPoll = message.isPoll;
    }
    if (message.isPromoted !== false) {
      obj.isPromoted = message.isPromoted;
    }
    if (message.isMultiMedia !== false) {
      obj.isMultiMedia = message.isMultiMedia;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.unlisted !== false) {
      obj.unlisted = message.unlisted;
    }
    return obj;
  },
  create(base) {
    return PostV2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostV2();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.selftext = object.selftext ?? "";
    message.nsfw = object.nsfw ?? false;
    message.authorId = object.authorId ?? "";
    message.crowdControlLevel = object.crowdControlLevel ?? 0;
    message.numReports = object.numReports ?? 0;
    message.isGallery = object.isGallery ?? false;
    message.isMeta = object.isMeta ?? false;
    message.createdAt = object.createdAt ?? 0;
    message.isApproved = object.isApproved ?? false;
    message.isArchived = object.isArchived ?? false;
    message.distinguished = object.distinguished ?? 0;
    message.ignoreReports = object.ignoreReports ?? false;
    message.isSelf = object.isSelf ?? false;
    message.isVideo = object.isVideo ?? false;
    message.isLocked = object.isLocked ?? false;
    message.isSpoiler = object.isSpoiler ?? false;
    message.subredditId = object.subredditId ?? "";
    message.upvotes = object.upvotes ?? 0;
    message.downvotes = object.downvotes ?? 0;
    message.url = object.url ?? "";
    message.isSticky = object.isSticky ?? false;
    message.linkFlair = object.linkFlair !== void 0 && object.linkFlair !== null ? LinkFlairV2.fromPartial(object.linkFlair) : void 0;
    message.authorFlair = object.authorFlair !== void 0 && object.authorFlair !== null ? UserFlairV2.fromPartial(object.authorFlair) : void 0;
    message.spam = object.spam ?? false;
    message.deleted = object.deleted ?? false;
    message.languageCode = object.languageCode ?? "";
    message.updatedAt = object.updatedAt ?? 0;
    message.gildings = object.gildings ?? 0;
    message.score = object.score ?? 0;
    message.numComments = object.numComments ?? 0;
    message.thumbnail = object.thumbnail ?? "";
    message.media = object.media !== void 0 && object.media !== null ? MediaObject.fromPartial(object.media) : void 0;
    message.crosspostParentId = object.crosspostParentId ?? "";
    message.permalink = object.permalink ?? "";
    message.isPoll = object.isPoll ?? false;
    message.isPromoted = object.isPromoted ?? false;
    message.isMultiMedia = object.isMultiMedia ?? false;
    message.type = object.type ?? "";
    message.unlisted = object.unlisted ?? false;
    return message;
  }
};
messageTypeRegistry.set(PostV2.$type, PostV2);
function createBaseOembed() {
  return {
    type: "",
    version: "",
    title: "",
    description: "",
    authorName: "",
    authorUrl: "",
    providerName: "",
    providerUrl: "",
    thumbnailUrl: "",
    thumbnailWidth: 0,
    thumbnailHeight: 0,
    html: "",
    width: 0,
    height: 0
  };
}
var Oembed = {
  $type: "devvit.reddit.v2alpha.Oembed",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.authorName !== "") {
      writer.uint32(42).string(message.authorName);
    }
    if (message.authorUrl !== "") {
      writer.uint32(50).string(message.authorUrl);
    }
    if (message.providerName !== "") {
      writer.uint32(58).string(message.providerName);
    }
    if (message.providerUrl !== "") {
      writer.uint32(66).string(message.providerUrl);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(74).string(message.thumbnailUrl);
    }
    if (message.thumbnailWidth !== 0) {
      writer.uint32(80).int32(message.thumbnailWidth);
    }
    if (message.thumbnailHeight !== 0) {
      writer.uint32(88).int32(message.thumbnailHeight);
    }
    if (message.html !== "") {
      writer.uint32(98).string(message.html);
    }
    if (message.width !== 0) {
      writer.uint32(104).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(112).int32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : import_minimal75.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOembed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.authorName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.authorUrl = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.providerName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.providerUrl = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.thumbnailUrl = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.thumbnailWidth = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.thumbnailHeight = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.html = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }
          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet70(object.type) ? globalThis.String(object.type) : "",
      version: isSet70(object.version) ? globalThis.String(object.version) : "",
      title: isSet70(object.title) ? globalThis.String(object.title) : "",
      description: isSet70(object.description) ? globalThis.String(object.description) : "",
      authorName: isSet70(object.authorName) ? globalThis.String(object.authorName) : "",
      authorUrl: isSet70(object.authorUrl) ? globalThis.String(object.authorUrl) : "",
      providerName: isSet70(object.providerName) ? globalThis.String(object.providerName) : "",
      providerUrl: isSet70(object.providerUrl) ? globalThis.String(object.providerUrl) : "",
      thumbnailUrl: isSet70(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      thumbnailWidth: isSet70(object.thumbnailWidth) ? globalThis.Number(object.thumbnailWidth) : 0,
      thumbnailHeight: isSet70(object.thumbnailHeight) ? globalThis.Number(object.thumbnailHeight) : 0,
      html: isSet70(object.html) ? globalThis.String(object.html) : "",
      width: isSet70(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet70(object.height) ? globalThis.Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.authorName !== "") {
      obj.authorName = message.authorName;
    }
    if (message.authorUrl !== "") {
      obj.authorUrl = message.authorUrl;
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.providerUrl !== "") {
      obj.providerUrl = message.providerUrl;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.thumbnailWidth !== 0) {
      obj.thumbnailWidth = Math.round(message.thumbnailWidth);
    }
    if (message.thumbnailHeight !== 0) {
      obj.thumbnailHeight = Math.round(message.thumbnailHeight);
    }
    if (message.html !== "") {
      obj.html = message.html;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },
  create(base) {
    return Oembed.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOembed();
    message.type = object.type ?? "";
    message.version = object.version ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.authorName = object.authorName ?? "";
    message.authorUrl = object.authorUrl ?? "";
    message.providerName = object.providerName ?? "";
    message.providerUrl = object.providerUrl ?? "";
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.thumbnailWidth = object.thumbnailWidth ?? 0;
    message.thumbnailHeight = object.thumbnailHeight ?? 0;
    message.html = object.html ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Oembed.$type, Oembed);
function createBaseRedditVideo() {
  return {
    bitrateKbps: 0,
    fallbackUrl: "",
    height: 0,
    width: 0,
    scrubberMediaUrl: "",
    dashUrl: "",
    duration: 0,
    hlsUrl: "",
    isGif: false,
    transcodingStatus: ""
  };
}
var RedditVideo = {
  $type: "devvit.reddit.v2alpha.RedditVideo",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    if (message.bitrateKbps !== 0) {
      writer.uint32(8).int32(message.bitrateKbps);
    }
    if (message.fallbackUrl !== "") {
      writer.uint32(18).string(message.fallbackUrl);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.scrubberMediaUrl !== "") {
      writer.uint32(42).string(message.scrubberMediaUrl);
    }
    if (message.dashUrl !== "") {
      writer.uint32(50).string(message.dashUrl);
    }
    if (message.duration !== 0) {
      writer.uint32(56).int64(message.duration);
    }
    if (message.hlsUrl !== "") {
      writer.uint32(66).string(message.hlsUrl);
    }
    if (message.isGif !== false) {
      writer.uint32(72).bool(message.isGif);
    }
    if (message.transcodingStatus !== "") {
      writer.uint32(82).string(message.transcodingStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : import_minimal75.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.bitrateKbps = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fallbackUrl = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.scrubberMediaUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.dashUrl = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.duration = longToNumber6(reader.int64());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.hlsUrl = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.isGif = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.transcodingStatus = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bitrateKbps: isSet70(object.bitrateKbps) ? globalThis.Number(object.bitrateKbps) : 0,
      fallbackUrl: isSet70(object.fallbackUrl) ? globalThis.String(object.fallbackUrl) : "",
      height: isSet70(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet70(object.width) ? globalThis.Number(object.width) : 0,
      scrubberMediaUrl: isSet70(object.scrubberMediaUrl) ? globalThis.String(object.scrubberMediaUrl) : "",
      dashUrl: isSet70(object.dashUrl) ? globalThis.String(object.dashUrl) : "",
      duration: isSet70(object.duration) ? globalThis.Number(object.duration) : 0,
      hlsUrl: isSet70(object.hlsUrl) ? globalThis.String(object.hlsUrl) : "",
      isGif: isSet70(object.isGif) ? globalThis.Boolean(object.isGif) : false,
      transcodingStatus: isSet70(object.transcodingStatus) ? globalThis.String(object.transcodingStatus) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bitrateKbps !== 0) {
      obj.bitrateKbps = Math.round(message.bitrateKbps);
    }
    if (message.fallbackUrl !== "") {
      obj.fallbackUrl = message.fallbackUrl;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.scrubberMediaUrl !== "") {
      obj.scrubberMediaUrl = message.scrubberMediaUrl;
    }
    if (message.dashUrl !== "") {
      obj.dashUrl = message.dashUrl;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.hlsUrl !== "") {
      obj.hlsUrl = message.hlsUrl;
    }
    if (message.isGif !== false) {
      obj.isGif = message.isGif;
    }
    if (message.transcodingStatus !== "") {
      obj.transcodingStatus = message.transcodingStatus;
    }
    return obj;
  },
  create(base) {
    return RedditVideo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedditVideo();
    message.bitrateKbps = object.bitrateKbps ?? 0;
    message.fallbackUrl = object.fallbackUrl ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.scrubberMediaUrl = object.scrubberMediaUrl ?? "";
    message.dashUrl = object.dashUrl ?? "";
    message.duration = object.duration ?? 0;
    message.hlsUrl = object.hlsUrl ?? "";
    message.isGif = object.isGif ?? false;
    message.transcodingStatus = object.transcodingStatus ?? "";
    return message;
  }
};
messageTypeRegistry.set(RedditVideo.$type, RedditVideo);
function createBaseMediaObject() {
  return { type: "", oembed: void 0, redditVideo: void 0 };
}
var MediaObject = {
  $type: "devvit.reddit.v2alpha.MediaObject",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.oembed !== void 0) {
      Oembed.encode(message.oembed, writer.uint32(18).fork()).ldelim();
    }
    if (message.redditVideo !== void 0) {
      RedditVideo.encode(message.redditVideo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : import_minimal75.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.oembed = Oembed.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.redditVideo = RedditVideo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet70(object.type) ? globalThis.String(object.type) : "",
      oembed: isSet70(object.oembed) ? Oembed.fromJSON(object.oembed) : void 0,
      redditVideo: isSet70(object.redditVideo) ? RedditVideo.fromJSON(object.redditVideo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.oembed !== void 0) {
      obj.oembed = Oembed.toJSON(message.oembed);
    }
    if (message.redditVideo !== void 0) {
      obj.redditVideo = RedditVideo.toJSON(message.redditVideo);
    }
    return obj;
  },
  create(base) {
    return MediaObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMediaObject();
    message.type = object.type ?? "";
    message.oembed = object.oembed !== void 0 && object.oembed !== null ? Oembed.fromPartial(object.oembed) : void 0;
    message.redditVideo = object.redditVideo !== void 0 && object.redditVideo !== null ? RedditVideo.fromPartial(object.redditVideo) : void 0;
    return message;
  }
};
messageTypeRegistry.set(MediaObject.$type, MediaObject);
function longToNumber6(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal75.default.util.Long !== import_long6.default) {
  import_minimal75.default.util.Long = import_long6.default;
  import_minimal75.default.configure();
}
function isSet70(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/modmail.js
var import_minimal76 = __toESM(require_minimal2(), 1);
function createBaseModMail() {
  return {
    messageAuthor: void 0,
    createdAt: void 0,
    messageAuthorType: "",
    conversationState: "",
    conversationType: "",
    isAutoGenerated: false,
    conversationSubreddit: void 0,
    destinationSubreddit: void 0,
    conversationId: "",
    messageId: ""
  };
}
var ModMail = {
  $type: "devvit.reddit.v2alpha.ModMail",
  encode(message, writer = import_minimal76.default.Writer.create()) {
    if (message.messageAuthor !== void 0) {
      UserV2.encode(message.messageAuthor, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp11(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.messageAuthorType !== "") {
      writer.uint32(34).string(message.messageAuthorType);
    }
    if (message.conversationState !== "") {
      writer.uint32(50).string(message.conversationState);
    }
    if (message.conversationType !== "") {
      writer.uint32(58).string(message.conversationType);
    }
    if (message.isAutoGenerated !== false) {
      writer.uint32(64).bool(message.isAutoGenerated);
    }
    if (message.conversationSubreddit !== void 0) {
      SubredditV2.encode(message.conversationSubreddit, writer.uint32(74).fork()).ldelim();
    }
    if (message.destinationSubreddit !== void 0) {
      SubredditV2.encode(message.destinationSubreddit, writer.uint32(98).fork()).ldelim();
    }
    if (message.conversationId !== "") {
      writer.uint32(82).string(message.conversationId);
    }
    if (message.messageId !== "") {
      writer.uint32(90).string(message.messageId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal76.default.Reader ? input : import_minimal76.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModMail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.messageAuthor = UserV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.createdAt = fromTimestamp11(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.messageAuthorType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.conversationState = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.conversationType = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.isAutoGenerated = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.conversationSubreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.destinationSubreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.conversationId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.messageId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messageAuthor: isSet71(object.messageAuthor) ? UserV2.fromJSON(object.messageAuthor) : void 0,
      createdAt: isSet71(object.createdAt) ? fromJsonTimestamp11(object.createdAt) : void 0,
      messageAuthorType: isSet71(object.messageAuthorType) ? globalThis.String(object.messageAuthorType) : "",
      conversationState: isSet71(object.conversationState) ? globalThis.String(object.conversationState) : "",
      conversationType: isSet71(object.conversationType) ? globalThis.String(object.conversationType) : "",
      isAutoGenerated: isSet71(object.isAutoGenerated) ? globalThis.Boolean(object.isAutoGenerated) : false,
      conversationSubreddit: isSet71(object.conversationSubreddit) ? SubredditV2.fromJSON(object.conversationSubreddit) : void 0,
      destinationSubreddit: isSet71(object.destinationSubreddit) ? SubredditV2.fromJSON(object.destinationSubreddit) : void 0,
      conversationId: isSet71(object.conversationId) ? globalThis.String(object.conversationId) : "",
      messageId: isSet71(object.messageId) ? globalThis.String(object.messageId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messageAuthor !== void 0) {
      obj.messageAuthor = UserV2.toJSON(message.messageAuthor);
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.messageAuthorType !== "") {
      obj.messageAuthorType = message.messageAuthorType;
    }
    if (message.conversationState !== "") {
      obj.conversationState = message.conversationState;
    }
    if (message.conversationType !== "") {
      obj.conversationType = message.conversationType;
    }
    if (message.isAutoGenerated !== false) {
      obj.isAutoGenerated = message.isAutoGenerated;
    }
    if (message.conversationSubreddit !== void 0) {
      obj.conversationSubreddit = SubredditV2.toJSON(message.conversationSubreddit);
    }
    if (message.destinationSubreddit !== void 0) {
      obj.destinationSubreddit = SubredditV2.toJSON(message.destinationSubreddit);
    }
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    return obj;
  },
  create(base) {
    return ModMail.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModMail();
    message.messageAuthor = object.messageAuthor !== void 0 && object.messageAuthor !== null ? UserV2.fromPartial(object.messageAuthor) : void 0;
    message.createdAt = object.createdAt ?? void 0;
    message.messageAuthorType = object.messageAuthorType ?? "";
    message.conversationState = object.conversationState ?? "";
    message.conversationType = object.conversationType ?? "";
    message.isAutoGenerated = object.isAutoGenerated ?? false;
    message.conversationSubreddit = object.conversationSubreddit !== void 0 && object.conversationSubreddit !== null ? SubredditV2.fromPartial(object.conversationSubreddit) : void 0;
    message.destinationSubreddit = object.destinationSubreddit !== void 0 && object.destinationSubreddit !== null ? SubredditV2.fromPartial(object.destinationSubreddit) : void 0;
    message.conversationId = object.conversationId ?? "";
    message.messageId = object.messageId ?? "";
    return message;
  }
};
messageTypeRegistry.set(ModMail.$type, ModMail);
function toTimestamp11(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp11(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp11(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp11(Timestamp.fromJSON(o));
  }
}
function isSet71(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/modaction.js
var import_minimal78 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/v2alpha/commentv2.js
var import_long7 = __toESM(require_long(), 1);
var import_minimal77 = __toESM(require_minimal2(), 1);
function createBaseCommentV2() {
  return {
    id: "",
    parentId: "",
    body: "",
    author: "",
    numReports: 0,
    collapsedBecauseCrowdControl: false,
    spam: false,
    deleted: false,
    createdAt: 0,
    upvotes: 0,
    downvotes: 0,
    languageCode: "",
    lastModifiedAt: 0,
    gilded: false,
    score: 0,
    permalink: "",
    hasMedia: false,
    postId: "",
    subredditId: "",
    elementTypes: []
  };
}
var CommentV2 = {
  $type: "devvit.reddit.v2alpha.CommentV2",
  encode(message, writer = import_minimal77.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.parentId !== "") {
      writer.uint32(18).string(message.parentId);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    if (message.numReports !== 0) {
      writer.uint32(40).int32(message.numReports);
    }
    if (message.collapsedBecauseCrowdControl !== false) {
      writer.uint32(48).bool(message.collapsedBecauseCrowdControl);
    }
    if (message.spam !== false) {
      writer.uint32(56).bool(message.spam);
    }
    if (message.deleted !== false) {
      writer.uint32(64).bool(message.deleted);
    }
    if (message.createdAt !== 0) {
      writer.uint32(72).int64(message.createdAt);
    }
    if (message.upvotes !== 0) {
      writer.uint32(80).int32(message.upvotes);
    }
    if (message.downvotes !== 0) {
      writer.uint32(88).int32(message.downvotes);
    }
    if (message.languageCode !== "") {
      writer.uint32(98).string(message.languageCode);
    }
    if (message.lastModifiedAt !== 0) {
      writer.uint32(104).int64(message.lastModifiedAt);
    }
    if (message.gilded !== false) {
      writer.uint32(112).bool(message.gilded);
    }
    if (message.score !== 0) {
      writer.uint32(120).int32(message.score);
    }
    if (message.permalink !== "") {
      writer.uint32(130).string(message.permalink);
    }
    if (message.hasMedia !== false) {
      writer.uint32(136).bool(message.hasMedia);
    }
    if (message.postId !== "") {
      writer.uint32(146).string(message.postId);
    }
    if (message.subredditId !== "") {
      writer.uint32(154).string(message.subredditId);
    }
    for (const v of message.elementTypes) {
      writer.uint32(162).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal77.default.Reader ? input : import_minimal77.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.parentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.body = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.author = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.numReports = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.collapsedBecauseCrowdControl = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.spam = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.deleted = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.createdAt = longToNumber7(reader.int64());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.upvotes = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.downvotes = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.languageCode = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }
          message.lastModifiedAt = longToNumber7(reader.int64());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }
          message.gilded = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }
          message.score = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.permalink = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }
          message.hasMedia = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.postId = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.subredditId = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.elementTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet72(object.id) ? globalThis.String(object.id) : "",
      parentId: isSet72(object.parentId) ? globalThis.String(object.parentId) : "",
      body: isSet72(object.body) ? globalThis.String(object.body) : "",
      author: isSet72(object.author) ? globalThis.String(object.author) : "",
      numReports: isSet72(object.numReports) ? globalThis.Number(object.numReports) : 0,
      collapsedBecauseCrowdControl: isSet72(object.collapsedBecauseCrowdControl) ? globalThis.Boolean(object.collapsedBecauseCrowdControl) : false,
      spam: isSet72(object.spam) ? globalThis.Boolean(object.spam) : false,
      deleted: isSet72(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      createdAt: isSet72(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      upvotes: isSet72(object.upvotes) ? globalThis.Number(object.upvotes) : 0,
      downvotes: isSet72(object.downvotes) ? globalThis.Number(object.downvotes) : 0,
      languageCode: isSet72(object.languageCode) ? globalThis.String(object.languageCode) : "",
      lastModifiedAt: isSet72(object.lastModifiedAt) ? globalThis.Number(object.lastModifiedAt) : 0,
      gilded: isSet72(object.gilded) ? globalThis.Boolean(object.gilded) : false,
      score: isSet72(object.score) ? globalThis.Number(object.score) : 0,
      permalink: isSet72(object.permalink) ? globalThis.String(object.permalink) : "",
      hasMedia: isSet72(object.hasMedia) ? globalThis.Boolean(object.hasMedia) : false,
      postId: isSet72(object.postId) ? globalThis.String(object.postId) : "",
      subredditId: isSet72(object.subredditId) ? globalThis.String(object.subredditId) : "",
      elementTypes: globalThis.Array.isArray(object?.elementTypes) ? object.elementTypes.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.numReports !== 0) {
      obj.numReports = Math.round(message.numReports);
    }
    if (message.collapsedBecauseCrowdControl !== false) {
      obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl;
    }
    if (message.spam !== false) {
      obj.spam = message.spam;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.upvotes !== 0) {
      obj.upvotes = Math.round(message.upvotes);
    }
    if (message.downvotes !== 0) {
      obj.downvotes = Math.round(message.downvotes);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.lastModifiedAt !== 0) {
      obj.lastModifiedAt = Math.round(message.lastModifiedAt);
    }
    if (message.gilded !== false) {
      obj.gilded = message.gilded;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.permalink !== "") {
      obj.permalink = message.permalink;
    }
    if (message.hasMedia !== false) {
      obj.hasMedia = message.hasMedia;
    }
    if (message.postId !== "") {
      obj.postId = message.postId;
    }
    if (message.subredditId !== "") {
      obj.subredditId = message.subredditId;
    }
    if (message.elementTypes?.length) {
      obj.elementTypes = message.elementTypes;
    }
    return obj;
  },
  create(base) {
    return CommentV2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentV2();
    message.id = object.id ?? "";
    message.parentId = object.parentId ?? "";
    message.body = object.body ?? "";
    message.author = object.author ?? "";
    message.numReports = object.numReports ?? 0;
    message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? false;
    message.spam = object.spam ?? false;
    message.deleted = object.deleted ?? false;
    message.createdAt = object.createdAt ?? 0;
    message.upvotes = object.upvotes ?? 0;
    message.downvotes = object.downvotes ?? 0;
    message.languageCode = object.languageCode ?? "";
    message.lastModifiedAt = object.lastModifiedAt ?? 0;
    message.gilded = object.gilded ?? false;
    message.score = object.score ?? 0;
    message.permalink = object.permalink ?? "";
    message.hasMedia = object.hasMedia ?? false;
    message.postId = object.postId ?? "";
    message.subredditId = object.subredditId ?? "";
    message.elementTypes = object.elementTypes?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(CommentV2.$type, CommentV2);
function longToNumber7(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal77.default.util.Long !== import_long7.default) {
  import_minimal77.default.util.Long = import_long7.default;
  import_minimal77.default.configure();
}
function isSet72(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/modaction.js
var ModActionType;
(function(ModActionType2) {
  ModActionType2[ModActionType2["UNKNOWN"] = 0] = "UNKNOWN";
  ModActionType2[ModActionType2["REMOVE_POST"] = 1] = "REMOVE_POST";
  ModActionType2[ModActionType2["REMOVE_COMMENT"] = 2] = "REMOVE_COMMENT";
  ModActionType2[ModActionType2["APPROVE_POST"] = 3] = "APPROVE_POST";
  ModActionType2[ModActionType2["APPROVE_COMMENT"] = 4] = "APPROVE_COMMENT";
  ModActionType2[ModActionType2["EDIT_POST_FLAIR"] = 5] = "EDIT_POST_FLAIR";
  ModActionType2[ModActionType2["EDIT_USER_FLAIR"] = 6] = "EDIT_USER_FLAIR";
  ModActionType2[ModActionType2["LOCK_POST"] = 7] = "LOCK_POST";
  ModActionType2[ModActionType2["LOCK_COMMENT"] = 8] = "LOCK_COMMENT";
  ModActionType2[ModActionType2["SPAM_POST"] = 9] = "SPAM_POST";
  ModActionType2[ModActionType2["SPAM_COMMENT"] = 10] = "SPAM_COMMENT";
  ModActionType2[ModActionType2["DISTINGUISH_POST"] = 11] = "DISTINGUISH_POST";
  ModActionType2[ModActionType2["DISTINGUISH_COMMENT"] = 12] = "DISTINGUISH_COMMENT";
  ModActionType2[ModActionType2["STICKY_POST"] = 13] = "STICKY_POST";
  ModActionType2[ModActionType2["STICKY_COMMENT"] = 14] = "STICKY_COMMENT";
  ModActionType2[ModActionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ModActionType || (ModActionType = {}));
function createBaseModAction() {
  return {
    action: void 0,
    actionedAt: void 0,
    subreddit: void 0,
    moderator: void 0,
    targetUser: void 0,
    targetComment: void 0,
    targetPost: void 0
  };
}
var ModAction = {
  $type: "devvit.reddit.v2alpha.ModAction",
  encode(message, writer = import_minimal78.default.Writer.create()) {
    if (message.action !== void 0) {
      writer.uint32(66).string(message.action);
    }
    if (message.actionedAt !== void 0) {
      Timestamp.encode(toTimestamp12(message.actionedAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(26).fork()).ldelim();
    }
    if (message.moderator !== void 0) {
      UserV2.encode(message.moderator, writer.uint32(34).fork()).ldelim();
    }
    if (message.targetUser !== void 0) {
      UserV2.encode(message.targetUser, writer.uint32(42).fork()).ldelim();
    }
    if (message.targetComment !== void 0) {
      CommentV2.encode(message.targetComment, writer.uint32(50).fork()).ldelim();
    }
    if (message.targetPost !== void 0) {
      PostV2.encode(message.targetPost, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal78.default.Reader ? input : import_minimal78.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }
          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.actionedAt = fromTimestamp12(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.moderator = UserV2.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.targetUser = UserV2.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.targetComment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.targetPost = PostV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet73(object.action) ? globalThis.String(object.action) : void 0,
      actionedAt: isSet73(object.actionedAt) ? fromJsonTimestamp12(object.actionedAt) : void 0,
      subreddit: isSet73(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      moderator: isSet73(object.moderator) ? UserV2.fromJSON(object.moderator) : void 0,
      targetUser: isSet73(object.targetUser) ? UserV2.fromJSON(object.targetUser) : void 0,
      targetComment: isSet73(object.targetComment) ? CommentV2.fromJSON(object.targetComment) : void 0,
      targetPost: isSet73(object.targetPost) ? PostV2.fromJSON(object.targetPost) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.action !== void 0) {
      obj.action = message.action;
    }
    if (message.actionedAt !== void 0) {
      obj.actionedAt = message.actionedAt.toISOString();
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.moderator !== void 0) {
      obj.moderator = UserV2.toJSON(message.moderator);
    }
    if (message.targetUser !== void 0) {
      obj.targetUser = UserV2.toJSON(message.targetUser);
    }
    if (message.targetComment !== void 0) {
      obj.targetComment = CommentV2.toJSON(message.targetComment);
    }
    if (message.targetPost !== void 0) {
      obj.targetPost = PostV2.toJSON(message.targetPost);
    }
    return obj;
  },
  create(base) {
    return ModAction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModAction();
    message.action = object.action ?? void 0;
    message.actionedAt = object.actionedAt ?? void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.moderator = object.moderator !== void 0 && object.moderator !== null ? UserV2.fromPartial(object.moderator) : void 0;
    message.targetUser = object.targetUser !== void 0 && object.targetUser !== null ? UserV2.fromPartial(object.targetUser) : void 0;
    message.targetComment = object.targetComment !== void 0 && object.targetComment !== null ? CommentV2.fromPartial(object.targetComment) : void 0;
    message.targetPost = object.targetPost !== void 0 && object.targetPost !== null ? PostV2.fromPartial(object.targetPost) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ModAction.$type, ModAction);
function toTimestamp12(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp12(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp12(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp12(Timestamp.fromJSON(o));
  }
}
function isSet73(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/v2events/v2events.js
var import_minimal79 = __toESM(require_minimal2(), 1);
function createBaseV2EventsActionInfo() {
  return { pageType: "", paneName: "" };
}
var V2EventsActionInfo = {
  $type: "devvit.plugin.v2events.V2EventsActionInfo",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    if (message.pageType !== "") {
      writer.uint32(10).string(message.pageType);
    }
    if (message.paneName !== "") {
      writer.uint32(18).string(message.paneName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : import_minimal79.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsActionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.pageType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.paneName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pageType: isSet74(object.pageType) ? globalThis.String(object.pageType) : "",
      paneName: isSet74(object.paneName) ? globalThis.String(object.paneName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.pageType !== "") {
      obj.pageType = message.pageType;
    }
    if (message.paneName !== "") {
      obj.paneName = message.paneName;
    }
    return obj;
  },
  create(base) {
    return V2EventsActionInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseV2EventsActionInfo();
    message.pageType = object.pageType ?? "";
    message.paneName = object.paneName ?? "";
    return message;
  }
};
messageTypeRegistry.set(V2EventsActionInfo.$type, V2EventsActionInfo);
function createBaseV2EventsPostGuidanceCreate() {
  return { actionInfo: void 0 };
}
var V2EventsPostGuidanceCreate = {
  $type: "devvit.plugin.v2events.V2EventsPostGuidanceCreate",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    if (message.actionInfo !== void 0) {
      V2EventsActionInfo.encode(message.actionInfo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : import_minimal79.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPostGuidanceCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionInfo = V2EventsActionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { actionInfo: isSet74(object.actionInfo) ? V2EventsActionInfo.fromJSON(object.actionInfo) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionInfo !== void 0) {
      obj.actionInfo = V2EventsActionInfo.toJSON(message.actionInfo);
    }
    return obj;
  },
  create(base) {
    return V2EventsPostGuidanceCreate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseV2EventsPostGuidanceCreate();
    message.actionInfo = object.actionInfo !== void 0 && object.actionInfo !== null ? V2EventsActionInfo.fromPartial(object.actionInfo) : void 0;
    return message;
  }
};
messageTypeRegistry.set(V2EventsPostGuidanceCreate.$type, V2EventsPostGuidanceCreate);
function createBaseV2EventsPostGuidanceUpdate() {
  return { actionInfo: void 0 };
}
var V2EventsPostGuidanceUpdate = {
  $type: "devvit.plugin.v2events.V2EventsPostGuidanceUpdate",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    if (message.actionInfo !== void 0) {
      V2EventsActionInfo.encode(message.actionInfo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : import_minimal79.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPostGuidanceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionInfo = V2EventsActionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { actionInfo: isSet74(object.actionInfo) ? V2EventsActionInfo.fromJSON(object.actionInfo) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionInfo !== void 0) {
      obj.actionInfo = V2EventsActionInfo.toJSON(message.actionInfo);
    }
    return obj;
  },
  create(base) {
    return V2EventsPostGuidanceUpdate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseV2EventsPostGuidanceUpdate();
    message.actionInfo = object.actionInfo !== void 0 && object.actionInfo !== null ? V2EventsActionInfo.fromPartial(object.actionInfo) : void 0;
    return message;
  }
};
messageTypeRegistry.set(V2EventsPostGuidanceUpdate.$type, V2EventsPostGuidanceUpdate);
function createBaseV2EventsPublishRequest() {
  return { postGuidanceCreate: void 0, postGuidanceUpdate: void 0 };
}
var V2EventsPublishRequest = {
  $type: "devvit.plugin.v2events.V2EventsPublishRequest",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    if (message.postGuidanceCreate !== void 0) {
      V2EventsPostGuidanceCreate.encode(message.postGuidanceCreate, writer.uint32(10).fork()).ldelim();
    }
    if (message.postGuidanceUpdate !== void 0) {
      V2EventsPostGuidanceUpdate.encode(message.postGuidanceUpdate, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : import_minimal79.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.postGuidanceCreate = V2EventsPostGuidanceCreate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.postGuidanceUpdate = V2EventsPostGuidanceUpdate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      postGuidanceCreate: isSet74(object.postGuidanceCreate) ? V2EventsPostGuidanceCreate.fromJSON(object.postGuidanceCreate) : void 0,
      postGuidanceUpdate: isSet74(object.postGuidanceUpdate) ? V2EventsPostGuidanceUpdate.fromJSON(object.postGuidanceUpdate) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.postGuidanceCreate !== void 0) {
      obj.postGuidanceCreate = V2EventsPostGuidanceCreate.toJSON(message.postGuidanceCreate);
    }
    if (message.postGuidanceUpdate !== void 0) {
      obj.postGuidanceUpdate = V2EventsPostGuidanceUpdate.toJSON(message.postGuidanceUpdate);
    }
    return obj;
  },
  create(base) {
    return V2EventsPublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseV2EventsPublishRequest();
    message.postGuidanceCreate = object.postGuidanceCreate !== void 0 && object.postGuidanceCreate !== null ? V2EventsPostGuidanceCreate.fromPartial(object.postGuidanceCreate) : void 0;
    message.postGuidanceUpdate = object.postGuidanceUpdate !== void 0 && object.postGuidanceUpdate !== null ? V2EventsPostGuidanceUpdate.fromPartial(object.postGuidanceUpdate) : void 0;
    return message;
  }
};
messageTypeRegistry.set(V2EventsPublishRequest.$type, V2EventsPublishRequest);
function createBaseV2EventsPublishResponse() {
  return {};
}
var V2EventsPublishResponse = {
  $type: "devvit.plugin.v2events.V2EventsPublishResponse",
  encode(_, writer = import_minimal79.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : import_minimal79.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return V2EventsPublishResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseV2EventsPublishResponse();
    return message;
  }
};
messageTypeRegistry.set(V2EventsPublishResponse.$type, V2EventsPublishResponse);
function isSet74(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/timer/timer.js
var import_minimal80 = __toESM(require_minimal2(), 1);
function createBaseTimerMessage() {
  return { durationMillis: 0 };
}
var TimerMessage = {
  $type: "devvit.plugin.timer.TimerMessage",
  encode(message, writer = import_minimal80.default.Writer.create()) {
    if (message.durationMillis !== 0) {
      writer.uint32(8).int32(message.durationMillis);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal80.default.Reader ? input : import_minimal80.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.durationMillis = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { durationMillis: isSet75(object.durationMillis) ? globalThis.Number(object.durationMillis) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.durationMillis !== 0) {
      obj.durationMillis = Math.round(message.durationMillis);
    }
    return obj;
  },
  create(base) {
    return TimerMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTimerMessage();
    message.durationMillis = object.durationMillis ?? 0;
    return message;
  }
};
messageTypeRegistry.set(TimerMessage.$type, TimerMessage);
function isSet75(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/streambroker/streambroker.js
var import_long8 = __toESM(require_long(), 1);
var import_minimal81 = __toESM(require_minimal2(), 1);
function createBaseMessage() {
  return { topic: "", value: "" };
}
var Message = {
  $type: "devvit.plugin.streambroker.Message",
  encode(message, writer = import_minimal81.default.Writer.create()) {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal81.default.Reader ? input : import_minimal81.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      topic: isSet76(object.topic) ? globalThis.String(object.topic) : "",
      value: isSet76(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Message.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessage();
    message.topic = object.topic ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(Message.$type, Message);
function createBaseCursor() {
  return { topic: "", offset: 0, closeAtEnd: false };
}
var Cursor = {
  $type: "devvit.plugin.streambroker.Cursor",
  encode(message, writer = import_minimal81.default.Writer.create()) {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    if (message.closeAtEnd !== false) {
      writer.uint32(24).bool(message.closeAtEnd);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal81.default.Reader ? input : import_minimal81.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.offset = longToNumber8(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.closeAtEnd = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      topic: isSet76(object.topic) ? globalThis.String(object.topic) : "",
      offset: isSet76(object.offset) ? globalThis.Number(object.offset) : 0,
      closeAtEnd: isSet76(object.closeAtEnd) ? globalThis.Boolean(object.closeAtEnd) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.closeAtEnd !== false) {
      obj.closeAtEnd = message.closeAtEnd;
    }
    return obj;
  },
  create(base) {
    return Cursor.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCursor();
    message.topic = object.topic ?? "";
    message.offset = object.offset ?? 0;
    message.closeAtEnd = object.closeAtEnd ?? false;
    return message;
  }
};
messageTypeRegistry.set(Cursor.$type, Cursor);
function longToNumber8(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal81.default.util.Long !== import_long8.default) {
  import_minimal81.default.util.Long = import_long8.default;
  import_minimal81.default.configure();
}
function isSet76(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/scheduler/scheduler.js
var import_minimal83 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/scheduler/action.js
var import_minimal82 = __toESM(require_minimal2(), 1);
function createBaseScheduledAction() {
  return { type: "", data: void 0 };
}
var ScheduledAction = {
  $type: "devvit.actor.scheduler.ScheduledAction",
  encode(message, writer = import_minimal82.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal82.default.Reader ? input : import_minimal82.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScheduledAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet77(object.type) ? globalThis.String(object.type) : "",
      data: isObject13(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return ScheduledAction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseScheduledAction();
    message.type = object.type ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ScheduledAction.$type, ScheduledAction);
function isObject13(value) {
  return typeof value === "object" && value !== null;
}
function isSet77(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/scheduler/scheduler.js
var StorableAction_State;
(function(StorableAction_State2) {
  StorableAction_State2[StorableAction_State2["WAITING"] = 0] = "WAITING";
  StorableAction_State2[StorableAction_State2["CANCELED"] = 1] = "CANCELED";
  StorableAction_State2[StorableAction_State2["FAILED"] = 2] = "FAILED";
  StorableAction_State2[StorableAction_State2["DELIVERED"] = 3] = "DELIVERED";
  StorableAction_State2[StorableAction_State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StorableAction_State || (StorableAction_State = {}));
function storableAction_StateFromJSON(object) {
  switch (object) {
    case 0:
    case "WAITING":
      return StorableAction_State.WAITING;
    case 1:
    case "CANCELED":
      return StorableAction_State.CANCELED;
    case 2:
    case "FAILED":
      return StorableAction_State.FAILED;
    case 3:
    case "DELIVERED":
      return StorableAction_State.DELIVERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StorableAction_State.UNRECOGNIZED;
  }
}
function storableAction_StateToJSON(object) {
  switch (object) {
    case StorableAction_State.WAITING:
      return 0;
    case StorableAction_State.CANCELED:
      return 1;
    case StorableAction_State.FAILED:
      return 2;
    case StorableAction_State.DELIVERED:
      return 3;
    case StorableAction_State.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseScheduledActionRequest() {
  return { when: void 0, cron: void 0, action: void 0 };
}
var ScheduledActionRequest = {
  $type: "devvit.plugin.scheduler.ScheduledActionRequest",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.when !== void 0) {
      Timestamp.encode(toTimestamp13(message.when), writer.uint32(10).fork()).ldelim();
    }
    if (message.cron !== void 0) {
      writer.uint32(18).string(message.cron);
    }
    if (message.action !== void 0) {
      ScheduledAction.encode(message.action, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScheduledActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.when = fromTimestamp13(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.cron = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.action = ScheduledAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      when: isSet78(object.when) ? fromJsonTimestamp13(object.when) : void 0,
      cron: isSet78(object.cron) ? globalThis.String(object.cron) : void 0,
      action: isSet78(object.action) ? ScheduledAction.fromJSON(object.action) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.when !== void 0) {
      obj.when = message.when.toISOString();
    }
    if (message.cron !== void 0) {
      obj.cron = message.cron;
    }
    if (message.action !== void 0) {
      obj.action = ScheduledAction.toJSON(message.action);
    }
    return obj;
  },
  create(base) {
    return ScheduledActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseScheduledActionRequest();
    message.when = object.when ?? void 0;
    message.cron = object.cron ?? void 0;
    message.action = object.action !== void 0 && object.action !== null ? ScheduledAction.fromPartial(object.action) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ScheduledActionRequest.$type, ScheduledActionRequest);
function createBaseScheduledActionResponse() {
  return { id: "" };
}
var ScheduledActionResponse = {
  $type: "devvit.plugin.scheduler.ScheduledActionResponse",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScheduledActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet78(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return ScheduledActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseScheduledActionResponse();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(ScheduledActionResponse.$type, ScheduledActionResponse);
function createBaseCancelActionRequest() {
  return { id: "" };
}
var CancelActionRequest = {
  $type: "devvit.plugin.scheduler.CancelActionRequest",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCancelActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet78(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return CancelActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCancelActionRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(CancelActionRequest.$type, CancelActionRequest);
function createBaseStorableAction() {
  return { id: "", actorHostname: "", request: void 0, metadata: {}, state: void 0 };
}
var StorableAction = {
  $type: "devvit.plugin.scheduler.StorableAction",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.actorHostname !== "") {
      writer.uint32(18).string(message.actorHostname);
    }
    if (message.request !== void 0) {
      ScheduledActionRequest.encode(message.request, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      StorableAction_MetadataEntry.encode({ key, value }, writer.uint32(74).fork()).ldelim();
    });
    if (message.state !== void 0) {
      writer.uint32(80).int32(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorableAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.actorHostname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.request = ScheduledActionRequest.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          const entry9 = StorableAction_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== void 0) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.state = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet78(object.id) ? globalThis.String(object.id) : "",
      actorHostname: isSet78(object.actorHostname) ? globalThis.String(object.actorHostname) : "",
      request: isSet78(object.request) ? ScheduledActionRequest.fromJSON(object.request) : void 0,
      metadata: isObject14(object.metadata) ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
        acc[key] = Strings.fromJSON(value);
        return acc;
      }, {}) : {},
      state: isSet78(object.state) ? storableAction_StateFromJSON(object.state) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.actorHostname !== "") {
      obj.actorHostname = message.actorHostname;
    }
    if (message.request !== void 0) {
      obj.request = ScheduledActionRequest.toJSON(message.request);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = Strings.toJSON(v);
        });
      }
    }
    if (message.state !== void 0) {
      obj.state = storableAction_StateToJSON(message.state);
    }
    return obj;
  },
  create(base) {
    return StorableAction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStorableAction();
    message.id = object.id ?? "";
    message.actorHostname = object.actorHostname ?? "";
    message.request = object.request !== void 0 && object.request !== null ? ScheduledActionRequest.fromPartial(object.request) : void 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Strings.fromPartial(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(StorableAction.$type, StorableAction);
function createBaseStorableAction_MetadataEntry() {
  return { key: "", value: void 0 };
}
var StorableAction_MetadataEntry = {
  $type: "devvit.plugin.scheduler.StorableAction.MetadataEntry",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorableAction_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = Strings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet78(object.key) ? globalThis.String(object.key) : "",
      value: isSet78(object.value) ? Strings.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = Strings.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return StorableAction_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStorableAction_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Strings.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StorableAction_MetadataEntry.$type, StorableAction_MetadataEntry);
function createBaseListActionRequest() {
  return { before: void 0, after: void 0 };
}
var ListActionRequest = {
  $type: "devvit.plugin.scheduler.ListActionRequest",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.before !== void 0) {
      Timestamp.encode(toTimestamp13(message.before), writer.uint32(10).fork()).ldelim();
    }
    if (message.after !== void 0) {
      Timestamp.encode(toTimestamp13(message.after), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.before = fromTimestamp13(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.after = fromTimestamp13(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      before: isSet78(object.before) ? fromJsonTimestamp13(object.before) : void 0,
      after: isSet78(object.after) ? fromJsonTimestamp13(object.after) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.before !== void 0) {
      obj.before = message.before.toISOString();
    }
    if (message.after !== void 0) {
      obj.after = message.after.toISOString();
    }
    return obj;
  },
  create(base) {
    return ListActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListActionRequest();
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ListActionRequest.$type, ListActionRequest);
function createBaseGetActionResponse() {
  return { id: "", request: void 0 };
}
var GetActionResponse = {
  $type: "devvit.plugin.scheduler.GetActionResponse",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.request !== void 0) {
      ScheduledActionRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.request = ScheduledActionRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet78(object.id) ? globalThis.String(object.id) : "",
      request: isSet78(object.request) ? ScheduledActionRequest.fromJSON(object.request) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.request !== void 0) {
      obj.request = ScheduledActionRequest.toJSON(message.request);
    }
    return obj;
  },
  create(base) {
    return GetActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetActionResponse();
    message.id = object.id ?? "";
    message.request = object.request !== void 0 && object.request !== null ? ScheduledActionRequest.fromPartial(object.request) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetActionResponse.$type, GetActionResponse);
function createBaseListActionResponse() {
  return { actions: [] };
}
var ListActionResponse = {
  $type: "devvit.plugin.scheduler.ListActionResponse",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    for (const v of message.actions) {
      GetActionResponse.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : import_minimal83.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actions.push(GetActionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e) => GetActionResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => GetActionResponse.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ListActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListActionResponse();
    message.actions = object.actions?.map((e) => GetActionResponse.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ListActionResponse.$type, ListActionResponse);
function toTimestamp13(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp13(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp13(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp13(Timestamp.fromJSON(o));
  }
}
function isObject14(value) {
  return typeof value === "object" && value !== null;
}
function isSet78(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redis/redisapi.js
var import_long9 = __toESM(require_long(), 1);
var import_minimal84 = __toESM(require_minimal2(), 1);
var RedisKeyScope;
(function(RedisKeyScope2) {
  RedisKeyScope2[RedisKeyScope2["INSTALLATION"] = 0] = "INSTALLATION";
  RedisKeyScope2[RedisKeyScope2["GLOBAL"] = 1] = "GLOBAL";
  RedisKeyScope2[RedisKeyScope2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RedisKeyScope || (RedisKeyScope = {}));
function redisKeyScopeFromJSON(object) {
  switch (object) {
    case 0:
    case "INSTALLATION":
      return RedisKeyScope.INSTALLATION;
    case 1:
    case "GLOBAL":
      return RedisKeyScope.GLOBAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RedisKeyScope.UNRECOGNIZED;
  }
}
function redisKeyScopeToJSON(object) {
  switch (object) {
    case RedisKeyScope.INSTALLATION:
      return 0;
    case RedisKeyScope.GLOBAL:
      return 1;
    case RedisKeyScope.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseTransactionResponses() {
  return { response: [] };
}
var TransactionResponses = {
  $type: "devvit.plugin.redis.TransactionResponses",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.response) {
      TransactionResponse.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTransactionResponses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.response.push(TransactionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      response: globalThis.Array.isArray(object?.response) ? object.response.map((e) => TransactionResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.response?.length) {
      obj.response = message.response.map((e) => TransactionResponse.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return TransactionResponses.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionResponses();
    message.response = object.response?.map((e) => TransactionResponse.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(TransactionResponses.$type, TransactionResponses);
function createBaseTransactionResponse() {
  return { str: void 0, nil: void 0, num: void 0, members: void 0, values: void 0 };
}
var TransactionResponse = {
  $type: "devvit.plugin.redis.TransactionResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.str !== void 0) {
      StringValue.encode({ value: message.str }, writer.uint32(10).fork()).ldelim();
    }
    if (message.nil !== void 0) {
      Empty.encode(message.nil, writer.uint32(18).fork()).ldelim();
    }
    if (message.num !== void 0) {
      Int64Value.encode({ value: message.num }, writer.uint32(26).fork()).ldelim();
    }
    if (message.members !== void 0) {
      ZMembers.encode(message.members, writer.uint32(34).fork()).ldelim();
    }
    if (message.values !== void 0) {
      RedisValues.encode(message.values, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.str = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.nil = Empty.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.num = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.members = ZMembers.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.values = RedisValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      str: isSet79(object.str) ? String(object.str) : void 0,
      nil: isSet79(object.nil) ? Empty.fromJSON(object.nil) : void 0,
      num: isSet79(object.num) ? Number(object.num) : void 0,
      members: isSet79(object.members) ? ZMembers.fromJSON(object.members) : void 0,
      values: isSet79(object.values) ? RedisValues.fromJSON(object.values) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.str !== void 0) {
      obj.str = message.str;
    }
    if (message.nil !== void 0) {
      obj.nil = Empty.toJSON(message.nil);
    }
    if (message.num !== void 0) {
      obj.num = message.num;
    }
    if (message.members !== void 0) {
      obj.members = ZMembers.toJSON(message.members);
    }
    if (message.values !== void 0) {
      obj.values = RedisValues.toJSON(message.values);
    }
    return obj;
  },
  create(base) {
    return TransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionResponse();
    message.str = object.str ?? void 0;
    message.nil = object.nil !== void 0 && object.nil !== null ? Empty.fromPartial(object.nil) : void 0;
    message.num = object.num ?? void 0;
    message.members = object.members !== void 0 && object.members !== null ? ZMembers.fromPartial(object.members) : void 0;
    message.values = object.values !== void 0 && object.values !== null ? RedisValues.fromPartial(object.values) : void 0;
    return message;
  }
};
messageTypeRegistry.set(TransactionResponse.$type, TransactionResponse);
function createBaseZRangeRequest() {
  return {
    key: void 0,
    start: "",
    stop: "",
    byScore: false,
    byLex: false,
    rev: false,
    offset: 0,
    count: 0,
    scope: void 0
  };
}
var ZRangeRequest = {
  $type: "devvit.plugin.redis.ZRangeRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.start !== "") {
      writer.uint32(18).string(message.start);
    }
    if (message.stop !== "") {
      writer.uint32(26).string(message.stop);
    }
    if (message.byScore !== false) {
      writer.uint32(32).bool(message.byScore);
    }
    if (message.byLex !== false) {
      writer.uint32(40).bool(message.byLex);
    }
    if (message.rev !== false) {
      writer.uint32(48).bool(message.rev);
    }
    if (message.offset !== 0) {
      writer.uint32(56).int32(message.offset);
    }
    if (message.count !== 0) {
      writer.uint32(64).int32(message.count);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.start = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.stop = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.byScore = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.byLex = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.rev = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.offset = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.count = reader.int32();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      start: isSet79(object.start) ? globalThis.String(object.start) : "",
      stop: isSet79(object.stop) ? globalThis.String(object.stop) : "",
      byScore: isSet79(object.byScore) ? globalThis.Boolean(object.byScore) : false,
      byLex: isSet79(object.byLex) ? globalThis.Boolean(object.byLex) : false,
      rev: isSet79(object.rev) ? globalThis.Boolean(object.rev) : false,
      offset: isSet79(object.offset) ? globalThis.Number(object.offset) : 0,
      count: isSet79(object.count) ? globalThis.Number(object.count) : 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.start !== "") {
      obj.start = message.start;
    }
    if (message.stop !== "") {
      obj.stop = message.stop;
    }
    if (message.byScore !== false) {
      obj.byScore = message.byScore;
    }
    if (message.byLex !== false) {
      obj.byLex = message.byLex;
    }
    if (message.rev !== false) {
      obj.rev = message.rev;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRangeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRangeRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.start = object.start ?? "";
    message.stop = object.stop ?? "";
    message.byScore = object.byScore ?? false;
    message.byLex = object.byLex ?? false;
    message.rev = object.rev ?? false;
    message.offset = object.offset ?? 0;
    message.count = object.count ?? 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRangeRequest.$type, ZRangeRequest);
function createBaseZRangeByLexRequest() {
  return { key: void 0, min: "", max: "", scope: void 0 };
}
var ZRangeByLexRequest = {
  $type: "devvit.plugin.redis.ZRangeByLexRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.min !== "") {
      writer.uint32(18).string(message.min);
    }
    if (message.max !== "") {
      writer.uint32(26).string(message.max);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRangeByLexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.min = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.max = reader.string();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      min: isSet79(object.min) ? globalThis.String(object.min) : "",
      max: isSet79(object.max) ? globalThis.String(object.max) : "",
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.min !== "") {
      obj.min = message.min;
    }
    if (message.max !== "") {
      obj.max = message.max;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRangeByLexRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRangeByLexRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.min = object.min ?? "";
    message.max = object.max ?? "";
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRangeByLexRequest.$type, ZRangeByLexRequest);
function createBaseZRangeByScoreRequest() {
  return { key: void 0, min: 0, max: 0, withScores: false, scope: void 0 };
}
var ZRangeByScoreRequest = {
  $type: "devvit.plugin.redis.ZRangeByScoreRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.min !== 0) {
      writer.uint32(17).double(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(25).double(message.max);
    }
    if (message.withScores !== false) {
      writer.uint32(32).bool(message.withScores);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRangeByScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.min = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }
          message.max = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.withScores = reader.bool();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      min: isSet79(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet79(object.max) ? globalThis.Number(object.max) : 0,
      withScores: isSet79(object.withScores) ? globalThis.Boolean(object.withScores) : false,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.withScores !== false) {
      obj.withScores = message.withScores;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRangeByScoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRangeByScoreRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.withScores = object.withScores ?? false;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRangeByScoreRequest.$type, ZRangeByScoreRequest);
function createBaseZRemRequest() {
  return { key: void 0, members: [], scope: void 0 };
}
var ZRemRequest = {
  $type: "devvit.plugin.redis.ZRemRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.members) {
      writer.uint32(18).string(v);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.members.push(reader.string());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => globalThis.String(e)) : [],
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.members?.length) {
      obj.members = message.members;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRemRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRemRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.members = object.members?.map((e) => e) || [];
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRemRequest.$type, ZRemRequest);
function createBaseZRemRangeByLexRequest() {
  return { key: void 0, min: "", max: "", scope: void 0 };
}
var ZRemRangeByLexRequest = {
  $type: "devvit.plugin.redis.ZRemRangeByLexRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.min !== "") {
      writer.uint32(18).string(message.min);
    }
    if (message.max !== "") {
      writer.uint32(26).string(message.max);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRemRangeByLexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.min = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.max = reader.string();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      min: isSet79(object.min) ? globalThis.String(object.min) : "",
      max: isSet79(object.max) ? globalThis.String(object.max) : "",
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.min !== "") {
      obj.min = message.min;
    }
    if (message.max !== "") {
      obj.max = message.max;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRemRangeByLexRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRemRangeByLexRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.min = object.min ?? "";
    message.max = object.max ?? "";
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRemRangeByLexRequest.$type, ZRemRangeByLexRequest);
function createBaseZRemRangeByRankRequest() {
  return { key: void 0, start: 0, stop: 0, scope: void 0 };
}
var ZRemRangeByRankRequest = {
  $type: "devvit.plugin.redis.ZRemRangeByRankRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.start !== 0) {
      writer.uint32(16).int32(message.start);
    }
    if (message.stop !== 0) {
      writer.uint32(24).int32(message.stop);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRemRangeByRankRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.start = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.stop = reader.int32();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      start: isSet79(object.start) ? globalThis.Number(object.start) : 0,
      stop: isSet79(object.stop) ? globalThis.Number(object.stop) : 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.stop !== 0) {
      obj.stop = Math.round(message.stop);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRemRangeByRankRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRemRangeByRankRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.start = object.start ?? 0;
    message.stop = object.stop ?? 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRemRangeByRankRequest.$type, ZRemRangeByRankRequest);
function createBaseZRemRangeByScoreRequest() {
  return { key: void 0, min: 0, max: 0, scope: void 0 };
}
var ZRemRangeByScoreRequest = {
  $type: "devvit.plugin.redis.ZRemRangeByScoreRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.min !== 0) {
      writer.uint32(17).double(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(25).double(message.max);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRemRangeByScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.min = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }
          message.max = reader.double();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      min: isSet79(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet79(object.max) ? globalThis.Number(object.max) : 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRemRangeByScoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRemRangeByScoreRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRemRangeByScoreRequest.$type, ZRemRangeByScoreRequest);
function createBaseZScoreRequest() {
  return { key: void 0, member: "", scope: void 0 };
}
var ZScoreRequest = {
  $type: "devvit.plugin.redis.ZScoreRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.member = reader.string();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      member: isSet79(object.member) ? globalThis.String(object.member) : "",
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZScoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZScoreRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.member = object.member ?? "";
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZScoreRequest.$type, ZScoreRequest);
function createBaseZRankRequest() {
  return { key: void 0, member: "", scope: void 0 };
}
var ZRankRequest = {
  $type: "devvit.plugin.redis.ZRankRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== void 0) {
      KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZRankRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = KeyRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.member = reader.string();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? KeyRequest.fromJSON(object.key) : void 0,
      member: isSet79(object.member) ? globalThis.String(object.member) : "",
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== void 0) {
      obj.key = KeyRequest.toJSON(message.key);
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZRankRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZRankRequest();
    message.key = object.key !== void 0 && object.key !== null ? KeyRequest.fromPartial(object.key) : void 0;
    message.member = object.member ?? "";
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZRankRequest.$type, ZRankRequest);
function createBaseZIncrByRequest() {
  return { key: "", member: "", value: 0, transactionId: void 0, scope: void 0 };
}
var ZIncrByRequest = {
  $type: "devvit.plugin.redis.ZIncrByRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    if (message.value !== 0) {
      writer.uint32(25).double(message.value);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZIncrByRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.member = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }
          message.value = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      member: isSet79(object.member) ? globalThis.String(object.member) : "",
      value: isSet79(object.value) ? globalThis.Number(object.value) : 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZIncrByRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZIncrByRequest();
    message.key = object.key ?? "";
    message.member = object.member ?? "";
    message.value = object.value ?? 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZIncrByRequest.$type, ZIncrByRequest);
function createBaseKeyRequest() {
  return { key: "", transactionId: void 0, scope: void 0 };
}
var KeyRequest = {
  $type: "devvit.plugin.redis.KeyRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return KeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeyRequest();
    message.key = object.key ?? "";
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(KeyRequest.$type, KeyRequest);
function createBaseIncrByRequest() {
  return { key: "", value: 0, transactionId: void 0, scope: void 0 };
}
var IncrByRequest = {
  $type: "devvit.plugin.redis.IncrByRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int64(message.value);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIncrByRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.value = longToNumber9(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      value: isSet79(object.value) ? globalThis.Number(object.value) : 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return IncrByRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseIncrByRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(IncrByRequest.$type, IncrByRequest);
function createBaseSetRequest() {
  return { key: "", value: "", expiration: 0, nx: false, xx: false, transactionId: void 0, scope: void 0 };
}
var SetRequest = {
  $type: "devvit.plugin.redis.SetRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.expiration !== 0) {
      writer.uint32(24).int64(message.expiration);
    }
    if (message.nx !== false) {
      writer.uint32(32).bool(message.nx);
    }
    if (message.xx !== false) {
      writer.uint32(40).bool(message.xx);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.expiration = longToNumber9(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.nx = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.xx = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      value: isSet79(object.value) ? globalThis.String(object.value) : "",
      expiration: isSet79(object.expiration) ? globalThis.Number(object.expiration) : 0,
      nx: isSet79(object.nx) ? globalThis.Boolean(object.nx) : false,
      xx: isSet79(object.xx) ? globalThis.Boolean(object.xx) : false,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.expiration !== 0) {
      obj.expiration = Math.round(message.expiration);
    }
    if (message.nx !== false) {
      obj.nx = message.nx;
    }
    if (message.xx !== false) {
      obj.xx = message.xx;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return SetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.expiration = object.expiration ?? 0;
    message.nx = object.nx ?? false;
    message.xx = object.xx ?? false;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SetRequest.$type, SetRequest);
function createBaseKeyRangeRequest() {
  return { key: "", start: 0, end: 0, transactionId: void 0, scope: void 0 };
}
var KeyRangeRequest = {
  $type: "devvit.plugin.redis.KeyRangeRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.start !== 0) {
      writer.uint32(16).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(24).int32(message.end);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeyRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.start = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.end = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      start: isSet79(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet79(object.end) ? globalThis.Number(object.end) : 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return KeyRangeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeyRangeRequest();
    message.key = object.key ?? "";
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(KeyRangeRequest.$type, KeyRangeRequest);
function createBaseSetRangeRequest() {
  return { key: "", offset: 0, value: "", transactionId: void 0, scope: void 0 };
}
var SetRangeRequest = {
  $type: "devvit.plugin.redis.SetRangeRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.offset = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      offset: isSet79(object.offset) ? globalThis.Number(object.offset) : 0,
      value: isSet79(object.value) ? globalThis.String(object.value) : "",
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return SetRangeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetRangeRequest();
    message.key = object.key ?? "";
    message.offset = object.offset ?? 0;
    message.value = object.value ?? "";
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SetRangeRequest.$type, SetRangeRequest);
function createBaseKeysRequest() {
  return { keys: [], transactionId: void 0, scope: void 0 };
}
var KeysRequest = {
  $type: "devvit.plugin.redis.KeysRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.keys) {
      writer.uint32(10).string(v);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.keys.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : [],
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return KeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeysRequest();
    message.keys = object.keys?.map((e) => e) || [];
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(KeysRequest.$type, KeysRequest);
function createBaseKeysResponse() {
  return { keys: [] };
}
var KeysResponse = {
  $type: "devvit.plugin.redis.KeysResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.keys) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.keys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },
  create(base) {
    return KeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeysResponse();
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(KeysResponse.$type, KeysResponse);
function createBaseHGetRequest() {
  return { key: "", field: "", transactionId: void 0, scope: void 0 };
}
var HGetRequest = {
  $type: "devvit.plugin.redis.HGetRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.field !== "") {
      writer.uint32(18).string(message.field);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.field = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      field: isSet79(object.field) ? globalThis.String(object.field) : "",
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return HGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHGetRequest();
    message.key = object.key ?? "";
    message.field = object.field ?? "";
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(HGetRequest.$type, HGetRequest);
function createBaseHSetRequest() {
  return { key: "", fv: [], transactionId: void 0, scope: void 0 };
}
var HSetRequest = {
  $type: "devvit.plugin.redis.HSetRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.fv) {
      RedisFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fv.push(RedisFieldValue.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      fv: globalThis.Array.isArray(object?.fv) ? object.fv.map((e) => RedisFieldValue.fromJSON(e)) : [],
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.fv?.length) {
      obj.fv = message.fv.map((e) => RedisFieldValue.toJSON(e));
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return HSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHSetRequest();
    message.key = object.key ?? "";
    message.fv = object.fv?.map((e) => RedisFieldValue.fromPartial(e)) || [];
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(HSetRequest.$type, HSetRequest);
function createBaseHDelRequest() {
  return { key: "", fields: [], transactionId: void 0, scope: void 0 };
}
var HDelRequest = {
  $type: "devvit.plugin.redis.HDelRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.fields) {
      writer.uint32(18).string(v);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHDelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fields.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => globalThis.String(e)) : [],
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return HDelRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHDelRequest();
    message.key = object.key ?? "";
    message.fields = object.fields?.map((e) => e) || [];
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(HDelRequest.$type, HDelRequest);
function createBaseHScanRequest() {
  return { key: "", cursor: 0, pattern: void 0, count: void 0, transactionId: void 0, scope: void 0 };
}
var HScanRequest = {
  $type: "devvit.plugin.redis.HScanRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.cursor !== 0) {
      writer.uint32(16).uint64(message.cursor);
    }
    if (message.pattern !== void 0) {
      writer.uint32(26).string(message.pattern);
    }
    if (message.count !== void 0) {
      writer.uint32(32).int64(message.count);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(42).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHScanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.cursor = longToNumber9(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.pattern = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.count = longToNumber9(reader.int64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      cursor: isSet79(object.cursor) ? globalThis.Number(object.cursor) : 0,
      pattern: isSet79(object.pattern) ? globalThis.String(object.pattern) : void 0,
      count: isSet79(object.count) ? globalThis.Number(object.count) : void 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.cursor !== 0) {
      obj.cursor = Math.round(message.cursor);
    }
    if (message.pattern !== void 0) {
      obj.pattern = message.pattern;
    }
    if (message.count !== void 0) {
      obj.count = Math.round(message.count);
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return HScanRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHScanRequest();
    message.key = object.key ?? "";
    message.cursor = object.cursor ?? 0;
    message.pattern = object.pattern ?? void 0;
    message.count = object.count ?? void 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(HScanRequest.$type, HScanRequest);
function createBaseHScanResponse() {
  return { cursor: 0, fieldValues: [] };
}
var HScanResponse = {
  $type: "devvit.plugin.redis.HScanResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.cursor !== 0) {
      writer.uint32(8).uint64(message.cursor);
    }
    for (const v of message.fieldValues) {
      RedisFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHScanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.cursor = longToNumber9(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fieldValues.push(RedisFieldValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cursor: isSet79(object.cursor) ? globalThis.Number(object.cursor) : 0,
      fieldValues: globalThis.Array.isArray(object?.fieldValues) ? object.fieldValues.map((e) => RedisFieldValue.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cursor !== 0) {
      obj.cursor = Math.round(message.cursor);
    }
    if (message.fieldValues?.length) {
      obj.fieldValues = message.fieldValues.map((e) => RedisFieldValue.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return HScanResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHScanResponse();
    message.cursor = object.cursor ?? 0;
    message.fieldValues = object.fieldValues?.map((e) => RedisFieldValue.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(HScanResponse.$type, HScanResponse);
function createBaseHIncrByRequest() {
  return { key: "", field: "", value: 0, transactionId: void 0, scope: void 0 };
}
var HIncrByRequest = {
  $type: "devvit.plugin.redis.HIncrByRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.field !== "") {
      writer.uint32(18).string(message.field);
    }
    if (message.value !== 0) {
      writer.uint32(24).int64(message.value);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHIncrByRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.field = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.value = longToNumber9(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      field: isSet79(object.field) ? globalThis.String(object.field) : "",
      value: isSet79(object.value) ? globalThis.Number(object.value) : 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return HIncrByRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHIncrByRequest();
    message.key = object.key ?? "";
    message.field = object.field ?? "";
    message.value = object.value ?? 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(HIncrByRequest.$type, HIncrByRequest);
function createBaseRedisFieldValue() {
  return { field: "", value: "" };
}
var RedisFieldValue = {
  $type: "devvit.plugin.redis.RedisFieldValue",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedisFieldValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      field: isSet79(object.field) ? globalThis.String(object.field) : "",
      value: isSet79(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return RedisFieldValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedisFieldValue();
    message.field = object.field ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(RedisFieldValue.$type, RedisFieldValue);
function createBaseRedisFieldValues() {
  return { fieldValues: {} };
}
var RedisFieldValues = {
  $type: "devvit.plugin.redis.RedisFieldValues",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    Object.entries(message.fieldValues).forEach(([key, value]) => {
      RedisFieldValues_FieldValuesEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedisFieldValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = RedisFieldValues_FieldValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.fieldValues[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldValues: isObject15(object.fieldValues) ? Object.entries(object.fieldValues).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fieldValues) {
      const entries = Object.entries(message.fieldValues);
      if (entries.length > 0) {
        obj.fieldValues = {};
        entries.forEach(([k, v]) => {
          obj.fieldValues[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return RedisFieldValues.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedisFieldValues();
    message.fieldValues = Object.entries(object.fieldValues ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(RedisFieldValues.$type, RedisFieldValues);
function createBaseRedisFieldValues_FieldValuesEntry() {
  return { key: "", value: "" };
}
var RedisFieldValues_FieldValuesEntry = {
  $type: "devvit.plugin.redis.RedisFieldValues.FieldValuesEntry",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedisFieldValues_FieldValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      value: isSet79(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return RedisFieldValues_FieldValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedisFieldValues_FieldValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(RedisFieldValues_FieldValuesEntry.$type, RedisFieldValues_FieldValuesEntry);
function createBaseKeyValuesRequest() {
  return { kv: [], transactionId: void 0, scope: void 0 };
}
var KeyValuesRequest = {
  $type: "devvit.plugin.redis.KeyValuesRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.kv) {
      RedisKeyValue.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeyValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kv.push(RedisKeyValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kv: globalThis.Array.isArray(object?.kv) ? object.kv.map((e) => RedisKeyValue.fromJSON(e)) : [],
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kv?.length) {
      obj.kv = message.kv.map((e) => RedisKeyValue.toJSON(e));
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return KeyValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeyValuesRequest();
    message.kv = object.kv?.map((e) => RedisKeyValue.fromPartial(e)) || [];
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(KeyValuesRequest.$type, KeyValuesRequest);
function createBaseRedisKeyValue() {
  return { key: "", value: "" };
}
var RedisKeyValue = {
  $type: "devvit.plugin.redis.RedisKeyValue",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedisKeyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      value: isSet79(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return RedisKeyValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedisKeyValue();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(RedisKeyValue.$type, RedisKeyValue);
function createBaseRedisValues() {
  return { values: [] };
}
var RedisValues = {
  $type: "devvit.plugin.redis.RedisValues",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.values) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedisValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.values.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return RedisValues.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRedisValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(RedisValues.$type, RedisValues);
function createBaseExpireRequest() {
  return { key: "", seconds: 0, transactionId: void 0, scope: void 0 };
}
var ExpireRequest = {
  $type: "devvit.plugin.redis.ExpireRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.seconds !== 0) {
      writer.uint32(16).int32(message.seconds);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExpireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.seconds = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      seconds: isSet79(object.seconds) ? globalThis.Number(object.seconds) : 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ExpireRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseExpireRequest();
    message.key = object.key ?? "";
    message.seconds = object.seconds ?? 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ExpireRequest.$type, ExpireRequest);
function createBaseZAddRequest() {
  return { key: "", members: [], transactionId: void 0, scope: void 0 };
}
var ZAddRequest = {
  $type: "devvit.plugin.redis.ZAddRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.members) {
      ZMember.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZAddRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.members.push(ZMember.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : [],
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.members?.length) {
      obj.members = message.members.map((e) => ZMember.toJSON(e));
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZAddRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZAddRequest();
    message.key = object.key ?? "";
    message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZAddRequest.$type, ZAddRequest);
function createBaseZScanRequest() {
  return { key: "", cursor: 0, pattern: void 0, count: void 0, transactionId: void 0, scope: void 0 };
}
var ZScanRequest = {
  $type: "devvit.plugin.redis.ZScanRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.cursor !== 0) {
      writer.uint32(16).uint64(message.cursor);
    }
    if (message.pattern !== void 0) {
      writer.uint32(26).string(message.pattern);
    }
    if (message.count !== void 0) {
      writer.uint32(32).int64(message.count);
    }
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(42).fork()).ldelim();
    }
    if (message.scope !== void 0) {
      writer.uint32(800).int32(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZScanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.cursor = longToNumber9(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.pattern = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.count = longToNumber9(reader.int64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }
          message.scope = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet79(object.key) ? globalThis.String(object.key) : "",
      cursor: isSet79(object.cursor) ? globalThis.Number(object.cursor) : 0,
      pattern: isSet79(object.pattern) ? globalThis.String(object.pattern) : void 0,
      count: isSet79(object.count) ? globalThis.Number(object.count) : void 0,
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      scope: isSet79(object.scope) ? redisKeyScopeFromJSON(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.cursor !== 0) {
      obj.cursor = Math.round(message.cursor);
    }
    if (message.pattern !== void 0) {
      obj.pattern = message.pattern;
    }
    if (message.count !== void 0) {
      obj.count = Math.round(message.count);
    }
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.scope !== void 0) {
      obj.scope = redisKeyScopeToJSON(message.scope);
    }
    return obj;
  },
  create(base) {
    return ZScanRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZScanRequest();
    message.key = object.key ?? "";
    message.cursor = object.cursor ?? 0;
    message.pattern = object.pattern ?? void 0;
    message.count = object.count ?? void 0;
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ZScanRequest.$type, ZScanRequest);
function createBaseZScanResponse() {
  return { cursor: 0, members: [] };
}
var ZScanResponse = {
  $type: "devvit.plugin.redis.ZScanResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.cursor !== 0) {
      writer.uint32(8).uint64(message.cursor);
    }
    for (const v of message.members) {
      ZMember.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZScanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.cursor = longToNumber9(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.members.push(ZMember.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cursor: isSet79(object.cursor) ? globalThis.Number(object.cursor) : 0,
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cursor !== 0) {
      obj.cursor = Math.round(message.cursor);
    }
    if (message.members?.length) {
      obj.members = message.members.map((e) => ZMember.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ZScanResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZScanResponse();
    message.cursor = object.cursor ?? 0;
    message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ZScanResponse.$type, ZScanResponse);
function createBaseZMembers() {
  return { members: [] };
}
var ZMembers = {
  $type: "devvit.plugin.redis.ZMembers",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.members) {
      ZMember.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZMembers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.members.push(ZMember.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => ZMember.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ZMembers.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZMembers();
    message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ZMembers.$type, ZMembers);
function createBaseZMember() {
  return { score: 0, member: "" };
}
var ZMember = {
  $type: "devvit.plugin.redis.ZMember",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.score !== 0) {
      writer.uint32(9).double(message.score);
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseZMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }
          message.score = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.member = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      score: isSet79(object.score) ? globalThis.Number(object.score) : 0,
      member: isSet79(object.member) ? globalThis.String(object.member) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    return obj;
  },
  create(base) {
    return ZMember.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseZMember();
    message.score = object.score ?? 0;
    message.member = object.member ?? "";
    return message;
  }
};
messageTypeRegistry.set(ZMember.$type, ZMember);
function createBaseTransactionId() {
  return { id: "" };
}
var TransactionId = {
  $type: "devvit.plugin.redis.TransactionId",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTransactionId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet79(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return TransactionId.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionId();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(TransactionId.$type, TransactionId);
function createBaseWatchRequest() {
  return { transactionId: void 0, keys: [] };
}
var WatchRequest = {
  $type: "devvit.plugin.redis.WatchRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.transactionId !== void 0) {
      TransactionId.encode(message.transactionId, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.keys) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : import_minimal84.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.keys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      transactionId: isSet79(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : void 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.transactionId !== void 0) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },
  create(base) {
    return WatchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWatchRequest();
    message.transactionId = object.transactionId !== void 0 && object.transactionId !== null ? TransactionId.fromPartial(object.transactionId) : void 0;
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(WatchRequest.$type, WatchRequest);
function longToNumber9(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal84.default.util.Long !== import_long9.default) {
  import_minimal84.default.util.Long = import_long9.default;
  import_minimal84.default.configure();
}
function isObject15(value) {
  return typeof value === "object" && value !== null;
}
function isSet79(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapiv2/redditapiv2.js
var import_minimal87 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/flair/flair_msg.js
var import_long10 = __toESM(require_long(), 1);
var import_minimal85 = __toESM(require_minimal2(), 1);
function createBaseClearFlairTemplatesRequest() {
  return { subreddit: "", flairType: "" };
}
var ClearFlairTemplatesRequest = {
  $type: "devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairType !== "") {
      writer.uint32(18).string(message.flairType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearFlairTemplatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.flairType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      flairType: isSet80(object.flairType) ? globalThis.String(object.flairType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.flairType !== "") {
      obj.flairType = message.flairType;
    }
    return obj;
  },
  create(base) {
    return ClearFlairTemplatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClearFlairTemplatesRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairType = object.flairType ?? "";
    return message;
  }
};
messageTypeRegistry.set(ClearFlairTemplatesRequest.$type, ClearFlairTemplatesRequest);
function createBaseDeleteFlairRequest() {
  return { subreddit: "", name: "" };
}
var DeleteFlairRequest = {
  $type: "devvit.plugin.redditapi.flair.DeleteFlairRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      name: isSet80(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return DeleteFlairRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteFlairRequest();
    message.subreddit = object.subreddit ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(DeleteFlairRequest.$type, DeleteFlairRequest);
function createBaseDeleteFlairTemplateRequest() {
  return { subreddit: "", flairTemplateId: "" };
}
var DeleteFlairTemplateRequest = {
  $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairTemplateId !== "") {
      writer.uint32(18).string(message.flairTemplateId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlairTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.flairTemplateId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      flairTemplateId: isSet80(object.flairTemplateId) ? globalThis.String(object.flairTemplateId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.flairTemplateId !== "") {
      obj.flairTemplateId = message.flairTemplateId;
    }
    return obj;
  },
  create(base) {
    return DeleteFlairTemplateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteFlairTemplateRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairTemplateId = object.flairTemplateId ?? "";
    return message;
  }
};
messageTypeRegistry.set(DeleteFlairTemplateRequest.$type, DeleteFlairTemplateRequest);
function createBaseFlairRequest() {
  return { subreddit: "", cssClass: void 0, link: void 0, name: void 0, text: void 0 };
}
var FlairRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.cssClass !== void 0) {
      StringValue.encode({ value: message.cssClass }, writer.uint32(18).fork()).ldelim();
    }
    if (message.link !== void 0) {
      StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.cssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.link = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      cssClass: isSet80(object.cssClass) ? String(object.cssClass) : void 0,
      link: isSet80(object.link) ? String(object.link) : void 0,
      name: isSet80(object.name) ? String(object.name) : void 0,
      text: isSet80(object.text) ? String(object.text) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.cssClass !== void 0) {
      obj.cssClass = message.cssClass;
    }
    if (message.link !== void 0) {
      obj.link = message.link;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return FlairRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairRequest();
    message.subreddit = object.subreddit ?? "";
    message.cssClass = object.cssClass ?? void 0;
    message.link = object.link ?? void 0;
    message.name = object.name ?? void 0;
    message.text = object.text ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairRequest.$type, FlairRequest);
function createBaseFlairTemplateOrderRequest() {
  return { subreddit: "", flairType: "", order: [] };
}
var FlairTemplateOrderRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairTemplateOrderRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairType !== "") {
      writer.uint32(18).string(message.flairType);
    }
    for (const v of message.order) {
      writer.uint32(26).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairTemplateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.flairType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.order.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      flairType: isSet80(object.flairType) ? globalThis.String(object.flairType) : "",
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.flairType !== "") {
      obj.flairType = message.flairType;
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    return obj;
  },
  create(base) {
    return FlairTemplateOrderRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairTemplateOrderRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairType = object.flairType ?? "";
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(FlairTemplateOrderRequest.$type, FlairTemplateOrderRequest);
function createBaseFlairConfigRequest() {
  return {
    subreddit: "",
    flairEnabled: false,
    flairPosition: "",
    flairSelfAssignEnabled: false,
    linkFlairPosition: "",
    linkFlairSelfAssignEnabled: false
  };
}
var FlairConfigRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairConfigRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairEnabled !== false) {
      writer.uint32(16).bool(message.flairEnabled);
    }
    if (message.flairPosition !== "") {
      writer.uint32(26).string(message.flairPosition);
    }
    if (message.flairSelfAssignEnabled !== false) {
      writer.uint32(32).bool(message.flairSelfAssignEnabled);
    }
    if (message.linkFlairPosition !== "") {
      writer.uint32(42).string(message.linkFlairPosition);
    }
    if (message.linkFlairSelfAssignEnabled !== false) {
      writer.uint32(48).bool(message.linkFlairSelfAssignEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.flairEnabled = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.flairPosition = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.flairSelfAssignEnabled = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.linkFlairPosition = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.linkFlairSelfAssignEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      flairEnabled: isSet80(object.flairEnabled) ? globalThis.Boolean(object.flairEnabled) : false,
      flairPosition: isSet80(object.flairPosition) ? globalThis.String(object.flairPosition) : "",
      flairSelfAssignEnabled: isSet80(object.flairSelfAssignEnabled) ? globalThis.Boolean(object.flairSelfAssignEnabled) : false,
      linkFlairPosition: isSet80(object.linkFlairPosition) ? globalThis.String(object.linkFlairPosition) : "",
      linkFlairSelfAssignEnabled: isSet80(object.linkFlairSelfAssignEnabled) ? globalThis.Boolean(object.linkFlairSelfAssignEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.flairEnabled !== false) {
      obj.flairEnabled = message.flairEnabled;
    }
    if (message.flairPosition !== "") {
      obj.flairPosition = message.flairPosition;
    }
    if (message.flairSelfAssignEnabled !== false) {
      obj.flairSelfAssignEnabled = message.flairSelfAssignEnabled;
    }
    if (message.linkFlairPosition !== "") {
      obj.linkFlairPosition = message.linkFlairPosition;
    }
    if (message.linkFlairSelfAssignEnabled !== false) {
      obj.linkFlairSelfAssignEnabled = message.linkFlairSelfAssignEnabled;
    }
    return obj;
  },
  create(base) {
    return FlairConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairConfigRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairEnabled = object.flairEnabled ?? false;
    message.flairPosition = object.flairPosition ?? "";
    message.flairSelfAssignEnabled = object.flairSelfAssignEnabled ?? false;
    message.linkFlairPosition = object.linkFlairPosition ?? "";
    message.linkFlairSelfAssignEnabled = object.linkFlairSelfAssignEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set(FlairConfigRequest.$type, FlairConfigRequest);
function createBaseFlairCsvRequest() {
  return { subreddit: "", flairCsv: "" };
}
var FlairCsvRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairCsv !== "") {
      writer.uint32(18).string(message.flairCsv);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.flairCsv = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      flairCsv: isSet80(object.flairCsv) ? globalThis.String(object.flairCsv) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.flairCsv !== "") {
      obj.flairCsv = message.flairCsv;
    }
    return obj;
  },
  create(base) {
    return FlairCsvRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairCsvRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairCsv = object.flairCsv ?? "";
    return message;
  }
};
messageTypeRegistry.set(FlairCsvRequest.$type, FlairCsvRequest);
function createBaseFlairListRequest() {
  return {
    subreddit: "",
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    name: void 0,
    show: void 0
  };
}
var FlairListRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairListRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      after: isSet80(object.after) ? String(object.after) : void 0,
      before: isSet80(object.before) ? String(object.before) : void 0,
      count: isSet80(object.count) ? Number(object.count) : void 0,
      limit: isSet80(object.limit) ? Number(object.limit) : void 0,
      name: isSet80(object.name) ? String(object.name) : void 0,
      show: isSet80(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    return obj;
  },
  create(base) {
    return FlairListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairListRequest();
    message.subreddit = object.subreddit ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.name = object.name ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairListRequest.$type, FlairListRequest);
function createBaseFlairSelectorRequest() {
  return { subreddit: "", isNewlink: false, link: void 0, name: "" };
}
var FlairSelectorRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairSelectorRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.isNewlink !== false) {
      writer.uint32(16).bool(message.isNewlink);
    }
    if (message.link !== void 0) {
      StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairSelectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.isNewlink = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.link = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      isNewlink: isSet80(object.isNewlink) ? globalThis.Boolean(object.isNewlink) : false,
      link: isSet80(object.link) ? String(object.link) : void 0,
      name: isSet80(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.isNewlink !== false) {
      obj.isNewlink = message.isNewlink;
    }
    if (message.link !== void 0) {
      obj.link = message.link;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return FlairSelectorRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairSelectorRequest();
    message.subreddit = object.subreddit ?? "";
    message.isNewlink = object.isNewlink ?? false;
    message.link = object.link ?? void 0;
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(FlairSelectorRequest.$type, FlairSelectorRequest);
function createBaseFlairTemplateRequest() {
  return {
    subreddit: "",
    allowableContent: "",
    backgroundColor: "",
    cssClass: "",
    flairTemplateId: "",
    flairType: "",
    maxEmojis: 0,
    modOnly: false,
    overrideCss: false,
    text: "",
    textColor: "",
    textEditable: false
  };
}
var FlairTemplateRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairTemplateRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.allowableContent !== "") {
      writer.uint32(18).string(message.allowableContent);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(26).string(message.backgroundColor);
    }
    if (message.cssClass !== "") {
      writer.uint32(34).string(message.cssClass);
    }
    if (message.flairTemplateId !== "") {
      writer.uint32(42).string(message.flairTemplateId);
    }
    if (message.flairType !== "") {
      writer.uint32(50).string(message.flairType);
    }
    if (message.maxEmojis !== 0) {
      writer.uint32(56).int64(message.maxEmojis);
    }
    if (message.modOnly !== false) {
      writer.uint32(64).bool(message.modOnly);
    }
    if (message.overrideCss !== false) {
      writer.uint32(72).bool(message.overrideCss);
    }
    if (message.text !== "") {
      writer.uint32(82).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(90).string(message.textColor);
    }
    if (message.textEditable !== false) {
      writer.uint32(96).bool(message.textEditable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.allowableContent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.cssClass = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.flairTemplateId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.flairType = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.maxEmojis = longToNumber10(reader.int64());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.modOnly = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.overrideCss = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.text = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.textColor = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }
          message.textEditable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      allowableContent: isSet80(object.allowableContent) ? globalThis.String(object.allowableContent) : "",
      backgroundColor: isSet80(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
      cssClass: isSet80(object.cssClass) ? globalThis.String(object.cssClass) : "",
      flairTemplateId: isSet80(object.flairTemplateId) ? globalThis.String(object.flairTemplateId) : "",
      flairType: isSet80(object.flairType) ? globalThis.String(object.flairType) : "",
      maxEmojis: isSet80(object.maxEmojis) ? globalThis.Number(object.maxEmojis) : 0,
      modOnly: isSet80(object.modOnly) ? globalThis.Boolean(object.modOnly) : false,
      overrideCss: isSet80(object.overrideCss) ? globalThis.Boolean(object.overrideCss) : false,
      text: isSet80(object.text) ? globalThis.String(object.text) : "",
      textColor: isSet80(object.textColor) ? globalThis.String(object.textColor) : "",
      textEditable: isSet80(object.textEditable) ? globalThis.Boolean(object.textEditable) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.allowableContent !== "") {
      obj.allowableContent = message.allowableContent;
    }
    if (message.backgroundColor !== "") {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.cssClass !== "") {
      obj.cssClass = message.cssClass;
    }
    if (message.flairTemplateId !== "") {
      obj.flairTemplateId = message.flairTemplateId;
    }
    if (message.flairType !== "") {
      obj.flairType = message.flairType;
    }
    if (message.maxEmojis !== 0) {
      obj.maxEmojis = Math.round(message.maxEmojis);
    }
    if (message.modOnly !== false) {
      obj.modOnly = message.modOnly;
    }
    if (message.overrideCss !== false) {
      obj.overrideCss = message.overrideCss;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.textEditable !== false) {
      obj.textEditable = message.textEditable;
    }
    return obj;
  },
  create(base) {
    return FlairTemplateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairTemplateRequest();
    message.subreddit = object.subreddit ?? "";
    message.allowableContent = object.allowableContent ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.cssClass = object.cssClass ?? "";
    message.flairTemplateId = object.flairTemplateId ?? "";
    message.flairType = object.flairType ?? "";
    message.maxEmojis = object.maxEmojis ?? 0;
    message.modOnly = object.modOnly ?? false;
    message.overrideCss = object.overrideCss ?? false;
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    message.textEditable = object.textEditable ?? false;
    return message;
  }
};
messageTypeRegistry.set(FlairTemplateRequest.$type, FlairTemplateRequest);
function createBaseLinkFlairRequest() {
  return { subreddit: "" };
}
var LinkFlairRequest = {
  $type: "devvit.plugin.redditapi.flair.LinkFlairRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return LinkFlairRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLinkFlairRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(LinkFlairRequest.$type, LinkFlairRequest);
function createBaseSelectFlairRequest() {
  return {
    subreddit: "",
    backgroundColor: "",
    cssClass: "",
    flairTemplateId: "",
    link: "",
    name: "",
    returnRtjson: "",
    text: "",
    textColor: ""
  };
}
var SelectFlairRequest = {
  $type: "devvit.plugin.redditapi.flair.SelectFlairRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(18).string(message.backgroundColor);
    }
    if (message.cssClass !== "") {
      writer.uint32(26).string(message.cssClass);
    }
    if (message.flairTemplateId !== "") {
      writer.uint32(34).string(message.flairTemplateId);
    }
    if (message.link !== "") {
      writer.uint32(42).string(message.link);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.returnRtjson !== "") {
      writer.uint32(58).string(message.returnRtjson);
    }
    if (message.text !== "") {
      writer.uint32(66).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(74).string(message.textColor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSelectFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.cssClass = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.flairTemplateId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.link = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.returnRtjson = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.text = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.textColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      backgroundColor: isSet80(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
      cssClass: isSet80(object.cssClass) ? globalThis.String(object.cssClass) : "",
      flairTemplateId: isSet80(object.flairTemplateId) ? globalThis.String(object.flairTemplateId) : "",
      link: isSet80(object.link) ? globalThis.String(object.link) : "",
      name: isSet80(object.name) ? globalThis.String(object.name) : "",
      returnRtjson: isSet80(object.returnRtjson) ? globalThis.String(object.returnRtjson) : "",
      text: isSet80(object.text) ? globalThis.String(object.text) : "",
      textColor: isSet80(object.textColor) ? globalThis.String(object.textColor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.backgroundColor !== "") {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.cssClass !== "") {
      obj.cssClass = message.cssClass;
    }
    if (message.flairTemplateId !== "") {
      obj.flairTemplateId = message.flairTemplateId;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.returnRtjson !== "") {
      obj.returnRtjson = message.returnRtjson;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    return obj;
  },
  create(base) {
    return SelectFlairRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSelectFlairRequest();
    message.subreddit = object.subreddit ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.cssClass = object.cssClass ?? "";
    message.flairTemplateId = object.flairTemplateId ?? "";
    message.link = object.link ?? "";
    message.name = object.name ?? "";
    message.returnRtjson = object.returnRtjson ?? "";
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    return message;
  }
};
messageTypeRegistry.set(SelectFlairRequest.$type, SelectFlairRequest);
function createBaseSetFlairEnabledRequest() {
  return { subreddit: "", flairEnabled: false };
}
var SetFlairEnabledRequest = {
  $type: "devvit.plugin.redditapi.flair.SetFlairEnabledRequest",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairEnabled !== false) {
      writer.uint32(16).bool(message.flairEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetFlairEnabledRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.flairEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet80(object.subreddit) ? globalThis.String(object.subreddit) : "",
      flairEnabled: isSet80(object.flairEnabled) ? globalThis.Boolean(object.flairEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.flairEnabled !== false) {
      obj.flairEnabled = message.flairEnabled;
    }
    return obj;
  },
  create(base) {
    return SetFlairEnabledRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetFlairEnabledRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairEnabled = object.flairEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set(SetFlairEnabledRequest.$type, SetFlairEnabledRequest);
function createBaseFlairObject() {
  return {
    allowableContent: void 0,
    text: void 0,
    textColor: void 0,
    modOnly: false,
    backgroundColor: void 0,
    id: void 0,
    cssClass: void 0,
    maxEmojis: 0,
    richtext: [],
    textEditable: false,
    overrideCss: false,
    type: void 0,
    flairType: void 0
  };
}
var FlairObject = {
  $type: "devvit.plugin.redditapi.flair.FlairObject",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.allowableContent !== void 0) {
      StringValue.encode({ value: message.allowableContent }, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(18).fork()).ldelim();
    }
    if (message.textColor !== void 0) {
      StringValue.encode({ value: message.textColor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.modOnly !== false) {
      writer.uint32(32).bool(message.modOnly);
    }
    if (message.backgroundColor !== void 0) {
      StringValue.encode({ value: message.backgroundColor }, writer.uint32(42).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
    }
    if (message.cssClass !== void 0) {
      StringValue.encode({ value: message.cssClass }, writer.uint32(58).fork()).ldelim();
    }
    if (message.maxEmojis !== 0) {
      writer.uint32(64).int64(message.maxEmojis);
    }
    for (const v of message.richtext) {
      StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
    }
    if (message.textEditable !== false) {
      writer.uint32(80).bool(message.textEditable);
    }
    if (message.overrideCss !== false) {
      writer.uint32(88).bool(message.overrideCss);
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
    }
    if (message.flairType !== void 0) {
      StringValue.encode({ value: message.flairType }, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.allowableContent = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.textColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.modOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.cssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.maxEmojis = longToNumber10(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.richtext.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.textEditable = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.overrideCss = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.type = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.flairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowableContent: isSet80(object.allowableContent) ? String(object.allowableContent) : void 0,
      text: isSet80(object.text) ? String(object.text) : void 0,
      textColor: isSet80(object.textColor) ? String(object.textColor) : void 0,
      modOnly: isSet80(object.modOnly) ? globalThis.Boolean(object.modOnly) : false,
      backgroundColor: isSet80(object.backgroundColor) ? String(object.backgroundColor) : void 0,
      id: isSet80(object.id) ? String(object.id) : void 0,
      cssClass: isSet80(object.cssClass) ? String(object.cssClass) : void 0,
      maxEmojis: isSet80(object.maxEmojis) ? globalThis.Number(object.maxEmojis) : 0,
      richtext: globalThis.Array.isArray(object?.richtext) ? object.richtext.map((e) => String(e)) : [],
      textEditable: isSet80(object.textEditable) ? globalThis.Boolean(object.textEditable) : false,
      overrideCss: isSet80(object.overrideCss) ? globalThis.Boolean(object.overrideCss) : false,
      type: isSet80(object.type) ? String(object.type) : void 0,
      flairType: isSet80(object.flairType) ? String(object.flairType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allowableContent !== void 0) {
      obj.allowableContent = message.allowableContent;
    }
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.textColor !== void 0) {
      obj.textColor = message.textColor;
    }
    if (message.modOnly !== false) {
      obj.modOnly = message.modOnly;
    }
    if (message.backgroundColor !== void 0) {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.cssClass !== void 0) {
      obj.cssClass = message.cssClass;
    }
    if (message.maxEmojis !== 0) {
      obj.maxEmojis = Math.round(message.maxEmojis);
    }
    if (message.richtext?.length) {
      obj.richtext = message.richtext;
    }
    if (message.textEditable !== false) {
      obj.textEditable = message.textEditable;
    }
    if (message.overrideCss !== false) {
      obj.overrideCss = message.overrideCss;
    }
    if (message.type !== void 0) {
      obj.type = message.type;
    }
    if (message.flairType !== void 0) {
      obj.flairType = message.flairType;
    }
    return obj;
  },
  create(base) {
    return FlairObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairObject();
    message.allowableContent = object.allowableContent ?? void 0;
    message.text = object.text ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.modOnly = object.modOnly ?? false;
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.id = object.id ?? void 0;
    message.cssClass = object.cssClass ?? void 0;
    message.maxEmojis = object.maxEmojis ?? 0;
    message.richtext = object.richtext?.map((e) => e) || [];
    message.textEditable = object.textEditable ?? false;
    message.overrideCss = object.overrideCss ?? false;
    message.type = object.type ?? void 0;
    message.flairType = object.flairType ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairObject.$type, FlairObject);
function createBaseFlairArray() {
  return { flair: [] };
}
var FlairArray = {
  $type: "devvit.plugin.redditapi.flair.FlairArray",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    for (const v of message.flair) {
      FlairObject.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.flair.push(FlairObject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      flair: globalThis.Array.isArray(object?.flair) ? object.flair.map((e) => FlairObject.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.flair?.length) {
      obj.flair = message.flair.map((e) => FlairObject.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FlairArray.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairArray();
    message.flair = object.flair?.map((e) => FlairObject.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FlairArray.$type, FlairArray);
function createBaseFlairSelectorResponseOption() {
  return {
    flairCssClass: void 0,
    flairTemplateId: void 0,
    flairText: void 0,
    flairTextEditable: void 0,
    flairPosition: void 0
  };
}
var FlairSelectorResponseOption = {
  $type: "devvit.plugin.redditapi.flair.FlairSelectorResponseOption",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.flairCssClass !== void 0) {
      StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
    }
    if (message.flairTemplateId !== void 0) {
      StringValue.encode({ value: message.flairTemplateId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
    }
    if (message.flairTextEditable !== void 0) {
      BoolValue.encode({ value: message.flairTextEditable }, writer.uint32(34).fork()).ldelim();
    }
    if (message.flairPosition !== void 0) {
      StringValue.encode({ value: message.flairPosition }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairSelectorResponseOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.flairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.flairTextEditable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.flairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      flairCssClass: isSet80(object.flairCssClass) ? String(object.flairCssClass) : void 0,
      flairTemplateId: isSet80(object.flairTemplateId) ? String(object.flairTemplateId) : void 0,
      flairText: isSet80(object.flairText) ? String(object.flairText) : void 0,
      flairTextEditable: isSet80(object.flairTextEditable) ? Boolean(object.flairTextEditable) : void 0,
      flairPosition: isSet80(object.flairPosition) ? String(object.flairPosition) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.flairCssClass !== void 0) {
      obj.flairCssClass = message.flairCssClass;
    }
    if (message.flairTemplateId !== void 0) {
      obj.flairTemplateId = message.flairTemplateId;
    }
    if (message.flairText !== void 0) {
      obj.flairText = message.flairText;
    }
    if (message.flairTextEditable !== void 0) {
      obj.flairTextEditable = message.flairTextEditable;
    }
    if (message.flairPosition !== void 0) {
      obj.flairPosition = message.flairPosition;
    }
    return obj;
  },
  create(base) {
    return FlairSelectorResponseOption.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairSelectorResponseOption();
    message.flairCssClass = object.flairCssClass ?? void 0;
    message.flairTemplateId = object.flairTemplateId ?? void 0;
    message.flairText = object.flairText ?? void 0;
    message.flairTextEditable = object.flairTextEditable ?? void 0;
    message.flairPosition = object.flairPosition ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairSelectorResponseOption.$type, FlairSelectorResponseOption);
function createBaseFlairSelectorResponse() {
  return { current: void 0, choices: [] };
}
var FlairSelectorResponse = {
  $type: "devvit.plugin.redditapi.flair.FlairSelectorResponse",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.current !== void 0) {
      FlairSelectorResponseOption.encode(message.current, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.choices) {
      FlairSelectorResponseOption.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairSelectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.current = FlairSelectorResponseOption.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.choices.push(FlairSelectorResponseOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      current: isSet80(object.current) ? FlairSelectorResponseOption.fromJSON(object.current) : void 0,
      choices: globalThis.Array.isArray(object?.choices) ? object.choices.map((e) => FlairSelectorResponseOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.current !== void 0) {
      obj.current = FlairSelectorResponseOption.toJSON(message.current);
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => FlairSelectorResponseOption.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FlairSelectorResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairSelectorResponse();
    message.current = object.current !== void 0 && object.current !== null ? FlairSelectorResponseOption.fromPartial(object.current) : void 0;
    message.choices = object.choices?.map((e) => FlairSelectorResponseOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FlairSelectorResponse.$type, FlairSelectorResponse);
function createBaseUserFlair() {
  return { flairCssClass: void 0, user: void 0, flairText: void 0 };
}
var UserFlair = {
  $type: "devvit.plugin.redditapi.flair.UserFlair",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.flairCssClass !== void 0) {
      StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(18).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFlair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.user = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      flairCssClass: isSet80(object.flairCssClass) ? String(object.flairCssClass) : void 0,
      user: isSet80(object.user) ? String(object.user) : void 0,
      flairText: isSet80(object.flairText) ? String(object.flairText) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.flairCssClass !== void 0) {
      obj.flairCssClass = message.flairCssClass;
    }
    if (message.user !== void 0) {
      obj.user = message.user;
    }
    if (message.flairText !== void 0) {
      obj.flairText = message.flairText;
    }
    return obj;
  },
  create(base) {
    return UserFlair.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserFlair();
    message.flairCssClass = object.flairCssClass ?? void 0;
    message.user = object.user ?? void 0;
    message.flairText = object.flairText ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserFlair.$type, UserFlair);
function createBaseFlairListResponse() {
  return { users: [], next: void 0, prev: void 0 };
}
var FlairListResponse = {
  $type: "devvit.plugin.redditapi.flair.FlairListResponse",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    for (const v of message.users) {
      UserFlair.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.next !== void 0) {
      StringValue.encode({ value: message.next }, writer.uint32(18).fork()).ldelim();
    }
    if (message.prev !== void 0) {
      StringValue.encode({ value: message.prev }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.users.push(UserFlair.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.next = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.prev = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e) => UserFlair.fromJSON(e)) : [],
      next: isSet80(object.next) ? String(object.next) : void 0,
      prev: isSet80(object.prev) ? String(object.prev) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserFlair.toJSON(e));
    }
    if (message.next !== void 0) {
      obj.next = message.next;
    }
    if (message.prev !== void 0) {
      obj.prev = message.prev;
    }
    return obj;
  },
  create(base) {
    return FlairListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairListResponse();
    message.users = object.users?.map((e) => UserFlair.fromPartial(e)) || [];
    message.next = object.next ?? void 0;
    message.prev = object.prev ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairListResponse.$type, FlairListResponse);
function createBaseFlairCsvResultError() {
  return { css: void 0, row: void 0, user: void 0 };
}
var FlairCsvResultError = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResultError",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.css !== void 0) {
      StringValue.encode({ value: message.css }, writer.uint32(10).fork()).ldelim();
    }
    if (message.row !== void 0) {
      StringValue.encode({ value: message.row }, writer.uint32(18).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResultError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.css = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.row = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      css: isSet80(object.css) ? String(object.css) : void 0,
      row: isSet80(object.row) ? String(object.row) : void 0,
      user: isSet80(object.user) ? String(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.css !== void 0) {
      obj.css = message.css;
    }
    if (message.row !== void 0) {
      obj.row = message.row;
    }
    if (message.user !== void 0) {
      obj.user = message.user;
    }
    return obj;
  },
  create(base) {
    return FlairCsvResultError.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResultError();
    message.css = object.css ?? void 0;
    message.row = object.row ?? void 0;
    message.user = object.user ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairCsvResultError.$type, FlairCsvResultError);
function createBaseFlairCsvResultWarning() {
  return { text: void 0 };
}
var FlairCsvResultWarning = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResultWarning",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResultWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { text: isSet80(object.text) ? String(object.text) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return FlairCsvResultWarning.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResultWarning();
    message.text = object.text ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairCsvResultWarning.$type, FlairCsvResultWarning);
function createBaseFlairCsvResult() {
  return { status: void 0, ok: void 0, errors: void 0, warnings: void 0 };
}
var FlairCsvResult = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResult",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.status !== void 0) {
      StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();
    }
    if (message.ok !== void 0) {
      BoolValue.encode({ value: message.ok }, writer.uint32(18).fork()).ldelim();
    }
    if (message.errors !== void 0) {
      FlairCsvResultError.encode(message.errors, writer.uint32(26).fork()).ldelim();
    }
    if (message.warnings !== void 0) {
      FlairCsvResultWarning.encode(message.warnings, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.status = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.ok = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.errors = FlairCsvResultError.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.warnings = FlairCsvResultWarning.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      status: isSet80(object.status) ? String(object.status) : void 0,
      ok: isSet80(object.ok) ? Boolean(object.ok) : void 0,
      errors: isSet80(object.errors) ? FlairCsvResultError.fromJSON(object.errors) : void 0,
      warnings: isSet80(object.warnings) ? FlairCsvResultWarning.fromJSON(object.warnings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.status !== void 0) {
      obj.status = message.status;
    }
    if (message.ok !== void 0) {
      obj.ok = message.ok;
    }
    if (message.errors !== void 0) {
      obj.errors = FlairCsvResultError.toJSON(message.errors);
    }
    if (message.warnings !== void 0) {
      obj.warnings = FlairCsvResultWarning.toJSON(message.warnings);
    }
    return obj;
  },
  create(base) {
    return FlairCsvResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResult();
    message.status = object.status ?? void 0;
    message.ok = object.ok ?? void 0;
    message.errors = object.errors !== void 0 && object.errors !== null ? FlairCsvResultError.fromPartial(object.errors) : void 0;
    message.warnings = object.warnings !== void 0 && object.warnings !== null ? FlairCsvResultWarning.fromPartial(object.warnings) : void 0;
    return message;
  }
};
messageTypeRegistry.set(FlairCsvResult.$type, FlairCsvResult);
function createBaseFlairCsvResponse() {
  return { result: [] };
}
var FlairCsvResponse = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResponse",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    for (const v of message.result) {
      FlairCsvResult.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : import_minimal85.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.result.push(FlairCsvResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e) => FlairCsvResult.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => FlairCsvResult.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FlairCsvResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResponse();
    message.result = object.result?.map((e) => FlairCsvResult.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(FlairCsvResponse.$type, FlairCsvResponse);
function longToNumber10(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal85.default.util.Long !== import_long10.default) {
  import_minimal85.default.util.Long = import_long10.default;
  import_minimal85.default.configure();
}
function isSet80(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/postcollections/postcollections_msg.js
var import_minimal86 = __toESM(require_minimal2(), 1);
function createBaseCollectionRequest() {
  return { collectionId: void 0, includeLinks: void 0 };
}
var CollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.CollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.includeLinks !== void 0) {
      BoolValue.encode({ value: message.includeLinks }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.includeLinks = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      includeLinks: isSet81(object.includeLinks) ? Boolean(object.includeLinks) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.includeLinks !== void 0) {
      obj.includeLinks = message.includeLinks;
    }
    return obj;
  },
  create(base) {
    return CollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCollectionRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.includeLinks = object.includeLinks ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CollectionRequest.$type, CollectionRequest);
function createBaseCreateCollectionRequest() {
  return { title: void 0, srFullname: void 0, description: void 0, displayLayout: void 0 };
}
var CreateCollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.CreateCollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
    }
    if (message.srFullname !== void 0) {
      StringValue.encode({ value: message.srFullname }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
    }
    if (message.displayLayout !== void 0) {
      StringValue.encode({ value: message.displayLayout }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.srFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet81(object.title) ? String(object.title) : void 0,
      srFullname: isSet81(object.srFullname) ? String(object.srFullname) : void 0,
      description: isSet81(object.description) ? String(object.description) : void 0,
      displayLayout: isSet81(object.displayLayout) ? String(object.displayLayout) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.srFullname !== void 0) {
      obj.srFullname = message.srFullname;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.displayLayout !== void 0) {
      obj.displayLayout = message.displayLayout;
    }
    return obj;
  },
  create(base) {
    return CreateCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateCollectionRequest();
    message.title = object.title ?? void 0;
    message.srFullname = object.srFullname ?? void 0;
    message.description = object.description ?? void 0;
    message.displayLayout = object.displayLayout ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateCollectionRequest.$type, CreateCollectionRequest);
function createBaseAddPostToCollectionRequest() {
  return { collectionId: void 0, linkFullname: void 0 };
}
var AddPostToCollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.AddPostToCollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.linkFullname !== void 0) {
      StringValue.encode({ value: message.linkFullname }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddPostToCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.linkFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      linkFullname: isSet81(object.linkFullname) ? String(object.linkFullname) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.linkFullname !== void 0) {
      obj.linkFullname = message.linkFullname;
    }
    return obj;
  },
  create(base) {
    return AddPostToCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddPostToCollectionRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.linkFullname = object.linkFullname ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AddPostToCollectionRequest.$type, AddPostToCollectionRequest);
function createBaseDeleteCollectionRequest() {
  return { collectionId: void 0 };
}
var DeleteCollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.DeleteCollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    return obj;
  },
  create(base) {
    return DeleteCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteCollectionRequest();
    message.collectionId = object.collectionId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(DeleteCollectionRequest.$type, DeleteCollectionRequest);
function createBaseFollowCollectionRequest() {
  return { collectionId: void 0, follow: void 0 };
}
var FollowCollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.FollowCollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.follow !== void 0) {
      BoolValue.encode({ value: message.follow }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFollowCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.follow = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      follow: isSet81(object.follow) ? Boolean(object.follow) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.follow !== void 0) {
      obj.follow = message.follow;
    }
    return obj;
  },
  create(base) {
    return FollowCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFollowCollectionRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.follow = object.follow ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FollowCollectionRequest.$type, FollowCollectionRequest);
function createBaseRemovePostInCollectionRequest() {
  return { collectionId: void 0, linkFullname: void 0 };
}
var RemovePostInCollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.RemovePostInCollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.linkFullname !== void 0) {
      StringValue.encode({ value: message.linkFullname }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemovePostInCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.linkFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      linkFullname: isSet81(object.linkFullname) ? String(object.linkFullname) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.linkFullname !== void 0) {
      obj.linkFullname = message.linkFullname;
    }
    return obj;
  },
  create(base) {
    return RemovePostInCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemovePostInCollectionRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.linkFullname = object.linkFullname ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(RemovePostInCollectionRequest.$type, RemovePostInCollectionRequest);
function createBaseReorderCollectionRequest() {
  return { collectionId: void 0, linkIds: void 0 };
}
var ReorderCollectionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.ReorderCollectionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.linkIds !== void 0) {
      StringValue.encode({ value: message.linkIds }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReorderCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.linkIds = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      linkIds: isSet81(object.linkIds) ? String(object.linkIds) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.linkIds !== void 0) {
      obj.linkIds = message.linkIds;
    }
    return obj;
  },
  create(base) {
    return ReorderCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReorderCollectionRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.linkIds = object.linkIds ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ReorderCollectionRequest.$type, ReorderCollectionRequest);
function createBaseSubredditCollectionsRequest() {
  return { srFullname: void 0 };
}
var SubredditCollectionsRequest = {
  $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.srFullname !== void 0) {
      StringValue.encode({ value: message.srFullname }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditCollectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.srFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { srFullname: isSet81(object.srFullname) ? String(object.srFullname) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.srFullname !== void 0) {
      obj.srFullname = message.srFullname;
    }
    return obj;
  },
  create(base) {
    return SubredditCollectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditCollectionsRequest();
    message.srFullname = object.srFullname ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditCollectionsRequest.$type, SubredditCollectionsRequest);
function createBaseUpdateCollectionDescriptionRequest() {
  return { collectionId: void 0, description: void 0 };
}
var UpdateCollectionDescriptionRequest = {
  $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDescriptionRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCollectionDescriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      description: isSet81(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return UpdateCollectionDescriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCollectionDescriptionRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCollectionDescriptionRequest.$type, UpdateCollectionDescriptionRequest);
function createBaseUpdateCollectionTitleRequest() {
  return { collectionId: void 0, title: void 0 };
}
var UpdateCollectionTitleRequest = {
  $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionTitleRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCollectionTitleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      title: isSet81(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return UpdateCollectionTitleRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCollectionTitleRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCollectionTitleRequest.$type, UpdateCollectionTitleRequest);
function createBaseUpdateCollectionDisplayLayoutRequest() {
  return { collectionId: void 0, displayLayout: void 0 };
}
var UpdateCollectionDisplayLayoutRequest = {
  $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDisplayLayoutRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.displayLayout !== void 0) {
      StringValue.encode({ value: message.displayLayout }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCollectionDisplayLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      displayLayout: isSet81(object.displayLayout) ? String(object.displayLayout) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.displayLayout !== void 0) {
      obj.displayLayout = message.displayLayout;
    }
    return obj;
  },
  create(base) {
    return UpdateCollectionDisplayLayoutRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCollectionDisplayLayoutRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.displayLayout = object.displayLayout ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCollectionDisplayLayoutRequest.$type, UpdateCollectionDisplayLayoutRequest);
function createBaseCollectionResponse() {
  return {
    collectionId: void 0,
    subredditId: void 0,
    title: void 0,
    description: void 0,
    authorId: void 0,
    authorName: void 0,
    permalink: void 0,
    linkIds: [],
    primaryLinkId: void 0,
    displayLayout: void 0,
    createdAtUtc: void 0,
    lastUpdateUtc: void 0
  };
}
var CollectionResponse = {
  $type: "devvit.plugin.redditapi.postcollections.CollectionResponse",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
    }
    if (message.authorId !== void 0) {
      StringValue.encode({ value: message.authorId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.authorName !== void 0) {
      StringValue.encode({ value: message.authorName }, writer.uint32(50).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.linkIds) {
      StringValue.encode({ value: v }, writer.uint32(66).fork()).ldelim();
    }
    if (message.primaryLinkId !== void 0) {
      StringValue.encode({ value: message.primaryLinkId }, writer.uint32(74).fork()).ldelim();
    }
    if (message.displayLayout !== void 0) {
      StringValue.encode({ value: message.displayLayout }, writer.uint32(82).fork()).ldelim();
    }
    if (message.createdAtUtc !== void 0) {
      Timestamp.encode(toTimestamp14(message.createdAtUtc), writer.uint32(90).fork()).ldelim();
    }
    if (message.lastUpdateUtc !== void 0) {
      Timestamp.encode(toTimestamp14(message.lastUpdateUtc), writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.authorId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.authorName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.linkIds.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.primaryLinkId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.createdAtUtc = fromTimestamp14(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.lastUpdateUtc = fromTimestamp14(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet81(object.collectionId) ? String(object.collectionId) : void 0,
      subredditId: isSet81(object.subredditId) ? String(object.subredditId) : void 0,
      title: isSet81(object.title) ? String(object.title) : void 0,
      description: isSet81(object.description) ? String(object.description) : void 0,
      authorId: isSet81(object.authorId) ? String(object.authorId) : void 0,
      authorName: isSet81(object.authorName) ? String(object.authorName) : void 0,
      permalink: isSet81(object.permalink) ? String(object.permalink) : void 0,
      linkIds: globalThis.Array.isArray(object?.linkIds) ? object.linkIds.map((e) => String(e)) : [],
      primaryLinkId: isSet81(object.primaryLinkId) ? String(object.primaryLinkId) : void 0,
      displayLayout: isSet81(object.displayLayout) ? String(object.displayLayout) : void 0,
      createdAtUtc: isSet81(object.createdAtUtc) ? fromJsonTimestamp14(object.createdAtUtc) : void 0,
      lastUpdateUtc: isSet81(object.lastUpdateUtc) ? fromJsonTimestamp14(object.lastUpdateUtc) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.authorId !== void 0) {
      obj.authorId = message.authorId;
    }
    if (message.authorName !== void 0) {
      obj.authorName = message.authorName;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.linkIds?.length) {
      obj.linkIds = message.linkIds;
    }
    if (message.primaryLinkId !== void 0) {
      obj.primaryLinkId = message.primaryLinkId;
    }
    if (message.displayLayout !== void 0) {
      obj.displayLayout = message.displayLayout;
    }
    if (message.createdAtUtc !== void 0) {
      obj.createdAtUtc = message.createdAtUtc.toISOString();
    }
    if (message.lastUpdateUtc !== void 0) {
      obj.lastUpdateUtc = message.lastUpdateUtc.toISOString();
    }
    return obj;
  },
  create(base) {
    return CollectionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCollectionResponse();
    message.collectionId = object.collectionId ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.title = object.title ?? void 0;
    message.description = object.description ?? void 0;
    message.authorId = object.authorId ?? void 0;
    message.authorName = object.authorName ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.linkIds = object.linkIds?.map((e) => e) || [];
    message.primaryLinkId = object.primaryLinkId ?? void 0;
    message.displayLayout = object.displayLayout ?? void 0;
    message.createdAtUtc = object.createdAtUtc ?? void 0;
    message.lastUpdateUtc = object.lastUpdateUtc ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CollectionResponse.$type, CollectionResponse);
function createBaseSubredditCollectionsResponse() {
  return { collections: [] };
}
var SubredditCollectionsResponse = {
  $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    for (const v of message.collections) {
      CollectionResponse.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : import_minimal86.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditCollectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.collections.push(CollectionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collections: globalThis.Array.isArray(object?.collections) ? object.collections.map((e) => CollectionResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collections?.length) {
      obj.collections = message.collections.map((e) => CollectionResponse.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SubredditCollectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditCollectionsResponse();
    message.collections = object.collections?.map((e) => CollectionResponse.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditCollectionsResponse.$type, SubredditCollectionsResponse);
function toTimestamp14(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp14(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp14(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp14(Timestamp.fromJSON(o));
  }
}
function isSet81(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/modlog/modlog.js
var import_minimal88 = __toESM(require_minimal2(), 1);
function createBaseModlogRequest() {
  return { action: "", details: void 0, description: void 0, note: void 0, target: void 0 };
}
var ModlogRequest = {
  $type: "devvit.plugin.modlog.ModlogRequest",
  encode(message, writer = import_minimal88.default.Writer.create()) {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.details !== void 0) {
      writer.uint32(18).string(message.details);
    }
    if (message.description !== void 0) {
      writer.uint32(26).string(message.description);
    }
    if (message.note !== void 0) {
      writer.uint32(34).string(message.note);
    }
    if (message.target !== void 0) {
      writer.uint32(42).string(message.target);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal88.default.Reader ? input : import_minimal88.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModlogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.details = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.note = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.target = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet82(object.action) ? globalThis.String(object.action) : "",
      details: isSet82(object.details) ? globalThis.String(object.details) : void 0,
      description: isSet82(object.description) ? globalThis.String(object.description) : void 0,
      note: isSet82(object.note) ? globalThis.String(object.note) : void 0,
      target: isSet82(object.target) ? globalThis.String(object.target) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.details !== void 0) {
      obj.details = message.details;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.note !== void 0) {
      obj.note = message.note;
    }
    if (message.target !== void 0) {
      obj.target = message.target;
    }
    return obj;
  },
  create(base) {
    return ModlogRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModlogRequest();
    message.action = object.action ?? "";
    message.details = object.details ?? void 0;
    message.description = object.description ?? void 0;
    message.note = object.note ?? void 0;
    message.target = object.target ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ModlogRequest.$type, ModlogRequest);
function createBaseModlogResponse() {
  return { success: false };
}
var ModlogResponse = {
  $type: "devvit.plugin.modlog.ModlogResponse",
  encode(message, writer = import_minimal88.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal88.default.Reader ? input : import_minimal88.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModlogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { success: isSet82(object.success) ? globalThis.Boolean(object.success) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },
  create(base) {
    return ModlogResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModlogResponse();
    message.success = object.success ?? false;
    return message;
  }
};
messageTypeRegistry.set(ModlogResponse.$type, ModlogResponse);
function isSet82(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/media/media.js
var import_minimal89 = __toESM(require_minimal2(), 1);
function createBaseMediaUploadRequest() {
  return { url: "", type: "" };
}
var MediaUploadRequest = {
  $type: "devvit.plugin.media.MediaUploadRequest",
  encode(message, writer = import_minimal89.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal89.default.Reader ? input : import_minimal89.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet83(object.url) ? globalThis.String(object.url) : "",
      type: isSet83(object.type) ? globalThis.String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },
  create(base) {
    return MediaUploadRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMediaUploadRequest();
    message.url = object.url ?? "";
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set(MediaUploadRequest.$type, MediaUploadRequest);
function createBaseMediaUploadResponse() {
  return { mediaId: "", mediaUrl: "" };
}
var MediaUploadResponse = {
  $type: "devvit.plugin.media.MediaUploadResponse",
  encode(message, writer = import_minimal89.default.Writer.create()) {
    if (message.mediaId !== "") {
      writer.uint32(10).string(message.mediaId);
    }
    if (message.mediaUrl !== "") {
      writer.uint32(18).string(message.mediaUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal89.default.Reader ? input : import_minimal89.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.mediaId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.mediaUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      mediaId: isSet83(object.mediaId) ? globalThis.String(object.mediaId) : "",
      mediaUrl: isSet83(object.mediaUrl) ? globalThis.String(object.mediaUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.mediaId !== "") {
      obj.mediaId = message.mediaId;
    }
    if (message.mediaUrl !== "") {
      obj.mediaUrl = message.mediaUrl;
    }
    return obj;
  },
  create(base) {
    return MediaUploadResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMediaUploadResponse();
    message.mediaId = object.mediaId ?? "";
    message.mediaUrl = object.mediaUrl ?? "";
    return message;
  }
};
messageTypeRegistry.set(MediaUploadResponse.$type, MediaUploadResponse);
function isSet83(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/linker/resolver.js
var import_minimal91 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/inspector/inspector.js
var import_minimal90 = __toESM(require_minimal2(), 1);
var InspectorUpdateType;
(function(InspectorUpdateType2) {
  InspectorUpdateType2[InspectorUpdateType2["ADDED"] = 0] = "ADDED";
  InspectorUpdateType2[InspectorUpdateType2["REMOVED"] = 1] = "REMOVED";
  InspectorUpdateType2[InspectorUpdateType2["CHANGED"] = 2] = "CHANGED";
  InspectorUpdateType2[InspectorUpdateType2["SUBSCRIBED"] = 3] = "SUBSCRIBED";
  InspectorUpdateType2[InspectorUpdateType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InspectorUpdateType || (InspectorUpdateType = {}));
function inspectorUpdateTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ADDED":
      return InspectorUpdateType.ADDED;
    case 1:
    case "REMOVED":
      return InspectorUpdateType.REMOVED;
    case 2:
    case "CHANGED":
      return InspectorUpdateType.CHANGED;
    case 3:
    case "SUBSCRIBED":
      return InspectorUpdateType.SUBSCRIBED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InspectorUpdateType.UNRECOGNIZED;
  }
}
function inspectorUpdateTypeToJSON(object) {
  switch (object) {
    case InspectorUpdateType.ADDED:
      return 0;
    case InspectorUpdateType.REMOVED:
      return 1;
    case InspectorUpdateType.CHANGED:
      return 2;
    case InspectorUpdateType.SUBSCRIBED:
      return 3;
    case InspectorUpdateType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseInspectorQuery() {
  return { type: "", hostname: "" };
}
var InspectorQuery = {
  $type: "devvit.plugin.inspector.InspectorQuery",
  encode(message, writer = import_minimal90.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal90.default.Reader ? input : import_minimal90.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet84(object.type) ? globalThis.String(object.type) : "",
      hostname: isSet84(object.hostname) ? globalThis.String(object.hostname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },
  create(base) {
    return InspectorQuery.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInspectorQuery();
    message.type = object.type ?? "";
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set(InspectorQuery.$type, InspectorQuery);
function createBaseInspectorDescription() {
  return { provides: [], hostname: "" };
}
var InspectorDescription = {
  $type: "devvit.plugin.inspector.InspectorDescription",
  encode(message, writer = import_minimal90.default.Writer.create()) {
    for (const v of message.provides) {
      SerializableServiceDefinition.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal90.default.Reader ? input : import_minimal90.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.provides.push(SerializableServiceDefinition.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      provides: globalThis.Array.isArray(object?.provides) ? object.provides.map((e) => SerializableServiceDefinition.fromJSON(e)) : [],
      hostname: isSet84(object.hostname) ? globalThis.String(object.hostname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.provides?.length) {
      obj.provides = message.provides.map((e) => SerializableServiceDefinition.toJSON(e));
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },
  create(base) {
    return InspectorDescription.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInspectorDescription();
    message.provides = object.provides?.map((e) => SerializableServiceDefinition.fromPartial(e)) || [];
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set(InspectorDescription.$type, InspectorDescription);
function createBaseInspectorDescriptions() {
  return { descriptions: [] };
}
var InspectorDescriptions = {
  $type: "devvit.plugin.inspector.InspectorDescriptions",
  encode(message, writer = import_minimal90.default.Writer.create()) {
    for (const v of message.descriptions) {
      InspectorDescription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal90.default.Reader ? input : import_minimal90.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorDescriptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.descriptions.push(InspectorDescription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      descriptions: globalThis.Array.isArray(object?.descriptions) ? object.descriptions.map((e) => InspectorDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.descriptions?.length) {
      obj.descriptions = message.descriptions.map((e) => InspectorDescription.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return InspectorDescriptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInspectorDescriptions();
    message.descriptions = object.descriptions?.map((e) => InspectorDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(InspectorDescriptions.$type, InspectorDescriptions);
function createBaseInspectorUpdate() {
  return { description: void 0, type: 0 };
}
var InspectorUpdate = {
  $type: "devvit.plugin.inspector.InspectorUpdate",
  encode(message, writer = import_minimal90.default.Writer.create()) {
    if (message.description !== void 0) {
      InspectorDescription.encode(message.description, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal90.default.Reader ? input : import_minimal90.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.description = InspectorDescription.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      description: isSet84(object.description) ? InspectorDescription.fromJSON(object.description) : void 0,
      type: isSet84(object.type) ? inspectorUpdateTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.description !== void 0) {
      obj.description = InspectorDescription.toJSON(message.description);
    }
    if (message.type !== 0) {
      obj.type = inspectorUpdateTypeToJSON(message.type);
    }
    return obj;
  },
  create(base) {
    return InspectorUpdate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInspectorUpdate();
    message.description = object.description !== void 0 && object.description !== null ? InspectorDescription.fromPartial(object.description) : void 0;
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set(InspectorUpdate.$type, InspectorUpdate);
function isSet84(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/linker/resolver.js
function createBaseResolution() {
  return { bundle: void 0, error: void 0, plugin: void 0 };
}
var Resolution = {
  $type: "devvit.plugin.linker.Resolution",
  encode(message, writer = import_minimal91.default.Writer.create()) {
    if (message.bundle !== void 0) {
      Bundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    if (message.error !== void 0) {
      ResolutionError.encode(message.error, writer.uint32(18).fork()).ldelim();
    }
    if (message.plugin !== void 0) {
      InspectorDescription.encode(message.plugin, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal91.default.Reader ? input : import_minimal91.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResolution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bundle = Bundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.error = ResolutionError.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.plugin = InspectorDescription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet85(object.bundle) ? Bundle.fromJSON(object.bundle) : void 0,
      error: isSet85(object.error) ? ResolutionError.fromJSON(object.error) : void 0,
      plugin: isSet85(object.plugin) ? InspectorDescription.fromJSON(object.plugin) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bundle !== void 0) {
      obj.bundle = Bundle.toJSON(message.bundle);
    }
    if (message.error !== void 0) {
      obj.error = ResolutionError.toJSON(message.error);
    }
    if (message.plugin !== void 0) {
      obj.plugin = InspectorDescription.toJSON(message.plugin);
    }
    return obj;
  },
  create(base) {
    return Resolution.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResolution();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? Bundle.fromPartial(object.bundle) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? ResolutionError.fromPartial(object.error) : void 0;
    message.plugin = object.plugin !== void 0 && object.plugin !== null ? InspectorDescription.fromPartial(object.plugin) : void 0;
    return message;
  }
};
messageTypeRegistry.set(Resolution.$type, Resolution);
function createBaseResolutionError() {
  return { query: void 0, text: "" };
}
var ResolutionError = {
  $type: "devvit.plugin.linker.ResolutionError",
  encode(message, writer = import_minimal91.default.Writer.create()) {
    if (message.query !== void 0) {
      PackageQuery.encode(message.query, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal91.default.Reader ? input : import_minimal91.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResolutionError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.query = PackageQuery.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      query: isSet85(object.query) ? PackageQuery.fromJSON(object.query) : void 0,
      text: isSet85(object.text) ? globalThis.String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.query !== void 0) {
      obj.query = PackageQuery.toJSON(message.query);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return ResolutionError.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResolutionError();
    message.query = object.query !== void 0 && object.query !== null ? PackageQuery.fromPartial(object.query) : void 0;
    message.text = object.text ?? "";
    return message;
  }
};
messageTypeRegistry.set(ResolutionError.$type, ResolutionError);
function isSet85(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/linker/linker.js
var import_minimal92 = __toESM(require_minimal2(), 1);
function createBaseLinkerResponse() {
  return { bundle: void 0, errors: [] };
}
var LinkerResponse = {
  $type: "devvit.plugin.linker.LinkerResponse",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.bundle !== void 0) {
      LinkedBundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      ResolutionError.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : import_minimal92.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bundle = LinkedBundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.errors.push(ResolutionError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet86(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : void 0,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => ResolutionError.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bundle !== void 0) {
      obj.bundle = LinkedBundle.toJSON(message.bundle);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ResolutionError.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return LinkerResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLinkerResponse();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? LinkedBundle.fromPartial(object.bundle) : void 0;
    message.errors = object.errors?.map((e) => ResolutionError.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(LinkerResponse.$type, LinkerResponse);
function isSet86(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/kvstore/kvstore.js
var import_minimal93 = __toESM(require_minimal2(), 1);
function createBaseMessageSet() {
  return { messages: {} };
}
var MessageSet = {
  $type: "devvit.plugin.kvstore.MessageSet",
  encode(message, writer = import_minimal93.default.Writer.create()) {
    Object.entries(message.messages).forEach(([key, value]) => {
      MessageSet_MessagesEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal93.default.Reader ? input : import_minimal93.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = MessageSet_MessagesEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.messages[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return MessageSet.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageSet();
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(MessageSet.$type, MessageSet);
function createBaseMessageSet_MessagesEntry() {
  return { key: "", value: "" };
}
var MessageSet_MessagesEntry = {
  $type: "devvit.plugin.kvstore.MessageSet.MessagesEntry",
  encode(message, writer = import_minimal93.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal93.default.Reader ? input : import_minimal93.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageSet_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet87(object.key) ? globalThis.String(object.key) : "",
      value: isSet87(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return MessageSet_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageSet_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(MessageSet_MessagesEntry.$type, MessageSet_MessagesEntry);
function createBaseKeySet() {
  return { keys: [] };
}
var KeySet = {
  $type: "devvit.plugin.kvstore.KeySet",
  encode(message, writer = import_minimal93.default.Writer.create()) {
    for (const v of message.keys) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal93.default.Reader ? input : import_minimal93.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeySet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.keys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => globalThis.String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },
  create(base) {
    return KeySet.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKeySet();
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(KeySet.$type, KeySet);
function createBaseListFilter() {
  return { filter: "" };
}
var ListFilter = {
  $type: "devvit.plugin.kvstore.ListFilter",
  encode(message, writer = import_minimal93.default.Writer.create()) {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal93.default.Reader ? input : import_minimal93.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { filter: isSet87(object.filter) ? globalThis.String(object.filter) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },
  create(base) {
    return ListFilter.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListFilter();
    message.filter = object.filter ?? "";
    return message;
  }
};
messageTypeRegistry.set(ListFilter.$type, ListFilter);
function isObject16(value) {
  return typeof value === "object" && value !== null;
}
function isSet87(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/http/http.js
var import_minimal94 = __toESM(require_minimal2(), 1);
function createBaseFetchRequest() {
  return { url: "", data: void 0 };
}
var FetchRequest = {
  $type: "devvit.plugin.http.FetchRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.data !== void 0) {
      RequestData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : import_minimal94.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFetchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = RequestData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet88(object.url) ? globalThis.String(object.url) : "",
      data: isSet88(object.data) ? RequestData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.data !== void 0) {
      obj.data = RequestData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return FetchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFetchRequest();
    message.url = object.url ?? "";
    message.data = object.data !== void 0 && object.data !== null ? RequestData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(FetchRequest.$type, FetchRequest);
function createBaseRequestData() {
  return { method: "", headers: {}, body: new Uint8Array(0) };
}
var RequestData = {
  $type: "devvit.plugin.http.RequestData",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      RequestData_HeadersEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.body.length !== 0) {
      writer.uint32(26).bytes(message.body);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : import_minimal94.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = RequestData_HeadersEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.headers[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.body = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      method: isSet88(object.method) ? globalThis.String(object.method) : "",
      headers: isObject17(object.headers) ? Object.entries(object.headers).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      body: isSet88(object.body) ? bytesFromBase645(object.body) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes5(message.body);
    }
    return obj;
  },
  create(base) {
    return RequestData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequestData();
    message.method = object.method ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? new Uint8Array(0);
    return message;
  }
};
messageTypeRegistry.set(RequestData.$type, RequestData);
function createBaseRequestData_HeadersEntry() {
  return { key: "", value: "" };
}
var RequestData_HeadersEntry = {
  $type: "devvit.plugin.http.RequestData.HeadersEntry",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : import_minimal94.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequestData_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet88(object.key) ? globalThis.String(object.key) : "",
      value: isSet88(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return RequestData_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequestData_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(RequestData_HeadersEntry.$type, RequestData_HeadersEntry);
function createBaseFetchResponse() {
  return { url: "", body: new Uint8Array(0), status: 0, headers: {} };
}
var FetchResponse = {
  $type: "devvit.plugin.http.FetchResponse",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      FetchResponse_HeadersEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : import_minimal94.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFetchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.body = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.status = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          const entry4 = FetchResponse_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet88(object.url) ? globalThis.String(object.url) : "",
      body: isSet88(object.body) ? bytesFromBase645(object.body) : new Uint8Array(0),
      status: isSet88(object.status) ? globalThis.Number(object.status) : 0,
      headers: isObject17(object.headers) ? Object.entries(object.headers).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes5(message.body);
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return FetchResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFetchResponse();
    message.url = object.url ?? "";
    message.body = object.body ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(FetchResponse.$type, FetchResponse);
function createBaseFetchResponse_HeadersEntry() {
  return { key: "", value: "" };
}
var FetchResponse_HeadersEntry = {
  $type: "devvit.plugin.http.FetchResponse.HeadersEntry",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : import_minimal94.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFetchResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet88(object.key) ? globalThis.String(object.key) : "",
      value: isSet88(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FetchResponse_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFetchResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(FetchResponse_HeadersEntry.$type, FetchResponse_HeadersEntry);
var HTTPDefinition = {
  name: "HTTP",
  fullName: "devvit.plugin.http.HTTP",
  methods: {
    fetch: {
      name: "Fetch",
      requestType: FetchRequest,
      requestStream: false,
      responseType: FetchResponse,
      responseStream: false,
      options: {}
    }
  }
};
function bytesFromBase645(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes5(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isObject17(value) {
  return typeof value === "object" && value !== null;
}
function isSet88(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/gl/methodtype.js
var GLMethodType;
(function(GLMethodType2) {
  GLMethodType2[GLMethodType2["ASYNC"] = 0] = "ASYNC";
  GLMethodType2[GLMethodType2["CONSTRUCTOR"] = 1] = "CONSTRUCTOR";
  GLMethodType2[GLMethodType2["DESTRUCTOR"] = 2] = "DESTRUCTOR";
  GLMethodType2[GLMethodType2["SYNC"] = 3] = "SYNC";
  GLMethodType2[GLMethodType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GLMethodType || (GLMethodType = {}));
function gLMethodTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ASYNC":
      return GLMethodType.ASYNC;
    case 1:
    case "CONSTRUCTOR":
      return GLMethodType.CONSTRUCTOR;
    case 2:
    case "DESTRUCTOR":
      return GLMethodType.DESTRUCTOR;
    case 3:
    case "SYNC":
      return GLMethodType.SYNC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GLMethodType.UNRECOGNIZED;
  }
}
function gLMethodTypeToJSON(object) {
  switch (object) {
    case GLMethodType.ASYNC:
      return 0;
    case GLMethodType.CONSTRUCTOR:
      return 1;
    case GLMethodType.DESTRUCTOR:
      return 2;
    case GLMethodType.SYNC:
      return 3;
    case GLMethodType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/plugin/gl/methods.js
var GLMethod;
(function(GLMethod2) {
  GLMethod2[GLMethod2["activeTexture"] = 0] = "activeTexture";
  GLMethod2[GLMethod2["attachShader"] = 1] = "attachShader";
  GLMethod2[GLMethod2["bindAttribLocation"] = 2] = "bindAttribLocation";
  GLMethod2[GLMethod2["bindBuffer"] = 3] = "bindBuffer";
  GLMethod2[GLMethod2["bindFramebuffer"] = 4] = "bindFramebuffer";
  GLMethod2[GLMethod2["bindRenderbuffer"] = 5] = "bindRenderbuffer";
  GLMethod2[GLMethod2["bindTexture"] = 6] = "bindTexture";
  GLMethod2[GLMethod2["blendColor"] = 7] = "blendColor";
  GLMethod2[GLMethod2["blendEquation"] = 8] = "blendEquation";
  GLMethod2[GLMethod2["blendEquationSeparate"] = 9] = "blendEquationSeparate";
  GLMethod2[GLMethod2["blendFunc"] = 10] = "blendFunc";
  GLMethod2[GLMethod2["blendFuncSeparate"] = 11] = "blendFuncSeparate";
  GLMethod2[GLMethod2["bufferData"] = 12] = "bufferData";
  GLMethod2[GLMethod2["bufferSubData"] = 13] = "bufferSubData";
  GLMethod2[GLMethod2["checkFramebufferStatus"] = 14] = "checkFramebufferStatus";
  GLMethod2[GLMethod2["clear"] = 15] = "clear";
  GLMethod2[GLMethod2["clearColor"] = 16] = "clearColor";
  GLMethod2[GLMethod2["clearDepth"] = 17] = "clearDepth";
  GLMethod2[GLMethod2["clearStencil"] = 18] = "clearStencil";
  GLMethod2[GLMethod2["colorMask"] = 19] = "colorMask";
  GLMethod2[GLMethod2["compileShader"] = 20] = "compileShader";
  GLMethod2[GLMethod2["copyTexImage2D"] = 21] = "copyTexImage2D";
  GLMethod2[GLMethod2["copyTexSubImage2D"] = 22] = "copyTexSubImage2D";
  GLMethod2[GLMethod2["createBuffer"] = 23] = "createBuffer";
  GLMethod2[GLMethod2["createFramebuffer"] = 24] = "createFramebuffer";
  GLMethod2[GLMethod2["createProgram"] = 25] = "createProgram";
  GLMethod2[GLMethod2["createRenderbuffer"] = 26] = "createRenderbuffer";
  GLMethod2[GLMethod2["createShader"] = 27] = "createShader";
  GLMethod2[GLMethod2["createTexture"] = 28] = "createTexture";
  GLMethod2[GLMethod2["cullFace"] = 29] = "cullFace";
  GLMethod2[GLMethod2["deleteBuffer"] = 30] = "deleteBuffer";
  GLMethod2[GLMethod2["deleteFramebuffer"] = 31] = "deleteFramebuffer";
  GLMethod2[GLMethod2["deleteProgram"] = 32] = "deleteProgram";
  GLMethod2[GLMethod2["deleteRenderbuffer"] = 33] = "deleteRenderbuffer";
  GLMethod2[GLMethod2["deleteShader"] = 34] = "deleteShader";
  GLMethod2[GLMethod2["deleteTexture"] = 35] = "deleteTexture";
  GLMethod2[GLMethod2["depthFunc"] = 36] = "depthFunc";
  GLMethod2[GLMethod2["depthMask"] = 37] = "depthMask";
  GLMethod2[GLMethod2["depthRange"] = 38] = "depthRange";
  GLMethod2[GLMethod2["detachShader"] = 39] = "detachShader";
  GLMethod2[GLMethod2["disable"] = 40] = "disable";
  GLMethod2[GLMethod2["disableVertexAttribArray"] = 41] = "disableVertexAttribArray";
  GLMethod2[GLMethod2["drawArrays"] = 42] = "drawArrays";
  GLMethod2[GLMethod2["drawElements"] = 43] = "drawElements";
  GLMethod2[GLMethod2["enable"] = 44] = "enable";
  GLMethod2[GLMethod2["enableVertexAttribArray"] = 45] = "enableVertexAttribArray";
  GLMethod2[GLMethod2["finish"] = 46] = "finish";
  GLMethod2[GLMethod2["flush"] = 47] = "flush";
  GLMethod2[GLMethod2["framebufferRenderbuffer"] = 48] = "framebufferRenderbuffer";
  GLMethod2[GLMethod2["framebufferTexture2D"] = 49] = "framebufferTexture2D";
  GLMethod2[GLMethod2["frontFace"] = 50] = "frontFace";
  GLMethod2[GLMethod2["generateMipmap"] = 51] = "generateMipmap";
  GLMethod2[GLMethod2["getActiveAttrib"] = 52] = "getActiveAttrib";
  GLMethod2[GLMethod2["getActiveUniform"] = 53] = "getActiveUniform";
  GLMethod2[GLMethod2["getAttachedShaders"] = 54] = "getAttachedShaders";
  GLMethod2[GLMethod2["getAttribLocation"] = 55] = "getAttribLocation";
  GLMethod2[GLMethod2["getBufferParameter"] = 56] = "getBufferParameter";
  GLMethod2[GLMethod2["getContextAttributes"] = 57] = "getContextAttributes";
  GLMethod2[GLMethod2["getError"] = 58] = "getError";
  GLMethod2[GLMethod2["getExtension"] = 59] = "getExtension";
  GLMethod2[GLMethod2["getFramebufferAttachmentParameter"] = 60] = "getFramebufferAttachmentParameter";
  GLMethod2[GLMethod2["getParameter"] = 61] = "getParameter";
  GLMethod2[GLMethod2["getProgramInfoLog"] = 62] = "getProgramInfoLog";
  GLMethod2[GLMethod2["getProgramParameter"] = 63] = "getProgramParameter";
  GLMethod2[GLMethod2["getRenderbufferParameter"] = 64] = "getRenderbufferParameter";
  GLMethod2[GLMethod2["getShaderInfoLog"] = 65] = "getShaderInfoLog";
  GLMethod2[GLMethod2["getShaderParameter"] = 66] = "getShaderParameter";
  GLMethod2[GLMethod2["getShaderPrecisionFormat"] = 67] = "getShaderPrecisionFormat";
  GLMethod2[GLMethod2["getShaderSource"] = 68] = "getShaderSource";
  GLMethod2[GLMethod2["getSupportedExtensions"] = 69] = "getSupportedExtensions";
  GLMethod2[GLMethod2["getTexParameter"] = 70] = "getTexParameter";
  GLMethod2[GLMethod2["getUniform"] = 71] = "getUniform";
  GLMethod2[GLMethod2["getUniformLocation"] = 72] = "getUniformLocation";
  GLMethod2[GLMethod2["getVertexAttrib"] = 73] = "getVertexAttrib";
  GLMethod2[GLMethod2["getVertexAttribOffset"] = 74] = "getVertexAttribOffset";
  GLMethod2[GLMethod2["hint"] = 75] = "hint";
  GLMethod2[GLMethod2["isBuffer"] = 76] = "isBuffer";
  GLMethod2[GLMethod2["isContextLost"] = 77] = "isContextLost";
  GLMethod2[GLMethod2["isEnabled"] = 78] = "isEnabled";
  GLMethod2[GLMethod2["isFramebuffer"] = 79] = "isFramebuffer";
  GLMethod2[GLMethod2["isProgram"] = 80] = "isProgram";
  GLMethod2[GLMethod2["isRenderbuffer"] = 81] = "isRenderbuffer";
  GLMethod2[GLMethod2["isShader"] = 82] = "isShader";
  GLMethod2[GLMethod2["isTexture"] = 83] = "isTexture";
  GLMethod2[GLMethod2["lineWidth"] = 84] = "lineWidth";
  GLMethod2[GLMethod2["linkProgram"] = 85] = "linkProgram";
  GLMethod2[GLMethod2["polygonOffset"] = 86] = "polygonOffset";
  GLMethod2[GLMethod2["renderbufferStorage"] = 87] = "renderbufferStorage";
  GLMethod2[GLMethod2["sampleCoverage"] = 88] = "sampleCoverage";
  GLMethod2[GLMethod2["scissor"] = 89] = "scissor";
  GLMethod2[GLMethod2["shaderSource"] = 90] = "shaderSource";
  GLMethod2[GLMethod2["stencilFunc"] = 91] = "stencilFunc";
  GLMethod2[GLMethod2["stencilFuncSeparate"] = 92] = "stencilFuncSeparate";
  GLMethod2[GLMethod2["stencilMask"] = 93] = "stencilMask";
  GLMethod2[GLMethod2["stencilMaskSeparate"] = 94] = "stencilMaskSeparate";
  GLMethod2[GLMethod2["stencilOp"] = 95] = "stencilOp";
  GLMethod2[GLMethod2["stencilOpSeparate"] = 96] = "stencilOpSeparate";
  GLMethod2[GLMethod2["texParameterf"] = 97] = "texParameterf";
  GLMethod2[GLMethod2["texParameteri"] = 98] = "texParameteri";
  GLMethod2[GLMethod2["uniform1f"] = 99] = "uniform1f";
  GLMethod2[GLMethod2["uniform1i"] = 100] = "uniform1i";
  GLMethod2[GLMethod2["uniform2f"] = 101] = "uniform2f";
  GLMethod2[GLMethod2["uniform2i"] = 102] = "uniform2i";
  GLMethod2[GLMethod2["uniform3f"] = 103] = "uniform3f";
  GLMethod2[GLMethod2["uniform3i"] = 104] = "uniform3i";
  GLMethod2[GLMethod2["uniform4f"] = 105] = "uniform4f";
  GLMethod2[GLMethod2["uniform4i"] = 106] = "uniform4i";
  GLMethod2[GLMethod2["useProgram"] = 107] = "useProgram";
  GLMethod2[GLMethod2["validateProgram"] = 108] = "validateProgram";
  GLMethod2[GLMethod2["vertexAttrib1f"] = 109] = "vertexAttrib1f";
  GLMethod2[GLMethod2["vertexAttrib2f"] = 110] = "vertexAttrib2f";
  GLMethod2[GLMethod2["vertexAttrib3f"] = 111] = "vertexAttrib3f";
  GLMethod2[GLMethod2["vertexAttrib4f"] = 112] = "vertexAttrib4f";
  GLMethod2[GLMethod2["vertexAttribPointer"] = 113] = "vertexAttribPointer";
  GLMethod2[GLMethod2["viewport"] = 114] = "viewport";
  GLMethod2[GLMethod2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GLMethod || (GLMethod = {}));
function gLMethodFromJSON(object) {
  switch (object) {
    case 0:
    case "activeTexture":
      return GLMethod.activeTexture;
    case 1:
    case "attachShader":
      return GLMethod.attachShader;
    case 2:
    case "bindAttribLocation":
      return GLMethod.bindAttribLocation;
    case 3:
    case "bindBuffer":
      return GLMethod.bindBuffer;
    case 4:
    case "bindFramebuffer":
      return GLMethod.bindFramebuffer;
    case 5:
    case "bindRenderbuffer":
      return GLMethod.bindRenderbuffer;
    case 6:
    case "bindTexture":
      return GLMethod.bindTexture;
    case 7:
    case "blendColor":
      return GLMethod.blendColor;
    case 8:
    case "blendEquation":
      return GLMethod.blendEquation;
    case 9:
    case "blendEquationSeparate":
      return GLMethod.blendEquationSeparate;
    case 10:
    case "blendFunc":
      return GLMethod.blendFunc;
    case 11:
    case "blendFuncSeparate":
      return GLMethod.blendFuncSeparate;
    case 12:
    case "bufferData":
      return GLMethod.bufferData;
    case 13:
    case "bufferSubData":
      return GLMethod.bufferSubData;
    case 14:
    case "checkFramebufferStatus":
      return GLMethod.checkFramebufferStatus;
    case 15:
    case "clear":
      return GLMethod.clear;
    case 16:
    case "clearColor":
      return GLMethod.clearColor;
    case 17:
    case "clearDepth":
      return GLMethod.clearDepth;
    case 18:
    case "clearStencil":
      return GLMethod.clearStencil;
    case 19:
    case "colorMask":
      return GLMethod.colorMask;
    case 20:
    case "compileShader":
      return GLMethod.compileShader;
    case 21:
    case "copyTexImage2D":
      return GLMethod.copyTexImage2D;
    case 22:
    case "copyTexSubImage2D":
      return GLMethod.copyTexSubImage2D;
    case 23:
    case "createBuffer":
      return GLMethod.createBuffer;
    case 24:
    case "createFramebuffer":
      return GLMethod.createFramebuffer;
    case 25:
    case "createProgram":
      return GLMethod.createProgram;
    case 26:
    case "createRenderbuffer":
      return GLMethod.createRenderbuffer;
    case 27:
    case "createShader":
      return GLMethod.createShader;
    case 28:
    case "createTexture":
      return GLMethod.createTexture;
    case 29:
    case "cullFace":
      return GLMethod.cullFace;
    case 30:
    case "deleteBuffer":
      return GLMethod.deleteBuffer;
    case 31:
    case "deleteFramebuffer":
      return GLMethod.deleteFramebuffer;
    case 32:
    case "deleteProgram":
      return GLMethod.deleteProgram;
    case 33:
    case "deleteRenderbuffer":
      return GLMethod.deleteRenderbuffer;
    case 34:
    case "deleteShader":
      return GLMethod.deleteShader;
    case 35:
    case "deleteTexture":
      return GLMethod.deleteTexture;
    case 36:
    case "depthFunc":
      return GLMethod.depthFunc;
    case 37:
    case "depthMask":
      return GLMethod.depthMask;
    case 38:
    case "depthRange":
      return GLMethod.depthRange;
    case 39:
    case "detachShader":
      return GLMethod.detachShader;
    case 40:
    case "disable":
      return GLMethod.disable;
    case 41:
    case "disableVertexAttribArray":
      return GLMethod.disableVertexAttribArray;
    case 42:
    case "drawArrays":
      return GLMethod.drawArrays;
    case 43:
    case "drawElements":
      return GLMethod.drawElements;
    case 44:
    case "enable":
      return GLMethod.enable;
    case 45:
    case "enableVertexAttribArray":
      return GLMethod.enableVertexAttribArray;
    case 46:
    case "finish":
      return GLMethod.finish;
    case 47:
    case "flush":
      return GLMethod.flush;
    case 48:
    case "framebufferRenderbuffer":
      return GLMethod.framebufferRenderbuffer;
    case 49:
    case "framebufferTexture2D":
      return GLMethod.framebufferTexture2D;
    case 50:
    case "frontFace":
      return GLMethod.frontFace;
    case 51:
    case "generateMipmap":
      return GLMethod.generateMipmap;
    case 52:
    case "getActiveAttrib":
      return GLMethod.getActiveAttrib;
    case 53:
    case "getActiveUniform":
      return GLMethod.getActiveUniform;
    case 54:
    case "getAttachedShaders":
      return GLMethod.getAttachedShaders;
    case 55:
    case "getAttribLocation":
      return GLMethod.getAttribLocation;
    case 56:
    case "getBufferParameter":
      return GLMethod.getBufferParameter;
    case 57:
    case "getContextAttributes":
      return GLMethod.getContextAttributes;
    case 58:
    case "getError":
      return GLMethod.getError;
    case 59:
    case "getExtension":
      return GLMethod.getExtension;
    case 60:
    case "getFramebufferAttachmentParameter":
      return GLMethod.getFramebufferAttachmentParameter;
    case 61:
    case "getParameter":
      return GLMethod.getParameter;
    case 62:
    case "getProgramInfoLog":
      return GLMethod.getProgramInfoLog;
    case 63:
    case "getProgramParameter":
      return GLMethod.getProgramParameter;
    case 64:
    case "getRenderbufferParameter":
      return GLMethod.getRenderbufferParameter;
    case 65:
    case "getShaderInfoLog":
      return GLMethod.getShaderInfoLog;
    case 66:
    case "getShaderParameter":
      return GLMethod.getShaderParameter;
    case 67:
    case "getShaderPrecisionFormat":
      return GLMethod.getShaderPrecisionFormat;
    case 68:
    case "getShaderSource":
      return GLMethod.getShaderSource;
    case 69:
    case "getSupportedExtensions":
      return GLMethod.getSupportedExtensions;
    case 70:
    case "getTexParameter":
      return GLMethod.getTexParameter;
    case 71:
    case "getUniform":
      return GLMethod.getUniform;
    case 72:
    case "getUniformLocation":
      return GLMethod.getUniformLocation;
    case 73:
    case "getVertexAttrib":
      return GLMethod.getVertexAttrib;
    case 74:
    case "getVertexAttribOffset":
      return GLMethod.getVertexAttribOffset;
    case 75:
    case "hint":
      return GLMethod.hint;
    case 76:
    case "isBuffer":
      return GLMethod.isBuffer;
    case 77:
    case "isContextLost":
      return GLMethod.isContextLost;
    case 78:
    case "isEnabled":
      return GLMethod.isEnabled;
    case 79:
    case "isFramebuffer":
      return GLMethod.isFramebuffer;
    case 80:
    case "isProgram":
      return GLMethod.isProgram;
    case 81:
    case "isRenderbuffer":
      return GLMethod.isRenderbuffer;
    case 82:
    case "isShader":
      return GLMethod.isShader;
    case 83:
    case "isTexture":
      return GLMethod.isTexture;
    case 84:
    case "lineWidth":
      return GLMethod.lineWidth;
    case 85:
    case "linkProgram":
      return GLMethod.linkProgram;
    case 86:
    case "polygonOffset":
      return GLMethod.polygonOffset;
    case 87:
    case "renderbufferStorage":
      return GLMethod.renderbufferStorage;
    case 88:
    case "sampleCoverage":
      return GLMethod.sampleCoverage;
    case 89:
    case "scissor":
      return GLMethod.scissor;
    case 90:
    case "shaderSource":
      return GLMethod.shaderSource;
    case 91:
    case "stencilFunc":
      return GLMethod.stencilFunc;
    case 92:
    case "stencilFuncSeparate":
      return GLMethod.stencilFuncSeparate;
    case 93:
    case "stencilMask":
      return GLMethod.stencilMask;
    case 94:
    case "stencilMaskSeparate":
      return GLMethod.stencilMaskSeparate;
    case 95:
    case "stencilOp":
      return GLMethod.stencilOp;
    case 96:
    case "stencilOpSeparate":
      return GLMethod.stencilOpSeparate;
    case 97:
    case "texParameterf":
      return GLMethod.texParameterf;
    case 98:
    case "texParameteri":
      return GLMethod.texParameteri;
    case 99:
    case "uniform1f":
      return GLMethod.uniform1f;
    case 100:
    case "uniform1i":
      return GLMethod.uniform1i;
    case 101:
    case "uniform2f":
      return GLMethod.uniform2f;
    case 102:
    case "uniform2i":
      return GLMethod.uniform2i;
    case 103:
    case "uniform3f":
      return GLMethod.uniform3f;
    case 104:
    case "uniform3i":
      return GLMethod.uniform3i;
    case 105:
    case "uniform4f":
      return GLMethod.uniform4f;
    case 106:
    case "uniform4i":
      return GLMethod.uniform4i;
    case 107:
    case "useProgram":
      return GLMethod.useProgram;
    case 108:
    case "validateProgram":
      return GLMethod.validateProgram;
    case 109:
    case "vertexAttrib1f":
      return GLMethod.vertexAttrib1f;
    case 110:
    case "vertexAttrib2f":
      return GLMethod.vertexAttrib2f;
    case 111:
    case "vertexAttrib3f":
      return GLMethod.vertexAttrib3f;
    case 112:
    case "vertexAttrib4f":
      return GLMethod.vertexAttrib4f;
    case 113:
    case "vertexAttribPointer":
      return GLMethod.vertexAttribPointer;
    case 114:
    case "viewport":
      return GLMethod.viewport;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GLMethod.UNRECOGNIZED;
  }
}
function gLMethodToJSON(object) {
  switch (object) {
    case GLMethod.activeTexture:
      return 0;
    case GLMethod.attachShader:
      return 1;
    case GLMethod.bindAttribLocation:
      return 2;
    case GLMethod.bindBuffer:
      return 3;
    case GLMethod.bindFramebuffer:
      return 4;
    case GLMethod.bindRenderbuffer:
      return 5;
    case GLMethod.bindTexture:
      return 6;
    case GLMethod.blendColor:
      return 7;
    case GLMethod.blendEquation:
      return 8;
    case GLMethod.blendEquationSeparate:
      return 9;
    case GLMethod.blendFunc:
      return 10;
    case GLMethod.blendFuncSeparate:
      return 11;
    case GLMethod.bufferData:
      return 12;
    case GLMethod.bufferSubData:
      return 13;
    case GLMethod.checkFramebufferStatus:
      return 14;
    case GLMethod.clear:
      return 15;
    case GLMethod.clearColor:
      return 16;
    case GLMethod.clearDepth:
      return 17;
    case GLMethod.clearStencil:
      return 18;
    case GLMethod.colorMask:
      return 19;
    case GLMethod.compileShader:
      return 20;
    case GLMethod.copyTexImage2D:
      return 21;
    case GLMethod.copyTexSubImage2D:
      return 22;
    case GLMethod.createBuffer:
      return 23;
    case GLMethod.createFramebuffer:
      return 24;
    case GLMethod.createProgram:
      return 25;
    case GLMethod.createRenderbuffer:
      return 26;
    case GLMethod.createShader:
      return 27;
    case GLMethod.createTexture:
      return 28;
    case GLMethod.cullFace:
      return 29;
    case GLMethod.deleteBuffer:
      return 30;
    case GLMethod.deleteFramebuffer:
      return 31;
    case GLMethod.deleteProgram:
      return 32;
    case GLMethod.deleteRenderbuffer:
      return 33;
    case GLMethod.deleteShader:
      return 34;
    case GLMethod.deleteTexture:
      return 35;
    case GLMethod.depthFunc:
      return 36;
    case GLMethod.depthMask:
      return 37;
    case GLMethod.depthRange:
      return 38;
    case GLMethod.detachShader:
      return 39;
    case GLMethod.disable:
      return 40;
    case GLMethod.disableVertexAttribArray:
      return 41;
    case GLMethod.drawArrays:
      return 42;
    case GLMethod.drawElements:
      return 43;
    case GLMethod.enable:
      return 44;
    case GLMethod.enableVertexAttribArray:
      return 45;
    case GLMethod.finish:
      return 46;
    case GLMethod.flush:
      return 47;
    case GLMethod.framebufferRenderbuffer:
      return 48;
    case GLMethod.framebufferTexture2D:
      return 49;
    case GLMethod.frontFace:
      return 50;
    case GLMethod.generateMipmap:
      return 51;
    case GLMethod.getActiveAttrib:
      return 52;
    case GLMethod.getActiveUniform:
      return 53;
    case GLMethod.getAttachedShaders:
      return 54;
    case GLMethod.getAttribLocation:
      return 55;
    case GLMethod.getBufferParameter:
      return 56;
    case GLMethod.getContextAttributes:
      return 57;
    case GLMethod.getError:
      return 58;
    case GLMethod.getExtension:
      return 59;
    case GLMethod.getFramebufferAttachmentParameter:
      return 60;
    case GLMethod.getParameter:
      return 61;
    case GLMethod.getProgramInfoLog:
      return 62;
    case GLMethod.getProgramParameter:
      return 63;
    case GLMethod.getRenderbufferParameter:
      return 64;
    case GLMethod.getShaderInfoLog:
      return 65;
    case GLMethod.getShaderParameter:
      return 66;
    case GLMethod.getShaderPrecisionFormat:
      return 67;
    case GLMethod.getShaderSource:
      return 68;
    case GLMethod.getSupportedExtensions:
      return 69;
    case GLMethod.getTexParameter:
      return 70;
    case GLMethod.getUniform:
      return 71;
    case GLMethod.getUniformLocation:
      return 72;
    case GLMethod.getVertexAttrib:
      return 73;
    case GLMethod.getVertexAttribOffset:
      return 74;
    case GLMethod.hint:
      return 75;
    case GLMethod.isBuffer:
      return 76;
    case GLMethod.isContextLost:
      return 77;
    case GLMethod.isEnabled:
      return 78;
    case GLMethod.isFramebuffer:
      return 79;
    case GLMethod.isProgram:
      return 80;
    case GLMethod.isRenderbuffer:
      return 81;
    case GLMethod.isShader:
      return 82;
    case GLMethod.isTexture:
      return 83;
    case GLMethod.lineWidth:
      return 84;
    case GLMethod.linkProgram:
      return 85;
    case GLMethod.polygonOffset:
      return 86;
    case GLMethod.renderbufferStorage:
      return 87;
    case GLMethod.sampleCoverage:
      return 88;
    case GLMethod.scissor:
      return 89;
    case GLMethod.shaderSource:
      return 90;
    case GLMethod.stencilFunc:
      return 91;
    case GLMethod.stencilFuncSeparate:
      return 92;
    case GLMethod.stencilMask:
      return 93;
    case GLMethod.stencilMaskSeparate:
      return 94;
    case GLMethod.stencilOp:
      return 95;
    case GLMethod.stencilOpSeparate:
      return 96;
    case GLMethod.texParameterf:
      return 97;
    case GLMethod.texParameteri:
      return 98;
    case GLMethod.uniform1f:
      return 99;
    case GLMethod.uniform1i:
      return 100;
    case GLMethod.uniform2f:
      return 101;
    case GLMethod.uniform2i:
      return 102;
    case GLMethod.uniform3f:
      return 103;
    case GLMethod.uniform3i:
      return 104;
    case GLMethod.uniform4f:
      return 105;
    case GLMethod.uniform4i:
      return 106;
    case GLMethod.useProgram:
      return 107;
    case GLMethod.validateProgram:
      return 108;
    case GLMethod.vertexAttrib1f:
      return 109;
    case GLMethod.vertexAttrib2f:
      return 110;
    case GLMethod.vertexAttrib3f:
      return 111;
    case GLMethod.vertexAttrib4f:
      return 112;
    case GLMethod.vertexAttribPointer:
      return 113;
    case GLMethod.viewport:
      return 114;
    case GLMethod.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/plugin/gl/glrenderer.js
var import_long11 = __toESM(require_long(), 1);
var import_minimal95 = __toESM(require_minimal2(), 1);
function createBaseCommandArgument() {
  return { null: void 0, scalar: void 0, blob: void 0, referenceId: void 0 };
}
var CommandArgument = {
  $type: "devvit.plugin.gl.CommandArgument",
  encode(message, writer = import_minimal95.default.Writer.create()) {
    if (message.null !== void 0) {
      writer.uint32(8).bool(message.null);
    }
    if (message.scalar !== void 0) {
      Value.encode(Value.wrap(message.scalar), writer.uint32(18).fork()).ldelim();
    }
    if (message.blob !== void 0) {
      writer.uint32(26).bytes(message.blob);
    }
    if (message.referenceId !== void 0) {
      writer.uint32(32).uint64(message.referenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal95.default.Reader ? input : import_minimal95.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandArgument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.null = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.scalar = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.blob = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.referenceId = longToNumber11(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      null: isSet89(object.null) ? globalThis.Boolean(object.null) : void 0,
      scalar: isSet89(object?.scalar) ? object.scalar : void 0,
      blob: isSet89(object.blob) ? bytesFromBase646(object.blob) : void 0,
      referenceId: isSet89(object.referenceId) ? globalThis.Number(object.referenceId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.null !== void 0) {
      obj.null = message.null;
    }
    if (message.scalar !== void 0) {
      obj.scalar = message.scalar;
    }
    if (message.blob !== void 0) {
      obj.blob = base64FromBytes6(message.blob);
    }
    if (message.referenceId !== void 0) {
      obj.referenceId = Math.round(message.referenceId);
    }
    return obj;
  },
  create(base) {
    return CommandArgument.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommandArgument();
    message.null = object.null ?? void 0;
    message.scalar = object.scalar ?? void 0;
    message.blob = object.blob ?? void 0;
    message.referenceId = object.referenceId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CommandArgument.$type, CommandArgument);
function createBaseGLCommand() {
  return { method: 0, type: 0, args: [], referenceId: 0 };
}
var GLCommand = {
  $type: "devvit.plugin.gl.GLCommand",
  encode(message, writer = import_minimal95.default.Writer.create()) {
    if (message.method !== 0) {
      writer.uint32(8).int32(message.method);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.args) {
      CommandArgument.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.referenceId !== 0) {
      writer.uint32(32).uint64(message.referenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal95.default.Reader ? input : import_minimal95.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGLCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.method = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.args.push(CommandArgument.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.referenceId = longToNumber11(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      method: isSet89(object.method) ? gLMethodFromJSON(object.method) : 0,
      type: isSet89(object.type) ? gLMethodTypeFromJSON(object.type) : 0,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e) => CommandArgument.fromJSON(e)) : [],
      referenceId: isSet89(object.referenceId) ? globalThis.Number(object.referenceId) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.method !== 0) {
      obj.method = gLMethodToJSON(message.method);
    }
    if (message.type !== 0) {
      obj.type = gLMethodTypeToJSON(message.type);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => CommandArgument.toJSON(e));
    }
    if (message.referenceId !== 0) {
      obj.referenceId = Math.round(message.referenceId);
    }
    return obj;
  },
  create(base) {
    return GLCommand.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGLCommand();
    message.method = object.method ?? 0;
    message.type = object.type ?? 0;
    message.args = object.args?.map((e) => CommandArgument.fromPartial(e)) || [];
    message.referenceId = object.referenceId ?? 0;
    return message;
  }
};
messageTypeRegistry.set(GLCommand.$type, GLCommand);
function createBaseExecuteMessage() {
  return { commands: [] };
}
var ExecuteMessage = {
  $type: "devvit.plugin.gl.ExecuteMessage",
  encode(message, writer = import_minimal95.default.Writer.create()) {
    for (const v of message.commands) {
      GLCommand.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal95.default.Reader ? input : import_minimal95.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExecuteMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.commands.push(GLCommand.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      commands: globalThis.Array.isArray(object?.commands) ? object.commands.map((e) => GLCommand.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => GLCommand.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ExecuteMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseExecuteMessage();
    message.commands = object.commands?.map((e) => GLCommand.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ExecuteMessage.$type, ExecuteMessage);
function bytesFromBase646(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes6(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function longToNumber11(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal95.default.util.Long !== import_long11.default) {
  import_minimal95.default.util.Long = import_long11.default;
  import_minimal95.default.configure();
}
function isSet89(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/devserver/testcases.js
var import_minimal96 = __toESM(require_minimal2(), 1);
function createBaseTestCasesList() {
  return { actorName: "", testCases: [] };
}
var TestCasesList = {
  $type: "devvit.plugin.devserver.TestCasesList",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.actorName !== "") {
      writer.uint32(10).string(message.actorName);
    }
    for (const v of message.testCases) {
      TestCase.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : import_minimal96.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestCasesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actorName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.testCases.push(TestCase.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actorName: isSet90(object.actorName) ? globalThis.String(object.actorName) : "",
      testCases: globalThis.Array.isArray(object?.testCases) ? object.testCases.map((e) => TestCase.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actorName !== "") {
      obj.actorName = message.actorName;
    }
    if (message.testCases?.length) {
      obj.testCases = message.testCases.map((e) => TestCase.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return TestCasesList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTestCasesList();
    message.actorName = object.actorName ?? "";
    message.testCases = object.testCases?.map((e) => TestCase.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(TestCasesList.$type, TestCasesList);
function createBaseTestCase() {
  return { methodName: "", testName: "", testInput: "" };
}
var TestCase = {
  $type: "devvit.plugin.devserver.TestCase",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.methodName !== "") {
      writer.uint32(10).string(message.methodName);
    }
    if (message.testName !== "") {
      writer.uint32(18).string(message.testName);
    }
    if (message.testInput !== "") {
      writer.uint32(26).string(message.testInput);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : import_minimal96.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.methodName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.testName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.testInput = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      methodName: isSet90(object.methodName) ? globalThis.String(object.methodName) : "",
      testName: isSet90(object.testName) ? globalThis.String(object.testName) : "",
      testInput: isSet90(object.testInput) ? globalThis.String(object.testInput) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.testName !== "") {
      obj.testName = message.testName;
    }
    if (message.testInput !== "") {
      obj.testInput = message.testInput;
    }
    return obj;
  },
  create(base) {
    return TestCase.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTestCase();
    message.methodName = object.methodName ?? "";
    message.testName = object.testName ?? "";
    message.testInput = object.testInput ?? "";
    return message;
  }
};
messageTypeRegistry.set(TestCase.$type, TestCase);
function isSet90(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/devserver/devserver.js
var import_minimal97 = __toESM(require_minimal2(), 1);
function createBaseProjectListRequest() {
  return { projectRootDirectory: "" };
}
var ProjectListRequest = {
  $type: "devvit.plugin.devserver.ProjectListRequest",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.projectRootDirectory = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectRootDirectory: isSet91(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.projectRootDirectory !== "") {
      obj.projectRootDirectory = message.projectRootDirectory;
    }
    return obj;
  },
  create(base) {
    return ProjectListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectListRequest();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    return message;
  }
};
messageTypeRegistry.set(ProjectListRequest.$type, ProjectListRequest);
function createBaseProjectBuildProblems() {
  return { warnings: [], errors: [] };
}
var ProjectBuildProblems = {
  $type: "devvit.plugin.devserver.ProjectBuildProblems",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    for (const v of message.warnings) {
      CompileLog.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectBuildProblems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.warnings.push(CompileLog.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.errors.push(CompileLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e) => CompileLog.fromJSON(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => CompileLog.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => CompileLog.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ProjectBuildProblems.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectBuildProblems();
    message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ProjectBuildProblems.$type, ProjectBuildProblems);
function createBaseProjectListingResponse() {
  return { projectRootDirectory: "", projectFileSystem: void 0, buildProblems: {} };
}
var ProjectListingResponse = {
  $type: "devvit.plugin.devserver.ProjectListingResponse",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    if (message.projectFileSystem !== void 0) {
      FileSystem.encode(message.projectFileSystem, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.buildProblems).forEach(([key, value]) => {
      ProjectListingResponse_BuildProblemsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectListingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.projectRootDirectory = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.projectFileSystem = FileSystem.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = ProjectListingResponse_BuildProblemsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.buildProblems[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectRootDirectory: isSet91(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : "",
      projectFileSystem: isSet91(object.projectFileSystem) ? FileSystem.fromJSON(object.projectFileSystem) : void 0,
      buildProblems: isObject18(object.buildProblems) ? Object.entries(object.buildProblems).reduce((acc, [key, value]) => {
        acc[key] = ProjectBuildProblems.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.projectRootDirectory !== "") {
      obj.projectRootDirectory = message.projectRootDirectory;
    }
    if (message.projectFileSystem !== void 0) {
      obj.projectFileSystem = FileSystem.toJSON(message.projectFileSystem);
    }
    if (message.buildProblems) {
      const entries = Object.entries(message.buildProblems);
      if (entries.length > 0) {
        obj.buildProblems = {};
        entries.forEach(([k, v]) => {
          obj.buildProblems[k] = ProjectBuildProblems.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return ProjectListingResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectListingResponse();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    message.projectFileSystem = object.projectFileSystem !== void 0 && object.projectFileSystem !== null ? FileSystem.fromPartial(object.projectFileSystem) : void 0;
    message.buildProblems = Object.entries(object.buildProblems ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ProjectBuildProblems.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ProjectListingResponse.$type, ProjectListingResponse);
function createBaseProjectListingResponse_BuildProblemsEntry() {
  return { key: "", value: void 0 };
}
var ProjectListingResponse_BuildProblemsEntry = {
  $type: "devvit.plugin.devserver.ProjectListingResponse.BuildProblemsEntry",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ProjectBuildProblems.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectListingResponse_BuildProblemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ProjectBuildProblems.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet91(object.key) ? globalThis.String(object.key) : "",
      value: isSet91(object.value) ? ProjectBuildProblems.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ProjectBuildProblems.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ProjectListingResponse_BuildProblemsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectListingResponse_BuildProblemsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ProjectBuildProblems.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ProjectListingResponse_BuildProblemsEntry.$type, ProjectListingResponse_BuildProblemsEntry);
function createBaseProjectUpdatesRequest() {
  return { projectRootDirectory: "" };
}
var ProjectUpdatesRequest = {
  $type: "devvit.plugin.devserver.ProjectUpdatesRequest",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectUpdatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.projectRootDirectory = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectRootDirectory: isSet91(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.projectRootDirectory !== "") {
      obj.projectRootDirectory = message.projectRootDirectory;
    }
    return obj;
  },
  create(base) {
    return ProjectUpdatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectUpdatesRequest();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    return message;
  }
};
messageTypeRegistry.set(ProjectUpdatesRequest.$type, ProjectUpdatesRequest);
function createBaseProjectUpdateResponse() {
  return { projectRootDirectory: "", file: void 0, linkedBundle: void 0, actorPath: "", buildProblems: {} };
}
var ProjectUpdateResponse = {
  $type: "devvit.plugin.devserver.ProjectUpdateResponse",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    if (message.file !== void 0) {
      File.encode(message.file, writer.uint32(18).fork()).ldelim();
    }
    if (message.linkedBundle !== void 0) {
      LinkedBundle.encode(message.linkedBundle, writer.uint32(26).fork()).ldelim();
    }
    if (message.actorPath !== "") {
      writer.uint32(34).string(message.actorPath);
    }
    Object.entries(message.buildProblems).forEach(([key, value]) => {
      ProjectUpdateResponse_BuildProblemsEntry.encode({ key, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.projectRootDirectory = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.file = File.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.linkedBundle = LinkedBundle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.actorPath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          const entry5 = ProjectUpdateResponse_BuildProblemsEntry.decode(reader, reader.uint32());
          if (entry5.value !== void 0) {
            message.buildProblems[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectRootDirectory: isSet91(object.projectRootDirectory) ? globalThis.String(object.projectRootDirectory) : "",
      file: isSet91(object.file) ? File.fromJSON(object.file) : void 0,
      linkedBundle: isSet91(object.linkedBundle) ? LinkedBundle.fromJSON(object.linkedBundle) : void 0,
      actorPath: isSet91(object.actorPath) ? globalThis.String(object.actorPath) : "",
      buildProblems: isObject18(object.buildProblems) ? Object.entries(object.buildProblems).reduce((acc, [key, value]) => {
        acc[key] = ProjectBuildProblems.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.projectRootDirectory !== "") {
      obj.projectRootDirectory = message.projectRootDirectory;
    }
    if (message.file !== void 0) {
      obj.file = File.toJSON(message.file);
    }
    if (message.linkedBundle !== void 0) {
      obj.linkedBundle = LinkedBundle.toJSON(message.linkedBundle);
    }
    if (message.actorPath !== "") {
      obj.actorPath = message.actorPath;
    }
    if (message.buildProblems) {
      const entries = Object.entries(message.buildProblems);
      if (entries.length > 0) {
        obj.buildProblems = {};
        entries.forEach(([k, v]) => {
          obj.buildProblems[k] = ProjectBuildProblems.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return ProjectUpdateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectUpdateResponse();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    message.file = object.file !== void 0 && object.file !== null ? File.fromPartial(object.file) : void 0;
    message.linkedBundle = object.linkedBundle !== void 0 && object.linkedBundle !== null ? LinkedBundle.fromPartial(object.linkedBundle) : void 0;
    message.actorPath = object.actorPath ?? "";
    message.buildProblems = Object.entries(object.buildProblems ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ProjectBuildProblems.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ProjectUpdateResponse.$type, ProjectUpdateResponse);
function createBaseProjectUpdateResponse_BuildProblemsEntry() {
  return { key: "", value: void 0 };
}
var ProjectUpdateResponse_BuildProblemsEntry = {
  $type: "devvit.plugin.devserver.ProjectUpdateResponse.BuildProblemsEntry",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ProjectBuildProblems.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectUpdateResponse_BuildProblemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ProjectBuildProblems.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet91(object.key) ? globalThis.String(object.key) : "",
      value: isSet91(object.value) ? ProjectBuildProblems.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ProjectBuildProblems.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ProjectUpdateResponse_BuildProblemsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProjectUpdateResponse_BuildProblemsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ProjectBuildProblems.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ProjectUpdateResponse_BuildProblemsEntry.$type, ProjectUpdateResponse_BuildProblemsEntry);
function createBaseTestCasesRequest() {
  return { actorName: "" };
}
var TestCasesRequest = {
  $type: "devvit.plugin.devserver.TestCasesRequest",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.actorName !== "") {
      writer.uint32(10).string(message.actorName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actorName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { actorName: isSet91(object.actorName) ? globalThis.String(object.actorName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.actorName !== "") {
      obj.actorName = message.actorName;
    }
    return obj;
  },
  create(base) {
    return TestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTestCasesRequest();
    message.actorName = object.actorName ?? "";
    return message;
  }
};
messageTypeRegistry.set(TestCasesRequest.$type, TestCasesRequest);
function createBaseAuthenticationRequest() {
  return {};
}
var AuthenticationRequest = {
  $type: "devvit.plugin.devserver.AuthenticationRequest",
  encode(_, writer = import_minimal97.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return AuthenticationRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseAuthenticationRequest();
    return message;
  }
};
messageTypeRegistry.set(AuthenticationRequest.$type, AuthenticationRequest);
function createBaseAuthenticationResponse() {
  return { storedToken: void 0 };
}
var AuthenticationResponse = {
  $type: "devvit.plugin.devserver.AuthenticationResponse",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.storedToken !== void 0) {
      StoredToken.encode(message.storedToken, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.storedToken = StoredToken.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { storedToken: isSet91(object.storedToken) ? StoredToken.fromJSON(object.storedToken) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.storedToken !== void 0) {
      obj.storedToken = StoredToken.toJSON(message.storedToken);
    }
    return obj;
  },
  create(base) {
    return AuthenticationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAuthenticationResponse();
    message.storedToken = object.storedToken !== void 0 && object.storedToken !== null ? StoredToken.fromPartial(object.storedToken) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AuthenticationResponse.$type, AuthenticationResponse);
function createBaseValidationRequest() {
  return {};
}
var ValidationRequest = {
  $type: "devvit.plugin.devserver.ValidationRequest",
  encode(_, writer = import_minimal97.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ValidationRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseValidationRequest();
    return message;
  }
};
messageTypeRegistry.set(ValidationRequest.$type, ValidationRequest);
function createBaseStoredToken() {
  return { refreshToken: "", accessToken: "", expiresAt: void 0, scope: "", tokenType: "" };
}
var StoredToken = {
  $type: "devvit.plugin.devserver.StoredToken",
  encode(message, writer = import_minimal97.default.Writer.create()) {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.expiresAt !== void 0) {
      Timestamp.encode(toTimestamp15(message.expiresAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== "") {
      writer.uint32(34).string(message.scope);
    }
    if (message.tokenType !== "") {
      writer.uint32(42).string(message.tokenType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal97.default.Reader ? input : import_minimal97.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoredToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.refreshToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.expiresAt = fromTimestamp15(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.scope = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.tokenType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      refreshToken: isSet91(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      accessToken: isSet91(object.accessToken) ? globalThis.String(object.accessToken) : "",
      expiresAt: isSet91(object.expiresAt) ? fromJsonTimestamp15(object.expiresAt) : void 0,
      scope: isSet91(object.scope) ? globalThis.String(object.scope) : "",
      tokenType: isSet91(object.tokenType) ? globalThis.String(object.tokenType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.expiresAt !== void 0) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    return obj;
  },
  create(base) {
    return StoredToken.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStoredToken();
    message.refreshToken = object.refreshToken ?? "";
    message.accessToken = object.accessToken ?? "";
    message.expiresAt = object.expiresAt ?? void 0;
    message.scope = object.scope ?? "";
    message.tokenType = object.tokenType ?? "";
    return message;
  }
};
messageTypeRegistry.set(StoredToken.$type, StoredToken);
function toTimestamp15(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp15(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp15(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp15(Timestamp.fromJSON(o));
  }
}
function isObject18(value) {
  return typeof value === "object" && value !== null;
}
function isSet91(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/clock/clock.js
var import_minimal98 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/buildpack/buildpack.js
var import_minimal99 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/builder/builder.js
var import_minimal100 = __toESM(require_minimal2(), 1);
function createBaseBuildResponse() {
  return { bundle: void 0, errors: [], warnings: [] };
}
var BuildResponse = {
  $type: "devvit.plugin.builder.BuildResponse",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.bundle !== void 0) {
      LinkedBundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.warnings) {
      CompileLog.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : import_minimal100.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.bundle = LinkedBundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.errors.push(CompileLog.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.warnings.push(CompileLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet92(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : void 0,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : [],
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e) => CompileLog.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bundle !== void 0) {
      obj.bundle = LinkedBundle.toJSON(message.bundle);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => CompileLog.toJSON(e));
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => CompileLog.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return BuildResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBuildResponse();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? LinkedBundle.fromPartial(object.bundle) : void 0;
    message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(BuildResponse.$type, BuildResponse);
function isSet92(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/automodregex/automodregex.js
var import_minimal101 = __toESM(require_minimal2(), 1);
function createBaseAutomodRegexInput() {
  return { pattern: "", input: "", caseInsensitive: false };
}
var AutomodRegexInput = {
  $type: "devvit.plugin.automodregex.AutomodRegexInput",
  encode(message, writer = import_minimal101.default.Writer.create()) {
    if (message.pattern !== "") {
      writer.uint32(10).string(message.pattern);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(24).bool(message.caseInsensitive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal101.default.Reader ? input : import_minimal101.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodRegexInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.pattern = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.input = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.caseInsensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pattern: isSet93(object.pattern) ? globalThis.String(object.pattern) : "",
      input: isSet93(object.input) ? globalThis.String(object.input) : "",
      caseInsensitive: isSet93(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    return obj;
  },
  create(base) {
    return AutomodRegexInput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomodRegexInput();
    message.pattern = object.pattern ?? "";
    message.input = object.input ?? "";
    message.caseInsensitive = object.caseInsensitive ?? false;
    return message;
  }
};
messageTypeRegistry.set(AutomodRegexInput.$type, AutomodRegexInput);
function createBaseAutomodRegexMatchOutput() {
  return { groups: [] };
}
var AutomodRegexMatchOutput = {
  $type: "devvit.plugin.automodregex.AutomodRegexMatchOutput",
  encode(message, writer = import_minimal101.default.Writer.create()) {
    for (const v of message.groups) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal101.default.Reader ? input : import_minimal101.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodRegexMatchOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.groups.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.groups?.length) {
      obj.groups = message.groups;
    }
    return obj;
  },
  create(base) {
    return AutomodRegexMatchOutput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomodRegexMatchOutput();
    message.groups = object.groups?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(AutomodRegexMatchOutput.$type, AutomodRegexMatchOutput);
function createBaseAutomodRegexTestOutput() {
  return { match: false };
}
var AutomodRegexTestOutput = {
  $type: "devvit.plugin.automodregex.AutomodRegexTestOutput",
  encode(message, writer = import_minimal101.default.Writer.create()) {
    if (message.match !== false) {
      writer.uint32(8).bool(message.match);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal101.default.Reader ? input : import_minimal101.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodRegexTestOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.match = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { match: isSet93(object.match) ? globalThis.Boolean(object.match) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.match !== false) {
      obj.match = message.match;
    }
    return obj;
  },
  create(base) {
    return AutomodRegexTestOutput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomodRegexTestOutput();
    message.match = object.match ?? false;
    return message;
  }
};
messageTypeRegistry.set(AutomodRegexTestOutput.$type, AutomodRegexTestOutput);
function isSet93(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/assetresolver/assetresolver.js
var import_minimal102 = __toESM(require_minimal2(), 1);
function createBaseGetAssetURLRequest() {
  return { path: "" };
}
var GetAssetURLRequest = {
  $type: "devvit.plugin.assetresolver.GetAssetURLRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : import_minimal102.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAssetURLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { path: isSet94(object.path) ? globalThis.String(object.path) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },
  create(base) {
    return GetAssetURLRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAssetURLRequest();
    message.path = object.path ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetAssetURLRequest.$type, GetAssetURLRequest);
function createBaseGetAssetURLResponse() {
  return { url: "", found: false };
}
var GetAssetURLResponse = {
  $type: "devvit.plugin.assetresolver.GetAssetURLResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : import_minimal102.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAssetURLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.found = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet94(object.url) ? globalThis.String(object.url) : "",
      found: isSet94(object.found) ? globalThis.Boolean(object.found) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  create(base) {
    return GetAssetURLResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetAssetURLResponse();
    message.url = object.url ?? "";
    message.found = object.found ?? false;
    return message;
  }
};
messageTypeRegistry.set(GetAssetURLResponse.$type, GetAssetURLResponse);
function createBaseGetMultipleAssetURLsRequest() {
  return { paths: [] };
}
var GetMultipleAssetURLsRequest = {
  $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    for (const v of message.paths) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : import_minimal102.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetMultipleAssetURLsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.paths.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },
  create(base) {
    return GetMultipleAssetURLsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetMultipleAssetURLsRequest();
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(GetMultipleAssetURLsRequest.$type, GetMultipleAssetURLsRequest);
function createBaseGetMultipleAssetURLsResponse() {
  return { urls: {} };
}
var GetMultipleAssetURLsResponse = {
  $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    Object.entries(message.urls).forEach(([key, value]) => {
      GetMultipleAssetURLsResponse_UrlsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : import_minimal102.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetMultipleAssetURLsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = GetMultipleAssetURLsResponse_UrlsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.urls[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      urls: isObject19(object.urls) ? Object.entries(object.urls).reduce((acc, [key, value]) => {
        acc[key] = GetMultipleAssetURLsResponse_GlobResult.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.urls) {
      const entries = Object.entries(message.urls);
      if (entries.length > 0) {
        obj.urls = {};
        entries.forEach(([k, v]) => {
          obj.urls[k] = GetMultipleAssetURLsResponse_GlobResult.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return GetMultipleAssetURLsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetMultipleAssetURLsResponse();
    message.urls = Object.entries(object.urls ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = GetMultipleAssetURLsResponse_GlobResult.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(GetMultipleAssetURLsResponse.$type, GetMultipleAssetURLsResponse);
function createBaseGetMultipleAssetURLsResponse_GlobResult() {
  return { found: false, paths: [] };
}
var GetMultipleAssetURLsResponse_GlobResult = {
  $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse.GlobResult",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    for (const v of message.paths) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : import_minimal102.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetMultipleAssetURLsResponse_GlobResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.found = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.paths.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      found: isSet94(object.found) ? globalThis.Boolean(object.found) : false,
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },
  create(base) {
    return GetMultipleAssetURLsResponse_GlobResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetMultipleAssetURLsResponse_GlobResult();
    message.found = object.found ?? false;
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(GetMultipleAssetURLsResponse_GlobResult.$type, GetMultipleAssetURLsResponse_GlobResult);
function createBaseGetMultipleAssetURLsResponse_UrlsEntry() {
  return { key: "", value: void 0 };
}
var GetMultipleAssetURLsResponse_UrlsEntry = {
  $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse.UrlsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      GetMultipleAssetURLsResponse_GlobResult.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : import_minimal102.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetMultipleAssetURLsResponse_UrlsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = GetMultipleAssetURLsResponse_GlobResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet94(object.key) ? globalThis.String(object.key) : "",
      value: isSet94(object.value) ? GetMultipleAssetURLsResponse_GlobResult.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = GetMultipleAssetURLsResponse_GlobResult.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetMultipleAssetURLsResponse_UrlsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetMultipleAssetURLsResponse_UrlsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? GetMultipleAssetURLsResponse_GlobResult.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetMultipleAssetURLsResponse_UrlsEntry.$type, GetMultipleAssetURLsResponse_UrlsEntry);
function isObject19(value) {
  return typeof value === "object" && value !== null;
}
function isSet94(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/v1alpha/triggers.js
var import_minimal105 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/data/triggers/v1alpha/triggers.js
var import_minimal104 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/events/v1alpha/events.js
var import_minimal103 = __toESM(require_minimal2(), 1);
var EventSource;
(function(EventSource2) {
  EventSource2[EventSource2["UNKNOWN_EVENT_SOURCE"] = 0] = "UNKNOWN_EVENT_SOURCE";
  EventSource2[EventSource2["USER"] = 1] = "USER";
  EventSource2[EventSource2["ADMIN"] = 2] = "ADMIN";
  EventSource2[EventSource2["MODERATOR"] = 3] = "MODERATOR";
  EventSource2[EventSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EventSource || (EventSource = {}));
function eventSourceFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_EVENT_SOURCE":
      return EventSource.UNKNOWN_EVENT_SOURCE;
    case 1:
    case "USER":
      return EventSource.USER;
    case 2:
    case "ADMIN":
      return EventSource.ADMIN;
    case 3:
    case "MODERATOR":
      return EventSource.MODERATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventSource.UNRECOGNIZED;
  }
}
function eventSourceToJSON(object) {
  switch (object) {
    case EventSource.UNKNOWN_EVENT_SOURCE:
      return 0;
    case EventSource.USER:
      return 1;
    case EventSource.ADMIN:
      return 2;
    case EventSource.MODERATOR:
      return 3;
    case EventSource.UNRECOGNIZED:
    default:
      return -1;
  }
}
var DeletionReason;
(function(DeletionReason2) {
  DeletionReason2[DeletionReason2["UNSPECIFIED_DELETION_REASON"] = 0] = "UNSPECIFIED_DELETION_REASON";
  DeletionReason2[DeletionReason2["SPAM"] = 1] = "SPAM";
  DeletionReason2[DeletionReason2["LEGAL"] = 2] = "LEGAL";
  DeletionReason2[DeletionReason2["OTHER"] = 3] = "OTHER";
  DeletionReason2[DeletionReason2["UNKNOWN"] = 4] = "UNKNOWN";
  DeletionReason2[DeletionReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DeletionReason || (DeletionReason = {}));
function deletionReasonFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSPECIFIED_DELETION_REASON":
      return DeletionReason.UNSPECIFIED_DELETION_REASON;
    case 1:
    case "SPAM":
      return DeletionReason.SPAM;
    case 2:
    case "LEGAL":
      return DeletionReason.LEGAL;
    case 3:
    case "OTHER":
      return DeletionReason.OTHER;
    case 4:
    case "UNKNOWN":
      return DeletionReason.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeletionReason.UNRECOGNIZED;
  }
}
function deletionReasonToJSON(object) {
  switch (object) {
    case DeletionReason.UNSPECIFIED_DELETION_REASON:
      return 0;
    case DeletionReason.SPAM:
      return 1;
    case DeletionReason.LEGAL:
      return 2;
    case DeletionReason.OTHER:
      return 3;
    case DeletionReason.UNKNOWN:
      return 4;
    case DeletionReason.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBasePostSubmit() {
  return { post: void 0, author: void 0, subreddit: void 0 };
}
var PostSubmit = {
  $type: "devvit.events.v1alpha.PostSubmit",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostSubmit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return PostSubmit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostSubmit();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostSubmit.$type, PostSubmit);
function createBasePostCreate() {
  return { post: void 0, author: void 0, subreddit: void 0 };
}
var PostCreate = {
  $type: "devvit.events.v1alpha.PostCreate",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return PostCreate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostCreate();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostCreate.$type, PostCreate);
function createBasePostUpdate() {
  return { post: void 0, author: void 0, previousBody: "", subreddit: void 0 };
}
var PostUpdate = {
  $type: "devvit.events.v1alpha.PostUpdate",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.previousBody !== "") {
      writer.uint32(26).string(message.previousBody);
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.previousBody = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      previousBody: isSet95(object.previousBody) ? globalThis.String(object.previousBody) : "",
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.previousBody !== "") {
      obj.previousBody = message.previousBody;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return PostUpdate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostUpdate();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.previousBody = object.previousBody ?? "";
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostUpdate.$type, PostUpdate);
function createBasePostReport() {
  return { post: void 0, subreddit: void 0, reason: "" };
}
var PostReport = {
  $type: "devvit.events.v1alpha.PostReport",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      reason: isSet95(object.reason) ? globalThis.String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return PostReport.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostReport();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set(PostReport.$type, PostReport);
function createBasePostFlairUpdate() {
  return { post: void 0, author: void 0, subreddit: void 0 };
}
var PostFlairUpdate = {
  $type: "devvit.events.v1alpha.PostFlairUpdate",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostFlairUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return PostFlairUpdate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostFlairUpdate();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostFlairUpdate.$type, PostFlairUpdate);
function createBasePostDelete() {
  return {
    postId: "",
    deletedAt: void 0,
    author: void 0,
    createdAt: void 0,
    source: 0,
    reason: 0,
    subreddit: void 0
  };
}
var PostDelete = {
  $type: "devvit.events.v1alpha.PostDelete",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.deletedAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.deletedAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(26).fork()).ldelim();
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.source !== 0) {
      writer.uint32(40).int32(message.source);
    }
    if (message.reason !== 0) {
      writer.uint32(48).int32(message.reason);
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.postId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.deletedAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.createdAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.source = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.reason = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      postId: isSet95(object.postId) ? globalThis.String(object.postId) : "",
      deletedAt: isSet95(object.deletedAt) ? fromJsonTimestamp16(object.deletedAt) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      createdAt: isSet95(object.createdAt) ? fromJsonTimestamp16(object.createdAt) : void 0,
      source: isSet95(object.source) ? eventSourceFromJSON(object.source) : 0,
      reason: isSet95(object.reason) ? deletionReasonFromJSON(object.reason) : 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.postId !== "") {
      obj.postId = message.postId;
    }
    if (message.deletedAt !== void 0) {
      obj.deletedAt = message.deletedAt.toISOString();
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.source !== 0) {
      obj.source = eventSourceToJSON(message.source);
    }
    if (message.reason !== 0) {
      obj.reason = deletionReasonToJSON(message.reason);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return PostDelete.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostDelete();
    message.postId = object.postId ?? "";
    message.deletedAt = object.deletedAt ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.createdAt = object.createdAt ?? void 0;
    message.source = object.source ?? 0;
    message.reason = object.reason ?? 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostDelete.$type, PostDelete);
function createBasePostApprove() {
  return { post: void 0, approvedAt: void 0, author: void 0, source: 0, subreddit: void 0 };
}
var PostApprove = {
  $type: "devvit.events.v1alpha.PostApprove",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.approvedAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.approvedAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(26).fork()).ldelim();
    }
    if (message.source !== 0) {
      writer.uint32(40).int32(message.source);
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostApprove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.approvedAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.source = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      approvedAt: isSet95(object.approvedAt) ? fromJsonTimestamp16(object.approvedAt) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      source: isSet95(object.source) ? eventSourceFromJSON(object.source) : 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.approvedAt !== void 0) {
      obj.approvedAt = message.approvedAt.toISOString();
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.source !== 0) {
      obj.source = eventSourceToJSON(message.source);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return PostApprove.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostApprove();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.approvedAt = object.approvedAt ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.source = object.source ?? 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostApprove.$type, PostApprove);
function createBaseCommentApprove() {
  return {
    comment: void 0,
    post: void 0,
    approvedAt: void 0,
    author: void 0,
    source: 0,
    subreddit: void 0
  };
}
var CommentApprove = {
  $type: "devvit.events.v1alpha.CommentApprove",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(18).fork()).ldelim();
    }
    if (message.approvedAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.approvedAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(34).fork()).ldelim();
    }
    if (message.source !== 0) {
      writer.uint32(48).int32(message.source);
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentApprove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.comment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.approvedAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.source = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet95(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      approvedAt: isSet95(object.approvedAt) ? fromJsonTimestamp16(object.approvedAt) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      source: isSet95(object.source) ? eventSourceFromJSON(object.source) : 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.comment !== void 0) {
      obj.comment = CommentV2.toJSON(message.comment);
    }
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.approvedAt !== void 0) {
      obj.approvedAt = message.approvedAt.toISOString();
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.source !== 0) {
      obj.source = eventSourceToJSON(message.source);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return CommentApprove.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentApprove();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.approvedAt = object.approvedAt ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.source = object.source ?? 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CommentApprove.$type, CommentApprove);
function createBaseCommentSubmit() {
  return { comment: void 0, author: void 0, post: void 0, subreddit: void 0 };
}
var CommentSubmit = {
  $type: "devvit.events.v1alpha.CommentSubmit",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentSubmit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.comment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet95(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.comment !== void 0) {
      obj.comment = CommentV2.toJSON(message.comment);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return CommentSubmit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentSubmit();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CommentSubmit.$type, CommentSubmit);
function createBaseCommentCreate() {
  return { comment: void 0, author: void 0, post: void 0, subreddit: void 0 };
}
var CommentCreate = {
  $type: "devvit.events.v1alpha.CommentCreate",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.comment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet95(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.comment !== void 0) {
      obj.comment = CommentV2.toJSON(message.comment);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return CommentCreate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentCreate();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CommentCreate.$type, CommentCreate);
function createBaseCommentUpdate() {
  return { comment: void 0, author: void 0, post: void 0, previousBody: "", subreddit: void 0 };
}
var CommentUpdate = {
  $type: "devvit.events.v1alpha.CommentUpdate",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.previousBody !== "") {
      writer.uint32(34).string(message.previousBody);
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.comment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.previousBody = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet95(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      previousBody: isSet95(object.previousBody) ? globalThis.String(object.previousBody) : "",
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.comment !== void 0) {
      obj.comment = CommentV2.toJSON(message.comment);
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.previousBody !== "") {
      obj.previousBody = message.previousBody;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return CommentUpdate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentUpdate();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.previousBody = object.previousBody ?? "";
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CommentUpdate.$type, CommentUpdate);
function createBaseCommentReport() {
  return { comment: void 0, subreddit: void 0, reason: "" };
}
var CommentReport = {
  $type: "devvit.events.v1alpha.CommentReport",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.comment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet95(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      reason: isSet95(object.reason) ? globalThis.String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.comment !== void 0) {
      obj.comment = CommentV2.toJSON(message.comment);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return CommentReport.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentReport();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set(CommentReport.$type, CommentReport);
function createBaseCommentDelete() {
  return {
    commentId: "",
    postId: "",
    parentId: "",
    deletedAt: void 0,
    author: void 0,
    createdAt: void 0,
    source: 0,
    reason: 0,
    subreddit: void 0
  };
}
var CommentDelete = {
  $type: "devvit.events.v1alpha.CommentDelete",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.commentId !== "") {
      writer.uint32(10).string(message.commentId);
    }
    if (message.postId !== "") {
      writer.uint32(18).string(message.postId);
    }
    if (message.parentId !== "") {
      writer.uint32(26).string(message.parentId);
    }
    if (message.deletedAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.deletedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(42).fork()).ldelim();
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.createdAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.source !== 0) {
      writer.uint32(56).int32(message.source);
    }
    if (message.reason !== 0) {
      writer.uint32(64).int32(message.reason);
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.commentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.postId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.parentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.deletedAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.author = UserV2.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.createdAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.source = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.reason = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      commentId: isSet95(object.commentId) ? globalThis.String(object.commentId) : "",
      postId: isSet95(object.postId) ? globalThis.String(object.postId) : "",
      parentId: isSet95(object.parentId) ? globalThis.String(object.parentId) : "",
      deletedAt: isSet95(object.deletedAt) ? fromJsonTimestamp16(object.deletedAt) : void 0,
      author: isSet95(object.author) ? UserV2.fromJSON(object.author) : void 0,
      createdAt: isSet95(object.createdAt) ? fromJsonTimestamp16(object.createdAt) : void 0,
      source: isSet95(object.source) ? eventSourceFromJSON(object.source) : 0,
      reason: isSet95(object.reason) ? deletionReasonFromJSON(object.reason) : 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.commentId !== "") {
      obj.commentId = message.commentId;
    }
    if (message.postId !== "") {
      obj.postId = message.postId;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.deletedAt !== void 0) {
      obj.deletedAt = message.deletedAt.toISOString();
    }
    if (message.author !== void 0) {
      obj.author = UserV2.toJSON(message.author);
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.source !== 0) {
      obj.source = eventSourceToJSON(message.source);
    }
    if (message.reason !== 0) {
      obj.reason = deletionReasonToJSON(message.reason);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return CommentDelete.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentDelete();
    message.commentId = object.commentId ?? "";
    message.postId = object.postId ?? "";
    message.parentId = object.parentId ?? "";
    message.deletedAt = object.deletedAt ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.createdAt = object.createdAt ?? void 0;
    message.source = object.source ?? 0;
    message.reason = object.reason ?? 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CommentDelete.$type, CommentDelete);
function createBaseSubredditSubscribe() {
  return { subreddit: void 0, subscriber: void 0 };
}
var SubredditSubscribe = {
  $type: "devvit.events.v1alpha.SubredditSubscribe",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.subscriber !== void 0) {
      UserV2.encode(message.subscriber, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subscriber = UserV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      subscriber: isSet95(object.subscriber) ? UserV2.fromJSON(object.subscriber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.subscriber !== void 0) {
      obj.subscriber = UserV2.toJSON(message.subscriber);
    }
    return obj;
  },
  create(base) {
    return SubredditSubscribe.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditSubscribe();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.subscriber = object.subscriber !== void 0 && object.subscriber !== null ? UserV2.fromPartial(object.subscriber) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditSubscribe.$type, SubredditSubscribe);
function createBaseAppInstall() {
  return { subreddit: void 0, installer: void 0 };
}
var AppInstall = {
  $type: "devvit.events.v1alpha.AppInstall",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.installer !== void 0) {
      UserV2.encode(message.installer, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppInstall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.installer = UserV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      installer: isSet95(object.installer) ? UserV2.fromJSON(object.installer) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.installer !== void 0) {
      obj.installer = UserV2.toJSON(message.installer);
    }
    return obj;
  },
  create(base) {
    return AppInstall.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppInstall();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.installer = object.installer !== void 0 && object.installer !== null ? UserV2.fromPartial(object.installer) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AppInstall.$type, AppInstall);
function createBaseAppUpgrade() {
  return { subreddit: void 0, installer: void 0 };
}
var AppUpgrade = {
  $type: "devvit.events.v1alpha.AppUpgrade",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.installer !== void 0) {
      UserV2.encode(message.installer, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppUpgrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.installer = UserV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      installer: isSet95(object.installer) ? UserV2.fromJSON(object.installer) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.installer !== void 0) {
      obj.installer = UserV2.toJSON(message.installer);
    }
    return obj;
  },
  create(base) {
    return AppUpgrade.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppUpgrade();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.installer = object.installer !== void 0 && object.installer !== null ? UserV2.fromPartial(object.installer) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AppUpgrade.$type, AppUpgrade);
function createBaseAccountDelete() {
  return { userId: "", deletedAt: void 0, user: void 0 };
}
var AccountDelete = {
  $type: "devvit.events.v1alpha.AccountDelete",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.deletedAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.deletedAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.user !== void 0) {
      UserV2.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAccountDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.deletedAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = UserV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet95(object.userId) ? globalThis.String(object.userId) : "",
      deletedAt: isSet95(object.deletedAt) ? fromJsonTimestamp16(object.deletedAt) : void 0,
      user: isSet95(object.user) ? UserV2.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.deletedAt !== void 0) {
      obj.deletedAt = message.deletedAt.toISOString();
    }
    if (message.user !== void 0) {
      obj.user = UserV2.toJSON(message.user);
    }
    return obj;
  },
  create(base) {
    return AccountDelete.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAccountDelete();
    message.userId = object.userId ?? "";
    message.deletedAt = object.deletedAt ?? void 0;
    message.user = object.user !== void 0 && object.user !== null ? UserV2.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AccountDelete.$type, AccountDelete);
function createBaseVote() {
  return { updatedAt: void 0, comment: void 0, post: void 0, subreddit: void 0, upvoteRatio: 0, score: 0 };
}
var Vote = {
  $type: "devvit.events.v1alpha.Vote",
  encode(message, writer = import_minimal103.default.Writer.create()) {
    if (message.updatedAt !== void 0) {
      Timestamp.encode(toTimestamp16(message.updatedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(42).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(50).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(58).fork()).ldelim();
    }
    if (message.upvoteRatio !== 0) {
      writer.uint32(69).float(message.upvoteRatio);
    }
    if (message.score !== 0) {
      writer.uint32(72).int32(message.score);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal103.default.Reader ? input : import_minimal103.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }
          message.updatedAt = fromTimestamp16(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.comment = CommentV2.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.post = PostV2.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }
          message.upvoteRatio = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.score = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      updatedAt: isSet95(object.updatedAt) ? fromJsonTimestamp16(object.updatedAt) : void 0,
      comment: isSet95(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      post: isSet95(object.post) ? PostV2.fromJSON(object.post) : void 0,
      subreddit: isSet95(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      upvoteRatio: isSet95(object.upvoteRatio) ? globalThis.Number(object.upvoteRatio) : 0,
      score: isSet95(object.score) ? globalThis.Number(object.score) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.updatedAt !== void 0) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.comment !== void 0) {
      obj.comment = CommentV2.toJSON(message.comment);
    }
    if (message.post !== void 0) {
      obj.post = PostV2.toJSON(message.post);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = SubredditV2.toJSON(message.subreddit);
    }
    if (message.upvoteRatio !== 0) {
      obj.upvoteRatio = message.upvoteRatio;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    return obj;
  },
  create(base) {
    return Vote.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVote();
    message.updatedAt = object.updatedAt ?? void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.upvoteRatio = object.upvoteRatio ?? 0;
    message.score = object.score ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Vote.$type, Vote);
function toTimestamp16(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp16(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp16(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp16(Timestamp.fromJSON(o));
  }
}
function isSet95(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/triggers/v1alpha/triggers.js
function createBaseTriggerEvent() {
  return {
    id: "",
    timestamp: void 0,
    subreddit: "",
    postSubmit: void 0,
    postCreate: void 0,
    postUpdate: void 0,
    postReport: void 0,
    postFlairUpdate: void 0,
    postDelete: void 0,
    commentSubmit: void 0,
    commentCreate: void 0,
    commentUpdate: void 0,
    commentReport: void 0,
    commentDelete: void 0,
    subredditSubscribe: void 0,
    appInstall: void 0,
    appUpgrade: void 0,
    modAction: void 0,
    modMail: void 0,
    accountDelete: void 0,
    vote: void 0,
    postApprove: void 0,
    commentApprove: void 0
  };
}
var TriggerEvent = {
  $type: "devvit.data.triggers.v1alpha.TriggerEvent",
  encode(message, writer = import_minimal104.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp17(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== "") {
      writer.uint32(26).string(message.subreddit);
    }
    if (message.postSubmit !== void 0) {
      PostSubmit.encode(message.postSubmit, writer.uint32(802).fork()).ldelim();
    }
    if (message.postCreate !== void 0) {
      PostCreate.encode(message.postCreate, writer.uint32(906).fork()).ldelim();
    }
    if (message.postUpdate !== void 0) {
      PostUpdate.encode(message.postUpdate, writer.uint32(810).fork()).ldelim();
    }
    if (message.postReport !== void 0) {
      PostReport.encode(message.postReport, writer.uint32(818).fork()).ldelim();
    }
    if (message.postFlairUpdate !== void 0) {
      PostFlairUpdate.encode(message.postFlairUpdate, writer.uint32(874).fork()).ldelim();
    }
    if (message.postDelete !== void 0) {
      PostDelete.encode(message.postDelete, writer.uint32(890).fork()).ldelim();
    }
    if (message.commentSubmit !== void 0) {
      CommentSubmit.encode(message.commentSubmit, writer.uint32(826).fork()).ldelim();
    }
    if (message.commentCreate !== void 0) {
      CommentCreate.encode(message.commentCreate, writer.uint32(914).fork()).ldelim();
    }
    if (message.commentUpdate !== void 0) {
      CommentUpdate.encode(message.commentUpdate, writer.uint32(834).fork()).ldelim();
    }
    if (message.commentReport !== void 0) {
      CommentReport.encode(message.commentReport, writer.uint32(842).fork()).ldelim();
    }
    if (message.commentDelete !== void 0) {
      CommentDelete.encode(message.commentDelete, writer.uint32(898).fork()).ldelim();
    }
    if (message.subredditSubscribe !== void 0) {
      SubredditSubscribe.encode(message.subredditSubscribe, writer.uint32(850).fork()).ldelim();
    }
    if (message.appInstall !== void 0) {
      AppInstall.encode(message.appInstall, writer.uint32(858).fork()).ldelim();
    }
    if (message.appUpgrade !== void 0) {
      AppUpgrade.encode(message.appUpgrade, writer.uint32(866).fork()).ldelim();
    }
    if (message.modAction !== void 0) {
      ModAction.encode(message.modAction, writer.uint32(882).fork()).ldelim();
    }
    if (message.modMail !== void 0) {
      ModMail.encode(message.modMail, writer.uint32(922).fork()).ldelim();
    }
    if (message.accountDelete !== void 0) {
      AccountDelete.encode(message.accountDelete, writer.uint32(930).fork()).ldelim();
    }
    if (message.vote !== void 0) {
      Vote.encode(message.vote, writer.uint32(938).fork()).ldelim();
    }
    if (message.postApprove !== void 0) {
      PostApprove.encode(message.postApprove, writer.uint32(946).fork()).ldelim();
    }
    if (message.commentApprove !== void 0) {
      CommentApprove.encode(message.commentApprove, writer.uint32(954).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal104.default.Reader ? input : import_minimal104.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.timestamp = fromTimestamp17(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.postSubmit = PostSubmit.decode(reader, reader.uint32());
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }
          message.postCreate = PostCreate.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.postUpdate = PostUpdate.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.postReport = PostReport.decode(reader, reader.uint32());
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }
          message.postFlairUpdate = PostFlairUpdate.decode(reader, reader.uint32());
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }
          message.postDelete = PostDelete.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.commentSubmit = CommentSubmit.decode(reader, reader.uint32());
          continue;
        case 114:
          if (tag !== 914) {
            break;
          }
          message.commentCreate = CommentCreate.decode(reader, reader.uint32());
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.commentUpdate = CommentUpdate.decode(reader, reader.uint32());
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.commentReport = CommentReport.decode(reader, reader.uint32());
          continue;
        case 112:
          if (tag !== 898) {
            break;
          }
          message.commentDelete = CommentDelete.decode(reader, reader.uint32());
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.subredditSubscribe = SubredditSubscribe.decode(reader, reader.uint32());
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }
          message.appInstall = AppInstall.decode(reader, reader.uint32());
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }
          message.appUpgrade = AppUpgrade.decode(reader, reader.uint32());
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }
          message.modAction = ModAction.decode(reader, reader.uint32());
          continue;
        case 115:
          if (tag !== 922) {
            break;
          }
          message.modMail = ModMail.decode(reader, reader.uint32());
          continue;
        case 116:
          if (tag !== 930) {
            break;
          }
          message.accountDelete = AccountDelete.decode(reader, reader.uint32());
          continue;
        case 117:
          if (tag !== 938) {
            break;
          }
          message.vote = Vote.decode(reader, reader.uint32());
          continue;
        case 118:
          if (tag !== 946) {
            break;
          }
          message.postApprove = PostApprove.decode(reader, reader.uint32());
          continue;
        case 119:
          if (tag !== 954) {
            break;
          }
          message.commentApprove = CommentApprove.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet96(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet96(object.timestamp) ? fromJsonTimestamp17(object.timestamp) : void 0,
      subreddit: isSet96(object.subreddit) ? globalThis.String(object.subreddit) : "",
      postSubmit: isSet96(object.postSubmit) ? PostSubmit.fromJSON(object.postSubmit) : void 0,
      postCreate: isSet96(object.postCreate) ? PostCreate.fromJSON(object.postCreate) : void 0,
      postUpdate: isSet96(object.postUpdate) ? PostUpdate.fromJSON(object.postUpdate) : void 0,
      postReport: isSet96(object.postReport) ? PostReport.fromJSON(object.postReport) : void 0,
      postFlairUpdate: isSet96(object.postFlairUpdate) ? PostFlairUpdate.fromJSON(object.postFlairUpdate) : void 0,
      postDelete: isSet96(object.postDelete) ? PostDelete.fromJSON(object.postDelete) : void 0,
      commentSubmit: isSet96(object.commentSubmit) ? CommentSubmit.fromJSON(object.commentSubmit) : void 0,
      commentCreate: isSet96(object.commentCreate) ? CommentCreate.fromJSON(object.commentCreate) : void 0,
      commentUpdate: isSet96(object.commentUpdate) ? CommentUpdate.fromJSON(object.commentUpdate) : void 0,
      commentReport: isSet96(object.commentReport) ? CommentReport.fromJSON(object.commentReport) : void 0,
      commentDelete: isSet96(object.commentDelete) ? CommentDelete.fromJSON(object.commentDelete) : void 0,
      subredditSubscribe: isSet96(object.subredditSubscribe) ? SubredditSubscribe.fromJSON(object.subredditSubscribe) : void 0,
      appInstall: isSet96(object.appInstall) ? AppInstall.fromJSON(object.appInstall) : void 0,
      appUpgrade: isSet96(object.appUpgrade) ? AppUpgrade.fromJSON(object.appUpgrade) : void 0,
      modAction: isSet96(object.modAction) ? ModAction.fromJSON(object.modAction) : void 0,
      modMail: isSet96(object.modMail) ? ModMail.fromJSON(object.modMail) : void 0,
      accountDelete: isSet96(object.accountDelete) ? AccountDelete.fromJSON(object.accountDelete) : void 0,
      vote: isSet96(object.vote) ? Vote.fromJSON(object.vote) : void 0,
      postApprove: isSet96(object.postApprove) ? PostApprove.fromJSON(object.postApprove) : void 0,
      commentApprove: isSet96(object.commentApprove) ? CommentApprove.fromJSON(object.commentApprove) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== void 0) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.postSubmit !== void 0) {
      obj.postSubmit = PostSubmit.toJSON(message.postSubmit);
    }
    if (message.postCreate !== void 0) {
      obj.postCreate = PostCreate.toJSON(message.postCreate);
    }
    if (message.postUpdate !== void 0) {
      obj.postUpdate = PostUpdate.toJSON(message.postUpdate);
    }
    if (message.postReport !== void 0) {
      obj.postReport = PostReport.toJSON(message.postReport);
    }
    if (message.postFlairUpdate !== void 0) {
      obj.postFlairUpdate = PostFlairUpdate.toJSON(message.postFlairUpdate);
    }
    if (message.postDelete !== void 0) {
      obj.postDelete = PostDelete.toJSON(message.postDelete);
    }
    if (message.commentSubmit !== void 0) {
      obj.commentSubmit = CommentSubmit.toJSON(message.commentSubmit);
    }
    if (message.commentCreate !== void 0) {
      obj.commentCreate = CommentCreate.toJSON(message.commentCreate);
    }
    if (message.commentUpdate !== void 0) {
      obj.commentUpdate = CommentUpdate.toJSON(message.commentUpdate);
    }
    if (message.commentReport !== void 0) {
      obj.commentReport = CommentReport.toJSON(message.commentReport);
    }
    if (message.commentDelete !== void 0) {
      obj.commentDelete = CommentDelete.toJSON(message.commentDelete);
    }
    if (message.subredditSubscribe !== void 0) {
      obj.subredditSubscribe = SubredditSubscribe.toJSON(message.subredditSubscribe);
    }
    if (message.appInstall !== void 0) {
      obj.appInstall = AppInstall.toJSON(message.appInstall);
    }
    if (message.appUpgrade !== void 0) {
      obj.appUpgrade = AppUpgrade.toJSON(message.appUpgrade);
    }
    if (message.modAction !== void 0) {
      obj.modAction = ModAction.toJSON(message.modAction);
    }
    if (message.modMail !== void 0) {
      obj.modMail = ModMail.toJSON(message.modMail);
    }
    if (message.accountDelete !== void 0) {
      obj.accountDelete = AccountDelete.toJSON(message.accountDelete);
    }
    if (message.vote !== void 0) {
      obj.vote = Vote.toJSON(message.vote);
    }
    if (message.postApprove !== void 0) {
      obj.postApprove = PostApprove.toJSON(message.postApprove);
    }
    if (message.commentApprove !== void 0) {
      obj.commentApprove = CommentApprove.toJSON(message.commentApprove);
    }
    return obj;
  },
  create(base) {
    return TriggerEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTriggerEvent();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? void 0;
    message.subreddit = object.subreddit ?? "";
    message.postSubmit = object.postSubmit !== void 0 && object.postSubmit !== null ? PostSubmit.fromPartial(object.postSubmit) : void 0;
    message.postCreate = object.postCreate !== void 0 && object.postCreate !== null ? PostCreate.fromPartial(object.postCreate) : void 0;
    message.postUpdate = object.postUpdate !== void 0 && object.postUpdate !== null ? PostUpdate.fromPartial(object.postUpdate) : void 0;
    message.postReport = object.postReport !== void 0 && object.postReport !== null ? PostReport.fromPartial(object.postReport) : void 0;
    message.postFlairUpdate = object.postFlairUpdate !== void 0 && object.postFlairUpdate !== null ? PostFlairUpdate.fromPartial(object.postFlairUpdate) : void 0;
    message.postDelete = object.postDelete !== void 0 && object.postDelete !== null ? PostDelete.fromPartial(object.postDelete) : void 0;
    message.commentSubmit = object.commentSubmit !== void 0 && object.commentSubmit !== null ? CommentSubmit.fromPartial(object.commentSubmit) : void 0;
    message.commentCreate = object.commentCreate !== void 0 && object.commentCreate !== null ? CommentCreate.fromPartial(object.commentCreate) : void 0;
    message.commentUpdate = object.commentUpdate !== void 0 && object.commentUpdate !== null ? CommentUpdate.fromPartial(object.commentUpdate) : void 0;
    message.commentReport = object.commentReport !== void 0 && object.commentReport !== null ? CommentReport.fromPartial(object.commentReport) : void 0;
    message.commentDelete = object.commentDelete !== void 0 && object.commentDelete !== null ? CommentDelete.fromPartial(object.commentDelete) : void 0;
    message.subredditSubscribe = object.subredditSubscribe !== void 0 && object.subredditSubscribe !== null ? SubredditSubscribe.fromPartial(object.subredditSubscribe) : void 0;
    message.appInstall = object.appInstall !== void 0 && object.appInstall !== null ? AppInstall.fromPartial(object.appInstall) : void 0;
    message.appUpgrade = object.appUpgrade !== void 0 && object.appUpgrade !== null ? AppUpgrade.fromPartial(object.appUpgrade) : void 0;
    message.modAction = object.modAction !== void 0 && object.modAction !== null ? ModAction.fromPartial(object.modAction) : void 0;
    message.modMail = object.modMail !== void 0 && object.modMail !== null ? ModMail.fromPartial(object.modMail) : void 0;
    message.accountDelete = object.accountDelete !== void 0 && object.accountDelete !== null ? AccountDelete.fromPartial(object.accountDelete) : void 0;
    message.vote = object.vote !== void 0 && object.vote !== null ? Vote.fromPartial(object.vote) : void 0;
    message.postApprove = object.postApprove !== void 0 && object.postApprove !== null ? PostApprove.fromPartial(object.postApprove) : void 0;
    message.commentApprove = object.commentApprove !== void 0 && object.commentApprove !== null ? CommentApprove.fromPartial(object.commentApprove) : void 0;
    return message;
  }
};
messageTypeRegistry.set(TriggerEvent.$type, TriggerEvent);
function toTimestamp17(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp17(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp17(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp17(Timestamp.fromJSON(o));
  }
}
function isSet96(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/v1alpha/triggers.js
function createBaseTriggerResponse() {
  return { total: 0, success: [], errors: {} };
}
var TriggerResponse = {
  $type: "devvit.gateway.v1alpha.TriggerResponse",
  encode(message, writer = import_minimal105.default.Writer.create()) {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    for (const v of message.success) {
      writer.uint32(18).string(v);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      TriggerResponse_ErrorsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal105.default.Reader ? input : import_minimal105.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.total = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.success.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = TriggerResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.errors[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      total: isSet97(object.total) ? globalThis.Number(object.total) : 0,
      success: globalThis.Array.isArray(object?.success) ? object.success.map((e) => globalThis.String(e)) : [],
      errors: isObject20(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.success?.length) {
      obj.success = message.success;
    }
    if (message.errors) {
      const entries = Object.entries(message.errors);
      if (entries.length > 0) {
        obj.errors = {};
        entries.forEach(([k, v]) => {
          obj.errors[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return TriggerResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTriggerResponse();
    message.total = object.total ?? 0;
    message.success = object.success?.map((e) => e) || [];
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(TriggerResponse.$type, TriggerResponse);
function createBaseTriggerResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var TriggerResponse_ErrorsEntry = {
  $type: "devvit.gateway.v1alpha.TriggerResponse.ErrorsEntry",
  encode(message, writer = import_minimal105.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal105.default.Reader ? input : import_minimal105.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet97(object.key) ? globalThis.String(object.key) : "",
      value: isSet97(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return TriggerResponse_ErrorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTriggerResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(TriggerResponse_ErrorsEntry.$type, TriggerResponse_ErrorsEntry);
function createBaseTriggerFanOutResponse() {
  return { installationIds: [] };
}
var TriggerFanOutResponse = {
  $type: "devvit.gateway.v1alpha.TriggerFanOutResponse",
  encode(message, writer = import_minimal105.default.Writer.create()) {
    for (const v of message.installationIds) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal105.default.Reader ? input : import_minimal105.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerFanOutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationIds: globalThis.Array.isArray(object?.installationIds) ? object.installationIds.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationIds?.length) {
      obj.installationIds = message.installationIds;
    }
    return obj;
  },
  create(base) {
    return TriggerFanOutResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTriggerFanOutResponse();
    message.installationIds = object.installationIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(TriggerFanOutResponse.$type, TriggerFanOutResponse);
function createBaseTriggerInvocation() {
  return { installationId: "", evt: void 0 };
}
var TriggerInvocation = {
  $type: "devvit.gateway.v1alpha.TriggerInvocation",
  encode(message, writer = import_minimal105.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    if (message.evt !== void 0) {
      TriggerEvent.encode(message.evt, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal105.default.Reader ? input : import_minimal105.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.evt = TriggerEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationId: isSet97(object.installationId) ? globalThis.String(object.installationId) : "",
      evt: isSet97(object.evt) ? TriggerEvent.fromJSON(object.evt) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    if (message.evt !== void 0) {
      obj.evt = TriggerEvent.toJSON(message.evt);
    }
    return obj;
  },
  create(base) {
    return TriggerInvocation.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTriggerInvocation();
    message.installationId = object.installationId ?? "";
    message.evt = object.evt !== void 0 && object.evt !== null ? TriggerEvent.fromPartial(object.evt) : void 0;
    return message;
  }
};
messageTypeRegistry.set(TriggerInvocation.$type, TriggerInvocation);
function isObject20(value) {
  return typeof value === "object" && value !== null;
}
function isSet97(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/events/v1alpha/wqcleanup.js
var import_long12 = __toESM(require_long(), 1);
var import_minimal106 = __toESM(require_minimal2(), 1);
function createBaseWqCleanup() {
  return { cursor: 0 };
}
var WqCleanup = {
  $type: "devvit.events.v1alpha.WqCleanup",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.cursor !== 0) {
      writer.uint32(8).uint64(message.cursor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : import_minimal106.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWqCleanup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.cursor = longToNumber12(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { cursor: isSet98(object.cursor) ? globalThis.Number(object.cursor) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.cursor !== 0) {
      obj.cursor = Math.round(message.cursor);
    }
    return obj;
  },
  create(base) {
    return WqCleanup.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWqCleanup();
    message.cursor = object.cursor ?? 0;
    return message;
  }
};
messageTypeRegistry.set(WqCleanup.$type, WqCleanup);
function longToNumber12(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal106.default.util.Long !== import_long12.default) {
  import_minimal106.default.util.Long = import_long12.default;
  import_minimal106.default.configure();
}
function isSet98(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/waitlist/waitlist.js
var import_minimal108 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/dev_portal/admin/waitlist_admin.js
var import_minimal107 = __toESM(require_minimal2(), 1);
var WaitlistStatus;
(function(WaitlistStatus2) {
  WaitlistStatus2[WaitlistStatus2["PENDING"] = 0] = "PENDING";
  WaitlistStatus2[WaitlistStatus2["ACCEPTED"] = 1] = "ACCEPTED";
  WaitlistStatus2[WaitlistStatus2["REJECTED"] = 2] = "REJECTED";
  WaitlistStatus2[WaitlistStatus2["REVOKED"] = 3] = "REVOKED";
  WaitlistStatus2[WaitlistStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WaitlistStatus || (WaitlistStatus = {}));
function waitlistStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "PENDING":
      return WaitlistStatus.PENDING;
    case 1:
    case "ACCEPTED":
      return WaitlistStatus.ACCEPTED;
    case 2:
    case "REJECTED":
      return WaitlistStatus.REJECTED;
    case 3:
    case "REVOKED":
      return WaitlistStatus.REVOKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WaitlistStatus.UNRECOGNIZED;
  }
}
function waitlistStatusToJSON(object) {
  switch (object) {
    case WaitlistStatus.PENDING:
      return 0;
    case WaitlistStatus.ACCEPTED:
      return 1;
    case WaitlistStatus.REJECTED:
      return 2;
    case WaitlistStatus.REVOKED:
      return 3;
    case WaitlistStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseSubmission() {
  return {
    id: "",
    userId: "",
    userName: "",
    whatToBuild: "",
    botsBuilt: "",
    createdAt: void 0,
    updatedAt: void 0,
    status: 0,
    acceptedTermsVersion: 0
  };
}
var Submission = {
  $type: "devvit.dev_portal.admin.Submission",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(26).string(message.userName);
    }
    if (message.whatToBuild !== "") {
      writer.uint32(34).string(message.whatToBuild);
    }
    if (message.botsBuilt !== "") {
      writer.uint32(42).string(message.botsBuilt);
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp18(message.createdAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.updatedAt !== void 0) {
      Timestamp.encode(toTimestamp18(message.updatedAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.acceptedTermsVersion !== 0) {
      writer.uint32(72).int32(message.acceptedTermsVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.userName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.whatToBuild = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.botsBuilt = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.createdAt = fromTimestamp18(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.updatedAt = fromTimestamp18(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.status = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.acceptedTermsVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet99(object.id) ? globalThis.String(object.id) : "",
      userId: isSet99(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet99(object.userName) ? globalThis.String(object.userName) : "",
      whatToBuild: isSet99(object.whatToBuild) ? globalThis.String(object.whatToBuild) : "",
      botsBuilt: isSet99(object.botsBuilt) ? globalThis.String(object.botsBuilt) : "",
      createdAt: isSet99(object.createdAt) ? fromJsonTimestamp18(object.createdAt) : void 0,
      updatedAt: isSet99(object.updatedAt) ? fromJsonTimestamp18(object.updatedAt) : void 0,
      status: isSet99(object.status) ? waitlistStatusFromJSON(object.status) : 0,
      acceptedTermsVersion: isSet99(object.acceptedTermsVersion) ? globalThis.Number(object.acceptedTermsVersion) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.whatToBuild !== "") {
      obj.whatToBuild = message.whatToBuild;
    }
    if (message.botsBuilt !== "") {
      obj.botsBuilt = message.botsBuilt;
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== void 0) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = waitlistStatusToJSON(message.status);
    }
    if (message.acceptedTermsVersion !== 0) {
      obj.acceptedTermsVersion = Math.round(message.acceptedTermsVersion);
    }
    return obj;
  },
  create(base) {
    return Submission.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmission();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.whatToBuild = object.whatToBuild ?? "";
    message.botsBuilt = object.botsBuilt ?? "";
    message.createdAt = object.createdAt ?? void 0;
    message.updatedAt = object.updatedAt ?? void 0;
    message.status = object.status ?? 0;
    message.acceptedTermsVersion = object.acceptedTermsVersion ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Submission.$type, Submission);
function createBaseSubmissionsRequest() {
  return { limit: 0, after: void 0, before: void 0, username: void 0 };
}
var SubmissionsRequest = {
  $type: "devvit.dev_portal.admin.SubmissionsRequest",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.after !== void 0) {
      Timestamp.encode(toTimestamp18(message.after), writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      Timestamp.encode(toTimestamp18(message.before), writer.uint32(26).fork()).ldelim();
    }
    if (message.username !== void 0) {
      writer.uint32(34).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.limit = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.after = fromTimestamp18(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.before = fromTimestamp18(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      limit: isSet99(object.limit) ? globalThis.Number(object.limit) : 0,
      after: isSet99(object.after) ? fromJsonTimestamp18(object.after) : void 0,
      before: isSet99(object.before) ? fromJsonTimestamp18(object.before) : void 0,
      username: isSet99(object.username) ? globalThis.String(object.username) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.after !== void 0) {
      obj.after = message.after.toISOString();
    }
    if (message.before !== void 0) {
      obj.before = message.before.toISOString();
    }
    if (message.username !== void 0) {
      obj.username = message.username;
    }
    return obj;
  },
  create(base) {
    return SubmissionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmissionsRequest();
    message.limit = object.limit ?? 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.username = object.username ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmissionsRequest.$type, SubmissionsRequest);
function createBaseSubmissionsResponse() {
  return { submissions: [], totalSubmissions: 0, count: 0, first: void 0, last: void 0 };
}
var SubmissionsResponse = {
  $type: "devvit.dev_portal.admin.SubmissionsResponse",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    for (const v of message.submissions) {
      Submission.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalSubmissions !== 0) {
      writer.uint32(16).int32(message.totalSubmissions);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.first !== void 0) {
      Timestamp.encode(toTimestamp18(message.first), writer.uint32(34).fork()).ldelim();
    }
    if (message.last !== void 0) {
      Timestamp.encode(toTimestamp18(message.last), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.submissions.push(Submission.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.totalSubmissions = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.count = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.first = fromTimestamp18(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.last = fromTimestamp18(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      submissions: globalThis.Array.isArray(object?.submissions) ? object.submissions.map((e) => Submission.fromJSON(e)) : [],
      totalSubmissions: isSet99(object.totalSubmissions) ? globalThis.Number(object.totalSubmissions) : 0,
      count: isSet99(object.count) ? globalThis.Number(object.count) : 0,
      first: isSet99(object.first) ? fromJsonTimestamp18(object.first) : void 0,
      last: isSet99(object.last) ? fromJsonTimestamp18(object.last) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.submissions?.length) {
      obj.submissions = message.submissions.map((e) => Submission.toJSON(e));
    }
    if (message.totalSubmissions !== 0) {
      obj.totalSubmissions = Math.round(message.totalSubmissions);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.first !== void 0) {
      obj.first = message.first.toISOString();
    }
    if (message.last !== void 0) {
      obj.last = message.last.toISOString();
    }
    return obj;
  },
  create(base) {
    return SubmissionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmissionsResponse();
    message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
    message.totalSubmissions = object.totalSubmissions ?? 0;
    message.count = object.count ?? 0;
    message.first = object.first ?? void 0;
    message.last = object.last ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmissionsResponse.$type, SubmissionsResponse);
function createBaseSubmissionUpdateRequest() {
  return { id: "", status: 0 };
}
var SubmissionUpdateRequest = {
  $type: "devvit.dev_portal.admin.SubmissionUpdateRequest",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.status = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet99(object.id) ? globalThis.String(object.id) : "",
      status: isSet99(object.status) ? waitlistStatusFromJSON(object.status) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== 0) {
      obj.status = waitlistStatusToJSON(message.status);
    }
    return obj;
  },
  create(base) {
    return SubmissionUpdateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmissionUpdateRequest();
    message.id = object.id ?? "";
    message.status = object.status ?? 0;
    return message;
  }
};
messageTypeRegistry.set(SubmissionUpdateRequest.$type, SubmissionUpdateRequest);
function createBaseSubmissionUpdateResponse() {
  return { success: false, message: void 0 };
}
var SubmissionUpdateResponse = {
  $type: "devvit.dev_portal.admin.SubmissionUpdateResponse",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet99(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet99(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return SubmissionUpdateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmissionUpdateResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmissionUpdateResponse.$type, SubmissionUpdateResponse);
function createBaseSubmissionAddRequest() {
  return { userId: void 0, userName: void 0 };
}
var SubmissionAddRequest = {
  $type: "devvit.dev_portal.admin.SubmissionAddRequest",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    if (message.userId !== void 0) {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== void 0) {
      writer.uint32(18).string(message.userName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionAddRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.userName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet99(object.userId) ? globalThis.String(object.userId) : void 0,
      userName: isSet99(object.userName) ? globalThis.String(object.userName) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== void 0) {
      obj.userId = message.userId;
    }
    if (message.userName !== void 0) {
      obj.userName = message.userName;
    }
    return obj;
  },
  create(base) {
    return SubmissionAddRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmissionAddRequest();
    message.userId = object.userId ?? void 0;
    message.userName = object.userName ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmissionAddRequest.$type, SubmissionAddRequest);
function createBaseSubmissionAddResponse() {
  return { success: false, message: void 0 };
}
var SubmissionAddResponse = {
  $type: "devvit.dev_portal.admin.SubmissionAddResponse",
  encode(message, writer = import_minimal107.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal107.default.Reader ? input : import_minimal107.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionAddResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet99(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet99(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return SubmissionAddResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmissionAddResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmissionAddResponse.$type, SubmissionAddResponse);
function toTimestamp18(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp18(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp18(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp18(Timestamp.fromJSON(o));
  }
}
function isSet99(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/waitlist/waitlist.js
var ProgrammingExperienceLevel;
(function(ProgrammingExperienceLevel2) {
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["BEGINNER"] = 0] = "BEGINNER";
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["PROFICIENT"] = 1] = "PROFICIENT";
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["EXPERT"] = 2] = "EXPERT";
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProgrammingExperienceLevel || (ProgrammingExperienceLevel = {}));
function programmingExperienceLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "BEGINNER":
      return ProgrammingExperienceLevel.BEGINNER;
    case 1:
    case "PROFICIENT":
      return ProgrammingExperienceLevel.PROFICIENT;
    case 2:
    case "EXPERT":
      return ProgrammingExperienceLevel.EXPERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProgrammingExperienceLevel.UNRECOGNIZED;
  }
}
function programmingExperienceLevelToJSON(object) {
  switch (object) {
    case ProgrammingExperienceLevel.BEGINNER:
      return 0;
    case ProgrammingExperienceLevel.PROFICIENT:
      return 1;
    case ProgrammingExperienceLevel.EXPERT:
      return 2;
    case ProgrammingExperienceLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseIsCurrentUserRegisteredResponse() {
  return { isRegistered: false, response: void 0, waitlistStatus: 0 };
}
var IsCurrentUserRegisteredResponse = {
  $type: "devvit.dev_portal.waitlist.IsCurrentUserRegisteredResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.isRegistered !== false) {
      writer.uint32(8).bool(message.isRegistered);
    }
    if (message.response !== void 0) {
      WaitlistRegisterUserRequest.encode(message.response, writer.uint32(18).fork()).ldelim();
    }
    if (message.waitlistStatus !== 0) {
      writer.uint32(24).int32(message.waitlistStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : import_minimal108.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIsCurrentUserRegisteredResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.isRegistered = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.response = WaitlistRegisterUserRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.waitlistStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isRegistered: isSet100(object.isRegistered) ? globalThis.Boolean(object.isRegistered) : false,
      response: isSet100(object.response) ? WaitlistRegisterUserRequest.fromJSON(object.response) : void 0,
      waitlistStatus: isSet100(object.waitlistStatus) ? waitlistStatusFromJSON(object.waitlistStatus) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isRegistered !== false) {
      obj.isRegistered = message.isRegistered;
    }
    if (message.response !== void 0) {
      obj.response = WaitlistRegisterUserRequest.toJSON(message.response);
    }
    if (message.waitlistStatus !== 0) {
      obj.waitlistStatus = waitlistStatusToJSON(message.waitlistStatus);
    }
    return obj;
  },
  create(base) {
    return IsCurrentUserRegisteredResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseIsCurrentUserRegisteredResponse();
    message.isRegistered = object.isRegistered ?? false;
    message.response = object.response !== void 0 && object.response !== null ? WaitlistRegisterUserRequest.fromPartial(object.response) : void 0;
    message.waitlistStatus = object.waitlistStatus ?? 0;
    return message;
  }
};
messageTypeRegistry.set(IsCurrentUserRegisteredResponse.$type, IsCurrentUserRegisteredResponse);
function createBaseWaitlistRegisterUserRequest() {
  return { userId: "", userName: "", whatToBuild: "", botsBuilt: void 0, programmingExperience: {}, appsWanted: "" };
}
var WaitlistRegisterUserRequest = {
  $type: "devvit.dev_portal.waitlist.WaitlistRegisterUserRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.whatToBuild !== "") {
      writer.uint32(26).string(message.whatToBuild);
    }
    if (message.botsBuilt !== void 0) {
      StringValue.encode({ value: message.botsBuilt }, writer.uint32(42).fork()).ldelim();
    }
    Object.entries(message.programmingExperience).forEach(([key, value]) => {
      WaitlistRegisterUserRequest_ProgrammingExperienceEntry.encode({ key, value }, writer.uint32(50).fork()).ldelim();
    });
    if (message.appsWanted !== "") {
      writer.uint32(58).string(message.appsWanted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : import_minimal108.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWaitlistRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.userName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.whatToBuild = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.botsBuilt = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          const entry6 = WaitlistRegisterUserRequest_ProgrammingExperienceEntry.decode(reader, reader.uint32());
          if (entry6.value !== void 0) {
            message.programmingExperience[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.appsWanted = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet100(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet100(object.userName) ? globalThis.String(object.userName) : "",
      whatToBuild: isSet100(object.whatToBuild) ? globalThis.String(object.whatToBuild) : "",
      botsBuilt: isSet100(object.botsBuilt) ? String(object.botsBuilt) : void 0,
      programmingExperience: isObject21(object.programmingExperience) ? Object.entries(object.programmingExperience).reduce((acc, [key, value]) => {
        acc[key] = programmingExperienceLevelFromJSON(value);
        return acc;
      }, {}) : {},
      appsWanted: isSet100(object.appsWanted) ? globalThis.String(object.appsWanted) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.whatToBuild !== "") {
      obj.whatToBuild = message.whatToBuild;
    }
    if (message.botsBuilt !== void 0) {
      obj.botsBuilt = message.botsBuilt;
    }
    if (message.programmingExperience) {
      const entries = Object.entries(message.programmingExperience);
      if (entries.length > 0) {
        obj.programmingExperience = {};
        entries.forEach(([k, v]) => {
          obj.programmingExperience[k] = programmingExperienceLevelToJSON(v);
        });
      }
    }
    if (message.appsWanted !== "") {
      obj.appsWanted = message.appsWanted;
    }
    return obj;
  },
  create(base) {
    return WaitlistRegisterUserRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWaitlistRegisterUserRequest();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.whatToBuild = object.whatToBuild ?? "";
    message.botsBuilt = object.botsBuilt ?? void 0;
    message.programmingExperience = Object.entries(object.programmingExperience ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.appsWanted = object.appsWanted ?? "";
    return message;
  }
};
messageTypeRegistry.set(WaitlistRegisterUserRequest.$type, WaitlistRegisterUserRequest);
function createBaseWaitlistRegisterUserRequest_ProgrammingExperienceEntry() {
  return { key: "", value: 0 };
}
var WaitlistRegisterUserRequest_ProgrammingExperienceEntry = {
  $type: "devvit.dev_portal.waitlist.WaitlistRegisterUserRequest.ProgrammingExperienceEntry",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : import_minimal108.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWaitlistRegisterUserRequest_ProgrammingExperienceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet100(object.key) ? globalThis.String(object.key) : "",
      value: isSet100(object.value) ? programmingExperienceLevelFromJSON(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = programmingExperienceLevelToJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return WaitlistRegisterUserRequest_ProgrammingExperienceEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWaitlistRegisterUserRequest_ProgrammingExperienceEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(WaitlistRegisterUserRequest_ProgrammingExperienceEntry.$type, WaitlistRegisterUserRequest_ProgrammingExperienceEntry);
function createBaseWaitlistRegisterUserResponse() {
  return { success: false, message: void 0 };
}
var WaitlistRegisterUserResponse = {
  $type: "devvit.dev_portal.waitlist.WaitlistRegisterUserResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : import_minimal108.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWaitlistRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet100(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet100(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return WaitlistRegisterUserResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWaitlistRegisterUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(WaitlistRegisterUserResponse.$type, WaitlistRegisterUserResponse);
function createBaseGetCurrentUserStatusResponse() {
  return { waitlistStatus: 0, acceptedTermsVersion: 0, currentTermsVersion: 0 };
}
var GetCurrentUserStatusResponse = {
  $type: "devvit.dev_portal.waitlist.GetCurrentUserStatusResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.waitlistStatus !== 0) {
      writer.uint32(8).int32(message.waitlistStatus);
    }
    if (message.acceptedTermsVersion !== 0) {
      writer.uint32(16).int32(message.acceptedTermsVersion);
    }
    if (message.currentTermsVersion !== 0) {
      writer.uint32(24).int32(message.currentTermsVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : import_minimal108.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.waitlistStatus = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.acceptedTermsVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.currentTermsVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      waitlistStatus: isSet100(object.waitlistStatus) ? waitlistStatusFromJSON(object.waitlistStatus) : 0,
      acceptedTermsVersion: isSet100(object.acceptedTermsVersion) ? globalThis.Number(object.acceptedTermsVersion) : 0,
      currentTermsVersion: isSet100(object.currentTermsVersion) ? globalThis.Number(object.currentTermsVersion) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.waitlistStatus !== 0) {
      obj.waitlistStatus = waitlistStatusToJSON(message.waitlistStatus);
    }
    if (message.acceptedTermsVersion !== 0) {
      obj.acceptedTermsVersion = Math.round(message.acceptedTermsVersion);
    }
    if (message.currentTermsVersion !== 0) {
      obj.currentTermsVersion = Math.round(message.currentTermsVersion);
    }
    return obj;
  },
  create(base) {
    return GetCurrentUserStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetCurrentUserStatusResponse();
    message.waitlistStatus = object.waitlistStatus ?? 0;
    message.acceptedTermsVersion = object.acceptedTermsVersion ?? 0;
    message.currentTermsVersion = object.currentTermsVersion ?? 0;
    return message;
  }
};
messageTypeRegistry.set(GetCurrentUserStatusResponse.$type, GetCurrentUserStatusResponse);
function isObject21(value) {
  return typeof value === "object" && value !== null;
}
function isSet100(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/debug/v1alpha/debug.js
var import_minimal109 = __toESM(require_minimal2(), 1);
function createBaseGetProfileRequest() {
  return { profileId: "" };
}
var GetProfileRequest = {
  $type: "devvit.debug.v1alpha.GetProfileRequest",
  encode(message, writer = import_minimal109.default.Writer.create()) {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal109.default.Reader ? input : import_minimal109.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.profileId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { profileId: isSet101(object.profileId) ? globalThis.String(object.profileId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },
  create(base) {
    return GetProfileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetProfileRequest();
    message.profileId = object.profileId ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetProfileRequest.$type, GetProfileRequest);
function createBaseGetProfileResponse() {
  return { profileId: "", profile: new Uint8Array(0) };
}
var GetProfileResponse = {
  $type: "devvit.debug.v1alpha.GetProfileResponse",
  encode(message, writer = import_minimal109.default.Writer.create()) {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    if (message.profile.length !== 0) {
      writer.uint32(18).bytes(message.profile);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal109.default.Reader ? input : import_minimal109.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.profileId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.profile = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      profileId: isSet101(object.profileId) ? globalThis.String(object.profileId) : "",
      profile: isSet101(object.profile) ? bytesFromBase647(object.profile) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.profile.length !== 0) {
      obj.profile = base64FromBytes7(message.profile);
    }
    return obj;
  },
  create(base) {
    return GetProfileResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetProfileResponse();
    message.profileId = object.profileId ?? "";
    message.profile = object.profile ?? new Uint8Array(0);
    return message;
  }
};
messageTypeRegistry.set(GetProfileResponse.$type, GetProfileResponse);
function bytesFromBase647(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes7(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isSet101(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/test/wrappertypes.js
var import_minimal110 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/test/streams.js
var import_minimal111 = __toESM(require_minimal2(), 1);
function createBaseTestMessage() {
  return { number: 0 };
}
var TestMessage = {
  $type: "devvit.actor.test.TestMessage",
  encode(message, writer = import_minimal111.default.Writer.create()) {
    if (message.number !== 0) {
      writer.uint32(8).int32(message.number);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal111.default.Reader ? input : import_minimal111.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.number = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { number: isSet102(object.number) ? globalThis.Number(object.number) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    return obj;
  },
  create(base) {
    return TestMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTestMessage();
    message.number = object.number ?? 0;
    return message;
  }
};
messageTypeRegistry.set(TestMessage.$type, TestMessage);
function isSet102(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/scheduler/handler.js
var import_minimal112 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/reddit/post_filter.js
var import_minimal113 = __toESM(require_minimal2(), 1);
function createBasePostFilterRequest() {
  return { post: void 0 };
}
var PostFilterRequest = {
  $type: "devvit.actor.reddit.PostFilterRequest",
  encode(message, writer = import_minimal113.default.Writer.create()) {
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal113.default.Reader ? input : import_minimal113.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostFilterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.post = Post.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { post: isSet103(object.post) ? Post.fromJSON(object.post) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.post !== void 0) {
      obj.post = Post.toJSON(message.post);
    }
    return obj;
  },
  create(base) {
    return PostFilterRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostFilterRequest();
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostFilterRequest.$type, PostFilterRequest);
function createBaseResponse() {
  return { accepted: false };
}
var Response = {
  $type: "devvit.actor.reddit.Response",
  encode(message, writer = import_minimal113.default.Writer.create()) {
    if (message.accepted !== false) {
      writer.uint32(8).bool(message.accepted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal113.default.Reader ? input : import_minimal113.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.accepted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { accepted: isSet103(object.accepted) ? globalThis.Boolean(object.accepted) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    return obj;
  },
  create(base) {
    return Response.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse();
    message.accepted = object.accepted ?? false;
    return message;
  }
};
messageTypeRegistry.set(Response.$type, Response);
function isSet103(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/producer/producer.js
var import_long13 = __toESM(require_long(), 1);
var import_minimal114 = __toESM(require_minimal2(), 1);
function createBaseArg() {
  return { str: void 0, i32: void 0, i64: void 0 };
}
var Arg = {
  $type: "devvit.actor.producer.Arg",
  encode(message, writer = import_minimal114.default.Writer.create()) {
    if (message.str !== void 0) {
      writer.uint32(10).string(message.str);
    }
    if (message.i32 !== void 0) {
      writer.uint32(16).int32(message.i32);
    }
    if (message.i64 !== void 0) {
      writer.uint32(24).int64(message.i64);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal114.default.Reader ? input : import_minimal114.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.str = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.i32 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.i64 = longToNumber13(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      str: isSet104(object.str) ? globalThis.String(object.str) : void 0,
      i32: isSet104(object.i32) ? globalThis.Number(object.i32) : void 0,
      i64: isSet104(object.i64) ? globalThis.Number(object.i64) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.str !== void 0) {
      obj.str = message.str;
    }
    if (message.i32 !== void 0) {
      obj.i32 = Math.round(message.i32);
    }
    if (message.i64 !== void 0) {
      obj.i64 = Math.round(message.i64);
    }
    return obj;
  },
  create(base) {
    return Arg.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseArg();
    message.str = object.str ?? void 0;
    message.i32 = object.i32 ?? void 0;
    message.i64 = object.i64 ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Arg.$type, Arg);
function createBaseArgs() {
  return { elements: [] };
}
var Args = {
  $type: "devvit.actor.producer.Args",
  encode(message, writer = import_minimal114.default.Writer.create()) {
    for (const v of message.elements) {
      Arg.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal114.default.Reader ? input : import_minimal114.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.elements.push(Arg.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      elements: globalThis.Array.isArray(object?.elements) ? object.elements.map((e) => Arg.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => Arg.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Args.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseArgs();
    message.elements = object.elements?.map((e) => Arg.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(Args.$type, Args);
function longToNumber13(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal114.default.util.Long !== import_long13.default) {
  import_minimal114.default.util.Long = import_long13.default;
  import_minimal114.default.configure();
}
function isSet104(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/permissions/permissions.js
var import_minimal115 = __toESM(require_minimal2(), 1);
var Permission;
(function(Permission2) {
  Permission2[Permission2["SYSTEM"] = 0] = "SYSTEM";
  Permission2[Permission2["HTTP"] = 1] = "HTTP";
  Permission2[Permission2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Permission || (Permission = {}));
function permissionFromJSON(object) {
  switch (object) {
    case 0:
    case "SYSTEM":
      return Permission.SYSTEM;
    case 1:
    case "HTTP":
      return Permission.HTTP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Permission.UNRECOGNIZED;
  }
}
function permissionToJSON(object) {
  switch (object) {
    case Permission.SYSTEM:
      return 0;
    case Permission.HTTP:
      return 1;
    case Permission.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseNestedRule() {
  return { requires: [] };
}
var NestedRule = {
  $type: "devvit.actor.permissions.NestedRule",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    for (const v of message.requires) {
      PermissionOrRule.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : import_minimal115.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNestedRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.requires.push(PermissionOrRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requires: globalThis.Array.isArray(object?.requires) ? object.requires.map((e) => PermissionOrRule.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requires?.length) {
      obj.requires = message.requires.map((e) => PermissionOrRule.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return NestedRule.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNestedRule();
    message.requires = object.requires?.map((e) => PermissionOrRule.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(NestedRule.$type, NestedRule);
function createBasePermissionOrRule() {
  return { permission: void 0, and: void 0, or: void 0 };
}
var PermissionOrRule = {
  $type: "devvit.actor.permissions.PermissionOrRule",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.permission !== void 0) {
      writer.uint32(8).int32(message.permission);
    }
    if (message.and !== void 0) {
      NestedRule.encode(message.and, writer.uint32(18).fork()).ldelim();
    }
    if (message.or !== void 0) {
      NestedRule.encode(message.or, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : import_minimal115.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePermissionOrRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.permission = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.and = NestedRule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.or = NestedRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      permission: isSet105(object.permission) ? permissionFromJSON(object.permission) : void 0,
      and: isSet105(object.and) ? NestedRule.fromJSON(object.and) : void 0,
      or: isSet105(object.or) ? NestedRule.fromJSON(object.or) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.permission !== void 0) {
      obj.permission = permissionToJSON(message.permission);
    }
    if (message.and !== void 0) {
      obj.and = NestedRule.toJSON(message.and);
    }
    if (message.or !== void 0) {
      obj.or = NestedRule.toJSON(message.or);
    }
    return obj;
  },
  create(base) {
    return PermissionOrRule.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePermissionOrRule();
    message.permission = object.permission ?? void 0;
    message.and = object.and !== void 0 && object.and !== null ? NestedRule.fromPartial(object.and) : void 0;
    message.or = object.or !== void 0 && object.or !== null ? NestedRule.fromPartial(object.or) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PermissionOrRule.$type, PermissionOrRule);
function createBasePermissionConfig() {
  return { actor: "", has: [], requires: [] };
}
var PermissionConfig = {
  $type: "devvit.actor.permissions.PermissionConfig",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    writer.uint32(18).fork();
    for (const v of message.has) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.requires) {
      PermissionOrRule.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : import_minimal115.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePermissionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.has.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.has.push(reader.int32());
            }
            continue;
          }
          break;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.requires.push(PermissionOrRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet105(object.actor) ? globalThis.String(object.actor) : "",
      has: globalThis.Array.isArray(object?.has) ? object.has.map((e) => permissionFromJSON(e)) : [],
      requires: globalThis.Array.isArray(object?.requires) ? object.requires.map((e) => PermissionOrRule.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.has?.length) {
      obj.has = message.has.map((e) => permissionToJSON(e));
    }
    if (message.requires?.length) {
      obj.requires = message.requires.map((e) => PermissionOrRule.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return PermissionConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePermissionConfig();
    message.actor = object.actor ?? "";
    message.has = object.has?.map((e) => e) || [];
    message.requires = object.requires?.map((e) => PermissionOrRule.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(PermissionConfig.$type, PermissionConfig);
function createBasePermissionList() {
  return { permissions: [] };
}
var PermissionList = {
  $type: "devvit.actor.permissions.PermissionList",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    for (const v of message.permissions) {
      PermissionConfig.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : import_minimal115.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePermissionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.permissions.push(PermissionConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      permissions: globalThis.Array.isArray(object?.permissions) ? object.permissions.map((e) => PermissionConfig.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => PermissionConfig.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return PermissionList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePermissionList();
    message.permissions = object.permissions?.map((e) => PermissionConfig.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(PermissionList.$type, PermissionList);
function isSet105(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/hello/hello.js
var import_minimal116 = __toESM(require_minimal2(), 1);
function createBasePingMessage() {
  return { message: "", delayMillis: 0, successProbability: 0 };
}
var PingMessage = {
  $type: "devvit.actor.hello.PingMessage",
  encode(message, writer = import_minimal116.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.delayMillis !== 0) {
      writer.uint32(16).int32(message.delayMillis);
    }
    if (message.successProbability !== 0) {
      writer.uint32(29).float(message.successProbability);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal116.default.Reader ? input : import_minimal116.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.delayMillis = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }
          message.successProbability = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet106(object.message) ? globalThis.String(object.message) : "",
      delayMillis: isSet106(object.delayMillis) ? globalThis.Number(object.delayMillis) : 0,
      successProbability: isSet106(object.successProbability) ? globalThis.Number(object.successProbability) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.delayMillis !== 0) {
      obj.delayMillis = Math.round(message.delayMillis);
    }
    if (message.successProbability !== 0) {
      obj.successProbability = message.successProbability;
    }
    return obj;
  },
  create(base) {
    return PingMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePingMessage();
    message.message = object.message ?? "";
    message.delayMillis = object.delayMillis ?? 0;
    message.successProbability = object.successProbability ?? 0;
    return message;
  }
};
messageTypeRegistry.set(PingMessage.$type, PingMessage);
function isSet106(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/gl/glclient.js
var import_minimal117 = __toESM(require_minimal2(), 1);
function createBaseConfigMessage() {
  return { width: 0, height: 0 };
}
var ConfigMessage = {
  $type: "devvit.actor.gl.ConfigMessage",
  encode(message, writer = import_minimal117.default.Writer.create()) {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal117.default.Reader ? input : import_minimal117.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      width: isSet107(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet107(object.height) ? globalThis.Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },
  create(base) {
    return ConfigMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConfigMessage();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  }
};
messageTypeRegistry.set(ConfigMessage.$type, ConfigMessage);
function createBaseTickMessage() {
  return {};
}
var TickMessage = {
  $type: "devvit.actor.gl.TickMessage",
  encode(_, writer = import_minimal117.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal117.default.Reader ? input : import_minimal117.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTickMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return TickMessage.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseTickMessage();
    return message;
  }
};
messageTypeRegistry.set(TickMessage.$type, TickMessage);
function createBaseInputMessage() {
  return {};
}
var InputMessage = {
  $type: "devvit.actor.gl.InputMessage",
  encode(_, writer = import_minimal117.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal117.default.Reader ? input : import_minimal117.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInputMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return InputMessage.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseInputMessage();
    return message;
  }
};
messageTypeRegistry.set(InputMessage.$type, InputMessage);
function isSet107(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/bot/bot.js
var import_minimal118 = __toESM(require_minimal2(), 1);
function createBaseCommandDescription() {
  return { name: "", command: "", description: "", usage: "" };
}
var CommandDescription = {
  $type: "devvit.actor.bot.CommandDescription",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.usage !== "") {
      writer.uint32(34).string(message.usage);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : import_minimal118.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.command = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.usage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet108(object.name) ? globalThis.String(object.name) : "",
      command: isSet108(object.command) ? globalThis.String(object.command) : "",
      description: isSet108(object.description) ? globalThis.String(object.description) : "",
      usage: isSet108(object.usage) ? globalThis.String(object.usage) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.usage !== "") {
      obj.usage = message.usage;
    }
    return obj;
  },
  create(base) {
    return CommandDescription.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommandDescription();
    message.name = object.name ?? "";
    message.command = object.command ?? "";
    message.description = object.description ?? "";
    message.usage = object.usage ?? "";
    return message;
  }
};
messageTypeRegistry.set(CommandDescription.$type, CommandDescription);
function createBaseCommandsList() {
  return { commands: [] };
}
var CommandsList = {
  $type: "devvit.actor.bot.CommandsList",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    for (const v of message.commands) {
      CommandDescription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : import_minimal118.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.commands.push(CommandDescription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      commands: globalThis.Array.isArray(object?.commands) ? object.commands.map((e) => CommandDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => CommandDescription.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return CommandsList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommandsList();
    message.commands = object.commands?.map((e) => CommandDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(CommandsList.$type, CommandsList);
function createBaseCommandContext() {
  return { user: "", subreddit: "", post: "", comment: "" };
}
var CommandContext = {
  $type: "devvit.actor.bot.CommandContext",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    if (message.post !== "") {
      writer.uint32(26).string(message.post);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : import_minimal118.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.user = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.post = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      user: isSet108(object.user) ? globalThis.String(object.user) : "",
      subreddit: isSet108(object.subreddit) ? globalThis.String(object.subreddit) : "",
      post: isSet108(object.post) ? globalThis.String(object.post) : "",
      comment: isSet108(object.comment) ? globalThis.String(object.comment) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.post !== "") {
      obj.post = message.post;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },
  create(base) {
    return CommandContext.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommandContext();
    message.user = object.user ?? "";
    message.subreddit = object.subreddit ?? "";
    message.post = object.post ?? "";
    message.comment = object.comment ?? "";
    return message;
  }
};
messageTypeRegistry.set(CommandContext.$type, CommandContext);
function createBaseCommandRequest() {
  return { context: void 0, command: "", args: "" };
}
var CommandRequest = {
  $type: "devvit.actor.bot.CommandRequest",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.context !== void 0) {
      CommandContext.encode(message.context, writer.uint32(10).fork()).ldelim();
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.args !== "") {
      writer.uint32(26).string(message.args);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : import_minimal118.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.context = CommandContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.command = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.args = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      context: isSet108(object.context) ? CommandContext.fromJSON(object.context) : void 0,
      command: isSet108(object.command) ? globalThis.String(object.command) : "",
      args: isSet108(object.args) ? globalThis.String(object.args) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.context !== void 0) {
      obj.context = CommandContext.toJSON(message.context);
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.args !== "") {
      obj.args = message.args;
    }
    return obj;
  },
  create(base) {
    return CommandRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommandRequest();
    message.context = object.context !== void 0 && object.context !== null ? CommandContext.fromPartial(object.context) : void 0;
    message.command = object.command ?? "";
    message.args = object.args ?? "";
    return message;
  }
};
messageTypeRegistry.set(CommandRequest.$type, CommandRequest);
function isSet108(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/events/v1alpha/handle_ui.js
var import_minimal119 = __toESM(require_minimal2(), 1);
function createBaseHandleUIEventRequest() {
  return { state: void 0, event: void 0 };
}
var HandleUIEventRequest = {
  $type: "devvit.ui.events.v1alpha.HandleUIEventRequest",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    if (message.event !== void 0) {
      UIEvent.encode(message.event, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : import_minimal119.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHandleUIEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.event = UIEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject22(object.state) ? object.state : void 0,
      event: isSet109(object.event) ? UIEvent.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.event !== void 0) {
      obj.event = UIEvent.toJSON(message.event);
    }
    return obj;
  },
  create(base) {
    return HandleUIEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHandleUIEventRequest();
    message.state = object.state ?? void 0;
    message.event = object.event !== void 0 && object.event !== null ? UIEvent.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set(HandleUIEventRequest.$type, HandleUIEventRequest);
function createBaseHandleUIEventResponse() {
  return { state: void 0, effects: [] };
}
var HandleUIEventResponse = {
  $type: "devvit.ui.events.v1alpha.HandleUIEventResponse",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : import_minimal119.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHandleUIEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject22(object.state) ? object.state : void 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return HandleUIEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHandleUIEventResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(HandleUIEventResponse.$type, HandleUIEventResponse);
function isObject22(value) {
  return typeof value === "object" && value !== null;
}
function isSet109(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/common/v1alpha/common.js
var import_minimal120 = __toESM(require_minimal2(), 1);
function createBaseUIDimensions() {
  return { height: 0, width: 0, scale: 0 };
}
var UIDimensions = {
  $type: "devvit.ui.common.v1alpha.UIDimensions",
  encode(message, writer = import_minimal120.default.Writer.create()) {
    if (message.height !== 0) {
      writer.uint32(8).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.scale !== 0) {
      writer.uint32(29).float(message.scale);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal120.default.Reader ? input : import_minimal120.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }
          message.scale = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet110(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet110(object.width) ? globalThis.Number(object.width) : 0,
      scale: isSet110(object.scale) ? globalThis.Number(object.scale) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.scale !== 0) {
      obj.scale = message.scale;
    }
    return obj;
  },
  create(base) {
    return UIDimensions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUIDimensions();
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.scale = object.scale ?? 0;
    return message;
  }
};
messageTypeRegistry.set(UIDimensions.$type, UIDimensions);
function isSet110(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/ui.js
var import_minimal123 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/block.js
var import_minimal122 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/attributes.js
var import_minimal121 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/enums.js
var BlockType;
(function(BlockType2) {
  BlockType2[BlockType2["BLOCK_ROOT"] = 0] = "BLOCK_ROOT";
  BlockType2[BlockType2["BLOCK_STACK"] = 1] = "BLOCK_STACK";
  BlockType2[BlockType2["BLOCK_TEXT"] = 2] = "BLOCK_TEXT";
  BlockType2[BlockType2["BLOCK_BUTTON"] = 3] = "BLOCK_BUTTON";
  BlockType2[BlockType2["BLOCK_IMAGE"] = 4] = "BLOCK_IMAGE";
  BlockType2[BlockType2["BLOCK_SPACER"] = 5] = "BLOCK_SPACER";
  BlockType2[BlockType2["BLOCK_ICON"] = 6] = "BLOCK_ICON";
  BlockType2[BlockType2["BLOCK_AVATAR"] = 7] = "BLOCK_AVATAR";
  BlockType2[BlockType2["BLOCK_FULLSNOO"] = 8] = "BLOCK_FULLSNOO";
  BlockType2[BlockType2["BLOCK_ANIMATION"] = 9] = "BLOCK_ANIMATION";
  BlockType2[BlockType2["BLOCK_WEBVIEW"] = 100] = "BLOCK_WEBVIEW";
  BlockType2[BlockType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockType || (BlockType = {}));
function blockTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "BLOCK_ROOT":
      return BlockType.BLOCK_ROOT;
    case 1:
    case "BLOCK_STACK":
      return BlockType.BLOCK_STACK;
    case 2:
    case "BLOCK_TEXT":
      return BlockType.BLOCK_TEXT;
    case 3:
    case "BLOCK_BUTTON":
      return BlockType.BLOCK_BUTTON;
    case 4:
    case "BLOCK_IMAGE":
      return BlockType.BLOCK_IMAGE;
    case 5:
    case "BLOCK_SPACER":
      return BlockType.BLOCK_SPACER;
    case 6:
    case "BLOCK_ICON":
      return BlockType.BLOCK_ICON;
    case 7:
    case "BLOCK_AVATAR":
      return BlockType.BLOCK_AVATAR;
    case 8:
    case "BLOCK_FULLSNOO":
      return BlockType.BLOCK_FULLSNOO;
    case 9:
    case "BLOCK_ANIMATION":
      return BlockType.BLOCK_ANIMATION;
    case 100:
    case "BLOCK_WEBVIEW":
      return BlockType.BLOCK_WEBVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockType.UNRECOGNIZED;
  }
}
function blockTypeToJSON(object) {
  switch (object) {
    case BlockType.BLOCK_ROOT:
      return 0;
    case BlockType.BLOCK_STACK:
      return 1;
    case BlockType.BLOCK_TEXT:
      return 2;
    case BlockType.BLOCK_BUTTON:
      return 3;
    case BlockType.BLOCK_IMAGE:
      return 4;
    case BlockType.BLOCK_SPACER:
      return 5;
    case BlockType.BLOCK_ICON:
      return 6;
    case BlockType.BLOCK_AVATAR:
      return 7;
    case BlockType.BLOCK_FULLSNOO:
      return 8;
    case BlockType.BLOCK_ANIMATION:
      return 9;
    case BlockType.BLOCK_WEBVIEW:
      return 100;
    case BlockType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockActionType;
(function(BlockActionType2) {
  BlockActionType2[BlockActionType2["ACTION_CLICK"] = 0] = "ACTION_CLICK";
  BlockActionType2[BlockActionType2["ACTION_WEBVIEW"] = 100] = "ACTION_WEBVIEW";
  BlockActionType2[BlockActionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockActionType || (BlockActionType = {}));
function blockActionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTION_CLICK":
      return BlockActionType.ACTION_CLICK;
    case 100:
    case "ACTION_WEBVIEW":
      return BlockActionType.ACTION_WEBVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockActionType.UNRECOGNIZED;
  }
}
function blockActionTypeToJSON(object) {
  switch (object) {
    case BlockActionType.ACTION_CLICK:
      return 0;
    case BlockActionType.ACTION_WEBVIEW:
      return 100;
    case BlockActionType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockRenderEventType;
(function(BlockRenderEventType2) {
  BlockRenderEventType2[BlockRenderEventType2["RENDER_INITIAL"] = 0] = "RENDER_INITIAL";
  BlockRenderEventType2[BlockRenderEventType2["RENDER_USER_ACTION"] = 1] = "RENDER_USER_ACTION";
  BlockRenderEventType2[BlockRenderEventType2["RENDER_EFFECT_EVENT"] = 2] = "RENDER_EFFECT_EVENT";
  BlockRenderEventType2[BlockRenderEventType2["RENDER_CACHED"] = 3] = "RENDER_CACHED";
  BlockRenderEventType2[BlockRenderEventType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockRenderEventType || (BlockRenderEventType = {}));
function blockRenderEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "RENDER_INITIAL":
      return BlockRenderEventType.RENDER_INITIAL;
    case 1:
    case "RENDER_USER_ACTION":
      return BlockRenderEventType.RENDER_USER_ACTION;
    case 2:
    case "RENDER_EFFECT_EVENT":
      return BlockRenderEventType.RENDER_EFFECT_EVENT;
    case 3:
    case "RENDER_CACHED":
      return BlockRenderEventType.RENDER_CACHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockRenderEventType.UNRECOGNIZED;
  }
}
function blockRenderEventTypeToJSON(object) {
  switch (object) {
    case BlockRenderEventType.RENDER_INITIAL:
      return 0;
    case BlockRenderEventType.RENDER_USER_ACTION:
      return 1;
    case BlockRenderEventType.RENDER_EFFECT_EVENT:
      return 2;
    case BlockRenderEventType.RENDER_CACHED:
      return 3;
    case BlockRenderEventType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockStackDirection;
(function(BlockStackDirection2) {
  BlockStackDirection2[BlockStackDirection2["STACK_HORIZONTAL"] = 0] = "STACK_HORIZONTAL";
  BlockStackDirection2[BlockStackDirection2["STACK_VERTICAL"] = 1] = "STACK_VERTICAL";
  BlockStackDirection2[BlockStackDirection2["STACK_DEPTH"] = 2] = "STACK_DEPTH";
  BlockStackDirection2[BlockStackDirection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockStackDirection || (BlockStackDirection = {}));
function blockStackDirectionFromJSON(object) {
  switch (object) {
    case 0:
    case "STACK_HORIZONTAL":
      return BlockStackDirection.STACK_HORIZONTAL;
    case 1:
    case "STACK_VERTICAL":
      return BlockStackDirection.STACK_VERTICAL;
    case 2:
    case "STACK_DEPTH":
      return BlockStackDirection.STACK_DEPTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockStackDirection.UNRECOGNIZED;
  }
}
function blockStackDirectionToJSON(object) {
  switch (object) {
    case BlockStackDirection.STACK_HORIZONTAL:
      return 0;
    case BlockStackDirection.STACK_VERTICAL:
      return 1;
    case BlockStackDirection.STACK_DEPTH:
      return 2;
    case BlockStackDirection.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockBorderWidth;
(function(BlockBorderWidth2) {
  BlockBorderWidth2[BlockBorderWidth2["BORDER_WIDTH_NONE"] = 0] = "BORDER_WIDTH_NONE";
  BlockBorderWidth2[BlockBorderWidth2["BORDER_WIDTH_THIN"] = 1] = "BORDER_WIDTH_THIN";
  BlockBorderWidth2[BlockBorderWidth2["BORDER_WIDTH_THICK"] = 2] = "BORDER_WIDTH_THICK";
  BlockBorderWidth2[BlockBorderWidth2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockBorderWidth || (BlockBorderWidth = {}));
function blockBorderWidthFromJSON(object) {
  switch (object) {
    case 0:
    case "BORDER_WIDTH_NONE":
      return BlockBorderWidth.BORDER_WIDTH_NONE;
    case 1:
    case "BORDER_WIDTH_THIN":
      return BlockBorderWidth.BORDER_WIDTH_THIN;
    case 2:
    case "BORDER_WIDTH_THICK":
      return BlockBorderWidth.BORDER_WIDTH_THICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockBorderWidth.UNRECOGNIZED;
  }
}
function blockBorderWidthToJSON(object) {
  switch (object) {
    case BlockBorderWidth.BORDER_WIDTH_NONE:
      return 0;
    case BlockBorderWidth.BORDER_WIDTH_THIN:
      return 1;
    case BlockBorderWidth.BORDER_WIDTH_THICK:
      return 2;
    case BlockBorderWidth.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockVerticalAlignment;
(function(BlockVerticalAlignment2) {
  BlockVerticalAlignment2[BlockVerticalAlignment2["ALIGN_TOP"] = 0] = "ALIGN_TOP";
  BlockVerticalAlignment2[BlockVerticalAlignment2["ALIGN_MIDDLE"] = 1] = "ALIGN_MIDDLE";
  BlockVerticalAlignment2[BlockVerticalAlignment2["ALIGN_BOTTOM"] = 2] = "ALIGN_BOTTOM";
  BlockVerticalAlignment2[BlockVerticalAlignment2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockVerticalAlignment || (BlockVerticalAlignment = {}));
function blockVerticalAlignmentFromJSON(object) {
  switch (object) {
    case 0:
    case "ALIGN_TOP":
      return BlockVerticalAlignment.ALIGN_TOP;
    case 1:
    case "ALIGN_MIDDLE":
      return BlockVerticalAlignment.ALIGN_MIDDLE;
    case 2:
    case "ALIGN_BOTTOM":
      return BlockVerticalAlignment.ALIGN_BOTTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockVerticalAlignment.UNRECOGNIZED;
  }
}
function blockVerticalAlignmentToJSON(object) {
  switch (object) {
    case BlockVerticalAlignment.ALIGN_TOP:
      return 0;
    case BlockVerticalAlignment.ALIGN_MIDDLE:
      return 1;
    case BlockVerticalAlignment.ALIGN_BOTTOM:
      return 2;
    case BlockVerticalAlignment.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockHorizontalAlignment;
(function(BlockHorizontalAlignment2) {
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["ALIGN_START"] = 0] = "ALIGN_START";
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["ALIGN_CENTER"] = 1] = "ALIGN_CENTER";
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["ALIGN_END"] = 2] = "ALIGN_END";
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockHorizontalAlignment || (BlockHorizontalAlignment = {}));
function blockHorizontalAlignmentFromJSON(object) {
  switch (object) {
    case 0:
    case "ALIGN_START":
      return BlockHorizontalAlignment.ALIGN_START;
    case 1:
    case "ALIGN_CENTER":
      return BlockHorizontalAlignment.ALIGN_CENTER;
    case 2:
    case "ALIGN_END":
      return BlockHorizontalAlignment.ALIGN_END;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockHorizontalAlignment.UNRECOGNIZED;
  }
}
function blockHorizontalAlignmentToJSON(object) {
  switch (object) {
    case BlockHorizontalAlignment.ALIGN_START:
      return 0;
    case BlockHorizontalAlignment.ALIGN_CENTER:
      return 1;
    case BlockHorizontalAlignment.ALIGN_END:
      return 2;
    case BlockHorizontalAlignment.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockPadding;
(function(BlockPadding2) {
  BlockPadding2[BlockPadding2["PADDING_NONE"] = 0] = "PADDING_NONE";
  BlockPadding2[BlockPadding2["PADDING_XSMALL"] = 1] = "PADDING_XSMALL";
  BlockPadding2[BlockPadding2["PADDING_SMALL"] = 2] = "PADDING_SMALL";
  BlockPadding2[BlockPadding2["PADDING_MEDIUM"] = 3] = "PADDING_MEDIUM";
  BlockPadding2[BlockPadding2["PADDING_LARGE"] = 4] = "PADDING_LARGE";
  BlockPadding2[BlockPadding2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockPadding || (BlockPadding = {}));
function blockPaddingFromJSON(object) {
  switch (object) {
    case 0:
    case "PADDING_NONE":
      return BlockPadding.PADDING_NONE;
    case 1:
    case "PADDING_XSMALL":
      return BlockPadding.PADDING_XSMALL;
    case 2:
    case "PADDING_SMALL":
      return BlockPadding.PADDING_SMALL;
    case 3:
    case "PADDING_MEDIUM":
      return BlockPadding.PADDING_MEDIUM;
    case 4:
    case "PADDING_LARGE":
      return BlockPadding.PADDING_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockPadding.UNRECOGNIZED;
  }
}
function blockPaddingToJSON(object) {
  switch (object) {
    case BlockPadding.PADDING_NONE:
      return 0;
    case BlockPadding.PADDING_XSMALL:
      return 1;
    case BlockPadding.PADDING_SMALL:
      return 2;
    case BlockPadding.PADDING_MEDIUM:
      return 3;
    case BlockPadding.PADDING_LARGE:
      return 4;
    case BlockPadding.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockGap;
(function(BlockGap2) {
  BlockGap2[BlockGap2["GAP_NONE"] = 0] = "GAP_NONE";
  BlockGap2[BlockGap2["GAP_SMALL"] = 1] = "GAP_SMALL";
  BlockGap2[BlockGap2["GAP_MEDIUM"] = 2] = "GAP_MEDIUM";
  BlockGap2[BlockGap2["GAP_LARGE"] = 3] = "GAP_LARGE";
  BlockGap2[BlockGap2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockGap || (BlockGap = {}));
function blockGapFromJSON(object) {
  switch (object) {
    case 0:
    case "GAP_NONE":
      return BlockGap.GAP_NONE;
    case 1:
    case "GAP_SMALL":
      return BlockGap.GAP_SMALL;
    case 2:
    case "GAP_MEDIUM":
      return BlockGap.GAP_MEDIUM;
    case 3:
    case "GAP_LARGE":
      return BlockGap.GAP_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockGap.UNRECOGNIZED;
  }
}
function blockGapToJSON(object) {
  switch (object) {
    case BlockGap.GAP_NONE:
      return 0;
    case BlockGap.GAP_SMALL:
      return 1;
    case BlockGap.GAP_MEDIUM:
      return 2;
    case BlockGap.GAP_LARGE:
      return 3;
    case BlockGap.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockRadius;
(function(BlockRadius2) {
  BlockRadius2[BlockRadius2["RADIUS_NONE"] = 0] = "RADIUS_NONE";
  BlockRadius2[BlockRadius2["RADIUS_SMALL"] = 1] = "RADIUS_SMALL";
  BlockRadius2[BlockRadius2["RADIUS_MEDIUM"] = 2] = "RADIUS_MEDIUM";
  BlockRadius2[BlockRadius2["RADIUS_LARGE"] = 3] = "RADIUS_LARGE";
  BlockRadius2[BlockRadius2["RADIUS_FULL"] = 100] = "RADIUS_FULL";
  BlockRadius2[BlockRadius2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockRadius || (BlockRadius = {}));
function blockRadiusFromJSON(object) {
  switch (object) {
    case 0:
    case "RADIUS_NONE":
      return BlockRadius.RADIUS_NONE;
    case 1:
    case "RADIUS_SMALL":
      return BlockRadius.RADIUS_SMALL;
    case 2:
    case "RADIUS_MEDIUM":
      return BlockRadius.RADIUS_MEDIUM;
    case 3:
    case "RADIUS_LARGE":
      return BlockRadius.RADIUS_LARGE;
    case 100:
    case "RADIUS_FULL":
      return BlockRadius.RADIUS_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockRadius.UNRECOGNIZED;
  }
}
function blockRadiusToJSON(object) {
  switch (object) {
    case BlockRadius.RADIUS_NONE:
      return 0;
    case BlockRadius.RADIUS_SMALL:
      return 1;
    case BlockRadius.RADIUS_MEDIUM:
      return 2;
    case BlockRadius.RADIUS_LARGE:
      return 3;
    case BlockRadius.RADIUS_FULL:
      return 100;
    case BlockRadius.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextSize;
(function(BlockTextSize2) {
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_MEDIUM"] = 0] = "TEXT_SIZE_MEDIUM";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_XSMALL"] = 1] = "TEXT_SIZE_XSMALL";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_SMALL"] = 2] = "TEXT_SIZE_SMALL";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_LARGE"] = 3] = "TEXT_SIZE_LARGE";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_XLARGE"] = 4] = "TEXT_SIZE_XLARGE";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_XXLARGE"] = 5] = "TEXT_SIZE_XXLARGE";
  BlockTextSize2[BlockTextSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextSize || (BlockTextSize = {}));
function blockTextSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_SIZE_MEDIUM":
      return BlockTextSize.TEXT_SIZE_MEDIUM;
    case 1:
    case "TEXT_SIZE_XSMALL":
      return BlockTextSize.TEXT_SIZE_XSMALL;
    case 2:
    case "TEXT_SIZE_SMALL":
      return BlockTextSize.TEXT_SIZE_SMALL;
    case 3:
    case "TEXT_SIZE_LARGE":
      return BlockTextSize.TEXT_SIZE_LARGE;
    case 4:
    case "TEXT_SIZE_XLARGE":
      return BlockTextSize.TEXT_SIZE_XLARGE;
    case 5:
    case "TEXT_SIZE_XXLARGE":
      return BlockTextSize.TEXT_SIZE_XXLARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextSize.UNRECOGNIZED;
  }
}
function blockTextSizeToJSON(object) {
  switch (object) {
    case BlockTextSize.TEXT_SIZE_MEDIUM:
      return 0;
    case BlockTextSize.TEXT_SIZE_XSMALL:
      return 1;
    case BlockTextSize.TEXT_SIZE_SMALL:
      return 2;
    case BlockTextSize.TEXT_SIZE_LARGE:
      return 3;
    case BlockTextSize.TEXT_SIZE_XLARGE:
      return 4;
    case BlockTextSize.TEXT_SIZE_XXLARGE:
      return 5;
    case BlockTextSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextWeight;
(function(BlockTextWeight2) {
  BlockTextWeight2[BlockTextWeight2["TEXT_WEIGHT_REGULAR"] = 0] = "TEXT_WEIGHT_REGULAR";
  BlockTextWeight2[BlockTextWeight2["TEXT_WEIGHT_BOLD"] = 1] = "TEXT_WEIGHT_BOLD";
  BlockTextWeight2[BlockTextWeight2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextWeight || (BlockTextWeight = {}));
function blockTextWeightFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_WEIGHT_REGULAR":
      return BlockTextWeight.TEXT_WEIGHT_REGULAR;
    case 1:
    case "TEXT_WEIGHT_BOLD":
      return BlockTextWeight.TEXT_WEIGHT_BOLD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextWeight.UNRECOGNIZED;
  }
}
function blockTextWeightToJSON(object) {
  switch (object) {
    case BlockTextWeight.TEXT_WEIGHT_REGULAR:
      return 0;
    case BlockTextWeight.TEXT_WEIGHT_BOLD:
      return 1;
    case BlockTextWeight.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextOutline;
(function(BlockTextOutline2) {
  BlockTextOutline2[BlockTextOutline2["TEXT_OUTLINE_NONE"] = 0] = "TEXT_OUTLINE_NONE";
  BlockTextOutline2[BlockTextOutline2["TEXT_OUTLINE_THIN"] = 1] = "TEXT_OUTLINE_THIN";
  BlockTextOutline2[BlockTextOutline2["TEXT_OUTLINE_THICK"] = 2] = "TEXT_OUTLINE_THICK";
  BlockTextOutline2[BlockTextOutline2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextOutline || (BlockTextOutline = {}));
function blockTextOutlineFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_OUTLINE_NONE":
      return BlockTextOutline.TEXT_OUTLINE_NONE;
    case 1:
    case "TEXT_OUTLINE_THIN":
      return BlockTextOutline.TEXT_OUTLINE_THIN;
    case 2:
    case "TEXT_OUTLINE_THICK":
      return BlockTextOutline.TEXT_OUTLINE_THICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextOutline.UNRECOGNIZED;
  }
}
function blockTextOutlineToJSON(object) {
  switch (object) {
    case BlockTextOutline.TEXT_OUTLINE_NONE:
      return 0;
    case BlockTextOutline.TEXT_OUTLINE_THIN:
      return 1;
    case BlockTextOutline.TEXT_OUTLINE_THICK:
      return 2;
    case BlockTextOutline.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextStyle;
(function(BlockTextStyle2) {
  BlockTextStyle2[BlockTextStyle2["TEXT_STYLE_BODY"] = 0] = "TEXT_STYLE_BODY";
  BlockTextStyle2[BlockTextStyle2["TEXT_STYLE_METADATA"] = 1] = "TEXT_STYLE_METADATA";
  BlockTextStyle2[BlockTextStyle2["TEXT_STYLE_HEADING"] = 2] = "TEXT_STYLE_HEADING";
  BlockTextStyle2[BlockTextStyle2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextStyle || (BlockTextStyle = {}));
function blockTextStyleFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_STYLE_BODY":
      return BlockTextStyle.TEXT_STYLE_BODY;
    case 1:
    case "TEXT_STYLE_METADATA":
      return BlockTextStyle.TEXT_STYLE_METADATA;
    case 2:
    case "TEXT_STYLE_HEADING":
      return BlockTextStyle.TEXT_STYLE_HEADING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextStyle.UNRECOGNIZED;
  }
}
function blockTextStyleToJSON(object) {
  switch (object) {
    case BlockTextStyle.TEXT_STYLE_BODY:
      return 0;
    case BlockTextStyle.TEXT_STYLE_METADATA:
      return 1;
    case BlockTextStyle.TEXT_STYLE_HEADING:
      return 2;
    case BlockTextStyle.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockButtonSize;
(function(BlockButtonSize2) {
  BlockButtonSize2[BlockButtonSize2["BUTTON_SIZE_MEDIUM"] = 0] = "BUTTON_SIZE_MEDIUM";
  BlockButtonSize2[BlockButtonSize2["BUTTON_SIZE_SMALL"] = 1] = "BUTTON_SIZE_SMALL";
  BlockButtonSize2[BlockButtonSize2["BUTTON_SIZE_LARGE"] = 2] = "BUTTON_SIZE_LARGE";
  BlockButtonSize2[BlockButtonSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockButtonSize || (BlockButtonSize = {}));
function blockButtonSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "BUTTON_SIZE_MEDIUM":
      return BlockButtonSize.BUTTON_SIZE_MEDIUM;
    case 1:
    case "BUTTON_SIZE_SMALL":
      return BlockButtonSize.BUTTON_SIZE_SMALL;
    case 2:
    case "BUTTON_SIZE_LARGE":
      return BlockButtonSize.BUTTON_SIZE_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockButtonSize.UNRECOGNIZED;
  }
}
function blockButtonSizeToJSON(object) {
  switch (object) {
    case BlockButtonSize.BUTTON_SIZE_MEDIUM:
      return 0;
    case BlockButtonSize.BUTTON_SIZE_SMALL:
      return 1;
    case BlockButtonSize.BUTTON_SIZE_LARGE:
      return 2;
    case BlockButtonSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockButtonAppearance;
(function(BlockButtonAppearance2) {
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_SECONDARY"] = 0] = "BUTTON_APPEARANCE_SECONDARY";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_PRIMARY"] = 1] = "BUTTON_APPEARANCE_PRIMARY";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_PLAIN"] = 2] = "BUTTON_APPEARANCE_PLAIN";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_BORDERED"] = 3] = "BUTTON_APPEARANCE_BORDERED";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_MEDIA"] = 4] = "BUTTON_APPEARANCE_MEDIA";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_DESTRUCTIVE"] = 5] = "BUTTON_APPEARANCE_DESTRUCTIVE";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_CAUTION"] = 6] = "BUTTON_APPEARANCE_CAUTION";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_SUCCESS"] = 7] = "BUTTON_APPEARANCE_SUCCESS";
  BlockButtonAppearance2[BlockButtonAppearance2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockButtonAppearance || (BlockButtonAppearance = {}));
function blockButtonAppearanceFromJSON(object) {
  switch (object) {
    case 0:
    case "BUTTON_APPEARANCE_SECONDARY":
      return BlockButtonAppearance.BUTTON_APPEARANCE_SECONDARY;
    case 1:
    case "BUTTON_APPEARANCE_PRIMARY":
      return BlockButtonAppearance.BUTTON_APPEARANCE_PRIMARY;
    case 2:
    case "BUTTON_APPEARANCE_PLAIN":
      return BlockButtonAppearance.BUTTON_APPEARANCE_PLAIN;
    case 3:
    case "BUTTON_APPEARANCE_BORDERED":
      return BlockButtonAppearance.BUTTON_APPEARANCE_BORDERED;
    case 4:
    case "BUTTON_APPEARANCE_MEDIA":
      return BlockButtonAppearance.BUTTON_APPEARANCE_MEDIA;
    case 5:
    case "BUTTON_APPEARANCE_DESTRUCTIVE":
      return BlockButtonAppearance.BUTTON_APPEARANCE_DESTRUCTIVE;
    case 6:
    case "BUTTON_APPEARANCE_CAUTION":
      return BlockButtonAppearance.BUTTON_APPEARANCE_CAUTION;
    case 7:
    case "BUTTON_APPEARANCE_SUCCESS":
      return BlockButtonAppearance.BUTTON_APPEARANCE_SUCCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockButtonAppearance.UNRECOGNIZED;
  }
}
function blockButtonAppearanceToJSON(object) {
  switch (object) {
    case BlockButtonAppearance.BUTTON_APPEARANCE_SECONDARY:
      return 0;
    case BlockButtonAppearance.BUTTON_APPEARANCE_PRIMARY:
      return 1;
    case BlockButtonAppearance.BUTTON_APPEARANCE_PLAIN:
      return 2;
    case BlockButtonAppearance.BUTTON_APPEARANCE_BORDERED:
      return 3;
    case BlockButtonAppearance.BUTTON_APPEARANCE_MEDIA:
      return 4;
    case BlockButtonAppearance.BUTTON_APPEARANCE_DESTRUCTIVE:
      return 5;
    case BlockButtonAppearance.BUTTON_APPEARANCE_CAUTION:
      return 6;
    case BlockButtonAppearance.BUTTON_APPEARANCE_SUCCESS:
      return 7;
    case BlockButtonAppearance.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockImageResizeMode;
(function(BlockImageResizeMode2) {
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_FIT"] = 0] = "IMAGE_RESIZE_FIT";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_FILL"] = 1] = "IMAGE_RESIZE_FILL";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_COVER"] = 2] = "IMAGE_RESIZE_COVER";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_NONE"] = 3] = "IMAGE_RESIZE_NONE";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_SCALE_DOWN"] = 4] = "IMAGE_RESIZE_SCALE_DOWN";
  BlockImageResizeMode2[BlockImageResizeMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockImageResizeMode || (BlockImageResizeMode = {}));
function blockImageResizeModeFromJSON(object) {
  switch (object) {
    case 0:
    case "IMAGE_RESIZE_FIT":
      return BlockImageResizeMode.IMAGE_RESIZE_FIT;
    case 1:
    case "IMAGE_RESIZE_FILL":
      return BlockImageResizeMode.IMAGE_RESIZE_FILL;
    case 2:
    case "IMAGE_RESIZE_COVER":
      return BlockImageResizeMode.IMAGE_RESIZE_COVER;
    case 3:
    case "IMAGE_RESIZE_NONE":
      return BlockImageResizeMode.IMAGE_RESIZE_NONE;
    case 4:
    case "IMAGE_RESIZE_SCALE_DOWN":
      return BlockImageResizeMode.IMAGE_RESIZE_SCALE_DOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockImageResizeMode.UNRECOGNIZED;
  }
}
function blockImageResizeModeToJSON(object) {
  switch (object) {
    case BlockImageResizeMode.IMAGE_RESIZE_FIT:
      return 0;
    case BlockImageResizeMode.IMAGE_RESIZE_FILL:
      return 1;
    case BlockImageResizeMode.IMAGE_RESIZE_COVER:
      return 2;
    case BlockImageResizeMode.IMAGE_RESIZE_NONE:
      return 3;
    case BlockImageResizeMode.IMAGE_RESIZE_SCALE_DOWN:
      return 4;
    case BlockImageResizeMode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockSpacerSize;
(function(BlockSpacerSize2) {
  BlockSpacerSize2[BlockSpacerSize2["SPACER_SMALL"] = 0] = "SPACER_SMALL";
  BlockSpacerSize2[BlockSpacerSize2["SPACER_XSMALL"] = 1] = "SPACER_XSMALL";
  BlockSpacerSize2[BlockSpacerSize2["SPACER_MEDIUM"] = 2] = "SPACER_MEDIUM";
  BlockSpacerSize2[BlockSpacerSize2["SPACER_LARGE"] = 3] = "SPACER_LARGE";
  BlockSpacerSize2[BlockSpacerSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockSpacerSize || (BlockSpacerSize = {}));
function blockSpacerSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "SPACER_SMALL":
      return BlockSpacerSize.SPACER_SMALL;
    case 1:
    case "SPACER_XSMALL":
      return BlockSpacerSize.SPACER_XSMALL;
    case 2:
    case "SPACER_MEDIUM":
      return BlockSpacerSize.SPACER_MEDIUM;
    case 3:
    case "SPACER_LARGE":
      return BlockSpacerSize.SPACER_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockSpacerSize.UNRECOGNIZED;
  }
}
function blockSpacerSizeToJSON(object) {
  switch (object) {
    case BlockSpacerSize.SPACER_SMALL:
      return 0;
    case BlockSpacerSize.SPACER_XSMALL:
      return 1;
    case BlockSpacerSize.SPACER_MEDIUM:
      return 2;
    case BlockSpacerSize.SPACER_LARGE:
      return 3;
    case BlockSpacerSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockSpacerShape;
(function(BlockSpacerShape2) {
  BlockSpacerShape2[BlockSpacerShape2["SPACER_INVISIBLE"] = 0] = "SPACER_INVISIBLE";
  BlockSpacerShape2[BlockSpacerShape2["SPACER_THIN"] = 1] = "SPACER_THIN";
  BlockSpacerShape2[BlockSpacerShape2["SPACER_SQUARE"] = 2] = "SPACER_SQUARE";
  BlockSpacerShape2[BlockSpacerShape2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockSpacerShape || (BlockSpacerShape = {}));
function blockSpacerShapeFromJSON(object) {
  switch (object) {
    case 0:
    case "SPACER_INVISIBLE":
      return BlockSpacerShape.SPACER_INVISIBLE;
    case 1:
    case "SPACER_THIN":
      return BlockSpacerShape.SPACER_THIN;
    case 2:
    case "SPACER_SQUARE":
      return BlockSpacerShape.SPACER_SQUARE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockSpacerShape.UNRECOGNIZED;
  }
}
function blockSpacerShapeToJSON(object) {
  switch (object) {
    case BlockSpacerShape.SPACER_INVISIBLE:
      return 0;
    case BlockSpacerShape.SPACER_THIN:
      return 1;
    case BlockSpacerShape.SPACER_SQUARE:
      return 2;
    case BlockSpacerShape.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockIconSize;
(function(BlockIconSize2) {
  BlockIconSize2[BlockIconSize2["ICON_SIZE_MEDIUM"] = 0] = "ICON_SIZE_MEDIUM";
  BlockIconSize2[BlockIconSize2["ICON_SIZE_XSMALL"] = 1] = "ICON_SIZE_XSMALL";
  BlockIconSize2[BlockIconSize2["ICON_SIZE_SMALL"] = 2] = "ICON_SIZE_SMALL";
  BlockIconSize2[BlockIconSize2["ICON_SIZE_LARGE"] = 3] = "ICON_SIZE_LARGE";
  BlockIconSize2[BlockIconSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockIconSize || (BlockIconSize = {}));
function blockIconSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "ICON_SIZE_MEDIUM":
      return BlockIconSize.ICON_SIZE_MEDIUM;
    case 1:
    case "ICON_SIZE_XSMALL":
      return BlockIconSize.ICON_SIZE_XSMALL;
    case 2:
    case "ICON_SIZE_SMALL":
      return BlockIconSize.ICON_SIZE_SMALL;
    case 3:
    case "ICON_SIZE_LARGE":
      return BlockIconSize.ICON_SIZE_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockIconSize.UNRECOGNIZED;
  }
}
function blockIconSizeToJSON(object) {
  switch (object) {
    case BlockIconSize.ICON_SIZE_MEDIUM:
      return 0;
    case BlockIconSize.ICON_SIZE_XSMALL:
      return 1;
    case BlockIconSize.ICON_SIZE_SMALL:
      return 2;
    case BlockIconSize.ICON_SIZE_LARGE:
      return 3;
    case BlockIconSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAvatarFacing;
(function(BlockAvatarFacing2) {
  BlockAvatarFacing2[BlockAvatarFacing2["AVATAR_FACING_LEFT"] = 0] = "AVATAR_FACING_LEFT";
  BlockAvatarFacing2[BlockAvatarFacing2["AVATAR_FACING_RIGHT"] = 1] = "AVATAR_FACING_RIGHT";
  BlockAvatarFacing2[BlockAvatarFacing2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAvatarFacing || (BlockAvatarFacing = {}));
function blockAvatarFacingFromJSON(object) {
  switch (object) {
    case 0:
    case "AVATAR_FACING_LEFT":
      return BlockAvatarFacing.AVATAR_FACING_LEFT;
    case 1:
    case "AVATAR_FACING_RIGHT":
      return BlockAvatarFacing.AVATAR_FACING_RIGHT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAvatarFacing.UNRECOGNIZED;
  }
}
function blockAvatarFacingToJSON(object) {
  switch (object) {
    case BlockAvatarFacing.AVATAR_FACING_LEFT:
      return 0;
    case BlockAvatarFacing.AVATAR_FACING_RIGHT:
      return 1;
    case BlockAvatarFacing.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAvatarSize;
(function(BlockAvatarSize2) {
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_SMALL"] = 0] = "AVATAR_SIZE_SMALL";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XXSMALL"] = 1] = "AVATAR_SIZE_XXSMALL";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XSMALL"] = 2] = "AVATAR_SIZE_XSMALL";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_MEDIUM"] = 3] = "AVATAR_SIZE_MEDIUM";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_LARGE"] = 4] = "AVATAR_SIZE_LARGE";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XLARGE"] = 5] = "AVATAR_SIZE_XLARGE";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XXLARGE"] = 6] = "AVATAR_SIZE_XXLARGE";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XXXLARGE"] = 7] = "AVATAR_SIZE_XXXLARGE";
  BlockAvatarSize2[BlockAvatarSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAvatarSize || (BlockAvatarSize = {}));
function blockAvatarSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "AVATAR_SIZE_SMALL":
      return BlockAvatarSize.AVATAR_SIZE_SMALL;
    case 1:
    case "AVATAR_SIZE_XXSMALL":
      return BlockAvatarSize.AVATAR_SIZE_XXSMALL;
    case 2:
    case "AVATAR_SIZE_XSMALL":
      return BlockAvatarSize.AVATAR_SIZE_XSMALL;
    case 3:
    case "AVATAR_SIZE_MEDIUM":
      return BlockAvatarSize.AVATAR_SIZE_MEDIUM;
    case 4:
    case "AVATAR_SIZE_LARGE":
      return BlockAvatarSize.AVATAR_SIZE_LARGE;
    case 5:
    case "AVATAR_SIZE_XLARGE":
      return BlockAvatarSize.AVATAR_SIZE_XLARGE;
    case 6:
    case "AVATAR_SIZE_XXLARGE":
      return BlockAvatarSize.AVATAR_SIZE_XXLARGE;
    case 7:
    case "AVATAR_SIZE_XXXLARGE":
      return BlockAvatarSize.AVATAR_SIZE_XXXLARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAvatarSize.UNRECOGNIZED;
  }
}
function blockAvatarSizeToJSON(object) {
  switch (object) {
    case BlockAvatarSize.AVATAR_SIZE_SMALL:
      return 0;
    case BlockAvatarSize.AVATAR_SIZE_XXSMALL:
      return 1;
    case BlockAvatarSize.AVATAR_SIZE_XSMALL:
      return 2;
    case BlockAvatarSize.AVATAR_SIZE_MEDIUM:
      return 3;
    case BlockAvatarSize.AVATAR_SIZE_LARGE:
      return 4;
    case BlockAvatarSize.AVATAR_SIZE_XLARGE:
      return 5;
    case BlockAvatarSize.AVATAR_SIZE_XXLARGE:
      return 6;
    case BlockAvatarSize.AVATAR_SIZE_XXXLARGE:
      return 7;
    case BlockAvatarSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAvatarBackground;
(function(BlockAvatarBackground2) {
  BlockAvatarBackground2[BlockAvatarBackground2["AVATAR_BG_LIGHT"] = 0] = "AVATAR_BG_LIGHT";
  BlockAvatarBackground2[BlockAvatarBackground2["AVATAR_BG_DARK"] = 1] = "AVATAR_BG_DARK";
  BlockAvatarBackground2[BlockAvatarBackground2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAvatarBackground || (BlockAvatarBackground = {}));
function blockAvatarBackgroundFromJSON(object) {
  switch (object) {
    case 0:
    case "AVATAR_BG_LIGHT":
      return BlockAvatarBackground.AVATAR_BG_LIGHT;
    case 1:
    case "AVATAR_BG_DARK":
      return BlockAvatarBackground.AVATAR_BG_DARK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAvatarBackground.UNRECOGNIZED;
  }
}
function blockAvatarBackgroundToJSON(object) {
  switch (object) {
    case BlockAvatarBackground.AVATAR_BG_LIGHT:
      return 0;
    case BlockAvatarBackground.AVATAR_BG_DARK:
      return 1;
    case BlockAvatarBackground.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockFullSnooSize;
(function(BlockFullSnooSize2) {
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_SMALL"] = 0] = "FULLSNOO_SMALL";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_XSMALL"] = 1] = "FULLSNOO_XSMALL";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_MEDIUM"] = 2] = "FULLSNOO_MEDIUM";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_LARGE"] = 3] = "FULLSNOO_LARGE";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_XLARGE"] = 4] = "FULLSNOO_XLARGE";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_XXLARGE"] = 5] = "FULLSNOO_XXLARGE";
  BlockFullSnooSize2[BlockFullSnooSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockFullSnooSize || (BlockFullSnooSize = {}));
function blockFullSnooSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "FULLSNOO_SMALL":
      return BlockFullSnooSize.FULLSNOO_SMALL;
    case 1:
    case "FULLSNOO_XSMALL":
      return BlockFullSnooSize.FULLSNOO_XSMALL;
    case 2:
    case "FULLSNOO_MEDIUM":
      return BlockFullSnooSize.FULLSNOO_MEDIUM;
    case 3:
    case "FULLSNOO_LARGE":
      return BlockFullSnooSize.FULLSNOO_LARGE;
    case 4:
    case "FULLSNOO_XLARGE":
      return BlockFullSnooSize.FULLSNOO_XLARGE;
    case 5:
    case "FULLSNOO_XXLARGE":
      return BlockFullSnooSize.FULLSNOO_XXLARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockFullSnooSize.UNRECOGNIZED;
  }
}
function blockFullSnooSizeToJSON(object) {
  switch (object) {
    case BlockFullSnooSize.FULLSNOO_SMALL:
      return 0;
    case BlockFullSnooSize.FULLSNOO_XSMALL:
      return 1;
    case BlockFullSnooSize.FULLSNOO_MEDIUM:
      return 2;
    case BlockFullSnooSize.FULLSNOO_LARGE:
      return 3;
    case BlockFullSnooSize.FULLSNOO_XLARGE:
      return 4;
    case BlockFullSnooSize.FULLSNOO_XXLARGE:
      return 5;
    case BlockFullSnooSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAnimationType;
(function(BlockAnimationType2) {
  BlockAnimationType2[BlockAnimationType2["ANIM_LOTTIE"] = 0] = "ANIM_LOTTIE";
  BlockAnimationType2[BlockAnimationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAnimationType || (BlockAnimationType = {}));
function blockAnimationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ANIM_LOTTIE":
      return BlockAnimationType.ANIM_LOTTIE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAnimationType.UNRECOGNIZED;
  }
}
function blockAnimationTypeToJSON(object) {
  switch (object) {
    case BlockAnimationType.ANIM_LOTTIE:
      return 0;
    case BlockAnimationType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAnimationLoopMode;
(function(BlockAnimationLoopMode2) {
  BlockAnimationLoopMode2[BlockAnimationLoopMode2["ANIM_LOOP_REPEAT"] = 0] = "ANIM_LOOP_REPEAT";
  BlockAnimationLoopMode2[BlockAnimationLoopMode2["ANIM_LOOP_BOUNCE"] = 1] = "ANIM_LOOP_BOUNCE";
  BlockAnimationLoopMode2[BlockAnimationLoopMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAnimationLoopMode || (BlockAnimationLoopMode = {}));
function blockAnimationLoopModeFromJSON(object) {
  switch (object) {
    case 0:
    case "ANIM_LOOP_REPEAT":
      return BlockAnimationLoopMode.ANIM_LOOP_REPEAT;
    case 1:
    case "ANIM_LOOP_BOUNCE":
      return BlockAnimationLoopMode.ANIM_LOOP_BOUNCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAnimationLoopMode.UNRECOGNIZED;
  }
}
function blockAnimationLoopModeToJSON(object) {
  switch (object) {
    case BlockAnimationLoopMode.ANIM_LOOP_REPEAT:
      return 0;
    case BlockAnimationLoopMode.ANIM_LOOP_BOUNCE:
      return 1;
    case BlockAnimationLoopMode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAnimationDirection;
(function(BlockAnimationDirection2) {
  BlockAnimationDirection2[BlockAnimationDirection2["ANIM_DIR_FORWARD"] = 0] = "ANIM_DIR_FORWARD";
  BlockAnimationDirection2[BlockAnimationDirection2["ANIM_DIR_BACKWARD"] = 1] = "ANIM_DIR_BACKWARD";
  BlockAnimationDirection2[BlockAnimationDirection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAnimationDirection || (BlockAnimationDirection = {}));
function blockAnimationDirectionFromJSON(object) {
  switch (object) {
    case 0:
    case "ANIM_DIR_FORWARD":
      return BlockAnimationDirection.ANIM_DIR_FORWARD;
    case 1:
    case "ANIM_DIR_BACKWARD":
      return BlockAnimationDirection.ANIM_DIR_BACKWARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAnimationDirection.UNRECOGNIZED;
  }
}
function blockAnimationDirectionToJSON(object) {
  switch (object) {
    case BlockAnimationDirection.ANIM_DIR_FORWARD:
      return 0;
    case BlockAnimationDirection.ANIM_DIR_BACKWARD:
      return 1;
    case BlockAnimationDirection.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockSizeUnit;
(function(BlockSizeUnit2) {
  BlockSizeUnit2[BlockSizeUnit2["SIZE_UNIT_PERCENT"] = 0] = "SIZE_UNIT_PERCENT";
  BlockSizeUnit2[BlockSizeUnit2["SIZE_UNIT_PIXELS"] = 1] = "SIZE_UNIT_PIXELS";
  BlockSizeUnit2[BlockSizeUnit2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockSizeUnit || (BlockSizeUnit = {}));
function blockSizeUnitFromJSON(object) {
  switch (object) {
    case 0:
    case "SIZE_UNIT_PERCENT":
      return BlockSizeUnit.SIZE_UNIT_PERCENT;
    case 1:
    case "SIZE_UNIT_PIXELS":
      return BlockSizeUnit.SIZE_UNIT_PIXELS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockSizeUnit.UNRECOGNIZED;
  }
}
function blockSizeUnitToJSON(object) {
  switch (object) {
    case BlockSizeUnit.SIZE_UNIT_PERCENT:
      return 0;
    case BlockSizeUnit.SIZE_UNIT_PIXELS:
      return 1;
    case BlockSizeUnit.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextOverflow;
(function(BlockTextOverflow2) {
  BlockTextOverflow2[BlockTextOverflow2["TEXT_OVERFLOW_CLIP"] = 0] = "TEXT_OVERFLOW_CLIP";
  BlockTextOverflow2[BlockTextOverflow2["TEXT_OVERFLOW_ELLIPSE"] = 1] = "TEXT_OVERFLOW_ELLIPSE";
  BlockTextOverflow2[BlockTextOverflow2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextOverflow || (BlockTextOverflow = {}));
function blockTextOverflowFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_OVERFLOW_CLIP":
      return BlockTextOverflow.TEXT_OVERFLOW_CLIP;
    case 1:
    case "TEXT_OVERFLOW_ELLIPSE":
      return BlockTextOverflow.TEXT_OVERFLOW_ELLIPSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextOverflow.UNRECOGNIZED;
  }
}
function blockTextOverflowToJSON(object) {
  switch (object) {
    case BlockTextOverflow.TEXT_OVERFLOW_CLIP:
      return 0;
    case BlockTextOverflow.TEXT_OVERFLOW_ELLIPSE:
      return 1;
    case BlockTextOverflow.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/attributes.js
function createBaseBlockAlignment() {
  return { vertical: void 0, horizontal: void 0 };
}
var BlockAlignment = {
  $type: "devvit.ui.block_kit.v1beta.BlockAlignment",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.vertical !== void 0) {
      writer.uint32(8).int32(message.vertical);
    }
    if (message.horizontal !== void 0) {
      writer.uint32(16).int32(message.horizontal);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockAlignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.vertical = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.horizontal = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      vertical: isSet111(object.vertical) ? blockVerticalAlignmentFromJSON(object.vertical) : void 0,
      horizontal: isSet111(object.horizontal) ? blockHorizontalAlignmentFromJSON(object.horizontal) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.vertical !== void 0) {
      obj.vertical = blockVerticalAlignmentToJSON(message.vertical);
    }
    if (message.horizontal !== void 0) {
      obj.horizontal = blockHorizontalAlignmentToJSON(message.horizontal);
    }
    return obj;
  },
  create(base) {
    return BlockAlignment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockAlignment();
    message.vertical = object.vertical ?? void 0;
    message.horizontal = object.horizontal ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockAlignment.$type, BlockAlignment);
function createBaseBlockBorder() {
  return { color: void 0, width: void 0, colors: void 0 };
}
var BlockBorder = {
  $type: "devvit.ui.block_kit.v1beta.BlockBorder",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.color !== void 0) {
      writer.uint32(10).string(message.color);
    }
    if (message.width !== void 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.colors !== void 0) {
      BlockColor.encode(message.colors, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockBorder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.color = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.colors = BlockColor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      color: isSet111(object.color) ? globalThis.String(object.color) : void 0,
      width: isSet111(object.width) ? blockBorderWidthFromJSON(object.width) : void 0,
      colors: isSet111(object.colors) ? BlockColor.fromJSON(object.colors) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.color !== void 0) {
      obj.color = message.color;
    }
    if (message.width !== void 0) {
      obj.width = blockBorderWidthToJSON(message.width);
    }
    if (message.colors !== void 0) {
      obj.colors = BlockColor.toJSON(message.colors);
    }
    return obj;
  },
  create(base) {
    return BlockBorder.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockBorder();
    message.color = object.color ?? void 0;
    message.width = object.width ?? void 0;
    message.colors = object.colors !== void 0 && object.colors !== null ? BlockColor.fromPartial(object.colors) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockBorder.$type, BlockBorder);
function createBaseBlockSizes() {
  return { grow: void 0, width: void 0, height: void 0 };
}
var BlockSizes = {
  $type: "devvit.ui.block_kit.v1beta.BlockSizes",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.grow !== void 0) {
      writer.uint32(8).bool(message.grow);
    }
    if (message.width !== void 0) {
      BlockSizes_Dimension.encode(message.width, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== void 0) {
      BlockSizes_Dimension.encode(message.height, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockSizes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.grow = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.width = BlockSizes_Dimension.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.height = BlockSizes_Dimension.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      grow: isSet111(object.grow) ? globalThis.Boolean(object.grow) : void 0,
      width: isSet111(object.width) ? BlockSizes_Dimension.fromJSON(object.width) : void 0,
      height: isSet111(object.height) ? BlockSizes_Dimension.fromJSON(object.height) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.grow !== void 0) {
      obj.grow = message.grow;
    }
    if (message.width !== void 0) {
      obj.width = BlockSizes_Dimension.toJSON(message.width);
    }
    if (message.height !== void 0) {
      obj.height = BlockSizes_Dimension.toJSON(message.height);
    }
    return obj;
  },
  create(base) {
    return BlockSizes.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockSizes();
    message.grow = object.grow ?? void 0;
    message.width = object.width !== void 0 && object.width !== null ? BlockSizes_Dimension.fromPartial(object.width) : void 0;
    message.height = object.height !== void 0 && object.height !== null ? BlockSizes_Dimension.fromPartial(object.height) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockSizes.$type, BlockSizes);
function createBaseBlockSizes_Dimension() {
  return { value: void 0, min: void 0, max: void 0 };
}
var BlockSizes_Dimension = {
  $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.value !== void 0) {
      BlockSizes_Dimension_Value.encode(message.value, writer.uint32(10).fork()).ldelim();
    }
    if (message.min !== void 0) {
      BlockSizes_Dimension_Value.encode(message.min, writer.uint32(18).fork()).ldelim();
    }
    if (message.max !== void 0) {
      BlockSizes_Dimension_Value.encode(message.max, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockSizes_Dimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.value = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.min = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.max = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      value: isSet111(object.value) ? BlockSizes_Dimension_Value.fromJSON(object.value) : void 0,
      min: isSet111(object.min) ? BlockSizes_Dimension_Value.fromJSON(object.min) : void 0,
      max: isSet111(object.max) ? BlockSizes_Dimension_Value.fromJSON(object.max) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== void 0) {
      obj.value = BlockSizes_Dimension_Value.toJSON(message.value);
    }
    if (message.min !== void 0) {
      obj.min = BlockSizes_Dimension_Value.toJSON(message.min);
    }
    if (message.max !== void 0) {
      obj.max = BlockSizes_Dimension_Value.toJSON(message.max);
    }
    return obj;
  },
  create(base) {
    return BlockSizes_Dimension.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockSizes_Dimension();
    message.value = object.value !== void 0 && object.value !== null ? BlockSizes_Dimension_Value.fromPartial(object.value) : void 0;
    message.min = object.min !== void 0 && object.min !== null ? BlockSizes_Dimension_Value.fromPartial(object.min) : void 0;
    message.max = object.max !== void 0 && object.max !== null ? BlockSizes_Dimension_Value.fromPartial(object.max) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockSizes_Dimension.$type, BlockSizes_Dimension);
function createBaseBlockSizes_Dimension_Value() {
  return { value: 0, unit: 0 };
}
var BlockSizes_Dimension_Value = {
  $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension.Value",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    if (message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockSizes_Dimension_Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }
          message.value = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.unit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      value: isSet111(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet111(object.unit) ? blockSizeUnitFromJSON(object.unit) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== 0) {
      obj.unit = blockSizeUnitToJSON(message.unit);
    }
    return obj;
  },
  create(base) {
    return BlockSizes_Dimension_Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockSizes_Dimension_Value();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? 0;
    return message;
  }
};
messageTypeRegistry.set(BlockSizes_Dimension_Value.$type, BlockSizes_Dimension_Value);
function createBaseBlockSize() {
  return { grow: void 0, width: void 0, widthUnit: void 0, height: void 0, heightUnit: void 0 };
}
var BlockSize = {
  $type: "devvit.ui.block_kit.v1beta.BlockSize",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.grow !== void 0) {
      writer.uint32(8).bool(message.grow);
    }
    if (message.width !== void 0) {
      writer.uint32(21).float(message.width);
    }
    if (message.widthUnit !== void 0) {
      writer.uint32(32).int32(message.widthUnit);
    }
    if (message.height !== void 0) {
      writer.uint32(29).float(message.height);
    }
    if (message.heightUnit !== void 0) {
      writer.uint32(40).int32(message.heightUnit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.grow = reader.bool();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }
          message.width = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.widthUnit = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }
          message.height = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.heightUnit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      grow: isSet111(object.grow) ? globalThis.Boolean(object.grow) : void 0,
      width: isSet111(object.width) ? globalThis.Number(object.width) : void 0,
      widthUnit: isSet111(object.widthUnit) ? blockSizeUnitFromJSON(object.widthUnit) : void 0,
      height: isSet111(object.height) ? globalThis.Number(object.height) : void 0,
      heightUnit: isSet111(object.heightUnit) ? blockSizeUnitFromJSON(object.heightUnit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.grow !== void 0) {
      obj.grow = message.grow;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    if (message.widthUnit !== void 0) {
      obj.widthUnit = blockSizeUnitToJSON(message.widthUnit);
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.heightUnit !== void 0) {
      obj.heightUnit = blockSizeUnitToJSON(message.heightUnit);
    }
    return obj;
  },
  create(base) {
    return BlockSize.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockSize();
    message.grow = object.grow ?? void 0;
    message.width = object.width ?? void 0;
    message.widthUnit = object.widthUnit ?? void 0;
    message.height = object.height ?? void 0;
    message.heightUnit = object.heightUnit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockSize.$type, BlockSize);
function createBaseBlockAction() {
  return { type: 0, id: "", data: void 0 };
}
var BlockAction = {
  $type: "devvit.ui.block_kit.v1beta.BlockAction",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet111(object.type) ? blockActionTypeFromJSON(object.type) : 0,
      id: isSet111(object.id) ? globalThis.String(object.id) : "",
      data: isObject23(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = blockActionTypeToJSON(message.type);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return BlockAction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockAction();
    message.type = object.type ?? 0;
    message.id = object.id ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockAction.$type, BlockAction);
function createBaseBlockColor() {
  return { light: void 0, dark: void 0 };
}
var BlockColor = {
  $type: "devvit.ui.block_kit.v1beta.BlockColor",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.light !== void 0) {
      writer.uint32(10).string(message.light);
    }
    if (message.dark !== void 0) {
      writer.uint32(18).string(message.dark);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : import_minimal121.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.light = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dark = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      light: isSet111(object.light) ? globalThis.String(object.light) : void 0,
      dark: isSet111(object.dark) ? globalThis.String(object.dark) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.light !== void 0) {
      obj.light = message.light;
    }
    if (message.dark !== void 0) {
      obj.dark = message.dark;
    }
    return obj;
  },
  create(base) {
    return BlockColor.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockColor();
    message.light = object.light ?? void 0;
    message.dark = object.dark ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockColor.$type, BlockColor);
function isObject23(value) {
  return typeof value === "object" && value !== null;
}
function isSet111(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/block.js
function createBaseBlock() {
  return { type: 0, size: void 0, sizes: void 0, config: void 0, actions: [], id: void 0, key: void 0 };
}
var Block = {
  $type: "devvit.ui.block_kit.v1beta.Block",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.size !== void 0) {
      BlockSize.encode(message.size, writer.uint32(18).fork()).ldelim();
    }
    if (message.sizes !== void 0) {
      BlockSizes.encode(message.sizes, writer.uint32(42).fork()).ldelim();
    }
    if (message.config !== void 0) {
      BlockConfig.encode(message.config, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.actions) {
      BlockAction.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.id !== void 0) {
      writer.uint32(50).string(message.id);
    }
    if (message.key !== void 0) {
      writer.uint32(58).string(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.size = BlockSize.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.sizes = BlockSizes.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.config = BlockConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.actions.push(BlockAction.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet112(object.type) ? blockTypeFromJSON(object.type) : 0,
      size: isSet112(object.size) ? BlockSize.fromJSON(object.size) : void 0,
      sizes: isSet112(object.sizes) ? BlockSizes.fromJSON(object.sizes) : void 0,
      config: isSet112(object.config) ? BlockConfig.fromJSON(object.config) : void 0,
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e) => BlockAction.fromJSON(e)) : [],
      id: isSet112(object.id) ? globalThis.String(object.id) : void 0,
      key: isSet112(object.key) ? globalThis.String(object.key) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = blockTypeToJSON(message.type);
    }
    if (message.size !== void 0) {
      obj.size = BlockSize.toJSON(message.size);
    }
    if (message.sizes !== void 0) {
      obj.sizes = BlockSizes.toJSON(message.sizes);
    }
    if (message.config !== void 0) {
      obj.config = BlockConfig.toJSON(message.config);
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => BlockAction.toJSON(e));
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.key !== void 0) {
      obj.key = message.key;
    }
    return obj;
  },
  create(base) {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlock();
    message.type = object.type ?? 0;
    message.size = object.size !== void 0 && object.size !== null ? BlockSize.fromPartial(object.size) : void 0;
    message.sizes = object.sizes !== void 0 && object.sizes !== null ? BlockSizes.fromPartial(object.sizes) : void 0;
    message.config = object.config !== void 0 && object.config !== null ? BlockConfig.fromPartial(object.config) : void 0;
    message.actions = object.actions?.map((e) => BlockAction.fromPartial(e)) || [];
    message.id = object.id ?? void 0;
    message.key = object.key ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Block.$type, Block);
function createBaseBlockConfig() {
  return {
    rootConfig: void 0,
    stackConfig: void 0,
    textConfig: void 0,
    buttonConfig: void 0,
    imageConfig: void 0,
    spacerConfig: void 0,
    iconConfig: void 0,
    avatarConfig: void 0,
    fullsnooConfig: void 0,
    animationConfig: void 0,
    webviewConfig: void 0
  };
}
var BlockConfig = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.rootConfig !== void 0) {
      BlockConfig_Root.encode(message.rootConfig, writer.uint32(10).fork()).ldelim();
    }
    if (message.stackConfig !== void 0) {
      BlockConfig_Stack.encode(message.stackConfig, writer.uint32(18).fork()).ldelim();
    }
    if (message.textConfig !== void 0) {
      BlockConfig_Text.encode(message.textConfig, writer.uint32(26).fork()).ldelim();
    }
    if (message.buttonConfig !== void 0) {
      BlockConfig_Button.encode(message.buttonConfig, writer.uint32(34).fork()).ldelim();
    }
    if (message.imageConfig !== void 0) {
      BlockConfig_Image.encode(message.imageConfig, writer.uint32(42).fork()).ldelim();
    }
    if (message.spacerConfig !== void 0) {
      BlockConfig_Spacer.encode(message.spacerConfig, writer.uint32(50).fork()).ldelim();
    }
    if (message.iconConfig !== void 0) {
      BlockConfig_Icon.encode(message.iconConfig, writer.uint32(58).fork()).ldelim();
    }
    if (message.avatarConfig !== void 0) {
      BlockConfig_Avatar.encode(message.avatarConfig, writer.uint32(66).fork()).ldelim();
    }
    if (message.fullsnooConfig !== void 0) {
      BlockConfig_FullSnoo.encode(message.fullsnooConfig, writer.uint32(74).fork()).ldelim();
    }
    if (message.animationConfig !== void 0) {
      BlockConfig_Animation.encode(message.animationConfig, writer.uint32(82).fork()).ldelim();
    }
    if (message.webviewConfig !== void 0) {
      BlockConfig_WebView.encode(message.webviewConfig, writer.uint32(802).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.rootConfig = BlockConfig_Root.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.stackConfig = BlockConfig_Stack.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.textConfig = BlockConfig_Text.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.buttonConfig = BlockConfig_Button.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.imageConfig = BlockConfig_Image.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.spacerConfig = BlockConfig_Spacer.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.iconConfig = BlockConfig_Icon.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.avatarConfig = BlockConfig_Avatar.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.fullsnooConfig = BlockConfig_FullSnoo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.animationConfig = BlockConfig_Animation.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.webviewConfig = BlockConfig_WebView.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      rootConfig: isSet112(object.rootConfig) ? BlockConfig_Root.fromJSON(object.rootConfig) : void 0,
      stackConfig: isSet112(object.stackConfig) ? BlockConfig_Stack.fromJSON(object.stackConfig) : void 0,
      textConfig: isSet112(object.textConfig) ? BlockConfig_Text.fromJSON(object.textConfig) : void 0,
      buttonConfig: isSet112(object.buttonConfig) ? BlockConfig_Button.fromJSON(object.buttonConfig) : void 0,
      imageConfig: isSet112(object.imageConfig) ? BlockConfig_Image.fromJSON(object.imageConfig) : void 0,
      spacerConfig: isSet112(object.spacerConfig) ? BlockConfig_Spacer.fromJSON(object.spacerConfig) : void 0,
      iconConfig: isSet112(object.iconConfig) ? BlockConfig_Icon.fromJSON(object.iconConfig) : void 0,
      avatarConfig: isSet112(object.avatarConfig) ? BlockConfig_Avatar.fromJSON(object.avatarConfig) : void 0,
      fullsnooConfig: isSet112(object.fullsnooConfig) ? BlockConfig_FullSnoo.fromJSON(object.fullsnooConfig) : void 0,
      animationConfig: isSet112(object.animationConfig) ? BlockConfig_Animation.fromJSON(object.animationConfig) : void 0,
      webviewConfig: isSet112(object.webviewConfig) ? BlockConfig_WebView.fromJSON(object.webviewConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.rootConfig !== void 0) {
      obj.rootConfig = BlockConfig_Root.toJSON(message.rootConfig);
    }
    if (message.stackConfig !== void 0) {
      obj.stackConfig = BlockConfig_Stack.toJSON(message.stackConfig);
    }
    if (message.textConfig !== void 0) {
      obj.textConfig = BlockConfig_Text.toJSON(message.textConfig);
    }
    if (message.buttonConfig !== void 0) {
      obj.buttonConfig = BlockConfig_Button.toJSON(message.buttonConfig);
    }
    if (message.imageConfig !== void 0) {
      obj.imageConfig = BlockConfig_Image.toJSON(message.imageConfig);
    }
    if (message.spacerConfig !== void 0) {
      obj.spacerConfig = BlockConfig_Spacer.toJSON(message.spacerConfig);
    }
    if (message.iconConfig !== void 0) {
      obj.iconConfig = BlockConfig_Icon.toJSON(message.iconConfig);
    }
    if (message.avatarConfig !== void 0) {
      obj.avatarConfig = BlockConfig_Avatar.toJSON(message.avatarConfig);
    }
    if (message.fullsnooConfig !== void 0) {
      obj.fullsnooConfig = BlockConfig_FullSnoo.toJSON(message.fullsnooConfig);
    }
    if (message.animationConfig !== void 0) {
      obj.animationConfig = BlockConfig_Animation.toJSON(message.animationConfig);
    }
    if (message.webviewConfig !== void 0) {
      obj.webviewConfig = BlockConfig_WebView.toJSON(message.webviewConfig);
    }
    return obj;
  },
  create(base) {
    return BlockConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig();
    message.rootConfig = object.rootConfig !== void 0 && object.rootConfig !== null ? BlockConfig_Root.fromPartial(object.rootConfig) : void 0;
    message.stackConfig = object.stackConfig !== void 0 && object.stackConfig !== null ? BlockConfig_Stack.fromPartial(object.stackConfig) : void 0;
    message.textConfig = object.textConfig !== void 0 && object.textConfig !== null ? BlockConfig_Text.fromPartial(object.textConfig) : void 0;
    message.buttonConfig = object.buttonConfig !== void 0 && object.buttonConfig !== null ? BlockConfig_Button.fromPartial(object.buttonConfig) : void 0;
    message.imageConfig = object.imageConfig !== void 0 && object.imageConfig !== null ? BlockConfig_Image.fromPartial(object.imageConfig) : void 0;
    message.spacerConfig = object.spacerConfig !== void 0 && object.spacerConfig !== null ? BlockConfig_Spacer.fromPartial(object.spacerConfig) : void 0;
    message.iconConfig = object.iconConfig !== void 0 && object.iconConfig !== null ? BlockConfig_Icon.fromPartial(object.iconConfig) : void 0;
    message.avatarConfig = object.avatarConfig !== void 0 && object.avatarConfig !== null ? BlockConfig_Avatar.fromPartial(object.avatarConfig) : void 0;
    message.fullsnooConfig = object.fullsnooConfig !== void 0 && object.fullsnooConfig !== null ? BlockConfig_FullSnoo.fromPartial(object.fullsnooConfig) : void 0;
    message.animationConfig = object.animationConfig !== void 0 && object.animationConfig !== null ? BlockConfig_Animation.fromPartial(object.animationConfig) : void 0;
    message.webviewConfig = object.webviewConfig !== void 0 && object.webviewConfig !== null ? BlockConfig_WebView.fromPartial(object.webviewConfig) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig.$type, BlockConfig);
function createBaseBlockConfig_Root() {
  return { children: [], height: 0 };
}
var BlockConfig_Root = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Root",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    for (const v of message.children) {
      Block.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Root();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.children.push(Block.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => Block.fromJSON(e)) : [],
      height: isSet112(object.height) ? globalThis.Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.children?.length) {
      obj.children = message.children.map((e) => Block.toJSON(e));
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Root.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Root();
    message.children = object.children?.map((e) => Block.fromPartial(e)) || [];
    message.height = object.height ?? 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Root.$type, BlockConfig_Root);
function createBaseBlockConfig_Stack() {
  return {
    direction: 0,
    children: [],
    reverse: void 0,
    alignment: void 0,
    padding: void 0,
    gap: void 0,
    border: void 0,
    cornerRadius: void 0,
    backgroundColor: void 0,
    backgroundColors: void 0
  };
}
var BlockConfig_Stack = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Stack",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.direction !== 0) {
      writer.uint32(8).int32(message.direction);
    }
    for (const v of message.children) {
      Block.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.reverse !== void 0) {
      writer.uint32(24).bool(message.reverse);
    }
    if (message.alignment !== void 0) {
      BlockAlignment.encode(message.alignment, writer.uint32(34).fork()).ldelim();
    }
    if (message.padding !== void 0) {
      writer.uint32(40).int32(message.padding);
    }
    if (message.gap !== void 0) {
      writer.uint32(48).int32(message.gap);
    }
    if (message.border !== void 0) {
      BlockBorder.encode(message.border, writer.uint32(58).fork()).ldelim();
    }
    if (message.cornerRadius !== void 0) {
      writer.uint32(64).int32(message.cornerRadius);
    }
    if (message.backgroundColor !== void 0) {
      writer.uint32(74).string(message.backgroundColor);
    }
    if (message.backgroundColors !== void 0) {
      BlockColor.encode(message.backgroundColors, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Stack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.direction = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.children.push(Block.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.reverse = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.alignment = BlockAlignment.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.padding = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.gap = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.border = BlockBorder.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.cornerRadius = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.backgroundColors = BlockColor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      direction: isSet112(object.direction) ? blockStackDirectionFromJSON(object.direction) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => Block.fromJSON(e)) : [],
      reverse: isSet112(object.reverse) ? globalThis.Boolean(object.reverse) : void 0,
      alignment: isSet112(object.alignment) ? BlockAlignment.fromJSON(object.alignment) : void 0,
      padding: isSet112(object.padding) ? blockPaddingFromJSON(object.padding) : void 0,
      gap: isSet112(object.gap) ? blockGapFromJSON(object.gap) : void 0,
      border: isSet112(object.border) ? BlockBorder.fromJSON(object.border) : void 0,
      cornerRadius: isSet112(object.cornerRadius) ? blockRadiusFromJSON(object.cornerRadius) : void 0,
      backgroundColor: isSet112(object.backgroundColor) ? globalThis.String(object.backgroundColor) : void 0,
      backgroundColors: isSet112(object.backgroundColors) ? BlockColor.fromJSON(object.backgroundColors) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.direction !== 0) {
      obj.direction = blockStackDirectionToJSON(message.direction);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Block.toJSON(e));
    }
    if (message.reverse !== void 0) {
      obj.reverse = message.reverse;
    }
    if (message.alignment !== void 0) {
      obj.alignment = BlockAlignment.toJSON(message.alignment);
    }
    if (message.padding !== void 0) {
      obj.padding = blockPaddingToJSON(message.padding);
    }
    if (message.gap !== void 0) {
      obj.gap = blockGapToJSON(message.gap);
    }
    if (message.border !== void 0) {
      obj.border = BlockBorder.toJSON(message.border);
    }
    if (message.cornerRadius !== void 0) {
      obj.cornerRadius = blockRadiusToJSON(message.cornerRadius);
    }
    if (message.backgroundColor !== void 0) {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.backgroundColors !== void 0) {
      obj.backgroundColors = BlockColor.toJSON(message.backgroundColors);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Stack.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Stack();
    message.direction = object.direction ?? 0;
    message.children = object.children?.map((e) => Block.fromPartial(e)) || [];
    message.reverse = object.reverse ?? void 0;
    message.alignment = object.alignment !== void 0 && object.alignment !== null ? BlockAlignment.fromPartial(object.alignment) : void 0;
    message.padding = object.padding ?? void 0;
    message.gap = object.gap ?? void 0;
    message.border = object.border !== void 0 && object.border !== null ? BlockBorder.fromPartial(object.border) : void 0;
    message.cornerRadius = object.cornerRadius ?? void 0;
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.backgroundColors = object.backgroundColors !== void 0 && object.backgroundColors !== null ? BlockColor.fromPartial(object.backgroundColors) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Stack.$type, BlockConfig_Stack);
function createBaseBlockConfig_Text() {
  return {
    text: "",
    size: void 0,
    weight: void 0,
    color: void 0,
    alignment: void 0,
    outline: void 0,
    style: void 0,
    selectable: void 0,
    colors: void 0,
    wrap: void 0,
    overflow: void 0
  };
}
var BlockConfig_Text = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Text",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.size !== void 0) {
      writer.uint32(16).int32(message.size);
    }
    if (message.weight !== void 0) {
      writer.uint32(24).int32(message.weight);
    }
    if (message.color !== void 0) {
      writer.uint32(34).string(message.color);
    }
    if (message.alignment !== void 0) {
      BlockAlignment.encode(message.alignment, writer.uint32(42).fork()).ldelim();
    }
    if (message.outline !== void 0) {
      writer.uint32(48).int32(message.outline);
    }
    if (message.style !== void 0) {
      writer.uint32(56).int32(message.style);
    }
    if (message.selectable !== void 0) {
      writer.uint32(64).bool(message.selectable);
    }
    if (message.colors !== void 0) {
      BlockColor.encode(message.colors, writer.uint32(74).fork()).ldelim();
    }
    if (message.wrap !== void 0) {
      writer.uint32(80).bool(message.wrap);
    }
    if (message.overflow !== void 0) {
      writer.uint32(88).int32(message.overflow);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Text();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.size = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.weight = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.color = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.alignment = BlockAlignment.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.outline = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.style = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.selectable = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.colors = BlockColor.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.wrap = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.overflow = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet112(object.text) ? globalThis.String(object.text) : "",
      size: isSet112(object.size) ? blockTextSizeFromJSON(object.size) : void 0,
      weight: isSet112(object.weight) ? blockTextWeightFromJSON(object.weight) : void 0,
      color: isSet112(object.color) ? globalThis.String(object.color) : void 0,
      alignment: isSet112(object.alignment) ? BlockAlignment.fromJSON(object.alignment) : void 0,
      outline: isSet112(object.outline) ? blockTextOutlineFromJSON(object.outline) : void 0,
      style: isSet112(object.style) ? blockTextStyleFromJSON(object.style) : void 0,
      selectable: isSet112(object.selectable) ? globalThis.Boolean(object.selectable) : void 0,
      colors: isSet112(object.colors) ? BlockColor.fromJSON(object.colors) : void 0,
      wrap: isSet112(object.wrap) ? globalThis.Boolean(object.wrap) : void 0,
      overflow: isSet112(object.overflow) ? blockTextOverflowFromJSON(object.overflow) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.size !== void 0) {
      obj.size = blockTextSizeToJSON(message.size);
    }
    if (message.weight !== void 0) {
      obj.weight = blockTextWeightToJSON(message.weight);
    }
    if (message.color !== void 0) {
      obj.color = message.color;
    }
    if (message.alignment !== void 0) {
      obj.alignment = BlockAlignment.toJSON(message.alignment);
    }
    if (message.outline !== void 0) {
      obj.outline = blockTextOutlineToJSON(message.outline);
    }
    if (message.style !== void 0) {
      obj.style = blockTextStyleToJSON(message.style);
    }
    if (message.selectable !== void 0) {
      obj.selectable = message.selectable;
    }
    if (message.colors !== void 0) {
      obj.colors = BlockColor.toJSON(message.colors);
    }
    if (message.wrap !== void 0) {
      obj.wrap = message.wrap;
    }
    if (message.overflow !== void 0) {
      obj.overflow = blockTextOverflowToJSON(message.overflow);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Text.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Text();
    message.text = object.text ?? "";
    message.size = object.size ?? void 0;
    message.weight = object.weight ?? void 0;
    message.color = object.color ?? void 0;
    message.alignment = object.alignment !== void 0 && object.alignment !== null ? BlockAlignment.fromPartial(object.alignment) : void 0;
    message.outline = object.outline ?? void 0;
    message.style = object.style ?? void 0;
    message.selectable = object.selectable ?? void 0;
    message.colors = object.colors !== void 0 && object.colors !== null ? BlockColor.fromPartial(object.colors) : void 0;
    message.wrap = object.wrap ?? void 0;
    message.overflow = object.overflow ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Text.$type, BlockConfig_Text);
function createBaseBlockConfig_Button() {
  return {
    text: void 0,
    icon: void 0,
    buttonSize: void 0,
    buttonAppearance: void 0,
    textColor: void 0,
    backgroundColor: void 0,
    disabled: void 0,
    textColors: void 0,
    backgroundColors: void 0
  };
}
var BlockConfig_Button = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Button",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.text !== void 0) {
      writer.uint32(10).string(message.text);
    }
    if (message.icon !== void 0) {
      writer.uint32(18).string(message.icon);
    }
    if (message.buttonSize !== void 0) {
      writer.uint32(24).int32(message.buttonSize);
    }
    if (message.buttonAppearance !== void 0) {
      writer.uint32(32).int32(message.buttonAppearance);
    }
    if (message.textColor !== void 0) {
      writer.uint32(42).string(message.textColor);
    }
    if (message.backgroundColor !== void 0) {
      writer.uint32(50).string(message.backgroundColor);
    }
    if (message.disabled !== void 0) {
      writer.uint32(56).bool(message.disabled);
    }
    if (message.textColors !== void 0) {
      BlockColor.encode(message.textColors, writer.uint32(66).fork()).ldelim();
    }
    if (message.backgroundColors !== void 0) {
      BlockColor.encode(message.backgroundColors, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Button();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.icon = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.buttonSize = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.buttonAppearance = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.textColor = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.disabled = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.textColors = BlockColor.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.backgroundColors = BlockColor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet112(object.text) ? globalThis.String(object.text) : void 0,
      icon: isSet112(object.icon) ? globalThis.String(object.icon) : void 0,
      buttonSize: isSet112(object.buttonSize) ? blockButtonSizeFromJSON(object.buttonSize) : void 0,
      buttonAppearance: isSet112(object.buttonAppearance) ? blockButtonAppearanceFromJSON(object.buttonAppearance) : void 0,
      textColor: isSet112(object.textColor) ? globalThis.String(object.textColor) : void 0,
      backgroundColor: isSet112(object.backgroundColor) ? globalThis.String(object.backgroundColor) : void 0,
      disabled: isSet112(object.disabled) ? globalThis.Boolean(object.disabled) : void 0,
      textColors: isSet112(object.textColors) ? BlockColor.fromJSON(object.textColors) : void 0,
      backgroundColors: isSet112(object.backgroundColors) ? BlockColor.fromJSON(object.backgroundColors) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    if (message.buttonSize !== void 0) {
      obj.buttonSize = blockButtonSizeToJSON(message.buttonSize);
    }
    if (message.buttonAppearance !== void 0) {
      obj.buttonAppearance = blockButtonAppearanceToJSON(message.buttonAppearance);
    }
    if (message.textColor !== void 0) {
      obj.textColor = message.textColor;
    }
    if (message.backgroundColor !== void 0) {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.disabled !== void 0) {
      obj.disabled = message.disabled;
    }
    if (message.textColors !== void 0) {
      obj.textColors = BlockColor.toJSON(message.textColors);
    }
    if (message.backgroundColors !== void 0) {
      obj.backgroundColors = BlockColor.toJSON(message.backgroundColors);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Button.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Button();
    message.text = object.text ?? void 0;
    message.icon = object.icon ?? void 0;
    message.buttonSize = object.buttonSize ?? void 0;
    message.buttonAppearance = object.buttonAppearance ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.disabled = object.disabled ?? void 0;
    message.textColors = object.textColors !== void 0 && object.textColors !== null ? BlockColor.fromPartial(object.textColors) : void 0;
    message.backgroundColors = object.backgroundColors !== void 0 && object.backgroundColors !== null ? BlockColor.fromPartial(object.backgroundColors) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Button.$type, BlockConfig_Button);
function createBaseBlockConfig_Image() {
  return { url: "", width: 0, height: 0, description: void 0, resizeMode: void 0 };
}
var BlockConfig_Image = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Image",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.description !== void 0) {
      writer.uint32(34).string(message.description);
    }
    if (message.resizeMode !== void 0) {
      writer.uint32(40).int32(message.resizeMode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.resizeMode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet112(object.url) ? globalThis.String(object.url) : "",
      width: isSet112(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet112(object.height) ? globalThis.Number(object.height) : 0,
      description: isSet112(object.description) ? globalThis.String(object.description) : void 0,
      resizeMode: isSet112(object.resizeMode) ? blockImageResizeModeFromJSON(object.resizeMode) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.resizeMode !== void 0) {
      obj.resizeMode = blockImageResizeModeToJSON(message.resizeMode);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Image.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Image();
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.description = object.description ?? void 0;
    message.resizeMode = object.resizeMode ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Image.$type, BlockConfig_Image);
function createBaseBlockConfig_Spacer() {
  return { size: void 0, shape: void 0 };
}
var BlockConfig_Spacer = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Spacer",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.size !== void 0) {
      writer.uint32(8).int32(message.size);
    }
    if (message.shape !== void 0) {
      writer.uint32(16).int32(message.shape);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Spacer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.size = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.shape = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      size: isSet112(object.size) ? blockSpacerSizeFromJSON(object.size) : void 0,
      shape: isSet112(object.shape) ? blockSpacerShapeFromJSON(object.shape) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.size !== void 0) {
      obj.size = blockSpacerSizeToJSON(message.size);
    }
    if (message.shape !== void 0) {
      obj.shape = blockSpacerShapeToJSON(message.shape);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Spacer.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Spacer();
    message.size = object.size ?? void 0;
    message.shape = object.shape ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Spacer.$type, BlockConfig_Spacer);
function createBaseBlockConfig_Icon() {
  return { icon: "", color: void 0, size: void 0, colors: void 0 };
}
var BlockConfig_Icon = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Icon",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.icon !== "") {
      writer.uint32(10).string(message.icon);
    }
    if (message.color !== void 0) {
      writer.uint32(18).string(message.color);
    }
    if (message.size !== void 0) {
      writer.uint32(24).int32(message.size);
    }
    if (message.colors !== void 0) {
      BlockColor.encode(message.colors, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Icon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.icon = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.color = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.size = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.colors = BlockColor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      icon: isSet112(object.icon) ? globalThis.String(object.icon) : "",
      color: isSet112(object.color) ? globalThis.String(object.color) : void 0,
      size: isSet112(object.size) ? blockIconSizeFromJSON(object.size) : void 0,
      colors: isSet112(object.colors) ? BlockColor.fromJSON(object.colors) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.color !== void 0) {
      obj.color = message.color;
    }
    if (message.size !== void 0) {
      obj.size = blockIconSizeToJSON(message.size);
    }
    if (message.colors !== void 0) {
      obj.colors = BlockColor.toJSON(message.colors);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Icon.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Icon();
    message.icon = object.icon ?? "";
    message.color = object.color ?? void 0;
    message.size = object.size ?? void 0;
    message.colors = object.colors !== void 0 && object.colors !== null ? BlockColor.fromPartial(object.colors) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Icon.$type, BlockConfig_Icon);
function createBaseBlockConfig_Avatar() {
  return { thingId: "", facing: void 0, size: void 0, background: void 0 };
}
var BlockConfig_Avatar = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Avatar",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.thingId !== "") {
      writer.uint32(10).string(message.thingId);
    }
    if (message.facing !== void 0) {
      writer.uint32(16).int32(message.facing);
    }
    if (message.size !== void 0) {
      writer.uint32(24).int32(message.size);
    }
    if (message.background !== void 0) {
      writer.uint32(32).int32(message.background);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Avatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.thingId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.facing = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.size = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.background = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      thingId: isSet112(object.thingId) ? globalThis.String(object.thingId) : "",
      facing: isSet112(object.facing) ? blockAvatarFacingFromJSON(object.facing) : void 0,
      size: isSet112(object.size) ? blockAvatarSizeFromJSON(object.size) : void 0,
      background: isSet112(object.background) ? blockAvatarBackgroundFromJSON(object.background) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.thingId !== "") {
      obj.thingId = message.thingId;
    }
    if (message.facing !== void 0) {
      obj.facing = blockAvatarFacingToJSON(message.facing);
    }
    if (message.size !== void 0) {
      obj.size = blockAvatarSizeToJSON(message.size);
    }
    if (message.background !== void 0) {
      obj.background = blockAvatarBackgroundToJSON(message.background);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Avatar.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Avatar();
    message.thingId = object.thingId ?? "";
    message.facing = object.facing ?? void 0;
    message.size = object.size ?? void 0;
    message.background = object.background ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Avatar.$type, BlockConfig_Avatar);
function createBaseBlockConfig_FullSnoo() {
  return { userId: "", facing: void 0, size: void 0 };
}
var BlockConfig_FullSnoo = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.FullSnoo",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.facing !== void 0) {
      writer.uint32(16).int32(message.facing);
    }
    if (message.size !== void 0) {
      writer.uint32(24).int32(message.size);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_FullSnoo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.facing = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.size = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet112(object.userId) ? globalThis.String(object.userId) : "",
      facing: isSet112(object.facing) ? blockAvatarFacingFromJSON(object.facing) : void 0,
      size: isSet112(object.size) ? blockFullSnooSizeFromJSON(object.size) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.facing !== void 0) {
      obj.facing = blockAvatarFacingToJSON(message.facing);
    }
    if (message.size !== void 0) {
      obj.size = blockFullSnooSizeToJSON(message.size);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_FullSnoo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_FullSnoo();
    message.userId = object.userId ?? "";
    message.facing = object.facing ?? void 0;
    message.size = object.size ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_FullSnoo.$type, BlockConfig_FullSnoo);
function createBaseBlockConfig_Animation() {
  return {
    url: "",
    width: 0,
    height: 0,
    type: 0,
    loop: void 0,
    loopMode: void 0,
    autoplay: void 0,
    speed: void 0,
    direction: void 0
  };
}
var BlockConfig_Animation = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Animation",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.loop !== void 0) {
      writer.uint32(40).bool(message.loop);
    }
    if (message.loopMode !== void 0) {
      writer.uint32(48).int32(message.loopMode);
    }
    if (message.autoplay !== void 0) {
      writer.uint32(56).bool(message.autoplay);
    }
    if (message.speed !== void 0) {
      writer.uint32(69).float(message.speed);
    }
    if (message.direction !== void 0) {
      writer.uint32(72).int32(message.direction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Animation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.loop = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.loopMode = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.autoplay = reader.bool();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }
          message.speed = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.direction = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet112(object.url) ? globalThis.String(object.url) : "",
      width: isSet112(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet112(object.height) ? globalThis.Number(object.height) : 0,
      type: isSet112(object.type) ? blockAnimationTypeFromJSON(object.type) : 0,
      loop: isSet112(object.loop) ? globalThis.Boolean(object.loop) : void 0,
      loopMode: isSet112(object.loopMode) ? blockAnimationLoopModeFromJSON(object.loopMode) : void 0,
      autoplay: isSet112(object.autoplay) ? globalThis.Boolean(object.autoplay) : void 0,
      speed: isSet112(object.speed) ? globalThis.Number(object.speed) : void 0,
      direction: isSet112(object.direction) ? blockAnimationDirectionFromJSON(object.direction) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.type !== 0) {
      obj.type = blockAnimationTypeToJSON(message.type);
    }
    if (message.loop !== void 0) {
      obj.loop = message.loop;
    }
    if (message.loopMode !== void 0) {
      obj.loopMode = blockAnimationLoopModeToJSON(message.loopMode);
    }
    if (message.autoplay !== void 0) {
      obj.autoplay = message.autoplay;
    }
    if (message.speed !== void 0) {
      obj.speed = message.speed;
    }
    if (message.direction !== void 0) {
      obj.direction = blockAnimationDirectionToJSON(message.direction);
    }
    return obj;
  },
  create(base) {
    return BlockConfig_Animation.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Animation();
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.type = object.type ?? 0;
    message.loop = object.loop ?? void 0;
    message.loopMode = object.loopMode ?? void 0;
    message.autoplay = object.autoplay ?? void 0;
    message.speed = object.speed ?? void 0;
    message.direction = object.direction ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_Animation.$type, BlockConfig_Animation);
function createBaseBlockConfig_WebView() {
  return { url: "" };
}
var BlockConfig_WebView = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.WebView",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : import_minimal122.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_WebView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { url: isSet112(object.url) ? globalThis.String(object.url) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return BlockConfig_WebView.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_WebView();
    message.url = object.url ?? "";
    return message;
  }
};
messageTypeRegistry.set(BlockConfig_WebView.$type, BlockConfig_WebView);
function isSet112(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/ui.js
function createBaseUIRequest() {
  return { env: void 0, props: void 0, state: void 0, events: [] };
}
var UIRequest = {
  $type: "devvit.ui.block_kit.v1beta.UIRequest",
  encode(message, writer = import_minimal123.default.Writer.create()) {
    if (message.env !== void 0) {
      UIEnvironment.encode(message.env, writer.uint32(42).fork()).ldelim();
    }
    if (message.props !== void 0) {
      Struct.encode(Struct.wrap(message.props), writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.events) {
      UIEvent.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal123.default.Reader ? input : import_minimal123.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }
          message.env = UIEnvironment.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }
          message.props = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.events.push(UIEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      env: isSet113(object.env) ? UIEnvironment.fromJSON(object.env) : void 0,
      props: isObject24(object.props) ? object.props : void 0,
      state: isObject24(object.state) ? object.state : void 0,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => UIEvent.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.env !== void 0) {
      obj.env = UIEnvironment.toJSON(message.env);
    }
    if (message.props !== void 0) {
      obj.props = message.props;
    }
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => UIEvent.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return UIRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUIRequest();
    message.env = object.env !== void 0 && object.env !== null ? UIEnvironment.fromPartial(object.env) : void 0;
    message.props = object.props ?? void 0;
    message.state = object.state ?? void 0;
    message.events = object.events?.map((e) => UIEvent.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(UIRequest.$type, UIRequest);
function createBaseUIResponse() {
  return { state: void 0, effects: [], blocks: void 0 };
}
var UIResponse = {
  $type: "devvit.ui.block_kit.v1beta.UIResponse",
  encode(message, writer = import_minimal123.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.blocks !== void 0) {
      Block.encode(message.blocks, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal123.default.Reader ? input : import_minimal123.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.blocks = Block.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject24(object.state) ? object.state : void 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : [],
      blocks: isSet113(object.blocks) ? Block.fromJSON(object.blocks) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    if (message.blocks !== void 0) {
      obj.blocks = Block.toJSON(message.blocks);
    }
    return obj;
  },
  create(base) {
    return UIResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUIResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.blocks = object.blocks !== void 0 && object.blocks !== null ? Block.fromPartial(object.blocks) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UIResponse.$type, UIResponse);
function createBaseUIEnvironment() {
  return { locale: void 0, colorScheme: void 0, dimensions: void 0, timezone: void 0 };
}
var UIEnvironment = {
  $type: "devvit.ui.block_kit.v1beta.UIEnvironment",
  encode(message, writer = import_minimal123.default.Writer.create()) {
    if (message.locale !== void 0) {
      writer.uint32(10).string(message.locale);
    }
    if (message.colorScheme !== void 0) {
      writer.uint32(18).string(message.colorScheme);
    }
    if (message.dimensions !== void 0) {
      UIDimensions.encode(message.dimensions, writer.uint32(26).fork()).ldelim();
    }
    if (message.timezone !== void 0) {
      TimeZone.encode(message.timezone, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal123.default.Reader ? input : import_minimal123.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.locale = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.colorScheme = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.dimensions = UIDimensions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.timezone = TimeZone.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      locale: isSet113(object.locale) ? globalThis.String(object.locale) : void 0,
      colorScheme: isSet113(object.colorScheme) ? globalThis.String(object.colorScheme) : void 0,
      dimensions: isSet113(object.dimensions) ? UIDimensions.fromJSON(object.dimensions) : void 0,
      timezone: isSet113(object.timezone) ? TimeZone.fromJSON(object.timezone) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.locale !== void 0) {
      obj.locale = message.locale;
    }
    if (message.colorScheme !== void 0) {
      obj.colorScheme = message.colorScheme;
    }
    if (message.dimensions !== void 0) {
      obj.dimensions = UIDimensions.toJSON(message.dimensions);
    }
    if (message.timezone !== void 0) {
      obj.timezone = TimeZone.toJSON(message.timezone);
    }
    return obj;
  },
  create(base) {
    return UIEnvironment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUIEnvironment();
    message.locale = object.locale ?? void 0;
    message.colorScheme = object.colorScheme ?? void 0;
    message.dimensions = object.dimensions !== void 0 && object.dimensions !== null ? UIDimensions.fromPartial(object.dimensions) : void 0;
    message.timezone = object.timezone !== void 0 && object.timezone !== null ? TimeZone.fromPartial(object.timezone) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UIEnvironment.$type, UIEnvironment);
function isObject24(value) {
  return typeof value === "object" && value !== null;
}
function isSet113(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/rendering.js
var import_minimal124 = __toESM(require_minimal2(), 1);
function createBaseBlockRenderRequest() {
  return { type: 0, id: void 0, data: void 0 };
}
var BlockRenderRequest = {
  $type: "devvit.ui.block_kit.v1beta.BlockRenderRequest",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== void 0) {
      writer.uint32(18).string(message.id);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : import_minimal124.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockRenderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet114(object.type) ? blockRenderEventTypeFromJSON(object.type) : 0,
      id: isSet114(object.id) ? globalThis.String(object.id) : void 0,
      data: isObject25(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = blockRenderEventTypeToJSON(message.type);
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return BlockRenderRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockRenderRequest();
    message.type = object.type ?? 0;
    message.id = object.id ?? void 0;
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockRenderRequest.$type, BlockRenderRequest);
function createBaseBlockRenderResponse() {
  return { ui: void 0 };
}
var BlockRenderResponse = {
  $type: "devvit.ui.block_kit.v1beta.BlockRenderResponse",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.ui !== void 0) {
      Block.encode(message.ui, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : import_minimal124.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockRenderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.ui = Block.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { ui: isSet114(object.ui) ? Block.fromJSON(object.ui) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.ui !== void 0) {
      obj.ui = Block.toJSON(message.ui);
    }
    return obj;
  },
  create(base) {
    return BlockRenderResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockRenderResponse();
    message.ui = object.ui !== void 0 && object.ui !== null ? Block.fromPartial(object.ui) : void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockRenderResponse.$type, BlockRenderResponse);
function isObject25(value) {
  return typeof value === "object" && value !== null;
}
function isSet114(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/v1alpha/health.js
var import_minimal125 = __toESM(require_minimal2(), 1);
function createBaseHealthStatus() {
  return { start: void 0, end: void 0 };
}
var HealthStatus = {
  $type: "devvit.runtime.actor.v1alpha.HealthStatus",
  encode(message, writer = import_minimal125.default.Writer.create()) {
    if (message.start !== void 0) {
      Timestamp.encode(toTimestamp19(message.start), writer.uint32(10).fork()).ldelim();
    }
    if (message.end !== void 0) {
      Timestamp.encode(toTimestamp19(message.end), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal125.default.Reader ? input : import_minimal125.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHealthStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.start = fromTimestamp19(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.end = fromTimestamp19(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet115(object.start) ? fromJsonTimestamp19(object.start) : void 0,
      end: isSet115(object.end) ? fromJsonTimestamp19(object.end) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.start !== void 0) {
      obj.start = message.start.toISOString();
    }
    if (message.end !== void 0) {
      obj.end = message.end.toISOString();
    }
    return obj;
  },
  create(base) {
    return HealthStatus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHealthStatus();
    message.start = object.start ?? void 0;
    message.end = object.end ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(HealthStatus.$type, HealthStatus);
function toTimestamp19(date) {
  const seconds = Math.trunc(date.getTime() / 1e3);
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp19(t) {
  let millis = (t.seconds || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp19(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp19(Timestamp.fromJSON(o));
  }
}
function isSet115(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/post_guidance/v1alpha/post_guidance.js
var import_minimal126 = __toESM(require_minimal2(), 1);
var DiscussionType;
(function(DiscussionType2) {
  DiscussionType2[DiscussionType2["NULL_VALUE"] = 0] = "NULL_VALUE";
  DiscussionType2[DiscussionType2["CHAT"] = 1] = "CHAT";
  DiscussionType2[DiscussionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DiscussionType || (DiscussionType = {}));
function discussionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return DiscussionType.NULL_VALUE;
    case 1:
    case "CHAT":
      return DiscussionType.CHAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiscussionType.UNRECOGNIZED;
  }
}
function discussionTypeToJSON(object) {
  switch (object) {
    case DiscussionType.NULL_VALUE:
      return 0;
    case DiscussionType.CHAT:
      return 1;
    case DiscussionType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var PostType;
(function(PostType2) {
  PostType2[PostType2["UNKNOWN"] = 0] = "UNKNOWN";
  PostType2[PostType2["LINK"] = 1] = "LINK";
  PostType2[PostType2["TEXT"] = 2] = "TEXT";
  PostType2[PostType2["LINK_TEXT"] = 3] = "LINK_TEXT";
  PostType2[PostType2["MEDIA_UPLOAD"] = 4] = "MEDIA_UPLOAD";
  PostType2[PostType2["POLL"] = 5] = "POLL";
  PostType2[PostType2["CROSSPOST"] = 6] = "CROSSPOST";
  PostType2[PostType2["GALLERY"] = 7] = "GALLERY";
  PostType2[PostType2["IMAGE"] = 9] = "IMAGE";
  PostType2[PostType2["VIDEO"] = 10] = "VIDEO";
  PostType2[PostType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PostType || (PostType = {}));
function postTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return PostType.UNKNOWN;
    case 1:
    case "LINK":
      return PostType.LINK;
    case 2:
    case "TEXT":
      return PostType.TEXT;
    case 3:
    case "LINK_TEXT":
      return PostType.LINK_TEXT;
    case 4:
    case "MEDIA_UPLOAD":
      return PostType.MEDIA_UPLOAD;
    case 5:
    case "POLL":
      return PostType.POLL;
    case 6:
    case "CROSSPOST":
      return PostType.CROSSPOST;
    case 7:
    case "GALLERY":
      return PostType.GALLERY;
    case 9:
    case "IMAGE":
      return PostType.IMAGE;
    case 10:
    case "VIDEO":
      return PostType.VIDEO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostType.UNRECOGNIZED;
  }
}
function postTypeToJSON(object) {
  switch (object) {
    case PostType.UNKNOWN:
      return 0;
    case PostType.LINK:
      return 1;
    case PostType.TEXT:
      return 2;
    case PostType.LINK_TEXT:
      return 3;
    case PostType.MEDIA_UPLOAD:
      return 4;
    case PostType.POLL:
      return 5;
    case PostType.CROSSPOST:
      return 6;
    case PostType.GALLERY:
      return 7;
    case PostType.IMAGE:
      return 9;
    case PostType.VIDEO:
      return 10;
    case PostType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var MediaType;
(function(MediaType2) {
  MediaType2[MediaType2["MEDIA_UNKNOWN"] = 0] = "MEDIA_UNKNOWN";
  MediaType2[MediaType2["MEDIA_IMAGE"] = 1] = "MEDIA_IMAGE";
  MediaType2[MediaType2["MEDIA_VIDEO"] = 2] = "MEDIA_VIDEO";
  MediaType2[MediaType2["MEDIA_VIDEOGIF"] = 3] = "MEDIA_VIDEOGIF";
  MediaType2[MediaType2["MEDIA_STREAMING"] = 4] = "MEDIA_STREAMING";
  MediaType2[MediaType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaType || (MediaType = {}));
function mediaTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "MEDIA_UNKNOWN":
      return MediaType.MEDIA_UNKNOWN;
    case 1:
    case "MEDIA_IMAGE":
      return MediaType.MEDIA_IMAGE;
    case 2:
    case "MEDIA_VIDEO":
      return MediaType.MEDIA_VIDEO;
    case 3:
    case "MEDIA_VIDEOGIF":
      return MediaType.MEDIA_VIDEOGIF;
    case 4:
    case "MEDIA_STREAMING":
      return MediaType.MEDIA_STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MediaType.UNRECOGNIZED;
  }
}
function mediaTypeToJSON(object) {
  switch (object) {
    case MediaType.MEDIA_UNKNOWN:
      return 0;
    case MediaType.MEDIA_IMAGE:
      return 1;
    case MediaType.MEDIA_VIDEO:
      return 2;
    case MediaType.MEDIA_VIDEOGIF:
      return 3;
    case MediaType.MEDIA_STREAMING:
      return 4;
    case MediaType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBasePostContent() {
  return {
    url: void 0,
    body: void 0,
    isRtjson: void 0,
    crosspostLinkId: void 0,
    mediaType: 0,
    isUserUpload: void 0,
    galleryItems: []
  };
}
var PostContent = {
  $type: "devvit.reddit.post_guidance.v1alpha.PostContent",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
    }
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(18).fork()).ldelim();
    }
    if (message.isRtjson !== void 0) {
      BoolValue.encode({ value: message.isRtjson }, writer.uint32(26).fork()).ldelim();
    }
    if (message.crosspostLinkId !== void 0) {
      StringValue.encode({ value: message.crosspostLinkId }, writer.uint32(34).fork()).ldelim();
    }
    if (message.mediaType !== 0) {
      writer.uint32(40).int32(message.mediaType);
    }
    if (message.isUserUpload !== void 0) {
      BoolValue.encode({ value: message.isUserUpload }, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.galleryItems) {
      GalleryItem.encode(v, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.body = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.isRtjson = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.crosspostLinkId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.mediaType = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isUserUpload = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.galleryItems.push(GalleryItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet116(object.url) ? String(object.url) : void 0,
      body: isSet116(object.body) ? String(object.body) : void 0,
      isRtjson: isSet116(object.isRtjson) ? Boolean(object.isRtjson) : void 0,
      crosspostLinkId: isSet116(object.crosspostLinkId) ? String(object.crosspostLinkId) : void 0,
      mediaType: isSet116(object.mediaType) ? mediaTypeFromJSON(object.mediaType) : 0,
      isUserUpload: isSet116(object.isUserUpload) ? Boolean(object.isUserUpload) : void 0,
      galleryItems: globalThis.Array.isArray(object?.galleryItems) ? object.galleryItems.map((e) => GalleryItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.body !== void 0) {
      obj.body = message.body;
    }
    if (message.isRtjson !== void 0) {
      obj.isRtjson = message.isRtjson;
    }
    if (message.crosspostLinkId !== void 0) {
      obj.crosspostLinkId = message.crosspostLinkId;
    }
    if (message.mediaType !== 0) {
      obj.mediaType = mediaTypeToJSON(message.mediaType);
    }
    if (message.isUserUpload !== void 0) {
      obj.isUserUpload = message.isUserUpload;
    }
    if (message.galleryItems?.length) {
      obj.galleryItems = message.galleryItems.map((e) => GalleryItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return PostContent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostContent();
    message.url = object.url ?? void 0;
    message.body = object.body ?? void 0;
    message.isRtjson = object.isRtjson ?? void 0;
    message.crosspostLinkId = object.crosspostLinkId ?? void 0;
    message.mediaType = object.mediaType ?? 0;
    message.isUserUpload = object.isUserUpload ?? void 0;
    message.galleryItems = object.galleryItems?.map((e) => GalleryItem.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(PostContent.$type, PostContent);
function createBasePostMetadata() {
  return {
    title: void 0,
    subredditId: void 0,
    userId: void 0,
    postType: 0,
    isLocked: void 0,
    isNsfw: void 0,
    isOriginalContent: void 0,
    isReceivingReplies: void 0,
    isSpoiler: void 0,
    isUnlisted: void 0,
    flairId: void 0,
    flairText: void 0,
    eventStart: void 0,
    eventEnd: void 0,
    discussionType: 0,
    collectionId: void 0,
    ip: void 0,
    isPromoted: void 0
  };
}
var PostMetadata = {
  $type: "devvit.reddit.post_guidance.v1alpha.PostMetadata",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== void 0) {
      StringValue.encode({ value: message.userId }, writer.uint32(26).fork()).ldelim();
    }
    if (message.postType !== 0) {
      writer.uint32(32).int32(message.postType);
    }
    if (message.isLocked !== void 0) {
      BoolValue.encode({ value: message.isLocked }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isNsfw !== void 0) {
      BoolValue.encode({ value: message.isNsfw }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isOriginalContent !== void 0) {
      BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(58).fork()).ldelim();
    }
    if (message.isReceivingReplies !== void 0) {
      BoolValue.encode({ value: message.isReceivingReplies }, writer.uint32(66).fork()).ldelim();
    }
    if (message.isSpoiler !== void 0) {
      BoolValue.encode({ value: message.isSpoiler }, writer.uint32(74).fork()).ldelim();
    }
    if (message.isUnlisted !== void 0) {
      BoolValue.encode({ value: message.isUnlisted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.flairId !== void 0) {
      StringValue.encode({ value: message.flairId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.eventStart !== void 0) {
      Int64Value.encode({ value: message.eventStart }, writer.uint32(106).fork()).ldelim();
    }
    if (message.eventEnd !== void 0) {
      Int64Value.encode({ value: message.eventEnd }, writer.uint32(114).fork()).ldelim();
    }
    if (message.discussionType !== 0) {
      writer.uint32(120).int32(message.discussionType);
    }
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(130).fork()).ldelim();
    }
    if (message.ip !== void 0) {
      StringValue.encode({ value: message.ip }, writer.uint32(138).fork()).ldelim();
    }
    if (message.isPromoted !== void 0) {
      BoolValue.encode({ value: message.isPromoted }, writer.uint32(146).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.userId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.postType = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.isLocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.isReceivingReplies = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.isSpoiler = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.isUnlisted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.flairId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.eventStart = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.eventEnd = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }
          message.discussionType = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.ip = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.isPromoted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet116(object.title) ? String(object.title) : void 0,
      subredditId: isSet116(object.subredditId) ? String(object.subredditId) : void 0,
      userId: isSet116(object.userId) ? String(object.userId) : void 0,
      postType: isSet116(object.postType) ? postTypeFromJSON(object.postType) : 0,
      isLocked: isSet116(object.isLocked) ? Boolean(object.isLocked) : void 0,
      isNsfw: isSet116(object.isNsfw) ? Boolean(object.isNsfw) : void 0,
      isOriginalContent: isSet116(object.isOriginalContent) ? Boolean(object.isOriginalContent) : void 0,
      isReceivingReplies: isSet116(object.isReceivingReplies) ? Boolean(object.isReceivingReplies) : void 0,
      isSpoiler: isSet116(object.isSpoiler) ? Boolean(object.isSpoiler) : void 0,
      isUnlisted: isSet116(object.isUnlisted) ? Boolean(object.isUnlisted) : void 0,
      flairId: isSet116(object.flairId) ? String(object.flairId) : void 0,
      flairText: isSet116(object.flairText) ? String(object.flairText) : void 0,
      eventStart: isSet116(object.eventStart) ? Number(object.eventStart) : void 0,
      eventEnd: isSet116(object.eventEnd) ? Number(object.eventEnd) : void 0,
      discussionType: isSet116(object.discussionType) ? discussionTypeFromJSON(object.discussionType) : 0,
      collectionId: isSet116(object.collectionId) ? String(object.collectionId) : void 0,
      ip: isSet116(object.ip) ? String(object.ip) : void 0,
      isPromoted: isSet116(object.isPromoted) ? Boolean(object.isPromoted) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.userId !== void 0) {
      obj.userId = message.userId;
    }
    if (message.postType !== 0) {
      obj.postType = postTypeToJSON(message.postType);
    }
    if (message.isLocked !== void 0) {
      obj.isLocked = message.isLocked;
    }
    if (message.isNsfw !== void 0) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.isOriginalContent !== void 0) {
      obj.isOriginalContent = message.isOriginalContent;
    }
    if (message.isReceivingReplies !== void 0) {
      obj.isReceivingReplies = message.isReceivingReplies;
    }
    if (message.isSpoiler !== void 0) {
      obj.isSpoiler = message.isSpoiler;
    }
    if (message.isUnlisted !== void 0) {
      obj.isUnlisted = message.isUnlisted;
    }
    if (message.flairId !== void 0) {
      obj.flairId = message.flairId;
    }
    if (message.flairText !== void 0) {
      obj.flairText = message.flairText;
    }
    if (message.eventStart !== void 0) {
      obj.eventStart = message.eventStart;
    }
    if (message.eventEnd !== void 0) {
      obj.eventEnd = message.eventEnd;
    }
    if (message.discussionType !== 0) {
      obj.discussionType = discussionTypeToJSON(message.discussionType);
    }
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.ip !== void 0) {
      obj.ip = message.ip;
    }
    if (message.isPromoted !== void 0) {
      obj.isPromoted = message.isPromoted;
    }
    return obj;
  },
  create(base) {
    return PostMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostMetadata();
    message.title = object.title ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.userId = object.userId ?? void 0;
    message.postType = object.postType ?? 0;
    message.isLocked = object.isLocked ?? void 0;
    message.isNsfw = object.isNsfw ?? void 0;
    message.isOriginalContent = object.isOriginalContent ?? void 0;
    message.isReceivingReplies = object.isReceivingReplies ?? void 0;
    message.isSpoiler = object.isSpoiler ?? void 0;
    message.isUnlisted = object.isUnlisted ?? void 0;
    message.flairId = object.flairId ?? void 0;
    message.flairText = object.flairText ?? void 0;
    message.eventStart = object.eventStart ?? void 0;
    message.eventEnd = object.eventEnd ?? void 0;
    message.discussionType = object.discussionType ?? 0;
    message.collectionId = object.collectionId ?? void 0;
    message.ip = object.ip ?? void 0;
    message.isPromoted = object.isPromoted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(PostMetadata.$type, PostMetadata);
function createBaseGalleryItem() {
  return {
    id: void 0,
    mediaId: void 0,
    caption: void 0,
    outboundUrl: void 0,
    isDeleted: void 0,
    callToAction: void 0,
    displayUrl: void 0,
    product: void 0
  };
}
var GalleryItem = {
  $type: "devvit.reddit.post_guidance.v1alpha.GalleryItem",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.mediaId !== void 0) {
      StringValue.encode({ value: message.mediaId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.caption !== void 0) {
      StringValue.encode({ value: message.caption }, writer.uint32(26).fork()).ldelim();
    }
    if (message.outboundUrl !== void 0) {
      StringValue.encode({ value: message.outboundUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isDeleted !== void 0) {
      BoolValue.encode({ value: message.isDeleted }, writer.uint32(42).fork()).ldelim();
    }
    if (message.callToAction !== void 0) {
      StringValue.encode({ value: message.callToAction }, writer.uint32(50).fork()).ldelim();
    }
    if (message.displayUrl !== void 0) {
      StringValue.encode({ value: message.displayUrl }, writer.uint32(58).fork()).ldelim();
    }
    if (message.product !== void 0) {
      Product.encode(message.product, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGalleryItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.mediaId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.caption = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.outboundUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.callToAction = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.displayUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.product = Product.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet116(object.id) ? String(object.id) : void 0,
      mediaId: isSet116(object.mediaId) ? String(object.mediaId) : void 0,
      caption: isSet116(object.caption) ? String(object.caption) : void 0,
      outboundUrl: isSet116(object.outboundUrl) ? String(object.outboundUrl) : void 0,
      isDeleted: isSet116(object.isDeleted) ? Boolean(object.isDeleted) : void 0,
      callToAction: isSet116(object.callToAction) ? String(object.callToAction) : void 0,
      displayUrl: isSet116(object.displayUrl) ? String(object.displayUrl) : void 0,
      product: isSet116(object.product) ? Product.fromJSON(object.product) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.mediaId !== void 0) {
      obj.mediaId = message.mediaId;
    }
    if (message.caption !== void 0) {
      obj.caption = message.caption;
    }
    if (message.outboundUrl !== void 0) {
      obj.outboundUrl = message.outboundUrl;
    }
    if (message.isDeleted !== void 0) {
      obj.isDeleted = message.isDeleted;
    }
    if (message.callToAction !== void 0) {
      obj.callToAction = message.callToAction;
    }
    if (message.displayUrl !== void 0) {
      obj.displayUrl = message.displayUrl;
    }
    if (message.product !== void 0) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },
  create(base) {
    return GalleryItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGalleryItem();
    message.id = object.id ?? void 0;
    message.mediaId = object.mediaId ?? void 0;
    message.caption = object.caption ?? void 0;
    message.outboundUrl = object.outboundUrl ?? void 0;
    message.isDeleted = object.isDeleted ?? void 0;
    message.callToAction = object.callToAction ?? void 0;
    message.displayUrl = object.displayUrl ?? void 0;
    message.product = object.product !== void 0 && object.product !== null ? Product.fromPartial(object.product) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GalleryItem.$type, GalleryItem);
function createBaseProduct() {
  return { title: void 0, price: void 0, description: void 0 };
}
var Product = {
  $type: "devvit.reddit.post_guidance.v1alpha.Product",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
    }
    if (message.price !== void 0) {
      StringValue.encode({ value: message.price }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.price = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet116(object.title) ? String(object.title) : void 0,
      price: isSet116(object.price) ? String(object.price) : void 0,
      description: isSet116(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.price !== void 0) {
      obj.price = message.price;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return Product.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProduct();
    message.title = object.title ?? void 0;
    message.price = object.price ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Product.$type, Product);
function createBaseValidatePostRequirementsRequest() {
  return { postContent: void 0, postMetadata: void 0 };
}
var ValidatePostRequirementsRequest = {
  $type: "devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsRequest",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    if (message.postContent !== void 0) {
      PostContent.encode(message.postContent, writer.uint32(10).fork()).ldelim();
    }
    if (message.postMetadata !== void 0) {
      PostMetadata.encode(message.postMetadata, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatePostRequirementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.postContent = PostContent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.postMetadata = PostMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      postContent: isSet116(object.postContent) ? PostContent.fromJSON(object.postContent) : void 0,
      postMetadata: isSet116(object.postMetadata) ? PostMetadata.fromJSON(object.postMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.postContent !== void 0) {
      obj.postContent = PostContent.toJSON(message.postContent);
    }
    if (message.postMetadata !== void 0) {
      obj.postMetadata = PostMetadata.toJSON(message.postMetadata);
    }
    return obj;
  },
  create(base) {
    return ValidatePostRequirementsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidatePostRequirementsRequest();
    message.postContent = object.postContent !== void 0 && object.postContent !== null ? PostContent.fromPartial(object.postContent) : void 0;
    message.postMetadata = object.postMetadata !== void 0 && object.postMetadata !== null ? PostMetadata.fromPartial(object.postMetadata) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ValidatePostRequirementsRequest.$type, ValidatePostRequirementsRequest);
function createBaseValidationError() {
  return { reason: void 0, field: void 0, shortName: void 0 };
}
var ValidationError = {
  $type: "devvit.reddit.post_guidance.v1alpha.ValidationError",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(10).fork()).ldelim();
    }
    if (message.field !== void 0) {
      StringValue.encode({ value: message.field }, writer.uint32(18).fork()).ldelim();
    }
    if (message.shortName !== void 0) {
      StringValue.encode({ value: message.shortName }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.field = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      reason: isSet116(object.reason) ? String(object.reason) : void 0,
      field: isSet116(object.field) ? String(object.field) : void 0,
      shortName: isSet116(object.shortName) ? String(object.shortName) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    if (message.field !== void 0) {
      obj.field = message.field;
    }
    if (message.shortName !== void 0) {
      obj.shortName = message.shortName;
    }
    return obj;
  },
  create(base) {
    return ValidationError.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidationError();
    message.reason = object.reason ?? void 0;
    message.field = object.field ?? void 0;
    message.shortName = object.shortName ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ValidationError.$type, ValidationError);
function createBaseValidatePostRequirementsResponse() {
  return { errors: [] };
}
var ValidatePostRequirementsResponse = {
  $type: "devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsResponse",
  encode(message, writer = import_minimal126.default.Writer.create()) {
    for (const v of message.errors) {
      ValidationError.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal126.default.Reader ? input : import_minimal126.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatePostRequirementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => ValidationError.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ValidationError.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ValidatePostRequirementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidatePostRequirementsResponse();
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ValidatePostRequirementsResponse.$type, ValidatePostRequirementsResponse);
function isSet116(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/custom_post/v1alpha/custom_post.js
var import_minimal127 = __toESM(require_minimal2(), 1);
function createBaseDimensions() {
  return { height: 0, width: 0, scale: 0 };
}
var Dimensions = {
  $type: "devvit.reddit.custom_post.v1alpha.Dimensions",
  encode(message, writer = import_minimal127.default.Writer.create()) {
    if (message.height !== 0) {
      writer.uint32(8).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.scale !== 0) {
      writer.uint32(29).float(message.scale);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal127.default.Reader ? input : import_minimal127.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.width = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }
          message.scale = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet117(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet117(object.width) ? globalThis.Number(object.width) : 0,
      scale: isSet117(object.scale) ? globalThis.Number(object.scale) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.scale !== 0) {
      obj.scale = message.scale;
    }
    return obj;
  },
  create(base) {
    return Dimensions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDimensions();
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.scale = object.scale ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Dimensions.$type, Dimensions);
function createBaseRenderPostRequest() {
  return { state: void 0, blocks: void 0, dimensions: void 0 };
}
var RenderPostRequest = {
  $type: "devvit.reddit.custom_post.v1alpha.RenderPostRequest",
  encode(message, writer = import_minimal127.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    if (message.blocks !== void 0) {
      BlockRenderRequest.encode(message.blocks, writer.uint32(18).fork()).ldelim();
    }
    if (message.dimensions !== void 0) {
      Dimensions.encode(message.dimensions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal127.default.Reader ? input : import_minimal127.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRenderPostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.blocks = BlockRenderRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.dimensions = Dimensions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject26(object.state) ? object.state : void 0,
      blocks: isSet117(object.blocks) ? BlockRenderRequest.fromJSON(object.blocks) : void 0,
      dimensions: isSet117(object.dimensions) ? Dimensions.fromJSON(object.dimensions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.blocks !== void 0) {
      obj.blocks = BlockRenderRequest.toJSON(message.blocks);
    }
    if (message.dimensions !== void 0) {
      obj.dimensions = Dimensions.toJSON(message.dimensions);
    }
    return obj;
  },
  create(base) {
    return RenderPostRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRenderPostRequest();
    message.state = object.state ?? void 0;
    message.blocks = object.blocks !== void 0 && object.blocks !== null ? BlockRenderRequest.fromPartial(object.blocks) : void 0;
    message.dimensions = object.dimensions !== void 0 && object.dimensions !== null ? Dimensions.fromPartial(object.dimensions) : void 0;
    return message;
  }
};
messageTypeRegistry.set(RenderPostRequest.$type, RenderPostRequest);
function createBaseRenderPostResponse() {
  return { state: void 0, effects: [], blocks: void 0 };
}
var RenderPostResponse = {
  $type: "devvit.reddit.custom_post.v1alpha.RenderPostResponse",
  encode(message, writer = import_minimal127.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.blocks !== void 0) {
      BlockRenderResponse.encode(message.blocks, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal127.default.Reader ? input : import_minimal127.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRenderPostResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.blocks = BlockRenderResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject26(object.state) ? object.state : void 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : [],
      blocks: isSet117(object.blocks) ? BlockRenderResponse.fromJSON(object.blocks) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    if (message.blocks !== void 0) {
      obj.blocks = BlockRenderResponse.toJSON(message.blocks);
    }
    return obj;
  },
  create(base) {
    return RenderPostResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRenderPostResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.blocks = object.blocks !== void 0 && object.blocks !== null ? BlockRenderResponse.fromPartial(object.blocks) : void 0;
    return message;
  }
};
messageTypeRegistry.set(RenderPostResponse.$type, RenderPostResponse);
function isObject26(value) {
  return typeof value === "object" && value !== null;
}
function isSet117(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/custom_actions/v2alpha/custom_actions.js
var import_minimal128 = __toESM(require_minimal2(), 1);
function createBaseCustomAction() {
  return { actionId: "", label: "", shortDescription: "", menus: void 0, options: void 0 };
}
var CustomAction = {
  $type: "devvit.reddit.custom_actions.v2alpha.CustomAction",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.shortDescription !== "") {
      writer.uint32(26).string(message.shortDescription);
    }
    if (message.menus !== void 0) {
      CustomAction_Menus.encode(message.menus, writer.uint32(34).fork()).ldelim();
    }
    if (message.options !== void 0) {
      CustomAction_Options.encode(message.options, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.menus = CustomAction_Menus.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.options = CustomAction_Options.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet118(object.actionId) ? globalThis.String(object.actionId) : "",
      label: isSet118(object.label) ? globalThis.String(object.label) : "",
      shortDescription: isSet118(object.shortDescription) ? globalThis.String(object.shortDescription) : "",
      menus: isSet118(object.menus) ? CustomAction_Menus.fromJSON(object.menus) : void 0,
      options: isSet118(object.options) ? CustomAction_Options.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.shortDescription !== "") {
      obj.shortDescription = message.shortDescription;
    }
    if (message.menus !== void 0) {
      obj.menus = CustomAction_Menus.toJSON(message.menus);
    }
    if (message.options !== void 0) {
      obj.options = CustomAction_Options.toJSON(message.options);
    }
    return obj;
  },
  create(base) {
    return CustomAction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomAction();
    message.actionId = object.actionId ?? "";
    message.label = object.label ?? "";
    message.shortDescription = object.shortDescription ?? "";
    message.menus = object.menus !== void 0 && object.menus !== null ? CustomAction_Menus.fromPartial(object.menus) : void 0;
    message.options = object.options !== void 0 && object.options !== null ? CustomAction_Options.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CustomAction.$type, CustomAction);
function createBaseCustomAction_Menus() {
  return { subreddit: void 0, post: void 0, comment: void 0 };
}
var CustomAction_Menus = {
  $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Menus",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      writer.uint32(8).bool(message.subreddit);
    }
    if (message.post !== void 0) {
      writer.uint32(16).bool(message.post);
    }
    if (message.comment !== void 0) {
      writer.uint32(24).bool(message.comment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomAction_Menus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.subreddit = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.post = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.comment = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet118(object.subreddit) ? globalThis.Boolean(object.subreddit) : void 0,
      post: isSet118(object.post) ? globalThis.Boolean(object.post) : void 0,
      comment: isSet118(object.comment) ? globalThis.Boolean(object.comment) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.post !== void 0) {
      obj.post = message.post;
    }
    if (message.comment !== void 0) {
      obj.comment = message.comment;
    }
    return obj;
  },
  create(base) {
    return CustomAction_Menus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomAction_Menus();
    message.subreddit = object.subreddit ?? void 0;
    message.post = object.post ?? void 0;
    message.comment = object.comment ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CustomAction_Menus.$type, CustomAction_Menus);
function createBaseCustomAction_Options() {
  return { modTool: void 0, icon: void 0 };
}
var CustomAction_Options = {
  $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Options",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.modTool !== void 0) {
      writer.uint32(8).bool(message.modTool);
    }
    if (message.icon !== void 0) {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomAction_Options();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.modTool = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      modTool: isSet118(object.modTool) ? globalThis.Boolean(object.modTool) : void 0,
      icon: isSet118(object.icon) ? globalThis.String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.modTool !== void 0) {
      obj.modTool = message.modTool;
    }
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    return obj;
  },
  create(base) {
    return CustomAction_Options.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomAction_Options();
    message.modTool = object.modTool ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CustomAction_Options.$type, CustomAction_Options);
function createBaseGetActionsRequest() {
  return {};
}
var GetActionsRequest = {
  $type: "devvit.reddit.custom_actions.v2alpha.GetActionsRequest",
  encode(_, writer = import_minimal128.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetActionsRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetActionsRequest();
    return message;
  }
};
messageTypeRegistry.set(GetActionsRequest.$type, GetActionsRequest);
function createBaseGetActionsResponse() {
  return { actions: [] };
}
var GetActionsResponse = {
  $type: "devvit.reddit.custom_actions.v2alpha.GetActionsResponse",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    for (const v of message.actions) {
      CustomAction.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actions.push(CustomAction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e) => CustomAction.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => CustomAction.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetActionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetActionsResponse();
    message.actions = object.actions?.map((e) => CustomAction.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetActionsResponse.$type, GetActionsResponse);
function createBaseOnActionRequest() {
  return { actionId: "", thingType: 0, thingId: "" };
}
var OnActionRequest = {
  $type: "devvit.reddit.custom_actions.v2alpha.OnActionRequest",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.thingType !== 0) {
      writer.uint32(16).int32(message.thingType);
    }
    if (message.thingId !== "") {
      writer.uint32(26).string(message.thingId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.thingType = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.thingId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet118(object.actionId) ? globalThis.String(object.actionId) : "",
      thingType: isSet118(object.thingType) ? thingTypeFromJSON(object.thingType) : 0,
      thingId: isSet118(object.thingId) ? globalThis.String(object.thingId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.thingType !== 0) {
      obj.thingType = thingTypeToJSON(message.thingType);
    }
    if (message.thingId !== "") {
      obj.thingId = message.thingId;
    }
    return obj;
  },
  create(base) {
    return OnActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOnActionRequest();
    message.actionId = object.actionId ?? "";
    message.thingType = object.thingType ?? 0;
    message.thingId = object.thingId ?? "";
    return message;
  }
};
messageTypeRegistry.set(OnActionRequest.$type, OnActionRequest);
function createBaseOnActionResponse() {
  return { state: void 0, effects: [] };
}
var OnActionResponse = {
  $type: "devvit.reddit.custom_actions.v2alpha.OnActionResponse",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : import_minimal128.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject27(object.state) ? object.state : void 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return OnActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOnActionResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(OnActionResponse.$type, OnActionResponse);
function isObject27(value) {
  return typeof value === "object" && value !== null;
}
function isSet118(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/wiki/wiki_svc.js
var import_minimal130 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/wiki/wiki_msg.js
var import_long14 = __toESM(require_long(), 1);
var import_minimal129 = __toESM(require_minimal2(), 1);
function createBaseGetWikiPagesRequest() {
  return { subreddit: "" };
}
var GetWikiPagesRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPagesRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return GetWikiPagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiPagesRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWikiPagesRequest.$type, GetWikiPagesRequest);
function createBaseGetWikiPagesResponse() {
  return { kind: "", data: [] };
}
var GetWikiPagesResponse = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPagesResponse",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    for (const v of message.data) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet119(object.kind) ? globalThis.String(object.kind) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data?.length) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return GetWikiPagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiPagesResponse();
    message.kind = object.kind ?? "";
    message.data = object.data?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(GetWikiPagesResponse.$type, GetWikiPagesResponse);
function createBaseGetWikiPageRequest() {
  return { subreddit: "", page: "" };
}
var GetWikiPageRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    return obj;
  },
  create(base) {
    return GetWikiPageRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWikiPageRequest.$type, GetWikiPageRequest);
function createBaseWikiPage() {
  return {
    contentMd: "",
    contentHtml: "",
    revisionId: "",
    revisionDate: 0,
    mayRevise: false,
    reason: void 0,
    revisionBy: void 0
  };
}
var WikiPage = {
  $type: "devvit.plugin.redditapi.wiki.WikiPage",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.contentMd !== "") {
      writer.uint32(10).string(message.contentMd);
    }
    if (message.contentHtml !== "") {
      writer.uint32(18).string(message.contentHtml);
    }
    if (message.revisionId !== "") {
      writer.uint32(26).string(message.revisionId);
    }
    if (message.revisionDate !== 0) {
      writer.uint32(32).int64(message.revisionDate);
    }
    if (message.mayRevise !== false) {
      writer.uint32(40).bool(message.mayRevise);
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.revisionBy !== void 0) {
      WrappedUserObject.encode(message.revisionBy, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.contentMd = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contentHtml = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.revisionId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.revisionDate = longToNumber14(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.mayRevise = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.revisionBy = WrappedUserObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contentMd: isSet119(object.contentMd) ? globalThis.String(object.contentMd) : "",
      contentHtml: isSet119(object.contentHtml) ? globalThis.String(object.contentHtml) : "",
      revisionId: isSet119(object.revisionId) ? globalThis.String(object.revisionId) : "",
      revisionDate: isSet119(object.revisionDate) ? globalThis.Number(object.revisionDate) : 0,
      mayRevise: isSet119(object.mayRevise) ? globalThis.Boolean(object.mayRevise) : false,
      reason: isSet119(object.reason) ? String(object.reason) : void 0,
      revisionBy: isSet119(object.revisionBy) ? WrappedUserObject.fromJSON(object.revisionBy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contentMd !== "") {
      obj.contentMd = message.contentMd;
    }
    if (message.contentHtml !== "") {
      obj.contentHtml = message.contentHtml;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.revisionDate !== 0) {
      obj.revisionDate = Math.round(message.revisionDate);
    }
    if (message.mayRevise !== false) {
      obj.mayRevise = message.mayRevise;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    if (message.revisionBy !== void 0) {
      obj.revisionBy = WrappedUserObject.toJSON(message.revisionBy);
    }
    return obj;
  },
  create(base) {
    return WikiPage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWikiPage();
    message.contentMd = object.contentMd ?? "";
    message.contentHtml = object.contentHtml ?? "";
    message.revisionId = object.revisionId ?? "";
    message.revisionDate = object.revisionDate ?? 0;
    message.mayRevise = object.mayRevise ?? false;
    message.reason = object.reason ?? void 0;
    message.revisionBy = object.revisionBy !== void 0 && object.revisionBy !== null ? WrappedUserObject.fromPartial(object.revisionBy) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WikiPage.$type, WikiPage);
function createBaseGetWikiPageResponse() {
  return { kind: "", data: void 0 };
}
var GetWikiPageResponse = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageResponse",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      WikiPage.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = WikiPage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet119(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet119(object.data) ? WikiPage.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = WikiPage.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return GetWikiPageResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageResponse();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? WikiPage.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetWikiPageResponse.$type, GetWikiPageResponse);
function createBaseEditWikiPageRequest() {
  return { subreddit: "", page: "", content: "", reason: "" };
}
var EditWikiPageRequest = {
  $type: "devvit.plugin.redditapi.wiki.EditWikiPageRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEditWikiPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      content: isSet119(object.content) ? globalThis.String(object.content) : "",
      reason: isSet119(object.reason) ? globalThis.String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return EditWikiPageRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEditWikiPageRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.content = object.content ?? "";
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set(EditWikiPageRequest.$type, EditWikiPageRequest);
function createBaseHideWikiPageRevisionRequest() {
  return { subreddit: "", page: "", revision: "" };
}
var HideWikiPageRevisionRequest = {
  $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.revision !== "") {
      writer.uint32(26).string(message.revision);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHideWikiPageRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.revision = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      revision: isSet119(object.revision) ? globalThis.String(object.revision) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.revision !== "") {
      obj.revision = message.revision;
    }
    return obj;
  },
  create(base) {
    return HideWikiPageRevisionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHideWikiPageRevisionRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.revision = object.revision ?? "";
    return message;
  }
};
messageTypeRegistry.set(HideWikiPageRevisionRequest.$type, HideWikiPageRevisionRequest);
function createBaseHideWikiPageRevisionResponse() {
  return { status: false };
}
var HideWikiPageRevisionResponse = {
  $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.status !== false) {
      writer.uint32(8).bool(message.status);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHideWikiPageRevisionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.status = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { status: isSet119(object.status) ? globalThis.Boolean(object.status) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    return obj;
  },
  create(base) {
    return HideWikiPageRevisionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHideWikiPageRevisionResponse();
    message.status = object.status ?? false;
    return message;
  }
};
messageTypeRegistry.set(HideWikiPageRevisionResponse.$type, HideWikiPageRevisionResponse);
function createBaseGetWikiPageRevisionsRequest() {
  return {
    subreddit: "",
    page: "",
    after: void 0,
    before: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    srDetail: void 0
  };
}
var GetWikiPageRevisionsRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      BoolValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.srDetail !== void 0) {
      BoolValue.encode({ value: message.srDetail }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.show = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.srDetail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      after: isSet119(object.after) ? String(object.after) : void 0,
      before: isSet119(object.before) ? String(object.before) : void 0,
      limit: isSet119(object.limit) ? Number(object.limit) : void 0,
      count: isSet119(object.count) ? Number(object.count) : void 0,
      show: isSet119(object.show) ? Boolean(object.show) : void 0,
      srDetail: isSet119(object.srDetail) ? Boolean(object.srDetail) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.srDetail !== void 0) {
      obj.srDetail = message.srDetail;
    }
    return obj;
  },
  create(base) {
    return GetWikiPageRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageRevisionsRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.srDetail = object.srDetail ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetWikiPageRevisionsRequest.$type, GetWikiPageRevisionsRequest);
function createBaseWikiPageRevision() {
  return { id: "", page: "", timestamp: 0, reason: "", revisionHidden: false, author: void 0 };
}
var WikiPageRevision = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageRevision",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.revisionHidden !== false) {
      writer.uint32(40).bool(message.revisionHidden);
    }
    if (message.author !== void 0) {
      WrappedUserObject.encode(message.author, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageRevision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.timestamp = longToNumber14(reader.int64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.reason = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.revisionHidden = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.author = WrappedUserObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet119(object.id) ? globalThis.String(object.id) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      timestamp: isSet119(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      reason: isSet119(object.reason) ? globalThis.String(object.reason) : "",
      revisionHidden: isSet119(object.revisionHidden) ? globalThis.Boolean(object.revisionHidden) : false,
      author: isSet119(object.author) ? WrappedUserObject.fromJSON(object.author) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.revisionHidden !== false) {
      obj.revisionHidden = message.revisionHidden;
    }
    if (message.author !== void 0) {
      obj.author = WrappedUserObject.toJSON(message.author);
    }
    return obj;
  },
  create(base) {
    return WikiPageRevision.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWikiPageRevision();
    message.id = object.id ?? "";
    message.page = object.page ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.reason = object.reason ?? "";
    message.revisionHidden = object.revisionHidden ?? false;
    message.author = object.author !== void 0 && object.author !== null ? WrappedUserObject.fromPartial(object.author) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WikiPageRevision.$type, WikiPageRevision);
function createBaseWikiPageRevisionListing() {
  return { kind: "", data: void 0 };
}
var WikiPageRevisionListing = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      WikiPageRevisionListing_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageRevisionListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = WikiPageRevisionListing_Data.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet119(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet119(object.data) ? WikiPageRevisionListing_Data.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = WikiPageRevisionListing_Data.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return WikiPageRevisionListing.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWikiPageRevisionListing();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? WikiPageRevisionListing_Data.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WikiPageRevisionListing.$type, WikiPageRevisionListing);
function createBaseWikiPageRevisionListing_Data() {
  return { after: void 0, before: void 0, children: [], dist: void 0 };
}
var WikiPageRevisionListing_Data = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing.Data",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      WikiPageRevision.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int64Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageRevisionListing_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.children.push(WikiPageRevision.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.dist = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet119(object.after) ? String(object.after) : void 0,
      before: isSet119(object.before) ? String(object.before) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => WikiPageRevision.fromJSON(e)) : [],
      dist: isSet119(object.dist) ? Number(object.dist) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => WikiPageRevision.toJSON(e));
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    return obj;
  },
  create(base) {
    return WikiPageRevisionListing_Data.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWikiPageRevisionListing_Data();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.children = object.children?.map((e) => WikiPageRevision.fromPartial(e)) || [];
    message.dist = object.dist ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(WikiPageRevisionListing_Data.$type, WikiPageRevisionListing_Data);
function createBaseGetWikiRevisionsRequest() {
  return {
    subreddit: "",
    after: void 0,
    before: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    srDetail: void 0
  };
}
var GetWikiRevisionsRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      BoolValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    if (message.srDetail !== void 0) {
      BoolValue.encode({ value: message.srDetail }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.show = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.srDetail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      after: isSet119(object.after) ? String(object.after) : void 0,
      before: isSet119(object.before) ? String(object.before) : void 0,
      limit: isSet119(object.limit) ? Number(object.limit) : void 0,
      count: isSet119(object.count) ? Number(object.count) : void 0,
      show: isSet119(object.show) ? Boolean(object.show) : void 0,
      srDetail: isSet119(object.srDetail) ? Boolean(object.srDetail) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.srDetail !== void 0) {
      obj.srDetail = message.srDetail;
    }
    return obj;
  },
  create(base) {
    return GetWikiRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiRevisionsRequest();
    message.subreddit = object.subreddit ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.srDetail = object.srDetail ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetWikiRevisionsRequest.$type, GetWikiRevisionsRequest);
function createBaseRevertWikiPageRequest() {
  return { subreddit: "", page: "", revision: "" };
}
var RevertWikiPageRequest = {
  $type: "devvit.plugin.redditapi.wiki.RevertWikiPageRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.revision !== "") {
      writer.uint32(26).string(message.revision);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevertWikiPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.revision = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      revision: isSet119(object.revision) ? globalThis.String(object.revision) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.revision !== "") {
      obj.revision = message.revision;
    }
    return obj;
  },
  create(base) {
    return RevertWikiPageRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRevertWikiPageRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.revision = object.revision ?? "";
    return message;
  }
};
messageTypeRegistry.set(RevertWikiPageRequest.$type, RevertWikiPageRequest);
function createBaseGetWikiPageSettingsRequest() {
  return { subreddit: "", page: "" };
}
var GetWikiPageSettingsRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    return obj;
  },
  create(base) {
    return GetWikiPageSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageSettingsRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWikiPageSettingsRequest.$type, GetWikiPageSettingsRequest);
function createBaseWikiPageSettings() {
  return { kind: "", data: void 0 };
}
var WikiPageSettings = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageSettings",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      WikiPageSettings_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = WikiPageSettings_Data.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet119(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet119(object.data) ? WikiPageSettings_Data.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = WikiPageSettings_Data.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return WikiPageSettings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWikiPageSettings();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? WikiPageSettings_Data.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WikiPageSettings.$type, WikiPageSettings);
function createBaseWikiPageSettings_Data() {
  return { permLevel: 0, editors: [], listed: false };
}
var WikiPageSettings_Data = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageSettings.Data",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.permLevel !== 0) {
      writer.uint32(8).int32(message.permLevel);
    }
    for (const v of message.editors) {
      WrappedUserObject.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.listed !== false) {
      writer.uint32(24).bool(message.listed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageSettings_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.permLevel = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.editors.push(WrappedUserObject.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.listed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      permLevel: isSet119(object.permLevel) ? globalThis.Number(object.permLevel) : 0,
      editors: globalThis.Array.isArray(object?.editors) ? object.editors.map((e) => WrappedUserObject.fromJSON(e)) : [],
      listed: isSet119(object.listed) ? globalThis.Boolean(object.listed) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.permLevel !== 0) {
      obj.permLevel = Math.round(message.permLevel);
    }
    if (message.editors?.length) {
      obj.editors = message.editors.map((e) => WrappedUserObject.toJSON(e));
    }
    if (message.listed !== false) {
      obj.listed = message.listed;
    }
    return obj;
  },
  create(base) {
    return WikiPageSettings_Data.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWikiPageSettings_Data();
    message.permLevel = object.permLevel ?? 0;
    message.editors = object.editors?.map((e) => WrappedUserObject.fromPartial(e)) || [];
    message.listed = object.listed ?? false;
    return message;
  }
};
messageTypeRegistry.set(WikiPageSettings_Data.$type, WikiPageSettings_Data);
function createBaseUpdateWikiPageSettingsRequest() {
  return { subreddit: "", page: "", permlevel: 0, listed: "" };
}
var UpdateWikiPageSettingsRequest = {
  $type: "devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.permlevel !== 0) {
      writer.uint32(24).int32(message.permlevel);
    }
    if (message.listed !== "") {
      writer.uint32(34).string(message.listed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateWikiPageSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.permlevel = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.listed = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      permlevel: isSet119(object.permlevel) ? globalThis.Number(object.permlevel) : 0,
      listed: isSet119(object.listed) ? globalThis.String(object.listed) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.permlevel !== 0) {
      obj.permlevel = Math.round(message.permlevel);
    }
    if (message.listed !== "") {
      obj.listed = message.listed;
    }
    return obj;
  },
  create(base) {
    return UpdateWikiPageSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateWikiPageSettingsRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.permlevel = object.permlevel ?? 0;
    message.listed = object.listed ?? "";
    return message;
  }
};
messageTypeRegistry.set(UpdateWikiPageSettingsRequest.$type, UpdateWikiPageSettingsRequest);
function createBaseAllowEditorRequest() {
  return { subreddit: "", page: "", act: "", username: "" };
}
var AllowEditorRequest = {
  $type: "devvit.plugin.redditapi.wiki.AllowEditorRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.act !== "") {
      writer.uint32(26).string(message.act);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : import_minimal129.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAllowEditorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.page = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.act = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet119(object.subreddit) ? globalThis.String(object.subreddit) : "",
      page: isSet119(object.page) ? globalThis.String(object.page) : "",
      act: isSet119(object.act) ? globalThis.String(object.act) : "",
      username: isSet119(object.username) ? globalThis.String(object.username) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    if (message.act !== "") {
      obj.act = message.act;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },
  create(base) {
    return AllowEditorRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAllowEditorRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.act = object.act ?? "";
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set(AllowEditorRequest.$type, AllowEditorRequest);
function longToNumber14(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal129.default.util.Long !== import_long14.default) {
  import_minimal129.default.util.Long = import_long14.default;
  import_minimal129.default.configure();
}
function isSet119(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/widgets/widgets_svc.js
var import_minimal132 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/widgets/widgets_msg.js
var import_minimal131 = __toESM(require_minimal2(), 1);
function createBaseWidgetStyles() {
  return { backgroundColor: void 0, headerColor: void 0 };
}
var WidgetStyles = {
  $type: "devvit.plugin.redditapi.widgets.WidgetStyles",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.backgroundColor !== void 0) {
      StringValue.encode({ value: message.backgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.headerColor !== void 0) {
      StringValue.encode({ value: message.headerColor }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetStyles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.headerColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      backgroundColor: isSet120(object.backgroundColor) ? String(object.backgroundColor) : void 0,
      headerColor: isSet120(object.headerColor) ? String(object.headerColor) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.backgroundColor !== void 0) {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.headerColor !== void 0) {
      obj.headerColor = message.headerColor;
    }
    return obj;
  },
  create(base) {
    return WidgetStyles.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWidgetStyles();
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.headerColor = object.headerColor ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(WidgetStyles.$type, WidgetStyles);
function createBaseWidgetImage() {
  return { url: "", linkUrl: "", height: 0, width: 0 };
}
var WidgetImage = {
  $type: "devvit.plugin.redditapi.widgets.WidgetImage",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.linkUrl !== "") {
      writer.uint32(18).string(message.linkUrl);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.linkUrl = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.width = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet120(object.url) ? globalThis.String(object.url) : "",
      linkUrl: isSet120(object.linkUrl) ? globalThis.String(object.linkUrl) : "",
      height: isSet120(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet120(object.width) ? globalThis.Number(object.width) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.linkUrl !== "") {
      obj.linkUrl = message.linkUrl;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    return obj;
  },
  create(base) {
    return WidgetImage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWidgetImage();
    message.url = object.url ?? "";
    message.linkUrl = object.linkUrl ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    return message;
  }
};
messageTypeRegistry.set(WidgetImage.$type, WidgetImage);
function createBaseImageWidget() {
  return { id: "", kind: "", data: [], shortName: "", styles: void 0, subreddit: void 0 };
}
var ImageWidget = {
  $type: "devvit.plugin.redditapi.widgets.ImageWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    for (const v of message.data) {
      WidgetImage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.data.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0,
      subreddit: isSet120(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => WidgetImage.toJSON(e));
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return ImageWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ImageWidget.$type, ImageWidget);
function createBaseAddImageWidgetRequest() {
  return { subreddit: "", data: [], shortName: "", styles: void 0 };
}
var AddImageWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddImageWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    for (const v of message.data) {
      WidgetImage.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddImageWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => WidgetImage.toJSON(e));
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddImageWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddImageWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddImageWidgetRequest.$type, AddImageWidgetRequest);
function createBaseUpdateImageWidgetRequest() {
  return { subreddit: "", id: "", data: [], shortName: "", styles: void 0 };
}
var UpdateImageWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    for (const v of message.data) {
      WidgetImage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateImageWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.data.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => WidgetImage.toJSON(e));
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateImageWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateImageWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateImageWidgetRequest.$type, UpdateImageWidgetRequest);
function createBaseCalendarWidgetConfiguration() {
  return {
    numEvents: 0,
    showDate: false,
    showDescription: false,
    showLocation: false,
    showTime: false,
    showTitle: false
  };
}
var CalendarWidgetConfiguration = {
  $type: "devvit.plugin.redditapi.widgets.CalendarWidgetConfiguration",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.numEvents !== 0) {
      writer.uint32(8).int32(message.numEvents);
    }
    if (message.showDate !== false) {
      writer.uint32(16).bool(message.showDate);
    }
    if (message.showDescription !== false) {
      writer.uint32(24).bool(message.showDescription);
    }
    if (message.showLocation !== false) {
      writer.uint32(32).bool(message.showLocation);
    }
    if (message.showTime !== false) {
      writer.uint32(40).bool(message.showTime);
    }
    if (message.showTitle !== false) {
      writer.uint32(48).bool(message.showTitle);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCalendarWidgetConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.numEvents = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.showDate = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.showDescription = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.showLocation = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.showTime = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.showTitle = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      numEvents: isSet120(object.numEvents) ? globalThis.Number(object.numEvents) : 0,
      showDate: isSet120(object.showDate) ? globalThis.Boolean(object.showDate) : false,
      showDescription: isSet120(object.showDescription) ? globalThis.Boolean(object.showDescription) : false,
      showLocation: isSet120(object.showLocation) ? globalThis.Boolean(object.showLocation) : false,
      showTime: isSet120(object.showTime) ? globalThis.Boolean(object.showTime) : false,
      showTitle: isSet120(object.showTitle) ? globalThis.Boolean(object.showTitle) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.numEvents !== 0) {
      obj.numEvents = Math.round(message.numEvents);
    }
    if (message.showDate !== false) {
      obj.showDate = message.showDate;
    }
    if (message.showDescription !== false) {
      obj.showDescription = message.showDescription;
    }
    if (message.showLocation !== false) {
      obj.showLocation = message.showLocation;
    }
    if (message.showTime !== false) {
      obj.showTime = message.showTime;
    }
    if (message.showTitle !== false) {
      obj.showTitle = message.showTitle;
    }
    return obj;
  },
  create(base) {
    return CalendarWidgetConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCalendarWidgetConfiguration();
    message.numEvents = object.numEvents ?? 0;
    message.showDate = object.showDate ?? false;
    message.showDescription = object.showDescription ?? false;
    message.showLocation = object.showLocation ?? false;
    message.showTime = object.showTime ?? false;
    message.showTitle = object.showTitle ?? false;
    return message;
  }
};
messageTypeRegistry.set(CalendarWidgetConfiguration.$type, CalendarWidgetConfiguration);
function createBaseCalendarWidget() {
  return {
    id: "",
    kind: "",
    configuration: void 0,
    googleCalendarId: "",
    requiresSync: false,
    shortName: "",
    styles: void 0
  };
}
var CalendarWidget = {
  $type: "devvit.plugin.redditapi.widgets.CalendarWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(26).fork()).ldelim();
    }
    if (message.googleCalendarId !== "") {
      writer.uint32(34).string(message.googleCalendarId);
    }
    if (message.requiresSync !== false) {
      writer.uint32(40).bool(message.requiresSync);
    }
    if (message.shortName !== "") {
      writer.uint32(50).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCalendarWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.googleCalendarId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.requiresSync = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      configuration: isSet120(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      googleCalendarId: isSet120(object.googleCalendarId) ? globalThis.String(object.googleCalendarId) : "",
      requiresSync: isSet120(object.requiresSync) ? globalThis.Boolean(object.requiresSync) : false,
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.configuration !== void 0) {
      obj.configuration = CalendarWidgetConfiguration.toJSON(message.configuration);
    }
    if (message.googleCalendarId !== "") {
      obj.googleCalendarId = message.googleCalendarId;
    }
    if (message.requiresSync !== false) {
      obj.requiresSync = message.requiresSync;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return CalendarWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCalendarWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.googleCalendarId = object.googleCalendarId ?? "";
    message.requiresSync = object.requiresSync ?? false;
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CalendarWidget.$type, CalendarWidget);
function createBaseAddCalendarWidgetRequest() {
  return {
    subreddit: "",
    configuration: void 0,
    googleCalendarId: "",
    requiresSync: false,
    shortName: "",
    styles: void 0
  };
}
var AddCalendarWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(18).fork()).ldelim();
    }
    if (message.googleCalendarId !== "") {
      writer.uint32(26).string(message.googleCalendarId);
    }
    if (message.requiresSync !== false) {
      writer.uint32(32).bool(message.requiresSync);
    }
    if (message.shortName !== "") {
      writer.uint32(42).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddCalendarWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.googleCalendarId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.requiresSync = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      configuration: isSet120(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      googleCalendarId: isSet120(object.googleCalendarId) ? globalThis.String(object.googleCalendarId) : "",
      requiresSync: isSet120(object.requiresSync) ? globalThis.Boolean(object.requiresSync) : false,
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.configuration !== void 0) {
      obj.configuration = CalendarWidgetConfiguration.toJSON(message.configuration);
    }
    if (message.googleCalendarId !== "") {
      obj.googleCalendarId = message.googleCalendarId;
    }
    if (message.requiresSync !== false) {
      obj.requiresSync = message.requiresSync;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddCalendarWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddCalendarWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.googleCalendarId = object.googleCalendarId ?? "";
    message.requiresSync = object.requiresSync ?? false;
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddCalendarWidgetRequest.$type, AddCalendarWidgetRequest);
function createBaseUpdateCalendarWidgetRequest() {
  return {
    subreddit: "",
    id: "",
    configuration: void 0,
    googleCalendarId: "",
    requiresSync: false,
    shortName: "",
    styles: void 0
  };
}
var UpdateCalendarWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(26).fork()).ldelim();
    }
    if (message.googleCalendarId !== "") {
      writer.uint32(34).string(message.googleCalendarId);
    }
    if (message.requiresSync !== false) {
      writer.uint32(40).bool(message.requiresSync);
    }
    if (message.shortName !== "") {
      writer.uint32(50).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCalendarWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.googleCalendarId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.requiresSync = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      configuration: isSet120(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      googleCalendarId: isSet120(object.googleCalendarId) ? globalThis.String(object.googleCalendarId) : "",
      requiresSync: isSet120(object.requiresSync) ? globalThis.Boolean(object.requiresSync) : false,
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.configuration !== void 0) {
      obj.configuration = CalendarWidgetConfiguration.toJSON(message.configuration);
    }
    if (message.googleCalendarId !== "") {
      obj.googleCalendarId = message.googleCalendarId;
    }
    if (message.requiresSync !== false) {
      obj.requiresSync = message.requiresSync;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateCalendarWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCalendarWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.googleCalendarId = object.googleCalendarId ?? "";
    message.requiresSync = object.requiresSync ?? false;
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCalendarWidgetRequest.$type, UpdateCalendarWidgetRequest);
function createBaseTextAreaWidget() {
  return { id: "", kind: "", shortName: "", text: "", styles: void 0 };
}
var TextAreaWidget = {
  $type: "devvit.plugin.redditapi.widgets.TextAreaWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTextAreaWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return TextAreaWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTextAreaWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(TextAreaWidget.$type, TextAreaWidget);
function createBaseAddTextAreaWidgetRequest() {
  return { subreddit: "", shortName: "", text: "", styles: void 0 };
}
var AddTextAreaWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddTextAreaWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddTextAreaWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddTextAreaWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddTextAreaWidgetRequest.$type, AddTextAreaWidgetRequest);
function createBaseUpdateTextAreaWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", text: "", styles: void 0 };
}
var UpdateTextAreaWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateTextAreaWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateTextAreaWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateTextAreaWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateTextAreaWidgetRequest.$type, UpdateTextAreaWidgetRequest);
function createBaseWidgetButton() {
  return {
    kind: "",
    text: "",
    url: void 0,
    imageUrl: void 0,
    linkUrl: void 0,
    color: void 0,
    fillColor: void 0,
    textColor: void 0,
    height: void 0,
    width: void 0,
    hoverState: void 0
  };
}
var WidgetButton = {
  $type: "devvit.plugin.redditapi.widgets.WidgetButton",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    if (message.imageUrl !== void 0) {
      StringValue.encode({ value: message.imageUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.linkUrl !== void 0) {
      StringValue.encode({ value: message.linkUrl }, writer.uint32(42).fork()).ldelim();
    }
    if (message.color !== void 0) {
      StringValue.encode({ value: message.color }, writer.uint32(50).fork()).ldelim();
    }
    if (message.fillColor !== void 0) {
      StringValue.encode({ value: message.fillColor }, writer.uint32(58).fork()).ldelim();
    }
    if (message.textColor !== void 0) {
      StringValue.encode({ value: message.textColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(74).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
    }
    if (message.hoverState !== void 0) {
      WidgetButton_HoverState.encode(message.hoverState, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.imageUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.color = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.fillColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.textColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.hoverState = WidgetButton_HoverState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      url: isSet120(object.url) ? String(object.url) : void 0,
      imageUrl: isSet120(object.imageUrl) ? String(object.imageUrl) : void 0,
      linkUrl: isSet120(object.linkUrl) ? String(object.linkUrl) : void 0,
      color: isSet120(object.color) ? String(object.color) : void 0,
      fillColor: isSet120(object.fillColor) ? String(object.fillColor) : void 0,
      textColor: isSet120(object.textColor) ? String(object.textColor) : void 0,
      height: isSet120(object.height) ? Number(object.height) : void 0,
      width: isSet120(object.width) ? Number(object.width) : void 0,
      hoverState: isSet120(object.hoverState) ? WidgetButton_HoverState.fromJSON(object.hoverState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.imageUrl !== void 0) {
      obj.imageUrl = message.imageUrl;
    }
    if (message.linkUrl !== void 0) {
      obj.linkUrl = message.linkUrl;
    }
    if (message.color !== void 0) {
      obj.color = message.color;
    }
    if (message.fillColor !== void 0) {
      obj.fillColor = message.fillColor;
    }
    if (message.textColor !== void 0) {
      obj.textColor = message.textColor;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    if (message.hoverState !== void 0) {
      obj.hoverState = WidgetButton_HoverState.toJSON(message.hoverState);
    }
    return obj;
  },
  create(base) {
    return WidgetButton.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWidgetButton();
    message.kind = object.kind ?? "";
    message.text = object.text ?? "";
    message.url = object.url ?? void 0;
    message.imageUrl = object.imageUrl ?? void 0;
    message.linkUrl = object.linkUrl ?? void 0;
    message.color = object.color ?? void 0;
    message.fillColor = object.fillColor ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    message.hoverState = object.hoverState !== void 0 && object.hoverState !== null ? WidgetButton_HoverState.fromPartial(object.hoverState) : void 0;
    return message;
  }
};
messageTypeRegistry.set(WidgetButton.$type, WidgetButton);
function createBaseWidgetButton_HoverState() {
  return {
    kind: "",
    color: void 0,
    fillColor: void 0,
    text: void 0,
    textColor: void 0,
    imageUrl: void 0,
    height: void 0,
    width: void 0
  };
}
var WidgetButton_HoverState = {
  $type: "devvit.plugin.redditapi.widgets.WidgetButton.HoverState",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.color !== void 0) {
      StringValue.encode({ value: message.color }, writer.uint32(18).fork()).ldelim();
    }
    if (message.fillColor !== void 0) {
      StringValue.encode({ value: message.fillColor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(34).fork()).ldelim();
    }
    if (message.textColor !== void 0) {
      StringValue.encode({ value: message.textColor }, writer.uint32(42).fork()).ldelim();
    }
    if (message.imageUrl !== void 0) {
      StringValue.encode({ value: message.imageUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(58).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetButton_HoverState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.color = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.fillColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.textColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.imageUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      color: isSet120(object.color) ? String(object.color) : void 0,
      fillColor: isSet120(object.fillColor) ? String(object.fillColor) : void 0,
      text: isSet120(object.text) ? String(object.text) : void 0,
      textColor: isSet120(object.textColor) ? String(object.textColor) : void 0,
      imageUrl: isSet120(object.imageUrl) ? String(object.imageUrl) : void 0,
      height: isSet120(object.height) ? Number(object.height) : void 0,
      width: isSet120(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.color !== void 0) {
      obj.color = message.color;
    }
    if (message.fillColor !== void 0) {
      obj.fillColor = message.fillColor;
    }
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.textColor !== void 0) {
      obj.textColor = message.textColor;
    }
    if (message.imageUrl !== void 0) {
      obj.imageUrl = message.imageUrl;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    return obj;
  },
  create(base) {
    return WidgetButton_HoverState.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWidgetButton_HoverState();
    message.kind = object.kind ?? "";
    message.color = object.color ?? void 0;
    message.fillColor = object.fillColor ?? void 0;
    message.text = object.text ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.imageUrl = object.imageUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(WidgetButton_HoverState.$type, WidgetButton_HoverState);
function createBaseButtonWidget() {
  return { id: "", kind: "", shortName: "", description: "", buttons: [], styles: void 0 };
}
var ButtonWidget = {
  $type: "devvit.plugin.redditapi.widgets.ButtonWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseButtonWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      description: isSet120(object.description) ? globalThis.String(object.description) : "",
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => WidgetButton.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return ButtonWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseButtonWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? "";
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ButtonWidget.$type, ButtonWidget);
function createBaseAddButtonWidgetRequest() {
  return { subreddit: "", shortName: "", description: "", buttons: [], styles: void 0 };
}
var AddButtonWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddButtonWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddButtonWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      description: isSet120(object.description) ? globalThis.String(object.description) : "",
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => WidgetButton.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddButtonWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddButtonWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? "";
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddButtonWidgetRequest.$type, AddButtonWidgetRequest);
function createBaseUpdateButtonWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", description: "", buttons: [], styles: void 0 };
}
var UpdateButtonWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateButtonWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      description: isSet120(object.description) ? globalThis.String(object.description) : "",
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => WidgetButton.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateButtonWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateButtonWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? "";
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateButtonWidgetRequest.$type, UpdateButtonWidgetRequest);
function createBaseCommunityListWidget() {
  return { id: "", kind: "", shortName: "", data: [], styles: void 0 };
}
var CommunityListWidget = {
  $type: "devvit.plugin.redditapi.widgets.CommunityListWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    for (const v of message.data) {
      CommunityListWidget_CommunityData.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommunityListWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.data.push(CommunityListWidget_CommunityData.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => CommunityListWidget_CommunityData.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => CommunityListWidget_CommunityData.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return CommunityListWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommunityListWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => CommunityListWidget_CommunityData.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CommunityListWidget.$type, CommunityListWidget);
function createBaseCommunityListWidget_CommunityData() {
  return {
    communityIcon: "",
    iconUrl: "",
    isNsfw: false,
    isSubscribed: false,
    name: "",
    prefixedName: "",
    primaryColor: "",
    subscribers: 0,
    type: ""
  };
}
var CommunityListWidget_CommunityData = {
  $type: "devvit.plugin.redditapi.widgets.CommunityListWidget.CommunityData",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.communityIcon !== "") {
      writer.uint32(10).string(message.communityIcon);
    }
    if (message.iconUrl !== "") {
      writer.uint32(18).string(message.iconUrl);
    }
    if (message.isNsfw !== false) {
      writer.uint32(24).bool(message.isNsfw);
    }
    if (message.isSubscribed !== false) {
      writer.uint32(32).bool(message.isSubscribed);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.prefixedName !== "") {
      writer.uint32(50).string(message.prefixedName);
    }
    if (message.primaryColor !== "") {
      writer.uint32(58).string(message.primaryColor);
    }
    if (message.subscribers !== 0) {
      writer.uint32(64).int32(message.subscribers);
    }
    if (message.type !== "") {
      writer.uint32(74).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommunityListWidget_CommunityData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.communityIcon = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.iconUrl = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.isNsfw = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.isSubscribed = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.prefixedName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.primaryColor = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.subscribers = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      communityIcon: isSet120(object.communityIcon) ? globalThis.String(object.communityIcon) : "",
      iconUrl: isSet120(object.iconUrl) ? globalThis.String(object.iconUrl) : "",
      isNsfw: isSet120(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false,
      isSubscribed: isSet120(object.isSubscribed) ? globalThis.Boolean(object.isSubscribed) : false,
      name: isSet120(object.name) ? globalThis.String(object.name) : "",
      prefixedName: isSet120(object.prefixedName) ? globalThis.String(object.prefixedName) : "",
      primaryColor: isSet120(object.primaryColor) ? globalThis.String(object.primaryColor) : "",
      subscribers: isSet120(object.subscribers) ? globalThis.Number(object.subscribers) : 0,
      type: isSet120(object.type) ? globalThis.String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.communityIcon !== "") {
      obj.communityIcon = message.communityIcon;
    }
    if (message.iconUrl !== "") {
      obj.iconUrl = message.iconUrl;
    }
    if (message.isNsfw !== false) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.isSubscribed !== false) {
      obj.isSubscribed = message.isSubscribed;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.prefixedName !== "") {
      obj.prefixedName = message.prefixedName;
    }
    if (message.primaryColor !== "") {
      obj.primaryColor = message.primaryColor;
    }
    if (message.subscribers !== 0) {
      obj.subscribers = Math.round(message.subscribers);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },
  create(base) {
    return CommunityListWidget_CommunityData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommunityListWidget_CommunityData();
    message.communityIcon = object.communityIcon ?? "";
    message.iconUrl = object.iconUrl ?? "";
    message.isNsfw = object.isNsfw ?? false;
    message.isSubscribed = object.isSubscribed ?? false;
    message.name = object.name ?? "";
    message.prefixedName = object.prefixedName ?? "";
    message.primaryColor = object.primaryColor ?? "";
    message.subscribers = object.subscribers ?? 0;
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set(CommunityListWidget_CommunityData.$type, CommunityListWidget_CommunityData);
function createBaseAddCommunityListWidgetRequest() {
  return { subreddit: "", shortName: "", data: [], styles: void 0 };
}
var AddCommunityListWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    for (const v of message.data) {
      writer.uint32(26).string(v);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddCommunityListWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.data.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => globalThis.String(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.data?.length) {
      obj.data = message.data;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddCommunityListWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddCommunityListWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => e) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddCommunityListWidgetRequest.$type, AddCommunityListWidgetRequest);
function createBaseUpdateCommunityListWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", data: [], styles: void 0 };
}
var UpdateCommunityListWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    for (const v of message.data) {
      writer.uint32(34).string(v);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCommunityListWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.data.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => globalThis.String(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.data?.length) {
      obj.data = message.data;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateCommunityListWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCommunityListWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => e) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCommunityListWidgetRequest.$type, UpdateCommunityListWidgetRequest);
function createBaseUpdateCommunityListWidgetResponse() {
  return { kind: "", shortName: "", data: [], styles: void 0 };
}
var UpdateCommunityListWidgetResponse = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    for (const v of message.data) {
      writer.uint32(26).string(v);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCommunityListWidgetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.data.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => globalThis.String(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.data?.length) {
      obj.data = message.data;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateCommunityListWidgetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCommunityListWidgetResponse();
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => e) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCommunityListWidgetResponse.$type, UpdateCommunityListWidgetResponse);
function createBasePostFlairWidget() {
  return { id: "", kind: "", display: "", order: [], shortName: "", styles: void 0, subreddit: void 0 };
}
var PostFlairWidget = {
  $type: "devvit.plugin.redditapi.widgets.PostFlairWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.display !== "") {
      writer.uint32(26).string(message.display);
    }
    for (const v of message.order) {
      writer.uint32(34).string(v);
    }
    if (message.shortName !== "") {
      writer.uint32(42).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostFlairWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.display = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.order.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      display: isSet120(object.display) ? globalThis.String(object.display) : "",
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : [],
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0,
      subreddit: isSet120(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.display !== "") {
      obj.display = message.display;
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return PostFlairWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostFlairWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.display = object.display ?? "";
    message.order = object.order?.map((e) => e) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(PostFlairWidget.$type, PostFlairWidget);
function createBaseAddPostFlairWidgetRequest() {
  return { subreddit: "", display: "", order: [], shortName: "", styles: void 0 };
}
var AddPostFlairWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.display !== "") {
      writer.uint32(18).string(message.display);
    }
    for (const v of message.order) {
      writer.uint32(26).string(v);
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddPostFlairWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.display = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.order.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      display: isSet120(object.display) ? globalThis.String(object.display) : "",
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : [],
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.display !== "") {
      obj.display = message.display;
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddPostFlairWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddPostFlairWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.display = object.display ?? "";
    message.order = object.order?.map((e) => e) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddPostFlairWidgetRequest.$type, AddPostFlairWidgetRequest);
function createBaseUpdatePostFlairWidgetRequest() {
  return { subreddit: "", id: "", display: "", order: [], shortName: "", styles: void 0 };
}
var UpdatePostFlairWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.display !== "") {
      writer.uint32(26).string(message.display);
    }
    for (const v of message.order) {
      writer.uint32(34).string(v);
    }
    if (message.shortName !== "") {
      writer.uint32(42).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdatePostFlairWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.display = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.order.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      display: isSet120(object.display) ? globalThis.String(object.display) : "",
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : [],
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.display !== "") {
      obj.display = message.display;
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdatePostFlairWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdatePostFlairWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.display = object.display ?? "";
    message.order = object.order?.map((e) => e) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdatePostFlairWidgetRequest.$type, UpdatePostFlairWidgetRequest);
function createBaseDeleteWidgetRequest() {
  return { id: "", subreddit: "" };
}
var DeleteWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.DeleteWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return DeleteWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteWidgetRequest();
    message.id = object.id ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(DeleteWidgetRequest.$type, DeleteWidgetRequest);
function createBaseGetWidgetsRequest() {
  return { subreddit: "", progressiveImages: void 0 };
}
var GetWidgetsRequest = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.progressiveImages !== void 0) {
      BoolValue.encode({ value: message.progressiveImages }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.progressiveImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      progressiveImages: isSet120(object.progressiveImages) ? Boolean(object.progressiveImages) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.progressiveImages !== void 0) {
      obj.progressiveImages = message.progressiveImages;
    }
    return obj;
  },
  create(base) {
    return GetWidgetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsRequest();
    message.subreddit = object.subreddit ?? "";
    message.progressiveImages = object.progressiveImages ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsRequest.$type, GetWidgetsRequest);
function createBaseGetWidgetsResponse() {
  return { layout: void 0, items: {} };
}
var GetWidgetsResponse = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.layout !== void 0) {
      GetWidgetsResponse_Layout.encode(message.layout, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.items).forEach(([key, value]) => {
      GetWidgetsResponse_ItemsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.layout = GetWidgetsResponse_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = GetWidgetsResponse_ItemsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.items[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      layout: isSet120(object.layout) ? GetWidgetsResponse_Layout.fromJSON(object.layout) : void 0,
      items: isObject28(object.items) ? Object.entries(object.items).reduce((acc, [key, value]) => {
        acc[key] = GetWidgetsResponse_WidgetItem.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.layout !== void 0) {
      obj.layout = GetWidgetsResponse_Layout.toJSON(message.layout);
    }
    if (message.items) {
      const entries = Object.entries(message.items);
      if (entries.length > 0) {
        obj.items = {};
        entries.forEach(([k, v]) => {
          obj.items[k] = GetWidgetsResponse_WidgetItem.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse();
    message.layout = object.layout !== void 0 && object.layout !== null ? GetWidgetsResponse_Layout.fromPartial(object.layout) : void 0;
    message.items = Object.entries(object.items ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = GetWidgetsResponse_WidgetItem.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse.$type, GetWidgetsResponse);
function createBaseGetWidgetsResponse_WidgetOrdering() {
  return { order: [] };
}
var GetWidgetsResponse_WidgetOrdering = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetOrdering",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    for (const v of message.order) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetOrdering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.order.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.order?.length) {
      obj.order = message.order;
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_WidgetOrdering.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetOrdering();
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_WidgetOrdering.$type, GetWidgetsResponse_WidgetOrdering);
function createBaseGetWidgetsResponse_Layout() {
  return { idCardWidget: "", topbar: void 0, sidebar: void 0, moderatorWidget: "" };
}
var GetWidgetsResponse_Layout = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.Layout",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.idCardWidget !== "") {
      writer.uint32(10).string(message.idCardWidget);
    }
    if (message.topbar !== void 0) {
      GetWidgetsResponse_WidgetOrdering.encode(message.topbar, writer.uint32(18).fork()).ldelim();
    }
    if (message.sidebar !== void 0) {
      GetWidgetsResponse_WidgetOrdering.encode(message.sidebar, writer.uint32(26).fork()).ldelim();
    }
    if (message.moderatorWidget !== "") {
      writer.uint32(34).string(message.moderatorWidget);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_Layout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.idCardWidget = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.topbar = GetWidgetsResponse_WidgetOrdering.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.sidebar = GetWidgetsResponse_WidgetOrdering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.moderatorWidget = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      idCardWidget: isSet120(object.idCardWidget) ? globalThis.String(object.idCardWidget) : "",
      topbar: isSet120(object.topbar) ? GetWidgetsResponse_WidgetOrdering.fromJSON(object.topbar) : void 0,
      sidebar: isSet120(object.sidebar) ? GetWidgetsResponse_WidgetOrdering.fromJSON(object.sidebar) : void 0,
      moderatorWidget: isSet120(object.moderatorWidget) ? globalThis.String(object.moderatorWidget) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.idCardWidget !== "") {
      obj.idCardWidget = message.idCardWidget;
    }
    if (message.topbar !== void 0) {
      obj.topbar = GetWidgetsResponse_WidgetOrdering.toJSON(message.topbar);
    }
    if (message.sidebar !== void 0) {
      obj.sidebar = GetWidgetsResponse_WidgetOrdering.toJSON(message.sidebar);
    }
    if (message.moderatorWidget !== "") {
      obj.moderatorWidget = message.moderatorWidget;
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_Layout.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_Layout();
    message.idCardWidget = object.idCardWidget ?? "";
    message.topbar = object.topbar !== void 0 && object.topbar !== null ? GetWidgetsResponse_WidgetOrdering.fromPartial(object.topbar) : void 0;
    message.sidebar = object.sidebar !== void 0 && object.sidebar !== null ? GetWidgetsResponse_WidgetOrdering.fromPartial(object.sidebar) : void 0;
    message.moderatorWidget = object.moderatorWidget ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_Layout.$type, GetWidgetsResponse_Layout);
function createBaseGetWidgetsResponse_WidgetItem() {
  return {
    id: "",
    kind: "",
    styles: void 0,
    shortName: "",
    description: void 0,
    data: [],
    buttons: [],
    subscribersCount: void 0,
    currentlyViewingText: void 0,
    currentlyViewingCount: void 0,
    subscribersText: void 0,
    showWiki: void 0,
    templates: {},
    display: void 0,
    order: [],
    mods: [],
    totalMods: void 0,
    googleCalendarId: void 0,
    requiresSync: void 0,
    configuration: void 0,
    text: void 0,
    css: void 0,
    stylesheetUrl: void 0,
    height: void 0,
    imageData: []
  };
}
var GetWidgetsResponse_WidgetItem = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(26).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.data) {
      GetWidgetsResponse_WidgetItem_Data.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.subscribersCount !== void 0) {
      Int64Value.encode({ value: message.subscribersCount }, writer.uint32(66).fork()).ldelim();
    }
    if (message.currentlyViewingText !== void 0) {
      StringValue.encode({ value: message.currentlyViewingText }, writer.uint32(74).fork()).ldelim();
    }
    if (message.currentlyViewingCount !== void 0) {
      Int64Value.encode({ value: message.currentlyViewingCount }, writer.uint32(82).fork()).ldelim();
    }
    if (message.subscribersText !== void 0) {
      StringValue.encode({ value: message.subscribersText }, writer.uint32(90).fork()).ldelim();
    }
    if (message.showWiki !== void 0) {
      BoolValue.encode({ value: message.showWiki }, writer.uint32(98).fork()).ldelim();
    }
    Object.entries(message.templates).forEach(([key, value]) => {
      GetWidgetsResponse_WidgetItem_TemplatesEntry.encode({ key, value }, writer.uint32(106).fork()).ldelim();
    });
    if (message.display !== void 0) {
      StringValue.encode({ value: message.display }, writer.uint32(114).fork()).ldelim();
    }
    for (const v of message.order) {
      writer.uint32(122).string(v);
    }
    for (const v of message.mods) {
      GetWidgetsResponse_WidgetItem_Moderator.encode(v, writer.uint32(130).fork()).ldelim();
    }
    if (message.totalMods !== void 0) {
      Int64Value.encode({ value: message.totalMods }, writer.uint32(138).fork()).ldelim();
    }
    if (message.googleCalendarId !== void 0) {
      StringValue.encode({ value: message.googleCalendarId }, writer.uint32(146).fork()).ldelim();
    }
    if (message.requiresSync !== void 0) {
      BoolValue.encode({ value: message.requiresSync }, writer.uint32(154).fork()).ldelim();
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(162).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(170).fork()).ldelim();
    }
    if (message.css !== void 0) {
      StringValue.encode({ value: message.css }, writer.uint32(178).fork()).ldelim();
    }
    if (message.stylesheetUrl !== void 0) {
      StringValue.encode({ value: message.stylesheetUrl }, writer.uint32(186).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int64Value.encode({ value: message.height }, writer.uint32(194).fork()).ldelim();
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.data.push(GetWidgetsResponse_WidgetItem_Data.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.subscribersCount = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.currentlyViewingText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.currentlyViewingCount = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.subscribersText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.showWiki = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          const entry13 = GetWidgetsResponse_WidgetItem_TemplatesEntry.decode(reader, reader.uint32());
          if (entry13.value !== void 0) {
            message.templates[entry13.key] = entry13.value;
          }
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.display = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.order.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.mods.push(GetWidgetsResponse_WidgetItem_Moderator.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.totalMods = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.googleCalendarId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.requiresSync = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.css = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.stylesheetUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.height = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0,
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      description: isSet120(object.description) ? String(object.description) : void 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => GetWidgetsResponse_WidgetItem_Data.fromJSON(e)) : [],
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      subscribersCount: isSet120(object.subscribersCount) ? Number(object.subscribersCount) : void 0,
      currentlyViewingText: isSet120(object.currentlyViewingText) ? String(object.currentlyViewingText) : void 0,
      currentlyViewingCount: isSet120(object.currentlyViewingCount) ? Number(object.currentlyViewingCount) : void 0,
      subscribersText: isSet120(object.subscribersText) ? String(object.subscribersText) : void 0,
      showWiki: isSet120(object.showWiki) ? Boolean(object.showWiki) : void 0,
      templates: isObject28(object.templates) ? Object.entries(object.templates).reduce((acc, [key, value]) => {
        acc[key] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromJSON(value);
        return acc;
      }, {}) : {},
      display: isSet120(object.display) ? String(object.display) : void 0,
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : [],
      mods: globalThis.Array.isArray(object?.mods) ? object.mods.map((e) => GetWidgetsResponse_WidgetItem_Moderator.fromJSON(e)) : [],
      totalMods: isSet120(object.totalMods) ? Number(object.totalMods) : void 0,
      googleCalendarId: isSet120(object.googleCalendarId) ? String(object.googleCalendarId) : void 0,
      requiresSync: isSet120(object.requiresSync) ? Boolean(object.requiresSync) : void 0,
      configuration: isSet120(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      text: isSet120(object.text) ? String(object.text) : void 0,
      css: isSet120(object.css) ? String(object.css) : void 0,
      stylesheetUrl: isSet120(object.stylesheetUrl) ? String(object.stylesheetUrl) : void 0,
      height: isSet120(object.height) ? Number(object.height) : void 0,
      imageData: globalThis.Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => GetWidgetsResponse_WidgetItem_Data.toJSON(e));
    }
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => WidgetButton.toJSON(e));
    }
    if (message.subscribersCount !== void 0) {
      obj.subscribersCount = message.subscribersCount;
    }
    if (message.currentlyViewingText !== void 0) {
      obj.currentlyViewingText = message.currentlyViewingText;
    }
    if (message.currentlyViewingCount !== void 0) {
      obj.currentlyViewingCount = message.currentlyViewingCount;
    }
    if (message.subscribersText !== void 0) {
      obj.subscribersText = message.subscribersText;
    }
    if (message.showWiki !== void 0) {
      obj.showWiki = message.showWiki;
    }
    if (message.templates) {
      const entries = Object.entries(message.templates);
      if (entries.length > 0) {
        obj.templates = {};
        entries.forEach(([k, v]) => {
          obj.templates[k] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.toJSON(v);
        });
      }
    }
    if (message.display !== void 0) {
      obj.display = message.display;
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    if (message.mods?.length) {
      obj.mods = message.mods.map((e) => GetWidgetsResponse_WidgetItem_Moderator.toJSON(e));
    }
    if (message.totalMods !== void 0) {
      obj.totalMods = message.totalMods;
    }
    if (message.googleCalendarId !== void 0) {
      obj.googleCalendarId = message.googleCalendarId;
    }
    if (message.requiresSync !== void 0) {
      obj.requiresSync = message.requiresSync;
    }
    if (message.configuration !== void 0) {
      obj.configuration = CalendarWidgetConfiguration.toJSON(message.configuration);
    }
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.css !== void 0) {
      obj.css = message.css;
    }
    if (message.stylesheetUrl !== void 0) {
      obj.stylesheetUrl = message.stylesheetUrl;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.imageData?.length) {
      obj.imageData = message.imageData.map((e) => WidgetImage.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_WidgetItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? void 0;
    message.data = object.data?.map((e) => GetWidgetsResponse_WidgetItem_Data.fromPartial(e)) || [];
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.subscribersCount = object.subscribersCount ?? void 0;
    message.currentlyViewingText = object.currentlyViewingText ?? void 0;
    message.currentlyViewingCount = object.currentlyViewingCount ?? void 0;
    message.subscribersText = object.subscribersText ?? void 0;
    message.showWiki = object.showWiki ?? void 0;
    message.templates = Object.entries(object.templates ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(value);
      }
      return acc;
    }, {});
    message.display = object.display ?? void 0;
    message.order = object.order?.map((e) => e) || [];
    message.mods = object.mods?.map((e) => GetWidgetsResponse_WidgetItem_Moderator.fromPartial(e)) || [];
    message.totalMods = object.totalMods ?? void 0;
    message.googleCalendarId = object.googleCalendarId ?? void 0;
    message.requiresSync = object.requiresSync ?? void 0;
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.text = object.text ?? void 0;
    message.css = object.css ?? void 0;
    message.stylesheetUrl = object.stylesheetUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_WidgetItem.$type, GetWidgetsResponse_WidgetItem);
function createBaseGetWidgetsResponse_WidgetItem_Data() {
  return {
    url: void 0,
    linkUrl: void 0,
    height: void 0,
    width: void 0,
    iconUrl: void 0,
    name: void 0,
    prefixedName: void 0,
    isSubscribed: void 0,
    type: void 0,
    subscribers: void 0,
    communityIcon: void 0,
    isNsfw: void 0,
    text: void 0,
    children: []
  };
}
var GetWidgetsResponse_WidgetItem_Data = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Data",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
    }
    if (message.linkUrl !== void 0) {
      StringValue.encode({ value: message.linkUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(34).fork()).ldelim();
    }
    if (message.iconUrl !== void 0) {
      StringValue.encode({ value: message.iconUrl }, writer.uint32(42).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
    }
    if (message.prefixedName !== void 0) {
      StringValue.encode({ value: message.prefixedName }, writer.uint32(58).fork()).ldelim();
    }
    if (message.isSubscribed !== void 0) {
      BoolValue.encode({ value: message.isSubscribed }, writer.uint32(66).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(74).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(82).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(90).fork()).ldelim();
    }
    if (message.isNsfw !== void 0) {
      BoolValue.encode({ value: message.isNsfw }, writer.uint32(98).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.children) {
      MenuWidgetItem.encode(v, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.prefixedName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.isSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.type = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.children.push(MenuWidgetItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet120(object.url) ? String(object.url) : void 0,
      linkUrl: isSet120(object.linkUrl) ? String(object.linkUrl) : void 0,
      height: isSet120(object.height) ? Number(object.height) : void 0,
      width: isSet120(object.width) ? Number(object.width) : void 0,
      iconUrl: isSet120(object.iconUrl) ? String(object.iconUrl) : void 0,
      name: isSet120(object.name) ? String(object.name) : void 0,
      prefixedName: isSet120(object.prefixedName) ? String(object.prefixedName) : void 0,
      isSubscribed: isSet120(object.isSubscribed) ? Boolean(object.isSubscribed) : void 0,
      type: isSet120(object.type) ? String(object.type) : void 0,
      subscribers: isSet120(object.subscribers) ? Number(object.subscribers) : void 0,
      communityIcon: isSet120(object.communityIcon) ? String(object.communityIcon) : void 0,
      isNsfw: isSet120(object.isNsfw) ? Boolean(object.isNsfw) : void 0,
      text: isSet120(object.text) ? String(object.text) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => MenuWidgetItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.linkUrl !== void 0) {
      obj.linkUrl = message.linkUrl;
    }
    if (message.height !== void 0) {
      obj.height = message.height;
    }
    if (message.width !== void 0) {
      obj.width = message.width;
    }
    if (message.iconUrl !== void 0) {
      obj.iconUrl = message.iconUrl;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.prefixedName !== void 0) {
      obj.prefixedName = message.prefixedName;
    }
    if (message.isSubscribed !== void 0) {
      obj.isSubscribed = message.isSubscribed;
    }
    if (message.type !== void 0) {
      obj.type = message.type;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.isNsfw !== void 0) {
      obj.isNsfw = message.isNsfw;
    }
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => MenuWidgetItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_WidgetItem_Data.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_Data();
    message.url = object.url ?? void 0;
    message.linkUrl = object.linkUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    message.iconUrl = object.iconUrl ?? void 0;
    message.name = object.name ?? void 0;
    message.prefixedName = object.prefixedName ?? void 0;
    message.isSubscribed = object.isSubscribed ?? void 0;
    message.type = object.type ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.isNsfw = object.isNsfw ?? void 0;
    message.text = object.text ?? void 0;
    message.children = object.children?.map((e) => MenuWidgetItem.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_WidgetItem_Data.$type, GetWidgetsResponse_WidgetItem_Data);
function createBaseGetWidgetsResponse_WidgetItem_Moderator() {
  return {
    name: "",
    authorFlairType: "",
    authorFlairTextColor: "",
    authorFlairBackgroundColor: "",
    authorFalirText: "",
    authorFlairRichtext: []
  };
}
var GetWidgetsResponse_WidgetItem_Moderator = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Moderator",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorFlairType !== "") {
      writer.uint32(18).string(message.authorFlairType);
    }
    if (message.authorFlairTextColor !== "") {
      writer.uint32(26).string(message.authorFlairTextColor);
    }
    if (message.authorFlairBackgroundColor !== "") {
      writer.uint32(34).string(message.authorFlairBackgroundColor);
    }
    if (message.authorFalirText !== "") {
      writer.uint32(42).string(message.authorFalirText);
    }
    for (const v of message.authorFlairRichtext) {
      AuthorFlairRichText.encode(v, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_Moderator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.authorFlairType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.authorFlairTextColor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.authorFlairBackgroundColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.authorFalirText = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet120(object.name) ? globalThis.String(object.name) : "",
      authorFlairType: isSet120(object.authorFlairType) ? globalThis.String(object.authorFlairType) : "",
      authorFlairTextColor: isSet120(object.authorFlairTextColor) ? globalThis.String(object.authorFlairTextColor) : "",
      authorFlairBackgroundColor: isSet120(object.authorFlairBackgroundColor) ? globalThis.String(object.authorFlairBackgroundColor) : "",
      authorFalirText: isSet120(object.authorFalirText) ? globalThis.String(object.authorFalirText) : "",
      authorFlairRichtext: globalThis.Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorFlairType !== "") {
      obj.authorFlairType = message.authorFlairType;
    }
    if (message.authorFlairTextColor !== "") {
      obj.authorFlairTextColor = message.authorFlairTextColor;
    }
    if (message.authorFlairBackgroundColor !== "") {
      obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor;
    }
    if (message.authorFalirText !== "") {
      obj.authorFalirText = message.authorFalirText;
    }
    if (message.authorFlairRichtext?.length) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => AuthorFlairRichText.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_WidgetItem_Moderator.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_Moderator();
    message.name = object.name ?? "";
    message.authorFlairType = object.authorFlairType ?? "";
    message.authorFlairTextColor = object.authorFlairTextColor ?? "";
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? "";
    message.authorFalirText = object.authorFalirText ?? "";
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_WidgetItem_Moderator.$type, GetWidgetsResponse_WidgetItem_Moderator);
function createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate() {
  return { text: "", richtext: [], backgroundColor: "", templateId: "", textColor: "", type: "" };
}
var GetWidgetsResponse_WidgetItem_PostFlairTemplate = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.PostFlairTemplate",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.richtext) {
      AuthorFlairRichText.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.backgroundColor !== "") {
      writer.uint32(26).string(message.backgroundColor);
    }
    if (message.templateId !== "") {
      writer.uint32(34).string(message.templateId);
    }
    if (message.textColor !== "") {
      writer.uint32(42).string(message.textColor);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.richtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.backgroundColor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.templateId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.textColor = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      richtext: globalThis.Array.isArray(object?.richtext) ? object.richtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
      backgroundColor: isSet120(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
      templateId: isSet120(object.templateId) ? globalThis.String(object.templateId) : "",
      textColor: isSet120(object.textColor) ? globalThis.String(object.textColor) : "",
      type: isSet120(object.type) ? globalThis.String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.richtext?.length) {
      obj.richtext = message.richtext.map((e) => AuthorFlairRichText.toJSON(e));
    }
    if (message.backgroundColor !== "") {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.templateId !== "") {
      obj.templateId = message.templateId;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate();
    message.text = object.text ?? "";
    message.richtext = object.richtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    message.backgroundColor = object.backgroundColor ?? "";
    message.templateId = object.templateId ?? "";
    message.textColor = object.textColor ?? "";
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_WidgetItem_PostFlairTemplate.$type, GetWidgetsResponse_WidgetItem_PostFlairTemplate);
function createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry() {
  return { key: "", value: void 0 };
}
var GetWidgetsResponse_WidgetItem_TemplatesEntry = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.TemplatesEntry",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      GetWidgetsResponse_WidgetItem_PostFlairTemplate.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = GetWidgetsResponse_WidgetItem_PostFlairTemplate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet120(object.key) ? globalThis.String(object.key) : "",
      value: isSet120(object.value) ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = GetWidgetsResponse_WidgetItem_PostFlairTemplate.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_WidgetItem_TemplatesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_WidgetItem_TemplatesEntry.$type, GetWidgetsResponse_WidgetItem_TemplatesEntry);
function createBaseGetWidgetsResponse_ItemsEntry() {
  return { key: "", value: void 0 };
}
var GetWidgetsResponse_ItemsEntry = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.ItemsEntry",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      GetWidgetsResponse_WidgetItem.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_ItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = GetWidgetsResponse_WidgetItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet120(object.key) ? globalThis.String(object.key) : "",
      value: isSet120(object.value) ? GetWidgetsResponse_WidgetItem.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = GetWidgetsResponse_WidgetItem.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetWidgetsResponse_ItemsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_ItemsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? GetWidgetsResponse_WidgetItem.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetWidgetsResponse_ItemsEntry.$type, GetWidgetsResponse_ItemsEntry);
function createBaseMenuWidgetItem() {
  return { text: void 0, url: void 0, children: [] };
}
var MenuWidgetItem = {
  $type: "devvit.plugin.redditapi.widgets.MenuWidgetItem",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      MenuWidgetItem.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMenuWidgetItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.children.push(MenuWidgetItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet120(object.text) ? String(object.text) : void 0,
      url: isSet120(object.url) ? String(object.url) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => MenuWidgetItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => MenuWidgetItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MenuWidgetItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMenuWidgetItem();
    message.text = object.text ?? void 0;
    message.url = object.url ?? void 0;
    message.children = object.children?.map((e) => MenuWidgetItem.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(MenuWidgetItem.$type, MenuWidgetItem);
function createBaseOrderWidgetsRequest() {
  return { subreddit: "", order: [] };
}
var OrderWidgetsRequest = {
  $type: "devvit.plugin.redditapi.widgets.OrderWidgetsRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    for (const v of message.order) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOrderWidgetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.order.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    return obj;
  },
  create(base) {
    return OrderWidgetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOrderWidgetsRequest();
    message.subreddit = object.subreddit ?? "";
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(OrderWidgetsRequest.$type, OrderWidgetsRequest);
function createBaseGetWidgetImageUploadLeaseRequest() {
  return { subreddit: "", filepath: "", mimetype: "" };
}
var GetWidgetImageUploadLeaseRequest = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.filepath !== "") {
      writer.uint32(18).string(message.filepath);
    }
    if (message.mimetype !== "") {
      writer.uint32(26).string(message.mimetype);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.filepath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.mimetype = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      filepath: isSet120(object.filepath) ? globalThis.String(object.filepath) : "",
      mimetype: isSet120(object.mimetype) ? globalThis.String(object.mimetype) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.mimetype !== "") {
      obj.mimetype = message.mimetype;
    }
    return obj;
  },
  create(base) {
    return GetWidgetImageUploadLeaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseRequest();
    message.subreddit = object.subreddit ?? "";
    message.filepath = object.filepath ?? "";
    message.mimetype = object.mimetype ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWidgetImageUploadLeaseRequest.$type, GetWidgetImageUploadLeaseRequest);
function createBaseGetWidgetImageUploadLeaseResponse() {
  return { s3UploadLease: void 0, websocketUrl: "" };
}
var GetWidgetImageUploadLeaseResponse = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.s3UploadLease !== void 0) {
      GetWidgetImageUploadLeaseResponse_S3UploadLease.encode(message.s3UploadLease, writer.uint32(10).fork()).ldelim();
    }
    if (message.websocketUrl !== "") {
      writer.uint32(18).string(message.websocketUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.s3UploadLease = GetWidgetImageUploadLeaseResponse_S3UploadLease.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.websocketUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      s3UploadLease: isSet120(object.s3UploadLease) ? GetWidgetImageUploadLeaseResponse_S3UploadLease.fromJSON(object.s3UploadLease) : void 0,
      websocketUrl: isSet120(object.websocketUrl) ? globalThis.String(object.websocketUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.s3UploadLease !== void 0) {
      obj.s3UploadLease = GetWidgetImageUploadLeaseResponse_S3UploadLease.toJSON(message.s3UploadLease);
    }
    if (message.websocketUrl !== "") {
      obj.websocketUrl = message.websocketUrl;
    }
    return obj;
  },
  create(base) {
    return GetWidgetImageUploadLeaseResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseResponse();
    message.s3UploadLease = object.s3UploadLease !== void 0 && object.s3UploadLease !== null ? GetWidgetImageUploadLeaseResponse_S3UploadLease.fromPartial(object.s3UploadLease) : void 0;
    message.websocketUrl = object.websocketUrl ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWidgetImageUploadLeaseResponse.$type, GetWidgetImageUploadLeaseResponse);
function createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease() {
  return { action: "", fields: [] };
}
var GetWidgetImageUploadLeaseResponse_S3UploadLease = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    for (const v of message.fields) {
      GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fields.push(GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet120(object.action) ? globalThis.String(object.action) : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetWidgetImageUploadLeaseResponse_S3UploadLease.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease();
    message.action = object.action ?? "";
    message.fields = object.fields?.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(GetWidgetImageUploadLeaseResponse_S3UploadLease.$type, GetWidgetImageUploadLeaseResponse_S3UploadLease);
function createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair() {
  return { name: "", value: "" };
}
var GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease.NameValuePair",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet120(object.name) ? globalThis.String(object.name) : "",
      value: isSet120(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.$type, GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair);
function createBaseCustomWidget() {
  return { id: "", kind: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: void 0 };
}
var CustomWidget = {
  $type: "devvit.plugin.redditapi.widgets.CustomWidget",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.height !== 0) {
      writer.uint32(48).int32(message.height);
    }
    if (message.css !== "") {
      writer.uint32(58).string(message.css);
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.text = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.css = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      kind: isSet120(object.kind) ? globalThis.String(object.kind) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      height: isSet120(object.height) ? globalThis.Number(object.height) : 0,
      css: isSet120(object.css) ? globalThis.String(object.css) : "",
      imageData: globalThis.Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.css !== "") {
      obj.css = message.css;
    }
    if (message.imageData?.length) {
      obj.imageData = message.imageData.map((e) => WidgetImage.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return CustomWidget.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.height = object.height ?? 0;
    message.css = object.css ?? "";
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CustomWidget.$type, CustomWidget);
function createBaseAddCustomWidgetRequest() {
  return { subreddit: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: void 0 };
}
var AddCustomWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddCustomWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.css !== "") {
      writer.uint32(42).string(message.css);
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(50).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddCustomWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.css = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      height: isSet120(object.height) ? globalThis.Number(object.height) : 0,
      css: isSet120(object.css) ? globalThis.String(object.css) : "",
      imageData: globalThis.Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.css !== "") {
      obj.css = message.css;
    }
    if (message.imageData?.length) {
      obj.imageData = message.imageData.map((e) => WidgetImage.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return AddCustomWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAddCustomWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.height = object.height ?? 0;
    message.css = object.css ?? "";
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AddCustomWidgetRequest.$type, AddCustomWidgetRequest);
function createBaseUpdateCustomWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: void 0 };
}
var UpdateCustomWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest",
  encode(message, writer = import_minimal131.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.css !== "") {
      writer.uint32(50).string(message.css);
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal131.default.Reader ? input : import_minimal131.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustomWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.height = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.css = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet120(object.subreddit) ? globalThis.String(object.subreddit) : "",
      id: isSet120(object.id) ? globalThis.String(object.id) : "",
      shortName: isSet120(object.shortName) ? globalThis.String(object.shortName) : "",
      text: isSet120(object.text) ? globalThis.String(object.text) : "",
      height: isSet120(object.height) ? globalThis.Number(object.height) : 0,
      css: isSet120(object.css) ? globalThis.String(object.css) : "",
      imageData: globalThis.Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
      styles: isSet120(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.css !== "") {
      obj.css = message.css;
    }
    if (message.imageData?.length) {
      obj.imageData = message.imageData.map((e) => WidgetImage.toJSON(e));
    }
    if (message.styles !== void 0) {
      obj.styles = WidgetStyles.toJSON(message.styles);
    }
    return obj;
  },
  create(base) {
    return UpdateCustomWidgetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCustomWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.height = object.height ?? 0;
    message.css = object.css ?? "";
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCustomWidgetRequest.$type, UpdateCustomWidgetRequest);
function isObject28(value) {
  return typeof value === "object" && value !== null;
}
function isSet120(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/users/users_svc.js
var import_minimal134 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/users/users_msg.js
var import_minimal133 = __toESM(require_minimal2(), 1);
function createBaseGenericUsersRequest() {
  return { id: void 0, username: "" };
}
var GenericUsersRequest = {
  $type: "devvit.plugin.redditapi.users.GenericUsersRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet121(object.id) ? String(object.id) : void 0,
      username: isSet121(object.username) ? globalThis.String(object.username) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },
  create(base) {
    return GenericUsersRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGenericUsersRequest();
    message.id = object.id ?? void 0;
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set(GenericUsersRequest.$type, GenericUsersRequest);
function createBaseBlockUserRequest() {
  return { accountId: void 0, name: void 0 };
}
var BlockUserRequest = {
  $type: "devvit.plugin.redditapi.users.BlockUserRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.accountId !== void 0) {
      StringValue.encode({ value: message.accountId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.accountId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      accountId: isSet121(object.accountId) ? String(object.accountId) : void 0,
      name: isSet121(object.name) ? String(object.name) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.accountId !== void 0) {
      obj.accountId = message.accountId;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return BlockUserRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockUserRequest();
    message.accountId = object.accountId ?? void 0;
    message.name = object.name ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockUserRequest.$type, BlockUserRequest);
function createBaseFriendRequest() {
  return {
    banContext: void 0,
    banMessage: void 0,
    banReason: void 0,
    duration: void 0,
    name: "",
    note: void 0,
    permissions: void 0,
    type: "",
    subreddit: void 0
  };
}
var FriendRequest = {
  $type: "devvit.plugin.redditapi.users.FriendRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.banContext !== void 0) {
      StringValue.encode({ value: message.banContext }, writer.uint32(10).fork()).ldelim();
    }
    if (message.banMessage !== void 0) {
      StringValue.encode({ value: message.banMessage }, writer.uint32(18).fork()).ldelim();
    }
    if (message.banReason !== void 0) {
      StringValue.encode({ value: message.banReason }, writer.uint32(26).fork()).ldelim();
    }
    if (message.duration !== void 0) {
      Int32Value.encode({ value: message.duration }, writer.uint32(34).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.note !== void 0) {
      StringValue.encode({ value: message.note }, writer.uint32(50).fork()).ldelim();
    }
    if (message.permissions !== void 0) {
      StringValue.encode({ value: message.permissions }, writer.uint32(58).fork()).ldelim();
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.banContext = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.banMessage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.banReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.duration = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.note = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.permissions = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.type = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      banContext: isSet121(object.banContext) ? String(object.banContext) : void 0,
      banMessage: isSet121(object.banMessage) ? String(object.banMessage) : void 0,
      banReason: isSet121(object.banReason) ? String(object.banReason) : void 0,
      duration: isSet121(object.duration) ? Number(object.duration) : void 0,
      name: isSet121(object.name) ? globalThis.String(object.name) : "",
      note: isSet121(object.note) ? String(object.note) : void 0,
      permissions: isSet121(object.permissions) ? String(object.permissions) : void 0,
      type: isSet121(object.type) ? globalThis.String(object.type) : "",
      subreddit: isSet121(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.banContext !== void 0) {
      obj.banContext = message.banContext;
    }
    if (message.banMessage !== void 0) {
      obj.banMessage = message.banMessage;
    }
    if (message.banReason !== void 0) {
      obj.banReason = message.banReason;
    }
    if (message.duration !== void 0) {
      obj.duration = message.duration;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.note !== void 0) {
      obj.note = message.note;
    }
    if (message.permissions !== void 0) {
      obj.permissions = message.permissions;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return FriendRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFriendRequest();
    message.banContext = object.banContext ?? void 0;
    message.banMessage = object.banMessage ?? void 0;
    message.banReason = object.banReason ?? void 0;
    message.duration = object.duration ?? void 0;
    message.name = object.name ?? "";
    message.note = object.note ?? void 0;
    message.permissions = object.permissions ?? void 0;
    message.type = object.type ?? "";
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FriendRequest.$type, FriendRequest);
function createBaseReportUserRequest() {
  return { details: "", reason: "", user: "" };
}
var ReportUserRequest = {
  $type: "devvit.plugin.redditapi.users.ReportUserRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.details !== "") {
      writer.uint32(10).string(message.details);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReportUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.details = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reason = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      details: isSet121(object.details) ? globalThis.String(object.details) : "",
      reason: isSet121(object.reason) ? globalThis.String(object.reason) : "",
      user: isSet121(object.user) ? globalThis.String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },
  create(base) {
    return ReportUserRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReportUserRequest();
    message.details = object.details ?? "";
    message.reason = object.reason ?? "";
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set(ReportUserRequest.$type, ReportUserRequest);
function createBaseSetPermissionsRequest() {
  return { name: "", subreddit: "", permissions: "", type: "" };
}
var SetPermissionsRequest = {
  $type: "devvit.plugin.redditapi.users.SetPermissionsRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    if (message.permissions !== "") {
      writer.uint32(26).string(message.permissions);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.permissions = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet121(object.name) ? globalThis.String(object.name) : "",
      subreddit: isSet121(object.subreddit) ? globalThis.String(object.subreddit) : "",
      permissions: isSet121(object.permissions) ? globalThis.String(object.permissions) : "",
      type: isSet121(object.type) ? globalThis.String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.permissions !== "") {
      obj.permissions = message.permissions;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },
  create(base) {
    return SetPermissionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetPermissionsRequest();
    message.name = object.name ?? "";
    message.subreddit = object.subreddit ?? "";
    message.permissions = object.permissions ?? "";
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set(SetPermissionsRequest.$type, SetPermissionsRequest);
function createBaseUnfriendRequest() {
  return { id: void 0, name: void 0, type: "", subreddit: void 0 };
}
var UnfriendRequest = {
  $type: "devvit.plugin.redditapi.users.UnfriendRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnfriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet121(object.id) ? String(object.id) : void 0,
      name: isSet121(object.name) ? String(object.name) : void 0,
      type: isSet121(object.type) ? globalThis.String(object.type) : "",
      subreddit: isSet121(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return UnfriendRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUnfriendRequest();
    message.id = object.id ?? void 0;
    message.name = object.name ?? void 0;
    message.type = object.type ?? "";
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UnfriendRequest.$type, UnfriendRequest);
function createBaseUserDataByAccountIdsRequest() {
  return { ids: "" };
}
var UserDataByAccountIdsRequest = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.ids !== "") {
      writer.uint32(10).string(message.ids);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.ids = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { ids: isSet121(object.ids) ? globalThis.String(object.ids) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.ids !== "") {
      obj.ids = message.ids;
    }
    return obj;
  },
  create(base) {
    return UserDataByAccountIdsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsRequest();
    message.ids = object.ids ?? "";
    return message;
  }
};
messageTypeRegistry.set(UserDataByAccountIdsRequest.$type, UserDataByAccountIdsRequest);
function createBaseUsernameAvailableRequest() {
  return { user: "" };
}
var UsernameAvailableRequest = {
  $type: "devvit.plugin.redditapi.users.UsernameAvailableRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsernameAvailableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { user: isSet121(object.user) ? globalThis.String(object.user) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },
  create(base) {
    return UsernameAvailableRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUsernameAvailableRequest();
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set(UsernameAvailableRequest.$type, UsernameAvailableRequest);
function createBaseUpdateFriendRelationshipRequest() {
  return { name: "", note: "" };
}
var UpdateFriendRelationshipRequest = {
  $type: "devvit.plugin.redditapi.users.UpdateFriendRelationshipRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.note !== "") {
      writer.uint32(18).string(message.note);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateFriendRelationshipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.note = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet121(object.name) ? globalThis.String(object.name) : "",
      note: isSet121(object.note) ? globalThis.String(object.note) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    return obj;
  },
  create(base) {
    return UpdateFriendRelationshipRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateFriendRelationshipRequest();
    message.name = object.name ?? "";
    message.note = object.note ?? "";
    return message;
  }
};
messageTypeRegistry.set(UpdateFriendRelationshipRequest.$type, UpdateFriendRelationshipRequest);
function createBaseUserAboutRequest() {
  return { username: "" };
}
var UserAboutRequest = {
  $type: "devvit.plugin.redditapi.users.UserAboutRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserAboutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { username: isSet121(object.username) ? globalThis.String(object.username) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },
  create(base) {
    return UserAboutRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserAboutRequest();
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set(UserAboutRequest.$type, UserAboutRequest);
function createBaseUserWhereRequest() {
  return {
    context: void 0,
    show: void 0,
    sort: void 0,
    t: void 0,
    type: void 0,
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    username: void 0,
    where: ""
  };
}
var UserWhereRequest = {
  $type: "devvit.plugin.redditapi.users.UserWhereRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.context !== void 0) {
      Int32Value.encode({ value: message.context }, writer.uint32(10).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(18).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(26).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(34).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(42).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(50).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(58).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(66).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int32Value.encode({ value: message.limit }, writer.uint32(74).fork()).ldelim();
    }
    if (message.username !== void 0) {
      StringValue.encode({ value: message.username }, writer.uint32(90).fork()).ldelim();
    }
    if (message.where !== "") {
      writer.uint32(98).string(message.where);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.context = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.t = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.type = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.username = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.where = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      context: isSet121(object.context) ? Number(object.context) : void 0,
      show: isSet121(object.show) ? String(object.show) : void 0,
      sort: isSet121(object.sort) ? String(object.sort) : void 0,
      t: isSet121(object.t) ? String(object.t) : void 0,
      type: isSet121(object.type) ? String(object.type) : void 0,
      after: isSet121(object.after) ? String(object.after) : void 0,
      before: isSet121(object.before) ? String(object.before) : void 0,
      count: isSet121(object.count) ? Number(object.count) : void 0,
      limit: isSet121(object.limit) ? Number(object.limit) : void 0,
      username: isSet121(object.username) ? String(object.username) : void 0,
      where: isSet121(object.where) ? globalThis.String(object.where) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.context !== void 0) {
      obj.context = message.context;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.t !== void 0) {
      obj.t = message.t;
    }
    if (message.type !== void 0) {
      obj.type = message.type;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.username !== void 0) {
      obj.username = message.username;
    }
    if (message.where !== "") {
      obj.where = message.where;
    }
    return obj;
  },
  create(base) {
    return UserWhereRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserWhereRequest();
    message.context = object.context ?? void 0;
    message.show = object.show ?? void 0;
    message.sort = object.sort ?? void 0;
    message.t = object.t ?? void 0;
    message.type = object.type ?? void 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.username = object.username ?? void 0;
    message.where = object.where ?? "";
    return message;
  }
};
messageTypeRegistry.set(UserWhereRequest.$type, UserWhereRequest);
function createBaseGeneralFriendResponse() {
  return {
    date: void 0,
    relId: void 0,
    name: void 0,
    id: void 0,
    fields: [],
    explanation: void 0,
    message: void 0,
    reason: void 0
  };
}
var GeneralFriendResponse = {
  $type: "devvit.plugin.redditapi.users.GeneralFriendResponse",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.date !== void 0) {
      Int64Value.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.relId !== void 0) {
      StringValue.encode({ value: message.relId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.explanation !== void 0) {
      StringValue.encode({ value: message.explanation }, writer.uint32(50).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneralFriendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.date = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.relId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.explanation = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet121(object.date) ? Number(object.date) : void 0,
      relId: isSet121(object.relId) ? String(object.relId) : void 0,
      name: isSet121(object.name) ? String(object.name) : void 0,
      id: isSet121(object.id) ? String(object.id) : void 0,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      explanation: isSet121(object.explanation) ? String(object.explanation) : void 0,
      message: isSet121(object.message) ? String(object.message) : void 0,
      reason: isSet121(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.relId !== void 0) {
      obj.relId = message.relId;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.explanation !== void 0) {
      obj.explanation = message.explanation;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return GeneralFriendResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGeneralFriendResponse();
    message.date = object.date ?? void 0;
    message.relId = object.relId ?? void 0;
    message.name = object.name ?? void 0;
    message.id = object.id ?? void 0;
    message.fields = object.fields?.map((e) => e) || [];
    message.explanation = object.explanation ?? void 0;
    message.message = object.message ?? void 0;
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GeneralFriendResponse.$type, GeneralFriendResponse);
function createBaseBlockUserResponse() {
  return { date: void 0, iconImg: void 0, id: void 0, name: void 0 };
}
var BlockUserResponse = {
  $type: "devvit.plugin.redditapi.users.BlockUserResponse",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.date !== void 0) {
      Int64Value.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.date = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet121(object.date) ? Number(object.date) : void 0,
      iconImg: isSet121(object.iconImg) ? String(object.iconImg) : void 0,
      id: isSet121(object.id) ? String(object.id) : void 0,
      name: isSet121(object.name) ? String(object.name) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return BlockUserResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockUserResponse();
    message.date = object.date ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.id = object.id ?? void 0;
    message.name = object.name ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BlockUserResponse.$type, BlockUserResponse);
function createBaseUserDataByAccountIdsResponse() {
  return { users: {} };
}
var UserDataByAccountIdsResponse = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    Object.entries(message.users).forEach(([key, value]) => {
      UserDataByAccountIdsResponse_UsersEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = UserDataByAccountIdsResponse_UsersEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.users[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      users: isObject29(object.users) ? Object.entries(object.users).reduce((acc, [key, value]) => {
        acc[key] = UserDataByAccountIdsResponse_UserAccountData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.users) {
      const entries = Object.entries(message.users);
      if (entries.length > 0) {
        obj.users = {};
        entries.forEach(([k, v]) => {
          obj.users[k] = UserDataByAccountIdsResponse_UserAccountData.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return UserDataByAccountIdsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsResponse();
    message.users = Object.entries(object.users ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = UserDataByAccountIdsResponse_UserAccountData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(UserDataByAccountIdsResponse.$type, UserDataByAccountIdsResponse);
function createBaseUserDataByAccountIdsResponse_UserAccountData() {
  return {
    name: void 0,
    createdUtc: void 0,
    linkKarma: void 0,
    commentKarma: void 0,
    profileImg: void 0,
    profileColor: void 0,
    profileOver18: void 0
  };
}
var UserDataByAccountIdsResponse_UserAccountData = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UserAccountData",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(18).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int64Value.encode({ value: message.linkKarma }, writer.uint32(26).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int64Value.encode({ value: message.commentKarma }, writer.uint32(34).fork()).ldelim();
    }
    if (message.profileImg !== void 0) {
      StringValue.encode({ value: message.profileImg }, writer.uint32(42).fork()).ldelim();
    }
    if (message.profileColor !== void 0) {
      StringValue.encode({ value: message.profileColor }, writer.uint32(50).fork()).ldelim();
    }
    if (message.profileOver18 !== void 0) {
      BoolValue.encode({ value: message.profileOver18 }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsResponse_UserAccountData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.linkKarma = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.profileImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.profileColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.profileOver18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet121(object.name) ? String(object.name) : void 0,
      createdUtc: isSet121(object.createdUtc) ? Number(object.createdUtc) : void 0,
      linkKarma: isSet121(object.linkKarma) ? Number(object.linkKarma) : void 0,
      commentKarma: isSet121(object.commentKarma) ? Number(object.commentKarma) : void 0,
      profileImg: isSet121(object.profileImg) ? String(object.profileImg) : void 0,
      profileColor: isSet121(object.profileColor) ? String(object.profileColor) : void 0,
      profileOver18: isSet121(object.profileOver18) ? Boolean(object.profileOver18) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.linkKarma !== void 0) {
      obj.linkKarma = message.linkKarma;
    }
    if (message.commentKarma !== void 0) {
      obj.commentKarma = message.commentKarma;
    }
    if (message.profileImg !== void 0) {
      obj.profileImg = message.profileImg;
    }
    if (message.profileColor !== void 0) {
      obj.profileColor = message.profileColor;
    }
    if (message.profileOver18 !== void 0) {
      obj.profileOver18 = message.profileOver18;
    }
    return obj;
  },
  create(base) {
    return UserDataByAccountIdsResponse_UserAccountData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsResponse_UserAccountData();
    message.name = object.name ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.profileImg = object.profileImg ?? void 0;
    message.profileColor = object.profileColor ?? void 0;
    message.profileOver18 = object.profileOver18 ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserDataByAccountIdsResponse_UserAccountData.$type, UserDataByAccountIdsResponse_UserAccountData);
function createBaseUserDataByAccountIdsResponse_UsersEntry() {
  return { key: "", value: void 0 };
}
var UserDataByAccountIdsResponse_UsersEntry = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UsersEntry",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      UserDataByAccountIdsResponse_UserAccountData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsResponse_UsersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = UserDataByAccountIdsResponse_UserAccountData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet121(object.key) ? globalThis.String(object.key) : "",
      value: isSet121(object.value) ? UserDataByAccountIdsResponse_UserAccountData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = UserDataByAccountIdsResponse_UserAccountData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return UserDataByAccountIdsResponse_UsersEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsResponse_UsersEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? UserDataByAccountIdsResponse_UserAccountData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserDataByAccountIdsResponse_UsersEntry.$type, UserDataByAccountIdsResponse_UsersEntry);
function createBaseUserTrophiesResponse() {
  return { kind: void 0, data: void 0 };
}
var UserTrophiesResponse = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserTrophiesResponse_UserTrophiesData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = UserTrophiesResponse_UserTrophiesData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet121(object.kind) ? String(object.kind) : void 0,
      data: isSet121(object.data) ? UserTrophiesResponse_UserTrophiesData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = UserTrophiesResponse_UserTrophiesData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return UserTrophiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserTrophiesResponse_UserTrophiesData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserTrophiesResponse.$type, UserTrophiesResponse);
function createBaseUserTrophiesResponse_TrophiesData() {
  return {
    icon70: void 0,
    grantedAt: void 0,
    url: void 0,
    icon40: void 0,
    name: void 0,
    awardId: void 0,
    id: void 0,
    description: void 0
  };
}
var UserTrophiesResponse_TrophiesData = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesData",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.icon70 !== void 0) {
      StringValue.encode({ value: message.icon70 }, writer.uint32(10).fork()).ldelim();
    }
    if (message.grantedAt !== void 0) {
      Int64Value.encode({ value: message.grantedAt }, writer.uint32(18).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    if (message.icon40 !== void 0) {
      StringValue.encode({ value: message.icon40 }, writer.uint32(34).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(42).fork()).ldelim();
    }
    if (message.awardId !== void 0) {
      StringValue.encode({ value: message.awardId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse_TrophiesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.icon70 = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.grantedAt = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.icon40 = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.awardId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      icon70: isSet121(object.icon70) ? String(object.icon70) : void 0,
      grantedAt: isSet121(object.grantedAt) ? Number(object.grantedAt) : void 0,
      url: isSet121(object.url) ? String(object.url) : void 0,
      icon40: isSet121(object.icon40) ? String(object.icon40) : void 0,
      name: isSet121(object.name) ? String(object.name) : void 0,
      awardId: isSet121(object.awardId) ? String(object.awardId) : void 0,
      id: isSet121(object.id) ? String(object.id) : void 0,
      description: isSet121(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.icon70 !== void 0) {
      obj.icon70 = message.icon70;
    }
    if (message.grantedAt !== void 0) {
      obj.grantedAt = message.grantedAt;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.icon40 !== void 0) {
      obj.icon40 = message.icon40;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.awardId !== void 0) {
      obj.awardId = message.awardId;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return UserTrophiesResponse_TrophiesData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse_TrophiesData();
    message.icon70 = object.icon70 ?? void 0;
    message.grantedAt = object.grantedAt ?? void 0;
    message.url = object.url ?? void 0;
    message.icon40 = object.icon40 ?? void 0;
    message.name = object.name ?? void 0;
    message.awardId = object.awardId ?? void 0;
    message.id = object.id ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserTrophiesResponse_TrophiesData.$type, UserTrophiesResponse_TrophiesData);
function createBaseUserTrophiesResponse_TrophiesType() {
  return { kind: void 0, data: void 0 };
}
var UserTrophiesResponse_TrophiesType = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesType",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserTrophiesResponse_TrophiesData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse_TrophiesType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = UserTrophiesResponse_TrophiesData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet121(object.kind) ? String(object.kind) : void 0,
      data: isSet121(object.data) ? UserTrophiesResponse_TrophiesData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = UserTrophiesResponse_TrophiesData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return UserTrophiesResponse_TrophiesType.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse_TrophiesType();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserTrophiesResponse_TrophiesData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserTrophiesResponse_TrophiesType.$type, UserTrophiesResponse_TrophiesType);
function createBaseUserTrophiesResponse_UserTrophiesData() {
  return { trophies: [] };
}
var UserTrophiesResponse_UserTrophiesData = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.UserTrophiesData",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    for (const v of message.trophies) {
      UserTrophiesResponse_TrophiesType.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse_UserTrophiesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.trophies.push(UserTrophiesResponse_TrophiesType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      trophies: globalThis.Array.isArray(object?.trophies) ? object.trophies.map((e) => UserTrophiesResponse_TrophiesType.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.trophies?.length) {
      obj.trophies = message.trophies.map((e) => UserTrophiesResponse_TrophiesType.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return UserTrophiesResponse_UserTrophiesData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse_UserTrophiesData();
    message.trophies = object.trophies?.map((e) => UserTrophiesResponse_TrophiesType.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(UserTrophiesResponse_UserTrophiesData.$type, UserTrophiesResponse_UserTrophiesData);
function createBaseUserAboutResponse() {
  return { kind: void 0, data: void 0 };
}
var UserAboutResponse = {
  $type: "devvit.plugin.redditapi.users.UserAboutResponse",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      User.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : import_minimal133.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserAboutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet121(object.kind) ? String(object.kind) : void 0,
      data: isSet121(object.data) ? User.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = User.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return UserAboutResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserAboutResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? User.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserAboutResponse.$type, UserAboutResponse);
function isObject29(value) {
  return typeof value === "object" && value !== null;
}
function isSet121(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/subreddits/subreddits_svc.js
var import_minimal136 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/subreddits/subreddits_msg.js
var import_long15 = __toESM(require_long(), 1);
var import_minimal135 = __toESM(require_minimal2(), 1);
function createBaseAboutWhereRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0,
    user: void 0,
    subreddit: void 0,
    where: ""
  };
}
var AboutWhereRequest = {
  $type: "devvit.plugin.redditapi.subreddits.AboutWhereRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(58).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(66).fork()).ldelim();
    }
    if (message.where !== "") {
      writer.uint32(74).string(message.where);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.user = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.where = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      count: isSet122(object.count) ? Number(object.count) : void 0,
      limit: isSet122(object.limit) ? Number(object.limit) : void 0,
      show: isSet122(object.show) ? String(object.show) : void 0,
      user: isSet122(object.user) ? String(object.user) : void 0,
      subreddit: isSet122(object.subreddit) ? String(object.subreddit) : void 0,
      where: isSet122(object.where) ? globalThis.String(object.where) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.user !== void 0) {
      obj.user = message.user;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.where !== "") {
      obj.where = message.where;
    }
    return obj;
  },
  create(base) {
    return AboutWhereRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutWhereRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    message.user = object.user ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.where = object.where ?? "";
    return message;
  }
};
messageTypeRegistry.set(AboutWhereRequest.$type, AboutWhereRequest);
function createBaseBasicSubredditRequest() {
  return { subreddit: "" };
}
var BasicSubredditRequest = {
  $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicSubredditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return BasicSubredditRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicSubredditRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(BasicSubredditRequest.$type, BasicSubredditRequest);
function createBaseDeleteSrImgRequest() {
  return { subreddit: "", imgName: "" };
}
var DeleteSrImgRequest = {
  $type: "devvit.plugin.redditapi.subreddits.DeleteSrImgRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.imgName !== "") {
      writer.uint32(18).string(message.imgName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteSrImgRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.imgName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : "",
      imgName: isSet122(object.imgName) ? globalThis.String(object.imgName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.imgName !== "") {
      obj.imgName = message.imgName;
    }
    return obj;
  },
  create(base) {
    return DeleteSrImgRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteSrImgRequest();
    message.subreddit = object.subreddit ?? "";
    message.imgName = object.imgName ?? "";
    return message;
  }
};
messageTypeRegistry.set(DeleteSrImgRequest.$type, DeleteSrImgRequest);
function createBaseBasicSearchRequest() {
  return {
    exact: void 0,
    includeOver18: void 0,
    includeUnadvertisable: void 0,
    query: "",
    searchQueryId: void 0,
    typeaheadActive: void 0
  };
}
var BasicSearchRequest = {
  $type: "devvit.plugin.redditapi.subreddits.BasicSearchRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.exact !== void 0) {
      BoolValue.encode({ value: message.exact }, writer.uint32(10).fork()).ldelim();
    }
    if (message.includeOver18 !== void 0) {
      BoolValue.encode({ value: message.includeOver18 }, writer.uint32(18).fork()).ldelim();
    }
    if (message.includeUnadvertisable !== void 0) {
      BoolValue.encode({ value: message.includeUnadvertisable }, writer.uint32(26).fork()).ldelim();
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.exact = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.includeOver18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.includeUnadvertisable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.query = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      exact: isSet122(object.exact) ? Boolean(object.exact) : void 0,
      includeOver18: isSet122(object.includeOver18) ? Boolean(object.includeOver18) : void 0,
      includeUnadvertisable: isSet122(object.includeUnadvertisable) ? Boolean(object.includeUnadvertisable) : void 0,
      query: isSet122(object.query) ? globalThis.String(object.query) : "",
      searchQueryId: isSet122(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      typeaheadActive: isSet122(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.exact !== void 0) {
      obj.exact = message.exact;
    }
    if (message.includeOver18 !== void 0) {
      obj.includeOver18 = message.includeOver18;
    }
    if (message.includeUnadvertisable !== void 0) {
      obj.includeUnadvertisable = message.includeUnadvertisable;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.searchQueryId !== void 0) {
      obj.searchQueryId = message.searchQueryId;
    }
    if (message.typeaheadActive !== void 0) {
      obj.typeaheadActive = message.typeaheadActive;
    }
    return obj;
  },
  create(base) {
    return BasicSearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicSearchRequest();
    message.exact = object.exact ?? void 0;
    message.includeOver18 = object.includeOver18 ?? void 0;
    message.includeUnadvertisable = object.includeUnadvertisable ?? void 0;
    message.query = object.query ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(BasicSearchRequest.$type, BasicSearchRequest);
function createBaseSiteAdminRequest() {
  return {
    acceptFollowers: false,
    adminOverrideSpamComments: false,
    adminOverrideSpamLinks: false,
    adminOverrideSpamSelfposts: false,
    allOriginalContent: false,
    allowChatPostCreation: false,
    allowDiscovery: false,
    allowGalleries: false,
    allowImages: false,
    allowPolls: false,
    allowPostCrossposts: false,
    allowPredictionContributors: false,
    allowPredictions: false,
    allowPredictionsTournament: false,
    allowTalks: false,
    allowTop: false,
    allowVideos: false,
    banEvasionThreshold: 0,
    collapseDeletedComments: false,
    commentContributionSettings: void 0,
    commentScoreHideMins: 0,
    crowdControlFilter: false,
    crowdControlLevel: 0,
    crowdControlMode: false,
    crowdControlPostLevel: 0,
    description: "",
    disableContributorRequests: false,
    excludeBannedModqueue: false,
    freeFormReports: false,
    gRecaptchaResponse: "",
    hatefulContentThresholdAbuse: 0,
    hatefulContentThresholdIdentity: 0,
    headerTitle: "",
    keyColor: "",
    linkType: "",
    name: "",
    newPinnedPostPnsEnabled: false,
    originalContentTagEnabled: false,
    over18: false,
    predictionLeaderboardEntryType: 0,
    publicDescription: "",
    restrictCommenting: false,
    restrictPosting: false,
    shouldArchivePosts: false,
    showMedia: false,
    showMediaPreview: false,
    spamComments: "",
    spamLinks: "",
    spamSelfposts: "",
    spoilersEnabled: false,
    sr: "",
    submitLinkLabel: "",
    submitText: "",
    submitTextLabel: "",
    suggestedCommentSort: "",
    title: "",
    toxicityThresholdChatLevel: 0,
    type: "",
    userFlairPnsEnabled: false,
    welcomeMessageEnabled: false,
    welcomeMessageText: "",
    wikiEditAge: 0,
    wikiEditKarma: 0,
    wikimode: "",
    crowdControlChatLevel: 0,
    hideAds: false,
    modmailHarassmentFilterEnabled: false
  };
}
var SiteAdminRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SiteAdminRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.acceptFollowers !== false) {
      writer.uint32(8).bool(message.acceptFollowers);
    }
    if (message.adminOverrideSpamComments !== false) {
      writer.uint32(16).bool(message.adminOverrideSpamComments);
    }
    if (message.adminOverrideSpamLinks !== false) {
      writer.uint32(24).bool(message.adminOverrideSpamLinks);
    }
    if (message.adminOverrideSpamSelfposts !== false) {
      writer.uint32(32).bool(message.adminOverrideSpamSelfposts);
    }
    if (message.allOriginalContent !== false) {
      writer.uint32(40).bool(message.allOriginalContent);
    }
    if (message.allowChatPostCreation !== false) {
      writer.uint32(48).bool(message.allowChatPostCreation);
    }
    if (message.allowDiscovery !== false) {
      writer.uint32(56).bool(message.allowDiscovery);
    }
    if (message.allowGalleries !== false) {
      writer.uint32(64).bool(message.allowGalleries);
    }
    if (message.allowImages !== false) {
      writer.uint32(72).bool(message.allowImages);
    }
    if (message.allowPolls !== false) {
      writer.uint32(80).bool(message.allowPolls);
    }
    if (message.allowPostCrossposts !== false) {
      writer.uint32(88).bool(message.allowPostCrossposts);
    }
    if (message.allowPredictionContributors !== false) {
      writer.uint32(96).bool(message.allowPredictionContributors);
    }
    if (message.allowPredictions !== false) {
      writer.uint32(104).bool(message.allowPredictions);
    }
    if (message.allowPredictionsTournament !== false) {
      writer.uint32(112).bool(message.allowPredictionsTournament);
    }
    if (message.allowTalks !== false) {
      writer.uint32(120).bool(message.allowTalks);
    }
    if (message.allowTop !== false) {
      writer.uint32(128).bool(message.allowTop);
    }
    if (message.allowVideos !== false) {
      writer.uint32(136).bool(message.allowVideos);
    }
    if (message.banEvasionThreshold !== 0) {
      writer.uint32(144).int64(message.banEvasionThreshold);
    }
    if (message.collapseDeletedComments !== false) {
      writer.uint32(152).bool(message.collapseDeletedComments);
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(162).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== 0) {
      writer.uint32(168).int32(message.commentScoreHideMins);
    }
    if (message.crowdControlFilter !== false) {
      writer.uint32(176).bool(message.crowdControlFilter);
    }
    if (message.crowdControlLevel !== 0) {
      writer.uint32(184).int64(message.crowdControlLevel);
    }
    if (message.crowdControlMode !== false) {
      writer.uint32(192).bool(message.crowdControlMode);
    }
    if (message.crowdControlPostLevel !== 0) {
      writer.uint32(200).int64(message.crowdControlPostLevel);
    }
    if (message.description !== "") {
      writer.uint32(210).string(message.description);
    }
    if (message.disableContributorRequests !== false) {
      writer.uint32(216).bool(message.disableContributorRequests);
    }
    if (message.excludeBannedModqueue !== false) {
      writer.uint32(224).bool(message.excludeBannedModqueue);
    }
    if (message.freeFormReports !== false) {
      writer.uint32(232).bool(message.freeFormReports);
    }
    if (message.gRecaptchaResponse !== "") {
      writer.uint32(242).string(message.gRecaptchaResponse);
    }
    if (message.hatefulContentThresholdAbuse !== 0) {
      writer.uint32(248).int64(message.hatefulContentThresholdAbuse);
    }
    if (message.hatefulContentThresholdIdentity !== 0) {
      writer.uint32(256).int64(message.hatefulContentThresholdIdentity);
    }
    if (message.headerTitle !== "") {
      writer.uint32(266).string(message.headerTitle);
    }
    if (message.keyColor !== "") {
      writer.uint32(274).string(message.keyColor);
    }
    if (message.linkType !== "") {
      writer.uint32(290).string(message.linkType);
    }
    if (message.name !== "") {
      writer.uint32(298).string(message.name);
    }
    if (message.newPinnedPostPnsEnabled !== false) {
      writer.uint32(304).bool(message.newPinnedPostPnsEnabled);
    }
    if (message.originalContentTagEnabled !== false) {
      writer.uint32(312).bool(message.originalContentTagEnabled);
    }
    if (message.over18 !== false) {
      writer.uint32(320).bool(message.over18);
    }
    if (message.predictionLeaderboardEntryType !== 0) {
      writer.uint32(328).int64(message.predictionLeaderboardEntryType);
    }
    if (message.publicDescription !== "") {
      writer.uint32(338).string(message.publicDescription);
    }
    if (message.restrictCommenting !== false) {
      writer.uint32(344).bool(message.restrictCommenting);
    }
    if (message.restrictPosting !== false) {
      writer.uint32(352).bool(message.restrictPosting);
    }
    if (message.shouldArchivePosts !== false) {
      writer.uint32(360).bool(message.shouldArchivePosts);
    }
    if (message.showMedia !== false) {
      writer.uint32(368).bool(message.showMedia);
    }
    if (message.showMediaPreview !== false) {
      writer.uint32(376).bool(message.showMediaPreview);
    }
    if (message.spamComments !== "") {
      writer.uint32(386).string(message.spamComments);
    }
    if (message.spamLinks !== "") {
      writer.uint32(394).string(message.spamLinks);
    }
    if (message.spamSelfposts !== "") {
      writer.uint32(402).string(message.spamSelfposts);
    }
    if (message.spoilersEnabled !== false) {
      writer.uint32(408).bool(message.spoilersEnabled);
    }
    if (message.sr !== "") {
      writer.uint32(418).string(message.sr);
    }
    if (message.submitLinkLabel !== "") {
      writer.uint32(426).string(message.submitLinkLabel);
    }
    if (message.submitText !== "") {
      writer.uint32(434).string(message.submitText);
    }
    if (message.submitTextLabel !== "") {
      writer.uint32(442).string(message.submitTextLabel);
    }
    if (message.suggestedCommentSort !== "") {
      writer.uint32(450).string(message.suggestedCommentSort);
    }
    if (message.title !== "") {
      writer.uint32(458).string(message.title);
    }
    if (message.toxicityThresholdChatLevel !== 0) {
      writer.uint32(464).int64(message.toxicityThresholdChatLevel);
    }
    if (message.type !== "") {
      writer.uint32(474).string(message.type);
    }
    if (message.userFlairPnsEnabled !== false) {
      writer.uint32(480).bool(message.userFlairPnsEnabled);
    }
    if (message.welcomeMessageEnabled !== false) {
      writer.uint32(488).bool(message.welcomeMessageEnabled);
    }
    if (message.welcomeMessageText !== "") {
      writer.uint32(498).string(message.welcomeMessageText);
    }
    if (message.wikiEditAge !== 0) {
      writer.uint32(504).int64(message.wikiEditAge);
    }
    if (message.wikiEditKarma !== 0) {
      writer.uint32(512).int64(message.wikiEditKarma);
    }
    if (message.wikimode !== "") {
      writer.uint32(522).string(message.wikimode);
    }
    if (message.crowdControlChatLevel !== 0) {
      writer.uint32(528).int64(message.crowdControlChatLevel);
    }
    if (message.hideAds !== false) {
      writer.uint32(536).bool(message.hideAds);
    }
    if (message.modmailHarassmentFilterEnabled !== false) {
      writer.uint32(544).bool(message.modmailHarassmentFilterEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSiteAdminRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.acceptFollowers = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.adminOverrideSpamComments = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.adminOverrideSpamLinks = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.adminOverrideSpamSelfposts = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.allOriginalContent = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.allowChatPostCreation = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.allowDiscovery = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.allowGalleries = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.allowImages = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.allowPolls = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.allowPostCrossposts = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }
          message.allowPredictionContributors = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }
          message.allowPredictions = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }
          message.allowPredictionsTournament = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }
          message.allowTalks = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }
          message.allowTop = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }
          message.allowVideos = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }
          message.banEvasionThreshold = longToNumber15(reader.int64());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }
          message.collapseDeletedComments = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }
          message.commentScoreHideMins = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }
          message.crowdControlFilter = reader.bool();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }
          message.crowdControlLevel = longToNumber15(reader.int64());
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }
          message.crowdControlMode = reader.bool();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }
          message.crowdControlPostLevel = longToNumber15(reader.int64());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.description = reader.string();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }
          message.disableContributorRequests = reader.bool();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }
          message.excludeBannedModqueue = reader.bool();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }
          message.freeFormReports = reader.bool();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.gRecaptchaResponse = reader.string();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }
          message.hatefulContentThresholdAbuse = longToNumber15(reader.int64());
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }
          message.hatefulContentThresholdIdentity = longToNumber15(reader.int64());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.headerTitle = reader.string();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.keyColor = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.name = reader.string();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }
          message.newPinnedPostPnsEnabled = reader.bool();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }
          message.originalContentTagEnabled = reader.bool();
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }
          message.over18 = reader.bool();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }
          message.predictionLeaderboardEntryType = longToNumber15(reader.int64());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.publicDescription = reader.string();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }
          message.restrictCommenting = reader.bool();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }
          message.restrictPosting = reader.bool();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }
          message.shouldArchivePosts = reader.bool();
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }
          message.showMedia = reader.bool();
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }
          message.showMediaPreview = reader.bool();
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.spamComments = reader.string();
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.spamLinks = reader.string();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.spamSelfposts = reader.string();
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }
          message.spoilersEnabled = reader.bool();
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.sr = reader.string();
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.submitLinkLabel = reader.string();
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.submitText = reader.string();
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.submitTextLabel = reader.string();
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.suggestedCommentSort = reader.string();
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.title = reader.string();
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }
          message.toxicityThresholdChatLevel = longToNumber15(reader.int64());
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.type = reader.string();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }
          message.userFlairPnsEnabled = reader.bool();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }
          message.welcomeMessageEnabled = reader.bool();
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.welcomeMessageText = reader.string();
          continue;
        case 63:
          if (tag !== 504) {
            break;
          }
          message.wikiEditAge = longToNumber15(reader.int64());
          continue;
        case 64:
          if (tag !== 512) {
            break;
          }
          message.wikiEditKarma = longToNumber15(reader.int64());
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.wikimode = reader.string();
          continue;
        case 66:
          if (tag !== 528) {
            break;
          }
          message.crowdControlChatLevel = longToNumber15(reader.int64());
          continue;
        case 67:
          if (tag !== 536) {
            break;
          }
          message.hideAds = reader.bool();
          continue;
        case 68:
          if (tag !== 544) {
            break;
          }
          message.modmailHarassmentFilterEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      acceptFollowers: isSet122(object.acceptFollowers) ? globalThis.Boolean(object.acceptFollowers) : false,
      adminOverrideSpamComments: isSet122(object.adminOverrideSpamComments) ? globalThis.Boolean(object.adminOverrideSpamComments) : false,
      adminOverrideSpamLinks: isSet122(object.adminOverrideSpamLinks) ? globalThis.Boolean(object.adminOverrideSpamLinks) : false,
      adminOverrideSpamSelfposts: isSet122(object.adminOverrideSpamSelfposts) ? globalThis.Boolean(object.adminOverrideSpamSelfposts) : false,
      allOriginalContent: isSet122(object.allOriginalContent) ? globalThis.Boolean(object.allOriginalContent) : false,
      allowChatPostCreation: isSet122(object.allowChatPostCreation) ? globalThis.Boolean(object.allowChatPostCreation) : false,
      allowDiscovery: isSet122(object.allowDiscovery) ? globalThis.Boolean(object.allowDiscovery) : false,
      allowGalleries: isSet122(object.allowGalleries) ? globalThis.Boolean(object.allowGalleries) : false,
      allowImages: isSet122(object.allowImages) ? globalThis.Boolean(object.allowImages) : false,
      allowPolls: isSet122(object.allowPolls) ? globalThis.Boolean(object.allowPolls) : false,
      allowPostCrossposts: isSet122(object.allowPostCrossposts) ? globalThis.Boolean(object.allowPostCrossposts) : false,
      allowPredictionContributors: isSet122(object.allowPredictionContributors) ? globalThis.Boolean(object.allowPredictionContributors) : false,
      allowPredictions: isSet122(object.allowPredictions) ? globalThis.Boolean(object.allowPredictions) : false,
      allowPredictionsTournament: isSet122(object.allowPredictionsTournament) ? globalThis.Boolean(object.allowPredictionsTournament) : false,
      allowTalks: isSet122(object.allowTalks) ? globalThis.Boolean(object.allowTalks) : false,
      allowTop: isSet122(object.allowTop) ? globalThis.Boolean(object.allowTop) : false,
      allowVideos: isSet122(object.allowVideos) ? globalThis.Boolean(object.allowVideos) : false,
      banEvasionThreshold: isSet122(object.banEvasionThreshold) ? globalThis.Number(object.banEvasionThreshold) : 0,
      collapseDeletedComments: isSet122(object.collapseDeletedComments) ? globalThis.Boolean(object.collapseDeletedComments) : false,
      commentContributionSettings: isSet122(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      commentScoreHideMins: isSet122(object.commentScoreHideMins) ? globalThis.Number(object.commentScoreHideMins) : 0,
      crowdControlFilter: isSet122(object.crowdControlFilter) ? globalThis.Boolean(object.crowdControlFilter) : false,
      crowdControlLevel: isSet122(object.crowdControlLevel) ? globalThis.Number(object.crowdControlLevel) : 0,
      crowdControlMode: isSet122(object.crowdControlMode) ? globalThis.Boolean(object.crowdControlMode) : false,
      crowdControlPostLevel: isSet122(object.crowdControlPostLevel) ? globalThis.Number(object.crowdControlPostLevel) : 0,
      description: isSet122(object.description) ? globalThis.String(object.description) : "",
      disableContributorRequests: isSet122(object.disableContributorRequests) ? globalThis.Boolean(object.disableContributorRequests) : false,
      excludeBannedModqueue: isSet122(object.excludeBannedModqueue) ? globalThis.Boolean(object.excludeBannedModqueue) : false,
      freeFormReports: isSet122(object.freeFormReports) ? globalThis.Boolean(object.freeFormReports) : false,
      gRecaptchaResponse: isSet122(object.gRecaptchaResponse) ? globalThis.String(object.gRecaptchaResponse) : "",
      hatefulContentThresholdAbuse: isSet122(object.hatefulContentThresholdAbuse) ? globalThis.Number(object.hatefulContentThresholdAbuse) : 0,
      hatefulContentThresholdIdentity: isSet122(object.hatefulContentThresholdIdentity) ? globalThis.Number(object.hatefulContentThresholdIdentity) : 0,
      headerTitle: isSet122(object.headerTitle) ? globalThis.String(object.headerTitle) : "",
      keyColor: isSet122(object.keyColor) ? globalThis.String(object.keyColor) : "",
      linkType: isSet122(object.linkType) ? globalThis.String(object.linkType) : "",
      name: isSet122(object.name) ? globalThis.String(object.name) : "",
      newPinnedPostPnsEnabled: isSet122(object.newPinnedPostPnsEnabled) ? globalThis.Boolean(object.newPinnedPostPnsEnabled) : false,
      originalContentTagEnabled: isSet122(object.originalContentTagEnabled) ? globalThis.Boolean(object.originalContentTagEnabled) : false,
      over18: isSet122(object.over18) ? globalThis.Boolean(object.over18) : false,
      predictionLeaderboardEntryType: isSet122(object.predictionLeaderboardEntryType) ? globalThis.Number(object.predictionLeaderboardEntryType) : 0,
      publicDescription: isSet122(object.publicDescription) ? globalThis.String(object.publicDescription) : "",
      restrictCommenting: isSet122(object.restrictCommenting) ? globalThis.Boolean(object.restrictCommenting) : false,
      restrictPosting: isSet122(object.restrictPosting) ? globalThis.Boolean(object.restrictPosting) : false,
      shouldArchivePosts: isSet122(object.shouldArchivePosts) ? globalThis.Boolean(object.shouldArchivePosts) : false,
      showMedia: isSet122(object.showMedia) ? globalThis.Boolean(object.showMedia) : false,
      showMediaPreview: isSet122(object.showMediaPreview) ? globalThis.Boolean(object.showMediaPreview) : false,
      spamComments: isSet122(object.spamComments) ? globalThis.String(object.spamComments) : "",
      spamLinks: isSet122(object.spamLinks) ? globalThis.String(object.spamLinks) : "",
      spamSelfposts: isSet122(object.spamSelfposts) ? globalThis.String(object.spamSelfposts) : "",
      spoilersEnabled: isSet122(object.spoilersEnabled) ? globalThis.Boolean(object.spoilersEnabled) : false,
      sr: isSet122(object.sr) ? globalThis.String(object.sr) : "",
      submitLinkLabel: isSet122(object.submitLinkLabel) ? globalThis.String(object.submitLinkLabel) : "",
      submitText: isSet122(object.submitText) ? globalThis.String(object.submitText) : "",
      submitTextLabel: isSet122(object.submitTextLabel) ? globalThis.String(object.submitTextLabel) : "",
      suggestedCommentSort: isSet122(object.suggestedCommentSort) ? globalThis.String(object.suggestedCommentSort) : "",
      title: isSet122(object.title) ? globalThis.String(object.title) : "",
      toxicityThresholdChatLevel: isSet122(object.toxicityThresholdChatLevel) ? globalThis.Number(object.toxicityThresholdChatLevel) : 0,
      type: isSet122(object.type) ? globalThis.String(object.type) : "",
      userFlairPnsEnabled: isSet122(object.userFlairPnsEnabled) ? globalThis.Boolean(object.userFlairPnsEnabled) : false,
      welcomeMessageEnabled: isSet122(object.welcomeMessageEnabled) ? globalThis.Boolean(object.welcomeMessageEnabled) : false,
      welcomeMessageText: isSet122(object.welcomeMessageText) ? globalThis.String(object.welcomeMessageText) : "",
      wikiEditAge: isSet122(object.wikiEditAge) ? globalThis.Number(object.wikiEditAge) : 0,
      wikiEditKarma: isSet122(object.wikiEditKarma) ? globalThis.Number(object.wikiEditKarma) : 0,
      wikimode: isSet122(object.wikimode) ? globalThis.String(object.wikimode) : "",
      crowdControlChatLevel: isSet122(object.crowdControlChatLevel) ? globalThis.Number(object.crowdControlChatLevel) : 0,
      hideAds: isSet122(object.hideAds) ? globalThis.Boolean(object.hideAds) : false,
      modmailHarassmentFilterEnabled: isSet122(object.modmailHarassmentFilterEnabled) ? globalThis.Boolean(object.modmailHarassmentFilterEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.acceptFollowers !== false) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.adminOverrideSpamComments !== false) {
      obj.adminOverrideSpamComments = message.adminOverrideSpamComments;
    }
    if (message.adminOverrideSpamLinks !== false) {
      obj.adminOverrideSpamLinks = message.adminOverrideSpamLinks;
    }
    if (message.adminOverrideSpamSelfposts !== false) {
      obj.adminOverrideSpamSelfposts = message.adminOverrideSpamSelfposts;
    }
    if (message.allOriginalContent !== false) {
      obj.allOriginalContent = message.allOriginalContent;
    }
    if (message.allowChatPostCreation !== false) {
      obj.allowChatPostCreation = message.allowChatPostCreation;
    }
    if (message.allowDiscovery !== false) {
      obj.allowDiscovery = message.allowDiscovery;
    }
    if (message.allowGalleries !== false) {
      obj.allowGalleries = message.allowGalleries;
    }
    if (message.allowImages !== false) {
      obj.allowImages = message.allowImages;
    }
    if (message.allowPolls !== false) {
      obj.allowPolls = message.allowPolls;
    }
    if (message.allowPostCrossposts !== false) {
      obj.allowPostCrossposts = message.allowPostCrossposts;
    }
    if (message.allowPredictionContributors !== false) {
      obj.allowPredictionContributors = message.allowPredictionContributors;
    }
    if (message.allowPredictions !== false) {
      obj.allowPredictions = message.allowPredictions;
    }
    if (message.allowPredictionsTournament !== false) {
      obj.allowPredictionsTournament = message.allowPredictionsTournament;
    }
    if (message.allowTalks !== false) {
      obj.allowTalks = message.allowTalks;
    }
    if (message.allowTop !== false) {
      obj.allowTop = message.allowTop;
    }
    if (message.allowVideos !== false) {
      obj.allowVideos = message.allowVideos;
    }
    if (message.banEvasionThreshold !== 0) {
      obj.banEvasionThreshold = Math.round(message.banEvasionThreshold);
    }
    if (message.collapseDeletedComments !== false) {
      obj.collapseDeletedComments = message.collapseDeletedComments;
    }
    if (message.commentContributionSettings !== void 0) {
      obj.commentContributionSettings = CommentContributionSettings.toJSON(message.commentContributionSettings);
    }
    if (message.commentScoreHideMins !== 0) {
      obj.commentScoreHideMins = Math.round(message.commentScoreHideMins);
    }
    if (message.crowdControlFilter !== false) {
      obj.crowdControlFilter = message.crowdControlFilter;
    }
    if (message.crowdControlLevel !== 0) {
      obj.crowdControlLevel = Math.round(message.crowdControlLevel);
    }
    if (message.crowdControlMode !== false) {
      obj.crowdControlMode = message.crowdControlMode;
    }
    if (message.crowdControlPostLevel !== 0) {
      obj.crowdControlPostLevel = Math.round(message.crowdControlPostLevel);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.disableContributorRequests !== false) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.excludeBannedModqueue !== false) {
      obj.excludeBannedModqueue = message.excludeBannedModqueue;
    }
    if (message.freeFormReports !== false) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.gRecaptchaResponse !== "") {
      obj.gRecaptchaResponse = message.gRecaptchaResponse;
    }
    if (message.hatefulContentThresholdAbuse !== 0) {
      obj.hatefulContentThresholdAbuse = Math.round(message.hatefulContentThresholdAbuse);
    }
    if (message.hatefulContentThresholdIdentity !== 0) {
      obj.hatefulContentThresholdIdentity = Math.round(message.hatefulContentThresholdIdentity);
    }
    if (message.headerTitle !== "") {
      obj.headerTitle = message.headerTitle;
    }
    if (message.keyColor !== "") {
      obj.keyColor = message.keyColor;
    }
    if (message.linkType !== "") {
      obj.linkType = message.linkType;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.newPinnedPostPnsEnabled !== false) {
      obj.newPinnedPostPnsEnabled = message.newPinnedPostPnsEnabled;
    }
    if (message.originalContentTagEnabled !== false) {
      obj.originalContentTagEnabled = message.originalContentTagEnabled;
    }
    if (message.over18 !== false) {
      obj.over18 = message.over18;
    }
    if (message.predictionLeaderboardEntryType !== 0) {
      obj.predictionLeaderboardEntryType = Math.round(message.predictionLeaderboardEntryType);
    }
    if (message.publicDescription !== "") {
      obj.publicDescription = message.publicDescription;
    }
    if (message.restrictCommenting !== false) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.restrictPosting !== false) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.shouldArchivePosts !== false) {
      obj.shouldArchivePosts = message.shouldArchivePosts;
    }
    if (message.showMedia !== false) {
      obj.showMedia = message.showMedia;
    }
    if (message.showMediaPreview !== false) {
      obj.showMediaPreview = message.showMediaPreview;
    }
    if (message.spamComments !== "") {
      obj.spamComments = message.spamComments;
    }
    if (message.spamLinks !== "") {
      obj.spamLinks = message.spamLinks;
    }
    if (message.spamSelfposts !== "") {
      obj.spamSelfposts = message.spamSelfposts;
    }
    if (message.spoilersEnabled !== false) {
      obj.spoilersEnabled = message.spoilersEnabled;
    }
    if (message.sr !== "") {
      obj.sr = message.sr;
    }
    if (message.submitLinkLabel !== "") {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.submitText !== "") {
      obj.submitText = message.submitText;
    }
    if (message.submitTextLabel !== "") {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.suggestedCommentSort !== "") {
      obj.suggestedCommentSort = message.suggestedCommentSort;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.toxicityThresholdChatLevel !== 0) {
      obj.toxicityThresholdChatLevel = Math.round(message.toxicityThresholdChatLevel);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.userFlairPnsEnabled !== false) {
      obj.userFlairPnsEnabled = message.userFlairPnsEnabled;
    }
    if (message.welcomeMessageEnabled !== false) {
      obj.welcomeMessageEnabled = message.welcomeMessageEnabled;
    }
    if (message.welcomeMessageText !== "") {
      obj.welcomeMessageText = message.welcomeMessageText;
    }
    if (message.wikiEditAge !== 0) {
      obj.wikiEditAge = Math.round(message.wikiEditAge);
    }
    if (message.wikiEditKarma !== 0) {
      obj.wikiEditKarma = Math.round(message.wikiEditKarma);
    }
    if (message.wikimode !== "") {
      obj.wikimode = message.wikimode;
    }
    if (message.crowdControlChatLevel !== 0) {
      obj.crowdControlChatLevel = Math.round(message.crowdControlChatLevel);
    }
    if (message.hideAds !== false) {
      obj.hideAds = message.hideAds;
    }
    if (message.modmailHarassmentFilterEnabled !== false) {
      obj.modmailHarassmentFilterEnabled = message.modmailHarassmentFilterEnabled;
    }
    return obj;
  },
  create(base) {
    return SiteAdminRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSiteAdminRequest();
    message.acceptFollowers = object.acceptFollowers ?? false;
    message.adminOverrideSpamComments = object.adminOverrideSpamComments ?? false;
    message.adminOverrideSpamLinks = object.adminOverrideSpamLinks ?? false;
    message.adminOverrideSpamSelfposts = object.adminOverrideSpamSelfposts ?? false;
    message.allOriginalContent = object.allOriginalContent ?? false;
    message.allowChatPostCreation = object.allowChatPostCreation ?? false;
    message.allowDiscovery = object.allowDiscovery ?? false;
    message.allowGalleries = object.allowGalleries ?? false;
    message.allowImages = object.allowImages ?? false;
    message.allowPolls = object.allowPolls ?? false;
    message.allowPostCrossposts = object.allowPostCrossposts ?? false;
    message.allowPredictionContributors = object.allowPredictionContributors ?? false;
    message.allowPredictions = object.allowPredictions ?? false;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? false;
    message.allowTalks = object.allowTalks ?? false;
    message.allowTop = object.allowTop ?? false;
    message.allowVideos = object.allowVideos ?? false;
    message.banEvasionThreshold = object.banEvasionThreshold ?? 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? false;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? 0;
    message.crowdControlFilter = object.crowdControlFilter ?? false;
    message.crowdControlLevel = object.crowdControlLevel ?? 0;
    message.crowdControlMode = object.crowdControlMode ?? false;
    message.crowdControlPostLevel = object.crowdControlPostLevel ?? 0;
    message.description = object.description ?? "";
    message.disableContributorRequests = object.disableContributorRequests ?? false;
    message.excludeBannedModqueue = object.excludeBannedModqueue ?? false;
    message.freeFormReports = object.freeFormReports ?? false;
    message.gRecaptchaResponse = object.gRecaptchaResponse ?? "";
    message.hatefulContentThresholdAbuse = object.hatefulContentThresholdAbuse ?? 0;
    message.hatefulContentThresholdIdentity = object.hatefulContentThresholdIdentity ?? 0;
    message.headerTitle = object.headerTitle ?? "";
    message.keyColor = object.keyColor ?? "";
    message.linkType = object.linkType ?? "";
    message.name = object.name ?? "";
    message.newPinnedPostPnsEnabled = object.newPinnedPostPnsEnabled ?? false;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? false;
    message.over18 = object.over18 ?? false;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? 0;
    message.publicDescription = object.publicDescription ?? "";
    message.restrictCommenting = object.restrictCommenting ?? false;
    message.restrictPosting = object.restrictPosting ?? false;
    message.shouldArchivePosts = object.shouldArchivePosts ?? false;
    message.showMedia = object.showMedia ?? false;
    message.showMediaPreview = object.showMediaPreview ?? false;
    message.spamComments = object.spamComments ?? "";
    message.spamLinks = object.spamLinks ?? "";
    message.spamSelfposts = object.spamSelfposts ?? "";
    message.spoilersEnabled = object.spoilersEnabled ?? false;
    message.sr = object.sr ?? "";
    message.submitLinkLabel = object.submitLinkLabel ?? "";
    message.submitText = object.submitText ?? "";
    message.submitTextLabel = object.submitTextLabel ?? "";
    message.suggestedCommentSort = object.suggestedCommentSort ?? "";
    message.title = object.title ?? "";
    message.toxicityThresholdChatLevel = object.toxicityThresholdChatLevel ?? 0;
    message.type = object.type ?? "";
    message.userFlairPnsEnabled = object.userFlairPnsEnabled ?? false;
    message.welcomeMessageEnabled = object.welcomeMessageEnabled ?? false;
    message.welcomeMessageText = object.welcomeMessageText ?? "";
    message.wikiEditAge = object.wikiEditAge ?? 0;
    message.wikiEditKarma = object.wikiEditKarma ?? 0;
    message.wikimode = object.wikimode ?? "";
    message.crowdControlChatLevel = object.crowdControlChatLevel ?? 0;
    message.hideAds = object.hideAds ?? false;
    message.modmailHarassmentFilterEnabled = object.modmailHarassmentFilterEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set(SiteAdminRequest.$type, SiteAdminRequest);
function createBaseSubredditAutocompleteRequest() {
  return {
    includeOver18: void 0,
    includeProfiles: void 0,
    limit: void 0,
    query: "",
    searchQueryId: void 0,
    typeaheadActive: void 0
  };
}
var SubredditAutocompleteRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.includeOver18 !== void 0) {
      BoolValue.encode({ value: message.includeOver18 }, writer.uint32(10).fork()).ldelim();
    }
    if (message.includeProfiles !== void 0) {
      BoolValue.encode({ value: message.includeProfiles }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.includeOver18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.includeProfiles = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.query = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      includeOver18: isSet122(object.includeOver18) ? Boolean(object.includeOver18) : void 0,
      includeProfiles: isSet122(object.includeProfiles) ? Boolean(object.includeProfiles) : void 0,
      limit: isSet122(object.limit) ? Number(object.limit) : void 0,
      query: isSet122(object.query) ? globalThis.String(object.query) : "",
      searchQueryId: isSet122(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      typeaheadActive: isSet122(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.includeOver18 !== void 0) {
      obj.includeOver18 = message.includeOver18;
    }
    if (message.includeProfiles !== void 0) {
      obj.includeProfiles = message.includeProfiles;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.searchQueryId !== void 0) {
      obj.searchQueryId = message.searchQueryId;
    }
    if (message.typeaheadActive !== void 0) {
      obj.typeaheadActive = message.typeaheadActive;
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteRequest();
    message.includeOver18 = object.includeOver18 ?? void 0;
    message.includeProfiles = object.includeProfiles ?? void 0;
    message.limit = object.limit ?? void 0;
    message.query = object.query ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteRequest.$type, SubredditAutocompleteRequest);
function createBaseSubredditStylesheetRequest() {
  return { op: "", reason: "", stylesheetContents: "", subreddit: "" };
}
var SubredditStylesheetRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.op !== "") {
      writer.uint32(10).string(message.op);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.stylesheetContents !== "") {
      writer.uint32(26).string(message.stylesheetContents);
    }
    if (message.subreddit !== "") {
      writer.uint32(34).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditStylesheetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.op = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reason = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.stylesheetContents = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      op: isSet122(object.op) ? globalThis.String(object.op) : "",
      reason: isSet122(object.reason) ? globalThis.String(object.reason) : "",
      stylesheetContents: isSet122(object.stylesheetContents) ? globalThis.String(object.stylesheetContents) : "",
      subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.op !== "") {
      obj.op = message.op;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.stylesheetContents !== "") {
      obj.stylesheetContents = message.stylesheetContents;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return SubredditStylesheetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditStylesheetRequest();
    message.op = object.op ?? "";
    message.reason = object.reason ?? "";
    message.stylesheetContents = object.stylesheetContents ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditStylesheetRequest.$type, SubredditStylesheetRequest);
function createBaseSubscribeRequest() {
  return { action: "", actionSource: "", skipInitialDefaults: false, sr: "", srName: "" };
}
var SubscribeRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubscribeRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.actionSource !== "") {
      writer.uint32(18).string(message.actionSource);
    }
    if (message.skipInitialDefaults !== false) {
      writer.uint32(24).bool(message.skipInitialDefaults);
    }
    if (message.sr !== "") {
      writer.uint32(34).string(message.sr);
    }
    if (message.srName !== "") {
      writer.uint32(42).string(message.srName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.actionSource = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.skipInitialDefaults = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.sr = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.srName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet122(object.action) ? globalThis.String(object.action) : "",
      actionSource: isSet122(object.actionSource) ? globalThis.String(object.actionSource) : "",
      skipInitialDefaults: isSet122(object.skipInitialDefaults) ? globalThis.Boolean(object.skipInitialDefaults) : false,
      sr: isSet122(object.sr) ? globalThis.String(object.sr) : "",
      srName: isSet122(object.srName) ? globalThis.String(object.srName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.actionSource !== "") {
      obj.actionSource = message.actionSource;
    }
    if (message.skipInitialDefaults !== false) {
      obj.skipInitialDefaults = message.skipInitialDefaults;
    }
    if (message.sr !== "") {
      obj.sr = message.sr;
    }
    if (message.srName !== "") {
      obj.srName = message.srName;
    }
    return obj;
  },
  create(base) {
    return SubscribeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubscribeRequest();
    message.action = object.action ?? "";
    message.actionSource = object.actionSource ?? "";
    message.skipInitialDefaults = object.skipInitialDefaults ?? false;
    message.sr = object.sr ?? "";
    message.srName = object.srName ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubscribeRequest.$type, SubscribeRequest);
function createBaseUploadSrImgRequest() {
  return { file: "", header: 0, imgType: "", name: "", uploadType: "", subreddit: "" };
}
var UploadSrImgRequest = {
  $type: "devvit.plugin.redditapi.subreddits.UploadSrImgRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.file !== "") {
      writer.uint32(10).string(message.file);
    }
    if (message.header !== 0) {
      writer.uint32(16).int64(message.header);
    }
    if (message.imgType !== "") {
      writer.uint32(26).string(message.imgType);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.uploadType !== "") {
      writer.uint32(42).string(message.uploadType);
    }
    if (message.subreddit !== "") {
      writer.uint32(50).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadSrImgRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.file = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.header = longToNumber15(reader.int64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.imgType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.uploadType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      file: isSet122(object.file) ? globalThis.String(object.file) : "",
      header: isSet122(object.header) ? globalThis.Number(object.header) : 0,
      imgType: isSet122(object.imgType) ? globalThis.String(object.imgType) : "",
      name: isSet122(object.name) ? globalThis.String(object.name) : "",
      uploadType: isSet122(object.uploadType) ? globalThis.String(object.uploadType) : "",
      subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.header !== 0) {
      obj.header = Math.round(message.header);
    }
    if (message.imgType !== "") {
      obj.imgType = message.imgType;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uploadType !== "") {
      obj.uploadType = message.uploadType;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return UploadSrImgRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUploadSrImgRequest();
    message.file = object.file ?? "";
    message.header = object.header ?? 0;
    message.imgType = object.imgType ?? "";
    message.name = object.name ?? "";
    message.uploadType = object.uploadType ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(UploadSrImgRequest.$type, UploadSrImgRequest);
function createBaseSubredditAboutEditRequest() {
  return { created: "", location: "", subreddit: "" };
}
var SubredditAboutEditRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.created !== "") {
      writer.uint32(10).string(message.created);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.subreddit !== "") {
      writer.uint32(26).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutEditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.created = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      created: isSet122(object.created) ? globalThis.String(object.created) : "",
      location: isSet122(object.location) ? globalThis.String(object.location) : "",
      subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.created !== "") {
      obj.created = message.created;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return SubredditAboutEditRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutEditRequest();
    message.created = object.created ?? "";
    message.location = object.location ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutEditRequest.$type, SubredditAboutEditRequest);
function createBaseStickyRequest() {
  return { num: 0, subreddit: "" };
}
var StickyRequest = {
  $type: "devvit.plugin.redditapi.subreddits.StickyRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.num !== 0) {
      writer.uint32(8).int64(message.num);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.num = longToNumber15(reader.int64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      num: isSet122(object.num) ? globalThis.Number(object.num) : 0,
      subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.num !== 0) {
      obj.num = Math.round(message.num);
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return StickyRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStickyRequest();
    message.num = object.num ?? 0;
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(StickyRequest.$type, StickyRequest);
function createBaseBasicWhereRequest() {
  return { after: void 0, before: void 0, count: void 0, limit: void 0, show: void 0, where: "" };
}
var BasicWhereRequest = {
  $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    if (message.where !== "") {
      writer.uint32(58).string(message.where);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.where = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      count: isSet122(object.count) ? Number(object.count) : void 0,
      limit: isSet122(object.limit) ? Number(object.limit) : void 0,
      show: isSet122(object.show) ? String(object.show) : void 0,
      where: isSet122(object.where) ? globalThis.String(object.where) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.where !== "") {
      obj.where = message.where;
    }
    return obj;
  },
  create(base) {
    return BasicWhereRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicWhereRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    message.where = object.where ?? "";
    return message;
  }
};
messageTypeRegistry.set(BasicWhereRequest.$type, BasicWhereRequest);
function createBaseSubredditsSearchRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    q: "",
    searchQueryId: void 0,
    show: void 0,
    showUsers: void 0,
    sort: void 0,
    typeaheadActive: void 0
  };
}
var SubredditsSearchRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.q !== "") {
      writer.uint32(42).string(message.q);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showUsers !== void 0) {
      BoolValue.encode({ value: message.showUsers }, writer.uint32(66).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(74).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.q = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.showUsers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      count: isSet122(object.count) ? Number(object.count) : void 0,
      limit: isSet122(object.limit) ? Number(object.limit) : void 0,
      q: isSet122(object.q) ? globalThis.String(object.q) : "",
      searchQueryId: isSet122(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      show: isSet122(object.show) ? String(object.show) : void 0,
      showUsers: isSet122(object.showUsers) ? Boolean(object.showUsers) : void 0,
      sort: isSet122(object.sort) ? String(object.sort) : void 0,
      typeaheadActive: isSet122(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.q !== "") {
      obj.q = message.q;
    }
    if (message.searchQueryId !== void 0) {
      obj.searchQueryId = message.searchQueryId;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.showUsers !== void 0) {
      obj.showUsers = message.showUsers;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.typeaheadActive !== void 0) {
      obj.typeaheadActive = message.typeaheadActive;
    }
    return obj;
  },
  create(base) {
    return SubredditsSearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.q = object.q ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.show = object.show ?? void 0;
    message.showUsers = object.showUsers ?? void 0;
    message.sort = object.sort ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditsSearchRequest.$type, SubredditsSearchRequest);
function createBaseUsersSearchRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    q: "",
    searchQueryId: void 0,
    show: void 0,
    sort: void 0,
    typeaheadActive: void 0
  };
}
var UsersSearchRequest = {
  $type: "devvit.plugin.redditapi.subreddits.UsersSearchRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.q !== "") {
      writer.uint32(42).string(message.q);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(66).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsersSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.q = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      count: isSet122(object.count) ? Number(object.count) : void 0,
      limit: isSet122(object.limit) ? Number(object.limit) : void 0,
      q: isSet122(object.q) ? globalThis.String(object.q) : "",
      searchQueryId: isSet122(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      show: isSet122(object.show) ? String(object.show) : void 0,
      sort: isSet122(object.sort) ? String(object.sort) : void 0,
      typeaheadActive: isSet122(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.q !== "") {
      obj.q = message.q;
    }
    if (message.searchQueryId !== void 0) {
      obj.searchQueryId = message.searchQueryId;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.typeaheadActive !== void 0) {
      obj.typeaheadActive = message.typeaheadActive;
    }
    return obj;
  },
  create(base) {
    return UsersSearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUsersSearchRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.q = object.q ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.show = object.show ?? void 0;
    message.sort = object.sort ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UsersSearchRequest.$type, UsersSearchRequest);
function createBaseSearchRedditNamesResponse() {
  return { names: [] };
}
var SearchRedditNamesResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.names) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchRedditNamesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.names.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { names: globalThis.Array.isArray(object?.names) ? object.names.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },
  create(base) {
    return SearchRedditNamesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSearchRedditNamesResponse();
    message.names = object.names?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(SearchRedditNamesResponse.$type, SearchRedditNamesResponse);
function createBaseSearchSubredditsResponse() {
  return { subreddits: [] };
}
var SearchSubredditsResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.subreddits) {
      SearchSubredditsResponse_SubredditData.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchSubredditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddits.push(SearchSubredditsResponse_SubredditData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: globalThis.Array.isArray(object?.subreddits) ? object.subreddits.map((e) => SearchSubredditsResponse_SubredditData.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddits?.length) {
      obj.subreddits = message.subreddits.map((e) => SearchSubredditsResponse_SubredditData.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SearchSubredditsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSearchSubredditsResponse();
    message.subreddits = object.subreddits?.map((e) => SearchSubredditsResponse_SubredditData.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SearchSubredditsResponse.$type, SearchSubredditsResponse);
function createBaseSearchSubredditsResponse_SubredditData() {
  return {
    activeUserCount: void 0,
    iconImg: void 0,
    keyColor: void 0,
    name: void 0,
    subscriberCount: void 0,
    isChatPostFeatureEnabled: void 0,
    allowChatPostCreation: void 0,
    allowImages: void 0
  };
}
var SearchSubredditsResponse_SubredditData = {
  $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse.SubredditData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.activeUserCount !== void 0) {
      Int32Value.encode({ value: message.activeUserCount }, writer.uint32(10).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(18).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    if (message.subscriberCount !== void 0) {
      Int32Value.encode({ value: message.subscriberCount }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(58).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchSubredditsResponse_SubredditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.activeUserCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.subscriberCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      activeUserCount: isSet122(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      keyColor: isSet122(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      subscriberCount: isSet122(object.subscriberCount) ? Number(object.subscriberCount) : void 0,
      isChatPostFeatureEnabled: isSet122(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      allowChatPostCreation: isSet122(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowImages: isSet122(object.allowImages) ? Boolean(object.allowImages) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.activeUserCount !== void 0) {
      obj.activeUserCount = message.activeUserCount;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.subscriberCount !== void 0) {
      obj.subscriberCount = message.subscriberCount;
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled;
    }
    if (message.allowChatPostCreation !== void 0) {
      obj.allowChatPostCreation = message.allowChatPostCreation;
    }
    if (message.allowImages !== void 0) {
      obj.allowImages = message.allowImages;
    }
    return obj;
  },
  create(base) {
    return SearchSubredditsResponse_SubredditData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSearchSubredditsResponse_SubredditData();
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.subscriberCount = object.subscriberCount ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SearchSubredditsResponse_SubredditData.$type, SearchSubredditsResponse_SubredditData);
function createBaseSubmitTextResponse() {
  return { submitText: void 0, submitTextHtml: void 0 };
}
var SubmitTextResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubmitTextResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(10).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      submitText: isSet122(object.submitText) ? String(object.submitText) : void 0,
      submitTextHtml: isSet122(object.submitTextHtml) ? String(object.submitTextHtml) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.submitText !== void 0) {
      obj.submitText = message.submitText;
    }
    if (message.submitTextHtml !== void 0) {
      obj.submitTextHtml = message.submitTextHtml;
    }
    return obj;
  },
  create(base) {
    return SubmitTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmitTextResponse();
    message.submitText = object.submitText ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmitTextResponse.$type, SubmitTextResponse);
function createBaseSubredditAutocompleteResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditAutocompleteResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditAutocompleteResponse_AutocompleteResponse.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = SubredditAutocompleteResponse_AutocompleteResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? SubredditAutocompleteResponse_AutocompleteResponse.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = SubredditAutocompleteResponse_AutocompleteResponse.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditAutocompleteResponse_AutocompleteResponse.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteResponse.$type, SubredditAutocompleteResponse);
function createBaseSubredditAutocompleteResponse_AutocompleteAccount() {
  return {
    isEmployee: void 0,
    isFriend: void 0,
    snoovatarSize: void 0,
    id: void 0,
    verified: void 0,
    isGold: void 0,
    isMod: void 0,
    hasVerifiedEmail: void 0,
    iconImg: void 0,
    hideFromRobots: void 0,
    linkKarma: void 0,
    acceptChats: void 0,
    isBlocked: void 0,
    prefShowSnoovatar: void 0,
    name: void 0,
    created: void 0,
    createdUtc: void 0,
    snoovatarImg: void 0,
    commentKarma: void 0,
    acceptFollowers: void 0,
    hasSubscribed: void 0,
    acceptPms: void 0
  };
}
var SubredditAutocompleteResponse_AutocompleteAccount = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.isEmployee !== void 0) {
      BoolValue.encode({ value: message.isEmployee }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isFriend !== void 0) {
      BoolValue.encode({ value: message.isFriend }, writer.uint32(18).fork()).ldelim();
    }
    if (message.snoovatarSize !== void 0) {
      Int32Value.encode({ value: message.snoovatarSize }, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
    }
    if (message.verified !== void 0) {
      BoolValue.encode({ value: message.verified }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isGold !== void 0) {
      BoolValue.encode({ value: message.isGold }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(58).fork()).ldelim();
    }
    if (message.hasVerifiedEmail !== void 0) {
      BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(74).fork()).ldelim();
    }
    if (message.hideFromRobots !== void 0) {
      BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(82).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int32Value.encode({ value: message.linkKarma }, writer.uint32(90).fork()).ldelim();
    }
    if (message.acceptChats !== void 0) {
      BoolValue.encode({ value: message.acceptChats }, writer.uint32(98).fork()).ldelim();
    }
    if (message.isBlocked !== void 0) {
      BoolValue.encode({ value: message.isBlocked }, writer.uint32(106).fork()).ldelim();
    }
    if (message.prefShowSnoovatar !== void 0) {
      BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(114).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(122).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(130).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(138).fork()).ldelim();
    }
    if (message.snoovatarImg !== void 0) {
      StringValue.encode({ value: message.snoovatarImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int64Value.encode({ value: message.commentKarma }, writer.uint32(154).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(162).fork()).ldelim();
    }
    if (message.hasSubscribed !== void 0) {
      BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(170).fork()).ldelim();
    }
    if (message.acceptPms !== void 0) {
      BoolValue.encode({ value: message.acceptPms }, writer.uint32(178).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.snoovatarSize = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isGold = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isEmployee: isSet122(object.isEmployee) ? Boolean(object.isEmployee) : void 0,
      isFriend: isSet122(object.isFriend) ? Boolean(object.isFriend) : void 0,
      snoovatarSize: isSet122(object.snoovatarSize) ? Number(object.snoovatarSize) : void 0,
      id: isSet122(object.id) ? String(object.id) : void 0,
      verified: isSet122(object.verified) ? Boolean(object.verified) : void 0,
      isGold: isSet122(object.isGold) ? Boolean(object.isGold) : void 0,
      isMod: isSet122(object.isMod) ? Boolean(object.isMod) : void 0,
      hasVerifiedEmail: isSet122(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      hideFromRobots: isSet122(object.hideFromRobots) ? Boolean(object.hideFromRobots) : void 0,
      linkKarma: isSet122(object.linkKarma) ? Number(object.linkKarma) : void 0,
      acceptChats: isSet122(object.acceptChats) ? Boolean(object.acceptChats) : void 0,
      isBlocked: isSet122(object.isBlocked) ? Boolean(object.isBlocked) : void 0,
      prefShowSnoovatar: isSet122(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      created: isSet122(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet122(object.createdUtc) ? Number(object.createdUtc) : void 0,
      snoovatarImg: isSet122(object.snoovatarImg) ? String(object.snoovatarImg) : void 0,
      commentKarma: isSet122(object.commentKarma) ? Number(object.commentKarma) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      hasSubscribed: isSet122(object.hasSubscribed) ? Boolean(object.hasSubscribed) : void 0,
      acceptPms: isSet122(object.acceptPms) ? Boolean(object.acceptPms) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isEmployee !== void 0) {
      obj.isEmployee = message.isEmployee;
    }
    if (message.isFriend !== void 0) {
      obj.isFriend = message.isFriend;
    }
    if (message.snoovatarSize !== void 0) {
      obj.snoovatarSize = message.snoovatarSize;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.verified !== void 0) {
      obj.verified = message.verified;
    }
    if (message.isGold !== void 0) {
      obj.isGold = message.isGold;
    }
    if (message.isMod !== void 0) {
      obj.isMod = message.isMod;
    }
    if (message.hasVerifiedEmail !== void 0) {
      obj.hasVerifiedEmail = message.hasVerifiedEmail;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.hideFromRobots !== void 0) {
      obj.hideFromRobots = message.hideFromRobots;
    }
    if (message.linkKarma !== void 0) {
      obj.linkKarma = message.linkKarma;
    }
    if (message.acceptChats !== void 0) {
      obj.acceptChats = message.acceptChats;
    }
    if (message.isBlocked !== void 0) {
      obj.isBlocked = message.isBlocked;
    }
    if (message.prefShowSnoovatar !== void 0) {
      obj.prefShowSnoovatar = message.prefShowSnoovatar;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.snoovatarImg !== void 0) {
      obj.snoovatarImg = message.snoovatarImg;
    }
    if (message.commentKarma !== void 0) {
      obj.commentKarma = message.commentKarma;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.hasSubscribed !== void 0) {
      obj.hasSubscribed = message.hasSubscribed;
    }
    if (message.acceptPms !== void 0) {
      obj.acceptPms = message.acceptPms;
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteResponse_AutocompleteAccount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount();
    message.isEmployee = object.isEmployee ?? void 0;
    message.isFriend = object.isFriend ?? void 0;
    message.snoovatarSize = object.snoovatarSize ?? void 0;
    message.id = object.id ?? void 0;
    message.verified = object.verified ?? void 0;
    message.isGold = object.isGold ?? void 0;
    message.isMod = object.isMod ?? void 0;
    message.hasVerifiedEmail = object.hasVerifiedEmail ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.hideFromRobots = object.hideFromRobots ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.acceptChats = object.acceptChats ?? void 0;
    message.isBlocked = object.isBlocked ?? void 0;
    message.prefShowSnoovatar = object.prefShowSnoovatar ?? void 0;
    message.name = object.name ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.snoovatarImg = object.snoovatarImg ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.hasSubscribed = object.hasSubscribed ?? void 0;
    message.acceptPms = object.acceptPms ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteResponse_AutocompleteAccount.$type, SubredditAutocompleteResponse_AutocompleteAccount);
function createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit() {
  return {
    defaultSet: void 0,
    userIsContributor: void 0,
    bannerImg: void 0,
    allowedMediaInComments: [],
    userIsBanned: void 0,
    freeFormReports: void 0,
    communityIcon: void 0,
    showMedia: void 0,
    iconColor: void 0,
    userIsMuted: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    previousNames: [],
    over18: void 0,
    iconSize: [],
    primaryColor: void 0,
    iconImg: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    headerSize: void 0,
    restrictPosting: void 0,
    restrictCommenting: void 0,
    subscribers: void 0,
    submitTextLabel: void 0,
    isDefaultIcon: void 0,
    inkFlairPosition: void 0,
    displayNamePrefixed: void 0,
    keyColor: void 0,
    name: void 0,
    isDefaultBanner: void 0,
    url: void 0,
    quarantine: void 0,
    bannerSize: void 0,
    userIsModerator: void 0,
    acceptFollowers: void 0,
    publicDescription: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    userIsSubscriber: void 0
  };
}
var SubredditAutocompleteResponse_AutocompleteAccount_Subreddit = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount.Subreddit",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(130).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(138).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(154).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(162).fork()).ldelim();
    }
    if (message.headerSize !== void 0) {
      Int32Value.encode({ value: message.headerSize }, writer.uint32(170).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(178).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
    }
    if (message.inkFlairPosition !== void 0) {
      StringValue.encode({ value: message.inkFlairPosition }, writer.uint32(218).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
    }
    if (message.bannerSize !== void 0) {
      Int32Value.encode({ value: message.bannerSize }, writer.uint32(274).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.headerSize = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.inkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.bannerSize = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet122(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      userIsContributor: isSet122(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      bannerImg: isSet122(object.bannerImg) ? String(object.bannerImg) : void 0,
      allowedMediaInComments: globalThis.Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      userIsBanned: isSet122(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet122(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      communityIcon: isSet122(object.communityIcon) ? String(object.communityIcon) : void 0,
      showMedia: isSet122(object.showMedia) ? Boolean(object.showMedia) : void 0,
      iconColor: isSet122(object.iconColor) ? String(object.iconColor) : void 0,
      userIsMuted: isSet122(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      displayName: isSet122(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet122(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet122(object.title) ? String(object.title) : void 0,
      previousNames: globalThis.Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      over18: isSet122(object.over18) ? Boolean(object.over18) : void 0,
      iconSize: globalThis.Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet122(object.primaryColor) ? String(object.primaryColor) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      description: isSet122(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet122(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      headerSize: isSet122(object.headerSize) ? Number(object.headerSize) : void 0,
      restrictPosting: isSet122(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      restrictCommenting: isSet122(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      subscribers: isSet122(object.subscribers) ? Number(object.subscribers) : void 0,
      submitTextLabel: isSet122(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      isDefaultIcon: isSet122(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      inkFlairPosition: isSet122(object.inkFlairPosition) ? String(object.inkFlairPosition) : void 0,
      displayNamePrefixed: isSet122(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      keyColor: isSet122(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      isDefaultBanner: isSet122(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      url: isSet122(object.url) ? String(object.url) : void 0,
      quarantine: isSet122(object.quarantine) ? Boolean(object.quarantine) : void 0,
      bannerSize: isSet122(object.bannerSize) ? Number(object.bannerSize) : void 0,
      userIsModerator: isSet122(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      publicDescription: isSet122(object.publicDescription) ? String(object.publicDescription) : void 0,
      linkFlairEnabled: isSet122(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet122(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet122(object.subredditType) ? String(object.subredditType) : void 0,
      userIsSubscriber: isSet122(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.defaultSet !== void 0) {
      obj.defaultSet = message.defaultSet;
    }
    if (message.userIsContributor !== void 0) {
      obj.userIsContributor = message.userIsContributor;
    }
    if (message.bannerImg !== void 0) {
      obj.bannerImg = message.bannerImg;
    }
    if (message.allowedMediaInComments?.length) {
      obj.allowedMediaInComments = message.allowedMediaInComments;
    }
    if (message.userIsBanned !== void 0) {
      obj.userIsBanned = message.userIsBanned;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.iconColor !== void 0) {
      obj.iconColor = message.iconColor;
    }
    if (message.userIsMuted !== void 0) {
      obj.userIsMuted = message.userIsMuted;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.headerImg !== void 0) {
      obj.headerImg = message.headerImg;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.previousNames?.length) {
      obj.previousNames = message.previousNames;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.iconSize?.length) {
      obj.iconSize = message.iconSize;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.headerSize !== void 0) {
      obj.headerSize = message.headerSize;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.isDefaultIcon !== void 0) {
      obj.isDefaultIcon = message.isDefaultIcon;
    }
    if (message.inkFlairPosition !== void 0) {
      obj.inkFlairPosition = message.inkFlairPosition;
    }
    if (message.displayNamePrefixed !== void 0) {
      obj.displayNamePrefixed = message.displayNamePrefixed;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.isDefaultBanner !== void 0) {
      obj.isDefaultBanner = message.isDefaultBanner;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.bannerSize !== void 0) {
      obj.bannerSize = message.bannerSize;
    }
    if (message.userIsModerator !== void 0) {
      obj.userIsModerator = message.userIsModerator;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.linkFlairEnabled !== void 0) {
      obj.linkFlairEnabled = message.linkFlairEnabled;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.userIsSubscriber !== void 0) {
      obj.userIsSubscriber = message.userIsSubscriber;
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteResponse_AutocompleteAccount_Subreddit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit();
    message.defaultSet = object.defaultSet ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.over18 = object.over18 ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.headerSize = object.headerSize ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.inkFlairPosition = object.inkFlairPosition ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.url = object.url ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.bannerSize = object.bannerSize ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteResponse_AutocompleteAccount_Subreddit.$type, SubredditAutocompleteResponse_AutocompleteAccount_Subreddit);
function createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit() {
  return { kind: "", data: void 0 };
}
var SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteSubreddit",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      FullSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = FullSubredditObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet122(object.data) ? FullSubredditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = FullSubredditObject.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? FullSubredditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.$type, SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit);
function createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount() {
  return { kind: "", data: void 0 };
}
var SubredditAutocompleteResponse_WrappedAutoCompleteAccount = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteAccount",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      SubredditAutocompleteResponse_AutocompleteAccount.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = SubredditAutocompleteResponse_AutocompleteAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet122(object.data) ? SubredditAutocompleteResponse_AutocompleteAccount.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = SubredditAutocompleteResponse_AutocompleteAccount.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? SubredditAutocompleteResponse_AutocompleteAccount.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteResponse_WrappedAutoCompleteAccount.$type, SubredditAutocompleteResponse_WrappedAutoCompleteAccount);
function createBaseSubredditAutocompleteResponse_AutocompleteResponse() {
  return { after: void 0, before: void 0, dist: void 0, childrenSubreddits: [], childrenAccounts: [] };
}
var SubredditAutocompleteResponse_AutocompleteResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.childrenSubreddits) {
      SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.childrenAccounts) {
      SubredditAutocompleteResponse_WrappedAutoCompleteAccount.encode(v, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_AutocompleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.childrenSubreddits.push(SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.childrenAccounts.push(SubredditAutocompleteResponse_WrappedAutoCompleteAccount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      dist: isSet122(object.dist) ? Number(object.dist) : void 0,
      childrenSubreddits: globalThis.Array.isArray(object?.childrenSubreddits) ? object.childrenSubreddits.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromJSON(e)) : [],
      childrenAccounts: globalThis.Array.isArray(object?.childrenAccounts) ? object.childrenAccounts.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    if (message.childrenSubreddits?.length) {
      obj.childrenSubreddits = message.childrenSubreddits.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.toJSON(e));
    }
    if (message.childrenAccounts?.length) {
      obj.childrenAccounts = message.childrenAccounts.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SubredditAutocompleteResponse_AutocompleteResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_AutocompleteResponse();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.dist = object.dist ?? void 0;
    message.childrenSubreddits = object.childrenSubreddits?.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromPartial(e)) || [];
    message.childrenAccounts = object.childrenAccounts?.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditAutocompleteResponse_AutocompleteResponse.$type, SubredditAutocompleteResponse_AutocompleteResponse);
function createBaseUploadSrImgResponse() {
  return { errors: [], imgSrc: void 0, errorsValues: [] };
}
var UploadSrImgResponse = {
  $type: "devvit.plugin.redditapi.subreddits.UploadSrImgResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.errors) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    if (message.imgSrc !== void 0) {
      StringValue.encode({ value: message.imgSrc }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.errorsValues) {
      StringValue.encode({ value: v }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadSrImgResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.errors.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.imgSrc = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.errorsValues.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [],
      imgSrc: isSet122(object.imgSrc) ? String(object.imgSrc) : void 0,
      errorsValues: globalThis.Array.isArray(object?.errorsValues) ? object.errorsValues.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    if (message.imgSrc !== void 0) {
      obj.imgSrc = message.imgSrc;
    }
    if (message.errorsValues?.length) {
      obj.errorsValues = message.errorsValues;
    }
    return obj;
  },
  create(base) {
    return UploadSrImgResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUploadSrImgResponse();
    message.errors = object.errors?.map((e) => e) || [];
    message.imgSrc = object.imgSrc ?? void 0;
    message.errorsValues = object.errorsValues?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(UploadSrImgResponse.$type, UploadSrImgResponse);
function createBaseSubredditPostRequirementsResponse() {
  return {
    titleRegexes: [],
    bodyBlacklistedStrings: [],
    titleBlacklistedStrings: [],
    bodyTextMaxLength: void 0,
    titleRequiredStrings: [],
    guidelinesText: void 0,
    galleryMinItems: void 0,
    domainBlacklist: [],
    domainWhitelist: [],
    titleTextMaxLength: void 0,
    bodyRestrictionPolicy: void 0,
    linkRestrictionPolicy: void 0,
    guidelinesDisplayPolicy: void 0,
    bodyRequiredStrings: [],
    titleTextMinLength: void 0,
    galleryCaptionsRequirement: void 0,
    isFlairRequired: void 0,
    galleryMaxItems: void 0,
    galleryUrlsRequirement: void 0,
    bodyRegexes: [],
    linkRepostAge: void 0,
    bodyTextMinLength: void 0
  };
}
var SubredditPostRequirementsResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.titleRegexes) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.bodyBlacklistedStrings) {
      StringValue.encode({ value: v }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.titleBlacklistedStrings) {
      StringValue.encode({ value: v }, writer.uint32(26).fork()).ldelim();
    }
    if (message.bodyTextMaxLength !== void 0) {
      Int32Value.encode({ value: message.bodyTextMaxLength }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.titleRequiredStrings) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.guidelinesText !== void 0) {
      StringValue.encode({ value: message.guidelinesText }, writer.uint32(50).fork()).ldelim();
    }
    if (message.galleryMinItems !== void 0) {
      Int32Value.encode({ value: message.galleryMinItems }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.domainBlacklist) {
      StringValue.encode({ value: v }, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.domainWhitelist) {
      StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
    }
    if (message.titleTextMaxLength !== void 0) {
      Int32Value.encode({ value: message.titleTextMaxLength }, writer.uint32(82).fork()).ldelim();
    }
    if (message.bodyRestrictionPolicy !== void 0) {
      StringValue.encode({ value: message.bodyRestrictionPolicy }, writer.uint32(90).fork()).ldelim();
    }
    if (message.linkRestrictionPolicy !== void 0) {
      StringValue.encode({ value: message.linkRestrictionPolicy }, writer.uint32(98).fork()).ldelim();
    }
    if (message.guidelinesDisplayPolicy !== void 0) {
      StringValue.encode({ value: message.guidelinesDisplayPolicy }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.bodyRequiredStrings) {
      StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
    }
    if (message.titleTextMinLength !== void 0) {
      Int32Value.encode({ value: message.titleTextMinLength }, writer.uint32(122).fork()).ldelim();
    }
    if (message.galleryCaptionsRequirement !== void 0) {
      StringValue.encode({ value: message.galleryCaptionsRequirement }, writer.uint32(130).fork()).ldelim();
    }
    if (message.isFlairRequired !== void 0) {
      BoolValue.encode({ value: message.isFlairRequired }, writer.uint32(138).fork()).ldelim();
    }
    if (message.galleryMaxItems !== void 0) {
      Int32Value.encode({ value: message.galleryMaxItems }, writer.uint32(146).fork()).ldelim();
    }
    if (message.galleryUrlsRequirement !== void 0) {
      StringValue.encode({ value: message.galleryUrlsRequirement }, writer.uint32(154).fork()).ldelim();
    }
    for (const v of message.bodyRegexes) {
      StringValue.encode({ value: v }, writer.uint32(162).fork()).ldelim();
    }
    if (message.linkRepostAge !== void 0) {
      Int32Value.encode({ value: message.linkRepostAge }, writer.uint32(170).fork()).ldelim();
    }
    if (message.bodyTextMinLength !== void 0) {
      Int32Value.encode({ value: message.bodyTextMinLength }, writer.uint32(178).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditPostRequirementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.titleRegexes.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.bodyBlacklistedStrings.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.titleBlacklistedStrings.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.bodyTextMaxLength = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.titleRequiredStrings.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.guidelinesText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.galleryMinItems = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.domainBlacklist.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.domainWhitelist.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.titleTextMaxLength = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.bodyRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.linkRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.guidelinesDisplayPolicy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.bodyRequiredStrings.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.titleTextMinLength = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.galleryCaptionsRequirement = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.isFlairRequired = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.galleryMaxItems = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.galleryUrlsRequirement = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.bodyRegexes.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.linkRepostAge = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.bodyTextMinLength = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      titleRegexes: globalThis.Array.isArray(object?.titleRegexes) ? object.titleRegexes.map((e) => String(e)) : [],
      bodyBlacklistedStrings: globalThis.Array.isArray(object?.bodyBlacklistedStrings) ? object.bodyBlacklistedStrings.map((e) => String(e)) : [],
      titleBlacklistedStrings: globalThis.Array.isArray(object?.titleBlacklistedStrings) ? object.titleBlacklistedStrings.map((e) => String(e)) : [],
      bodyTextMaxLength: isSet122(object.bodyTextMaxLength) ? Number(object.bodyTextMaxLength) : void 0,
      titleRequiredStrings: globalThis.Array.isArray(object?.titleRequiredStrings) ? object.titleRequiredStrings.map((e) => String(e)) : [],
      guidelinesText: isSet122(object.guidelinesText) ? String(object.guidelinesText) : void 0,
      galleryMinItems: isSet122(object.galleryMinItems) ? Number(object.galleryMinItems) : void 0,
      domainBlacklist: globalThis.Array.isArray(object?.domainBlacklist) ? object.domainBlacklist.map((e) => String(e)) : [],
      domainWhitelist: globalThis.Array.isArray(object?.domainWhitelist) ? object.domainWhitelist.map((e) => String(e)) : [],
      titleTextMaxLength: isSet122(object.titleTextMaxLength) ? Number(object.titleTextMaxLength) : void 0,
      bodyRestrictionPolicy: isSet122(object.bodyRestrictionPolicy) ? String(object.bodyRestrictionPolicy) : void 0,
      linkRestrictionPolicy: isSet122(object.linkRestrictionPolicy) ? String(object.linkRestrictionPolicy) : void 0,
      guidelinesDisplayPolicy: isSet122(object.guidelinesDisplayPolicy) ? String(object.guidelinesDisplayPolicy) : void 0,
      bodyRequiredStrings: globalThis.Array.isArray(object?.bodyRequiredStrings) ? object.bodyRequiredStrings.map((e) => String(e)) : [],
      titleTextMinLength: isSet122(object.titleTextMinLength) ? Number(object.titleTextMinLength) : void 0,
      galleryCaptionsRequirement: isSet122(object.galleryCaptionsRequirement) ? String(object.galleryCaptionsRequirement) : void 0,
      isFlairRequired: isSet122(object.isFlairRequired) ? Boolean(object.isFlairRequired) : void 0,
      galleryMaxItems: isSet122(object.galleryMaxItems) ? Number(object.galleryMaxItems) : void 0,
      galleryUrlsRequirement: isSet122(object.galleryUrlsRequirement) ? String(object.galleryUrlsRequirement) : void 0,
      bodyRegexes: globalThis.Array.isArray(object?.bodyRegexes) ? object.bodyRegexes.map((e) => String(e)) : [],
      linkRepostAge: isSet122(object.linkRepostAge) ? Number(object.linkRepostAge) : void 0,
      bodyTextMinLength: isSet122(object.bodyTextMinLength) ? Number(object.bodyTextMinLength) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.titleRegexes?.length) {
      obj.titleRegexes = message.titleRegexes;
    }
    if (message.bodyBlacklistedStrings?.length) {
      obj.bodyBlacklistedStrings = message.bodyBlacklistedStrings;
    }
    if (message.titleBlacklistedStrings?.length) {
      obj.titleBlacklistedStrings = message.titleBlacklistedStrings;
    }
    if (message.bodyTextMaxLength !== void 0) {
      obj.bodyTextMaxLength = message.bodyTextMaxLength;
    }
    if (message.titleRequiredStrings?.length) {
      obj.titleRequiredStrings = message.titleRequiredStrings;
    }
    if (message.guidelinesText !== void 0) {
      obj.guidelinesText = message.guidelinesText;
    }
    if (message.galleryMinItems !== void 0) {
      obj.galleryMinItems = message.galleryMinItems;
    }
    if (message.domainBlacklist?.length) {
      obj.domainBlacklist = message.domainBlacklist;
    }
    if (message.domainWhitelist?.length) {
      obj.domainWhitelist = message.domainWhitelist;
    }
    if (message.titleTextMaxLength !== void 0) {
      obj.titleTextMaxLength = message.titleTextMaxLength;
    }
    if (message.bodyRestrictionPolicy !== void 0) {
      obj.bodyRestrictionPolicy = message.bodyRestrictionPolicy;
    }
    if (message.linkRestrictionPolicy !== void 0) {
      obj.linkRestrictionPolicy = message.linkRestrictionPolicy;
    }
    if (message.guidelinesDisplayPolicy !== void 0) {
      obj.guidelinesDisplayPolicy = message.guidelinesDisplayPolicy;
    }
    if (message.bodyRequiredStrings?.length) {
      obj.bodyRequiredStrings = message.bodyRequiredStrings;
    }
    if (message.titleTextMinLength !== void 0) {
      obj.titleTextMinLength = message.titleTextMinLength;
    }
    if (message.galleryCaptionsRequirement !== void 0) {
      obj.galleryCaptionsRequirement = message.galleryCaptionsRequirement;
    }
    if (message.isFlairRequired !== void 0) {
      obj.isFlairRequired = message.isFlairRequired;
    }
    if (message.galleryMaxItems !== void 0) {
      obj.galleryMaxItems = message.galleryMaxItems;
    }
    if (message.galleryUrlsRequirement !== void 0) {
      obj.galleryUrlsRequirement = message.galleryUrlsRequirement;
    }
    if (message.bodyRegexes?.length) {
      obj.bodyRegexes = message.bodyRegexes;
    }
    if (message.linkRepostAge !== void 0) {
      obj.linkRepostAge = message.linkRepostAge;
    }
    if (message.bodyTextMinLength !== void 0) {
      obj.bodyTextMinLength = message.bodyTextMinLength;
    }
    return obj;
  },
  create(base) {
    return SubredditPostRequirementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditPostRequirementsResponse();
    message.titleRegexes = object.titleRegexes?.map((e) => e) || [];
    message.bodyBlacklistedStrings = object.bodyBlacklistedStrings?.map((e) => e) || [];
    message.titleBlacklistedStrings = object.titleBlacklistedStrings?.map((e) => e) || [];
    message.bodyTextMaxLength = object.bodyTextMaxLength ?? void 0;
    message.titleRequiredStrings = object.titleRequiredStrings?.map((e) => e) || [];
    message.guidelinesText = object.guidelinesText ?? void 0;
    message.galleryMinItems = object.galleryMinItems ?? void 0;
    message.domainBlacklist = object.domainBlacklist?.map((e) => e) || [];
    message.domainWhitelist = object.domainWhitelist?.map((e) => e) || [];
    message.titleTextMaxLength = object.titleTextMaxLength ?? void 0;
    message.bodyRestrictionPolicy = object.bodyRestrictionPolicy ?? void 0;
    message.linkRestrictionPolicy = object.linkRestrictionPolicy ?? void 0;
    message.guidelinesDisplayPolicy = object.guidelinesDisplayPolicy ?? void 0;
    message.bodyRequiredStrings = object.bodyRequiredStrings?.map((e) => e) || [];
    message.titleTextMinLength = object.titleTextMinLength ?? void 0;
    message.galleryCaptionsRequirement = object.galleryCaptionsRequirement ?? void 0;
    message.isFlairRequired = object.isFlairRequired ?? void 0;
    message.galleryMaxItems = object.galleryMaxItems ?? void 0;
    message.galleryUrlsRequirement = object.galleryUrlsRequirement ?? void 0;
    message.bodyRegexes = object.bodyRegexes?.map((e) => e) || [];
    message.linkRepostAge = object.linkRepostAge ?? void 0;
    message.bodyTextMinLength = object.bodyTextMinLength ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditPostRequirementsResponse.$type, SubredditPostRequirementsResponse);
function createBaseSubredditAboutResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditAboutResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditAboutResponse_AboutData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = SubredditAboutResponse_AboutData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? SubredditAboutResponse_AboutData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = SubredditAboutResponse_AboutData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditAboutResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditAboutResponse_AboutData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutResponse.$type, SubredditAboutResponse);
function createBaseSubredditAboutResponse_AboutData() {
  return {
    userFlairBackgroundColor: void 0,
    submitTextHtml: void 0,
    restrictPosting: void 0,
    userIsBanned: void 0,
    freeFormReports: void 0,
    wikiEnabled: void 0,
    userIsMuted: void 0,
    userCanFlairInSr: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    allowGalleries: void 0,
    iconSize: void 0,
    primaryColor: void 0,
    activeUserCount: void 0,
    iconImg: void 0,
    displayNamePrefixed: void 0,
    accountsActive: void 0,
    publicTraffic: void 0,
    subscribers: void 0,
    userFlairRichtext: [],
    name: void 0,
    quarantine: void 0,
    hideAds: void 0,
    predictionLeaderboardEntryType: void 0,
    emojisEnabled: void 0,
    advertiserCategory: void 0,
    publicDescription: void 0,
    commentScoreHideMins: void 0,
    allowPredictions: void 0,
    userHasFavorited: void 0,
    userFlairTemplateId: void 0,
    communityIcon: void 0,
    bannerBackgroundImage: void 0,
    originalContentTagEnabled: void 0,
    communityReviewed: void 0,
    submitText: void 0,
    descriptionHtml: void 0,
    spoilersEnabled: void 0,
    commentContributionSettings: void 0,
    allowTalks: void 0,
    headerSize: void 0,
    userFlairPosition: void 0,
    allOriginalContent: void 0,
    collectionsEnabled: void 0,
    isEnrolledInNewModmail: void 0,
    keyColor: void 0,
    eventPostsEnabled: void 0,
    canAssignUserFlair: void 0,
    created: void 0,
    wls: void 0,
    showMediaPreview: void 0,
    submissionType: void 0,
    userIsSubscriber: void 0,
    allowedMediaInComments: [],
    allowVideogifs: void 0,
    shouldArchivePosts: void 0,
    userFlairType: void 0,
    allowPolls: void 0,
    collapseDeletedComments: void 0,
    coins: void 0,
    emojisCustomSize: void 0,
    publicDescriptionHtml: void 0,
    allowVideos: void 0,
    isCrosspostableSubreddit: void 0,
    notificationLevel: void 0,
    shouldShowMediaInCommentsSetting: void 0,
    canAssignLinkFlair: void 0,
    hasMenuWidget: void 0,
    accountsActiveIsFuzzed: void 0,
    allowPredictionContributors: void 0,
    submitTextLabel: void 0,
    linkFlairPosition: void 0,
    userSrFlairEnabled: void 0,
    userFlairEnabledInSr: void 0,
    allowChatPostCreation: void 0,
    allowDiscovery: void 0,
    acceptFollowers: void 0,
    userSrThemeEnabled: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    suggestedCommentSort: void 0,
    bannerImg: void 0,
    userFlairText: void 0,
    bannerBackgroundColor: void 0,
    showMedia: void 0,
    id: void 0,
    userIsModerator: void 0,
    over18: void 0,
    headerTitle: void 0,
    description: void 0,
    isChatPostFeatureEnabled: void 0,
    submitLinkLabel: void 0,
    userFlairTextColor: void 0,
    restrictCommenting: void 0,
    userFlairCssClass: void 0,
    allowImages: void 0,
    lang: void 0,
    whitelistStatus: void 0,
    url: void 0,
    createdUtc: void 0,
    bannerSize: void 0,
    mobileBannerImage: void 0,
    userIsContributor: void 0,
    allowPredictionsTournament: void 0
  };
}
var SubredditAboutResponse_AboutData = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse.AboutData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.userFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(26).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(34).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(42).fork()).ldelim();
    }
    if (message.wikiEnabled !== void 0) {
      BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(50).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(58).fork()).ldelim();
    }
    if (message.userCanFlairInSr !== void 0) {
      BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(66).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(74).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(82).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(90).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(98).fork()).ldelim();
    }
    if (message.iconSize !== void 0) {
      Int64Value.encode({ value: message.iconSize }, writer.uint32(106).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(114).fork()).ldelim();
    }
    if (message.activeUserCount !== void 0) {
      Int64Value.encode({ value: message.activeUserCount }, writer.uint32(122).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(130).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(138).fork()).ldelim();
    }
    if (message.accountsActive !== void 0) {
      Int64Value.encode({ value: message.accountsActive }, writer.uint32(146).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(154).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.userFlairRichtext) {
      UserFlairRichtext.encode(v, writer.uint32(170).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(178).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(186).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(194).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(202).fork()).ldelim();
    }
    if (message.emojisEnabled !== void 0) {
      BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(210).fork()).ldelim();
    }
    if (message.advertiserCategory !== void 0) {
      StringValue.encode({ value: message.advertiserCategory }, writer.uint32(218).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(226).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(234).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(242).fork()).ldelim();
    }
    if (message.userHasFavorited !== void 0) {
      BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(250).fork()).ldelim();
    }
    if (message.userFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(258).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(266).fork()).ldelim();
    }
    if (message.bannerBackgroundImage !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(274).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(282).fork()).ldelim();
    }
    if (message.communityReviewed !== void 0) {
      BoolValue.encode({ value: message.communityReviewed }, writer.uint32(290).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(298).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(306).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(314).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(322).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(330).fork()).ldelim();
    }
    if (message.headerSize !== void 0) {
      Int64Value.encode({ value: message.headerSize }, writer.uint32(338).fork()).ldelim();
    }
    if (message.userFlairPosition !== void 0) {
      StringValue.encode({ value: message.userFlairPosition }, writer.uint32(346).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(354).fork()).ldelim();
    }
    if (message.collectionsEnabled !== void 0) {
      BoolValue.encode({ value: message.collectionsEnabled }, writer.uint32(362).fork()).ldelim();
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(370).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(378).fork()).ldelim();
    }
    if (message.eventPostsEnabled !== void 0) {
      BoolValue.encode({ value: message.eventPostsEnabled }, writer.uint32(386).fork()).ldelim();
    }
    if (message.canAssignUserFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(394).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(402).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      StringValue.encode({ value: message.wls }, writer.uint32(410).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(418).fork()).ldelim();
    }
    if (message.submissionType !== void 0) {
      StringValue.encode({ value: message.submissionType }, writer.uint32(426).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(434).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(442).fork()).ldelim();
    }
    if (message.allowVideogifs !== void 0) {
      BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(450).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(458).fork()).ldelim();
    }
    if (message.userFlairType !== void 0) {
      StringValue.encode({ value: message.userFlairType }, writer.uint32(466).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(474).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(482).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int64Value.encode({ value: message.coins }, writer.uint32(490).fork()).ldelim();
    }
    if (message.emojisCustomSize !== void 0) {
      Int64Value.encode({ value: message.emojisCustomSize }, writer.uint32(498).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(506).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(514).fork()).ldelim();
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(522).fork()).ldelim();
    }
    if (message.notificationLevel !== void 0) {
      StringValue.encode({ value: message.notificationLevel }, writer.uint32(530).fork()).ldelim();
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(538).fork()).ldelim();
    }
    if (message.canAssignLinkFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(546).fork()).ldelim();
    }
    if (message.hasMenuWidget !== void 0) {
      BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(554).fork()).ldelim();
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(562).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(570).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(578).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(586).fork()).ldelim();
    }
    if (message.userSrFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(594).fork()).ldelim();
    }
    if (message.userFlairEnabledInSr !== void 0) {
      BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(602).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(610).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(618).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(626).fork()).ldelim();
    }
    if (message.userSrThemeEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(634).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(642).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(650).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(658).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(666).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(674).fork()).ldelim();
    }
    if (message.userFlairText !== void 0) {
      StringValue.encode({ value: message.userFlairText }, writer.uint32(682).fork()).ldelim();
    }
    if (message.bannerBackgroundColor !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(690).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(698).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(706).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(714).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(722).fork()).ldelim();
    }
    if (message.headerTitle !== void 0) {
      StringValue.encode({ value: message.headerTitle }, writer.uint32(730).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(738).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(746).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(754).fork()).ldelim();
    }
    if (message.userFlairTextColor !== void 0) {
      StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(762).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(770).fork()).ldelim();
    }
    if (message.userFlairCssClass !== void 0) {
      StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(778).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(786).fork()).ldelim();
    }
    if (message.lang !== void 0) {
      StringValue.encode({ value: message.lang }, writer.uint32(794).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      BoolValue.encode({ value: message.whitelistStatus }, writer.uint32(802).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(810).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(818).fork()).ldelim();
    }
    if (message.bannerSize !== void 0) {
      Int64Value.encode({ value: message.bannerSize }, writer.uint32(826).fork()).ldelim();
    }
    if (message.mobileBannerImage !== void 0) {
      StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(834).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(842).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(850).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutResponse_AboutData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.iconSize = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.activeUserCount = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.accountsActive = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.userFlairRichtext.push(UserFlairRichtext.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.headerSize = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.collectionsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.eventPostsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.wls = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.submissionType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.coins = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.emojisCustomSize = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }
          message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }
          message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 85:
          if (tag !== 682) {
            break;
          }
          message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 86:
          if (tag !== 690) {
            break;
          }
          message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 88:
          if (tag !== 706) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 89:
          if (tag !== 714) {
            break;
          }
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }
          message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 92:
          if (tag !== 738) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 94:
          if (tag !== 754) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 95:
          if (tag !== 762) {
            break;
          }
          message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }
          message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }
          message.lang = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.whitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.bannerSize = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userFlairBackgroundColor: isSet122(object.userFlairBackgroundColor) ? String(object.userFlairBackgroundColor) : void 0,
      submitTextHtml: isSet122(object.submitTextHtml) ? String(object.submitTextHtml) : void 0,
      restrictPosting: isSet122(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      userIsBanned: isSet122(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet122(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      wikiEnabled: isSet122(object.wikiEnabled) ? Boolean(object.wikiEnabled) : void 0,
      userIsMuted: isSet122(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      userCanFlairInSr: isSet122(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : void 0,
      displayName: isSet122(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet122(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet122(object.title) ? String(object.title) : void 0,
      allowGalleries: isSet122(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      iconSize: isSet122(object.iconSize) ? Number(object.iconSize) : void 0,
      primaryColor: isSet122(object.primaryColor) ? String(object.primaryColor) : void 0,
      activeUserCount: isSet122(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      displayNamePrefixed: isSet122(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      accountsActive: isSet122(object.accountsActive) ? Number(object.accountsActive) : void 0,
      publicTraffic: isSet122(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      subscribers: isSet122(object.subscribers) ? Number(object.subscribers) : void 0,
      userFlairRichtext: globalThis.Array.isArray(object?.userFlairRichtext) ? object.userFlairRichtext.map((e) => UserFlairRichtext.fromJSON(e)) : [],
      name: isSet122(object.name) ? String(object.name) : void 0,
      quarantine: isSet122(object.quarantine) ? Boolean(object.quarantine) : void 0,
      hideAds: isSet122(object.hideAds) ? Boolean(object.hideAds) : void 0,
      predictionLeaderboardEntryType: isSet122(object.predictionLeaderboardEntryType) ? String(object.predictionLeaderboardEntryType) : void 0,
      emojisEnabled: isSet122(object.emojisEnabled) ? Boolean(object.emojisEnabled) : void 0,
      advertiserCategory: isSet122(object.advertiserCategory) ? String(object.advertiserCategory) : void 0,
      publicDescription: isSet122(object.publicDescription) ? String(object.publicDescription) : void 0,
      commentScoreHideMins: isSet122(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      allowPredictions: isSet122(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      userHasFavorited: isSet122(object.userHasFavorited) ? Boolean(object.userHasFavorited) : void 0,
      userFlairTemplateId: isSet122(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : void 0,
      communityIcon: isSet122(object.communityIcon) ? String(object.communityIcon) : void 0,
      bannerBackgroundImage: isSet122(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : void 0,
      originalContentTagEnabled: isSet122(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : void 0,
      communityReviewed: isSet122(object.communityReviewed) ? Boolean(object.communityReviewed) : void 0,
      submitText: isSet122(object.submitText) ? String(object.submitText) : void 0,
      descriptionHtml: isSet122(object.descriptionHtml) ? String(object.descriptionHtml) : void 0,
      spoilersEnabled: isSet122(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      commentContributionSettings: isSet122(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      allowTalks: isSet122(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      headerSize: isSet122(object.headerSize) ? Number(object.headerSize) : void 0,
      userFlairPosition: isSet122(object.userFlairPosition) ? String(object.userFlairPosition) : void 0,
      allOriginalContent: isSet122(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      collectionsEnabled: isSet122(object.collectionsEnabled) ? Boolean(object.collectionsEnabled) : void 0,
      isEnrolledInNewModmail: isSet122(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : void 0,
      keyColor: isSet122(object.keyColor) ? String(object.keyColor) : void 0,
      eventPostsEnabled: isSet122(object.eventPostsEnabled) ? Boolean(object.eventPostsEnabled) : void 0,
      canAssignUserFlair: isSet122(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : void 0,
      created: isSet122(object.created) ? Number(object.created) : void 0,
      wls: isSet122(object.wls) ? String(object.wls) : void 0,
      showMediaPreview: isSet122(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      submissionType: isSet122(object.submissionType) ? String(object.submissionType) : void 0,
      userIsSubscriber: isSet122(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      allowedMediaInComments: globalThis.Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      allowVideogifs: isSet122(object.allowVideogifs) ? Boolean(object.allowVideogifs) : void 0,
      shouldArchivePosts: isSet122(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      userFlairType: isSet122(object.userFlairType) ? String(object.userFlairType) : void 0,
      allowPolls: isSet122(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      collapseDeletedComments: isSet122(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      coins: isSet122(object.coins) ? Number(object.coins) : void 0,
      emojisCustomSize: isSet122(object.emojisCustomSize) ? Number(object.emojisCustomSize) : void 0,
      publicDescriptionHtml: isSet122(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      allowVideos: isSet122(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      isCrosspostableSubreddit: isSet122(object.isCrosspostableSubreddit) ? Boolean(object.isCrosspostableSubreddit) : void 0,
      notificationLevel: isSet122(object.notificationLevel) ? String(object.notificationLevel) : void 0,
      shouldShowMediaInCommentsSetting: isSet122(object.shouldShowMediaInCommentsSetting) ? Boolean(object.shouldShowMediaInCommentsSetting) : void 0,
      canAssignLinkFlair: isSet122(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : void 0,
      hasMenuWidget: isSet122(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : void 0,
      accountsActiveIsFuzzed: isSet122(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : void 0,
      allowPredictionContributors: isSet122(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      submitTextLabel: isSet122(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      linkFlairPosition: isSet122(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      userSrFlairEnabled: isSet122(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : void 0,
      userFlairEnabledInSr: isSet122(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : void 0,
      allowChatPostCreation: isSet122(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowDiscovery: isSet122(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      userSrThemeEnabled: isSet122(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : void 0,
      linkFlairEnabled: isSet122(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet122(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet122(object.subredditType) ? String(object.subredditType) : void 0,
      suggestedCommentSort: isSet122(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : void 0,
      bannerImg: isSet122(object.bannerImg) ? String(object.bannerImg) : void 0,
      userFlairText: isSet122(object.userFlairText) ? String(object.userFlairText) : void 0,
      bannerBackgroundColor: isSet122(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : void 0,
      showMedia: isSet122(object.showMedia) ? Boolean(object.showMedia) : void 0,
      id: isSet122(object.id) ? String(object.id) : void 0,
      userIsModerator: isSet122(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      over18: isSet122(object.over18) ? Boolean(object.over18) : void 0,
      headerTitle: isSet122(object.headerTitle) ? String(object.headerTitle) : void 0,
      description: isSet122(object.description) ? String(object.description) : void 0,
      isChatPostFeatureEnabled: isSet122(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      submitLinkLabel: isSet122(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      userFlairTextColor: isSet122(object.userFlairTextColor) ? String(object.userFlairTextColor) : void 0,
      restrictCommenting: isSet122(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      userFlairCssClass: isSet122(object.userFlairCssClass) ? String(object.userFlairCssClass) : void 0,
      allowImages: isSet122(object.allowImages) ? Boolean(object.allowImages) : void 0,
      lang: isSet122(object.lang) ? String(object.lang) : void 0,
      whitelistStatus: isSet122(object.whitelistStatus) ? Boolean(object.whitelistStatus) : void 0,
      url: isSet122(object.url) ? String(object.url) : void 0,
      createdUtc: isSet122(object.createdUtc) ? Number(object.createdUtc) : void 0,
      bannerSize: isSet122(object.bannerSize) ? Number(object.bannerSize) : void 0,
      mobileBannerImage: isSet122(object.mobileBannerImage) ? String(object.mobileBannerImage) : void 0,
      userIsContributor: isSet122(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      allowPredictionsTournament: isSet122(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userFlairBackgroundColor !== void 0) {
      obj.userFlairBackgroundColor = message.userFlairBackgroundColor;
    }
    if (message.submitTextHtml !== void 0) {
      obj.submitTextHtml = message.submitTextHtml;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.userIsBanned !== void 0) {
      obj.userIsBanned = message.userIsBanned;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.wikiEnabled !== void 0) {
      obj.wikiEnabled = message.wikiEnabled;
    }
    if (message.userIsMuted !== void 0) {
      obj.userIsMuted = message.userIsMuted;
    }
    if (message.userCanFlairInSr !== void 0) {
      obj.userCanFlairInSr = message.userCanFlairInSr;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.headerImg !== void 0) {
      obj.headerImg = message.headerImg;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.allowGalleries !== void 0) {
      obj.allowGalleries = message.allowGalleries;
    }
    if (message.iconSize !== void 0) {
      obj.iconSize = message.iconSize;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.activeUserCount !== void 0) {
      obj.activeUserCount = message.activeUserCount;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.displayNamePrefixed !== void 0) {
      obj.displayNamePrefixed = message.displayNamePrefixed;
    }
    if (message.accountsActive !== void 0) {
      obj.accountsActive = message.accountsActive;
    }
    if (message.publicTraffic !== void 0) {
      obj.publicTraffic = message.publicTraffic;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.userFlairRichtext?.length) {
      obj.userFlairRichtext = message.userFlairRichtext.map((e) => UserFlairRichtext.toJSON(e));
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.hideAds !== void 0) {
      obj.hideAds = message.hideAds;
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType;
    }
    if (message.emojisEnabled !== void 0) {
      obj.emojisEnabled = message.emojisEnabled;
    }
    if (message.advertiserCategory !== void 0) {
      obj.advertiserCategory = message.advertiserCategory;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.commentScoreHideMins !== void 0) {
      obj.commentScoreHideMins = message.commentScoreHideMins;
    }
    if (message.allowPredictions !== void 0) {
      obj.allowPredictions = message.allowPredictions;
    }
    if (message.userHasFavorited !== void 0) {
      obj.userHasFavorited = message.userHasFavorited;
    }
    if (message.userFlairTemplateId !== void 0) {
      obj.userFlairTemplateId = message.userFlairTemplateId;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.bannerBackgroundImage !== void 0) {
      obj.bannerBackgroundImage = message.bannerBackgroundImage;
    }
    if (message.originalContentTagEnabled !== void 0) {
      obj.originalContentTagEnabled = message.originalContentTagEnabled;
    }
    if (message.communityReviewed !== void 0) {
      obj.communityReviewed = message.communityReviewed;
    }
    if (message.submitText !== void 0) {
      obj.submitText = message.submitText;
    }
    if (message.descriptionHtml !== void 0) {
      obj.descriptionHtml = message.descriptionHtml;
    }
    if (message.spoilersEnabled !== void 0) {
      obj.spoilersEnabled = message.spoilersEnabled;
    }
    if (message.commentContributionSettings !== void 0) {
      obj.commentContributionSettings = CommentContributionSettings.toJSON(message.commentContributionSettings);
    }
    if (message.allowTalks !== void 0) {
      obj.allowTalks = message.allowTalks;
    }
    if (message.headerSize !== void 0) {
      obj.headerSize = message.headerSize;
    }
    if (message.userFlairPosition !== void 0) {
      obj.userFlairPosition = message.userFlairPosition;
    }
    if (message.allOriginalContent !== void 0) {
      obj.allOriginalContent = message.allOriginalContent;
    }
    if (message.collectionsEnabled !== void 0) {
      obj.collectionsEnabled = message.collectionsEnabled;
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.eventPostsEnabled !== void 0) {
      obj.eventPostsEnabled = message.eventPostsEnabled;
    }
    if (message.canAssignUserFlair !== void 0) {
      obj.canAssignUserFlair = message.canAssignUserFlair;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.wls !== void 0) {
      obj.wls = message.wls;
    }
    if (message.showMediaPreview !== void 0) {
      obj.showMediaPreview = message.showMediaPreview;
    }
    if (message.submissionType !== void 0) {
      obj.submissionType = message.submissionType;
    }
    if (message.userIsSubscriber !== void 0) {
      obj.userIsSubscriber = message.userIsSubscriber;
    }
    if (message.allowedMediaInComments?.length) {
      obj.allowedMediaInComments = message.allowedMediaInComments;
    }
    if (message.allowVideogifs !== void 0) {
      obj.allowVideogifs = message.allowVideogifs;
    }
    if (message.shouldArchivePosts !== void 0) {
      obj.shouldArchivePosts = message.shouldArchivePosts;
    }
    if (message.userFlairType !== void 0) {
      obj.userFlairType = message.userFlairType;
    }
    if (message.allowPolls !== void 0) {
      obj.allowPolls = message.allowPolls;
    }
    if (message.collapseDeletedComments !== void 0) {
      obj.collapseDeletedComments = message.collapseDeletedComments;
    }
    if (message.coins !== void 0) {
      obj.coins = message.coins;
    }
    if (message.emojisCustomSize !== void 0) {
      obj.emojisCustomSize = message.emojisCustomSize;
    }
    if (message.publicDescriptionHtml !== void 0) {
      obj.publicDescriptionHtml = message.publicDescriptionHtml;
    }
    if (message.allowVideos !== void 0) {
      obj.allowVideos = message.allowVideos;
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit;
    }
    if (message.notificationLevel !== void 0) {
      obj.notificationLevel = message.notificationLevel;
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting;
    }
    if (message.canAssignLinkFlair !== void 0) {
      obj.canAssignLinkFlair = message.canAssignLinkFlair;
    }
    if (message.hasMenuWidget !== void 0) {
      obj.hasMenuWidget = message.hasMenuWidget;
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed;
    }
    if (message.allowPredictionContributors !== void 0) {
      obj.allowPredictionContributors = message.allowPredictionContributors;
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.linkFlairPosition !== void 0) {
      obj.linkFlairPosition = message.linkFlairPosition;
    }
    if (message.userSrFlairEnabled !== void 0) {
      obj.userSrFlairEnabled = message.userSrFlairEnabled;
    }
    if (message.userFlairEnabledInSr !== void 0) {
      obj.userFlairEnabledInSr = message.userFlairEnabledInSr;
    }
    if (message.allowChatPostCreation !== void 0) {
      obj.allowChatPostCreation = message.allowChatPostCreation;
    }
    if (message.allowDiscovery !== void 0) {
      obj.allowDiscovery = message.allowDiscovery;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.userSrThemeEnabled !== void 0) {
      obj.userSrThemeEnabled = message.userSrThemeEnabled;
    }
    if (message.linkFlairEnabled !== void 0) {
      obj.linkFlairEnabled = message.linkFlairEnabled;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.suggestedCommentSort !== void 0) {
      obj.suggestedCommentSort = message.suggestedCommentSort;
    }
    if (message.bannerImg !== void 0) {
      obj.bannerImg = message.bannerImg;
    }
    if (message.userFlairText !== void 0) {
      obj.userFlairText = message.userFlairText;
    }
    if (message.bannerBackgroundColor !== void 0) {
      obj.bannerBackgroundColor = message.bannerBackgroundColor;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.userIsModerator !== void 0) {
      obj.userIsModerator = message.userIsModerator;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.headerTitle !== void 0) {
      obj.headerTitle = message.headerTitle;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.userFlairTextColor !== void 0) {
      obj.userFlairTextColor = message.userFlairTextColor;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.userFlairCssClass !== void 0) {
      obj.userFlairCssClass = message.userFlairCssClass;
    }
    if (message.allowImages !== void 0) {
      obj.allowImages = message.allowImages;
    }
    if (message.lang !== void 0) {
      obj.lang = message.lang;
    }
    if (message.whitelistStatus !== void 0) {
      obj.whitelistStatus = message.whitelistStatus;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.bannerSize !== void 0) {
      obj.bannerSize = message.bannerSize;
    }
    if (message.mobileBannerImage !== void 0) {
      obj.mobileBannerImage = message.mobileBannerImage;
    }
    if (message.userIsContributor !== void 0) {
      obj.userIsContributor = message.userIsContributor;
    }
    if (message.allowPredictionsTournament !== void 0) {
      obj.allowPredictionsTournament = message.allowPredictionsTournament;
    }
    return obj;
  },
  create(base) {
    return SubredditAboutResponse_AboutData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutResponse_AboutData();
    message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.wikiEnabled = object.wikiEnabled ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.userCanFlairInSr = object.userCanFlairInSr ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.iconSize = object.iconSize ?? void 0;
    message.primaryColor = object.primaryColor ?? void 0;
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.accountsActive = object.accountsActive ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.userFlairRichtext = object.userFlairRichtext?.map((e) => UserFlairRichtext.fromPartial(e)) || [];
    message.name = object.name ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.emojisEnabled = object.emojisEnabled ?? void 0;
    message.advertiserCategory = object.advertiserCategory ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.userHasFavorited = object.userHasFavorited ?? void 0;
    message.userFlairTemplateId = object.userFlairTemplateId ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.bannerBackgroundImage = object.bannerBackgroundImage ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.communityReviewed = object.communityReviewed ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.headerSize = object.headerSize ?? void 0;
    message.userFlairPosition = object.userFlairPosition ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.collectionsEnabled = object.collectionsEnabled ?? void 0;
    message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.eventPostsEnabled = object.eventPostsEnabled ?? void 0;
    message.canAssignUserFlair = object.canAssignUserFlair ?? void 0;
    message.created = object.created ?? void 0;
    message.wls = object.wls ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.submissionType = object.submissionType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.allowVideogifs = object.allowVideogifs ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.userFlairType = object.userFlairType ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.coins = object.coins ?? void 0;
    message.emojisCustomSize = object.emojisCustomSize ?? void 0;
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? void 0;
    message.notificationLevel = object.notificationLevel ?? void 0;
    message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? void 0;
    message.canAssignLinkFlair = object.canAssignLinkFlair ?? void 0;
    message.hasMenuWidget = object.hasMenuWidget ?? void 0;
    message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.userSrFlairEnabled = object.userSrFlairEnabled ?? void 0;
    message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.userSrThemeEnabled = object.userSrThemeEnabled ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.userFlairText = object.userFlairText ?? void 0;
    message.bannerBackgroundColor = object.bannerBackgroundColor ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.id = object.id ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.headerTitle = object.headerTitle ?? void 0;
    message.description = object.description ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.userFlairTextColor = object.userFlairTextColor ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.userFlairCssClass = object.userFlairCssClass ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.lang = object.lang ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.url = object.url ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.bannerSize = object.bannerSize ?? void 0;
    message.mobileBannerImage = object.mobileBannerImage ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutResponse_AboutData.$type, SubredditAboutResponse_AboutData);
function createBaseSubredditAboutEditResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditAboutEditResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditAboutEditResponse_SubredditSettings.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutEditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = SubredditAboutEditResponse_SubredditSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? SubredditAboutEditResponse_SubredditSettings.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = SubredditAboutEditResponse_SubredditSettings.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditAboutEditResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutEditResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditAboutEditResponse_SubredditSettings.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutEditResponse.$type, SubredditAboutEditResponse);
function createBaseSubredditAboutEditResponse_SubredditSettings() {
  return {
    defaultSet: void 0,
    toxicityThresholdChatLevel: void 0,
    crowdControlChatLevel: void 0,
    restrictPosting: void 0,
    publicDescription: void 0,
    subredditId: void 0,
    allowImages: void 0,
    freeFormReports: void 0,
    domain: void 0,
    originalContentTagEnabled: void 0,
    showMedia: void 0,
    excludeBannedModqueue: void 0,
    shouldArchivePosts: void 0,
    submitText: void 0,
    spamLinks: void 0,
    title: void 0,
    collapseDeletedComments: void 0,
    wikimode: void 0,
    over18: void 0,
    allowVideos: void 0,
    allowGalleries: void 0,
    crowdControlLevel: void 0,
    banEvasionThreshold: void 0,
    crowdControlMode: void 0,
    welcomeMessageEnabled: void 0,
    welcomeMessageText: void 0,
    suggestedCommentSort: void 0,
    disableContributorRequests: void 0,
    allowTalks: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    spoilersEnabled: void 0,
    allowPostCrossposts: void 0,
    spamComments: void 0,
    publicTraffic: void 0,
    restrictCommenting: void 0,
    allowPolls: void 0,
    commentContributionSettings: void 0,
    submitTextLabel: void 0,
    commentScoreHideMins: void 0,
    allOriginalContent: void 0,
    spamSelfposts: void 0,
    keyColor: void 0,
    language: void 0,
    newPinnedPostPnsEnabled: void 0,
    hideAds: void 0,
    predictionLeaderboardEntryType: void 0,
    headerHoverText: void 0,
    wikiEditAge: void 0,
    allowChatPostCreation: void 0,
    allowPredictionContributors: void 0,
    allowDiscovery: void 0,
    acceptFollowers: void 0,
    crowdControlPostLevel: void 0,
    allowPredictionsTournament: void 0,
    wikiEditKarma: void 0,
    showMediaPreview: void 0,
    crowdControlFilter: void 0,
    subredditType: void 0,
    allowPredictions: void 0,
    userFlairPnsEnabled: void 0,
    contentOptions: void 0
  };
}
var SubredditAboutEditResponse_SubredditSettings = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse.SubredditSettings",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.toxicityThresholdChatLevel !== void 0) {
      Int32Value.encode({ value: message.toxicityThresholdChatLevel }, writer.uint32(18).fork()).ldelim();
    }
    if (message.crowdControlChatLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlChatLevel }, writer.uint32(26).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(34).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(42).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(58).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(66).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(74).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(82).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(90).fork()).ldelim();
    }
    if (message.excludeBannedModqueue !== void 0) {
      BoolValue.encode({ value: message.excludeBannedModqueue }, writer.uint32(98).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(106).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(114).fork()).ldelim();
    }
    if (message.spamLinks !== void 0) {
      StringValue.encode({ value: message.spamLinks }, writer.uint32(122).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(130).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(138).fork()).ldelim();
    }
    if (message.wikimode !== void 0) {
      StringValue.encode({ value: message.wikimode }, writer.uint32(146).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(154).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(162).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(170).fork()).ldelim();
    }
    if (message.crowdControlLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlLevel }, writer.uint32(178).fork()).ldelim();
    }
    if (message.banEvasionThreshold !== void 0) {
      Int32Value.encode({ value: message.banEvasionThreshold }, writer.uint32(186).fork()).ldelim();
    }
    if (message.crowdControlMode !== void 0) {
      BoolValue.encode({ value: message.crowdControlMode }, writer.uint32(194).fork()).ldelim();
    }
    if (message.welcomeMessageEnabled !== void 0) {
      BoolValue.encode({ value: message.welcomeMessageEnabled }, writer.uint32(202).fork()).ldelim();
    }
    if (message.welcomeMessageText !== void 0) {
      StringValue.encode({ value: message.welcomeMessageText }, writer.uint32(210).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      BoolValue.encode({ value: message.suggestedCommentSort }, writer.uint32(218).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(226).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(234).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(242).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(250).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(258).fork()).ldelim();
    }
    if (message.allowPostCrossposts !== void 0) {
      BoolValue.encode({ value: message.allowPostCrossposts }, writer.uint32(266).fork()).ldelim();
    }
    if (message.spamComments !== void 0) {
      StringValue.encode({ value: message.spamComments }, writer.uint32(274).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(282).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(290).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(298).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(306).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(314).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(322).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(330).fork()).ldelim();
    }
    if (message.spamSelfposts !== void 0) {
      StringValue.encode({ value: message.spamSelfposts }, writer.uint32(338).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(346).fork()).ldelim();
    }
    if (message.language !== void 0) {
      StringValue.encode({ value: message.language }, writer.uint32(354).fork()).ldelim();
    }
    if (message.newPinnedPostPnsEnabled !== void 0) {
      BoolValue.encode({ value: message.newPinnedPostPnsEnabled }, writer.uint32(362).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(370).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      Int32Value.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(378).fork()).ldelim();
    }
    if (message.headerHoverText !== void 0) {
      StringValue.encode({ value: message.headerHoverText }, writer.uint32(386).fork()).ldelim();
    }
    if (message.wikiEditAge !== void 0) {
      Int32Value.encode({ value: message.wikiEditAge }, writer.uint32(394).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(402).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(410).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(418).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(426).fork()).ldelim();
    }
    if (message.crowdControlPostLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlPostLevel }, writer.uint32(434).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(442).fork()).ldelim();
    }
    if (message.wikiEditKarma !== void 0) {
      Int32Value.encode({ value: message.wikiEditKarma }, writer.uint32(450).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(458).fork()).ldelim();
    }
    if (message.crowdControlFilter !== void 0) {
      BoolValue.encode({ value: message.crowdControlFilter }, writer.uint32(466).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(474).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(482).fork()).ldelim();
    }
    if (message.userFlairPnsEnabled !== void 0) {
      BoolValue.encode({ value: message.userFlairPnsEnabled }, writer.uint32(490).fork()).ldelim();
    }
    if (message.contentOptions !== void 0) {
      StringValue.encode({ value: message.contentOptions }, writer.uint32(498).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutEditResponse_SubredditSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.toxicityThresholdChatLevel = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.crowdControlChatLevel = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.excludeBannedModqueue = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.spamLinks = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.wikimode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.crowdControlLevel = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.banEvasionThreshold = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.crowdControlMode = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.welcomeMessageEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.welcomeMessageText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.suggestedCommentSort = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.allowPostCrossposts = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.spamComments = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.spamSelfposts = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.language = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.newPinnedPostPnsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.predictionLeaderboardEntryType = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.headerHoverText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.wikiEditAge = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.crowdControlPostLevel = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.wikiEditKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.crowdControlFilter = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.userFlairPnsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.contentOptions = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet122(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      toxicityThresholdChatLevel: isSet122(object.toxicityThresholdChatLevel) ? Number(object.toxicityThresholdChatLevel) : void 0,
      crowdControlChatLevel: isSet122(object.crowdControlChatLevel) ? Number(object.crowdControlChatLevel) : void 0,
      restrictPosting: isSet122(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      publicDescription: isSet122(object.publicDescription) ? String(object.publicDescription) : void 0,
      subredditId: isSet122(object.subredditId) ? String(object.subredditId) : void 0,
      allowImages: isSet122(object.allowImages) ? Boolean(object.allowImages) : void 0,
      freeFormReports: isSet122(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      domain: isSet122(object.domain) ? String(object.domain) : void 0,
      originalContentTagEnabled: isSet122(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : void 0,
      showMedia: isSet122(object.showMedia) ? Boolean(object.showMedia) : void 0,
      excludeBannedModqueue: isSet122(object.excludeBannedModqueue) ? Boolean(object.excludeBannedModqueue) : void 0,
      shouldArchivePosts: isSet122(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      submitText: isSet122(object.submitText) ? String(object.submitText) : void 0,
      spamLinks: isSet122(object.spamLinks) ? String(object.spamLinks) : void 0,
      title: isSet122(object.title) ? String(object.title) : void 0,
      collapseDeletedComments: isSet122(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      wikimode: isSet122(object.wikimode) ? String(object.wikimode) : void 0,
      over18: isSet122(object.over18) ? Boolean(object.over18) : void 0,
      allowVideos: isSet122(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      allowGalleries: isSet122(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      crowdControlLevel: isSet122(object.crowdControlLevel) ? Number(object.crowdControlLevel) : void 0,
      banEvasionThreshold: isSet122(object.banEvasionThreshold) ? Number(object.banEvasionThreshold) : void 0,
      crowdControlMode: isSet122(object.crowdControlMode) ? Boolean(object.crowdControlMode) : void 0,
      welcomeMessageEnabled: isSet122(object.welcomeMessageEnabled) ? Boolean(object.welcomeMessageEnabled) : void 0,
      welcomeMessageText: isSet122(object.welcomeMessageText) ? String(object.welcomeMessageText) : void 0,
      suggestedCommentSort: isSet122(object.suggestedCommentSort) ? Boolean(object.suggestedCommentSort) : void 0,
      disableContributorRequests: isSet122(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      allowTalks: isSet122(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      description: isSet122(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet122(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      spoilersEnabled: isSet122(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      allowPostCrossposts: isSet122(object.allowPostCrossposts) ? Boolean(object.allowPostCrossposts) : void 0,
      spamComments: isSet122(object.spamComments) ? String(object.spamComments) : void 0,
      publicTraffic: isSet122(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      restrictCommenting: isSet122(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      allowPolls: isSet122(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      commentContributionSettings: isSet122(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      submitTextLabel: isSet122(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      commentScoreHideMins: isSet122(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      allOriginalContent: isSet122(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      spamSelfposts: isSet122(object.spamSelfposts) ? String(object.spamSelfposts) : void 0,
      keyColor: isSet122(object.keyColor) ? String(object.keyColor) : void 0,
      language: isSet122(object.language) ? String(object.language) : void 0,
      newPinnedPostPnsEnabled: isSet122(object.newPinnedPostPnsEnabled) ? Boolean(object.newPinnedPostPnsEnabled) : void 0,
      hideAds: isSet122(object.hideAds) ? Boolean(object.hideAds) : void 0,
      predictionLeaderboardEntryType: isSet122(object.predictionLeaderboardEntryType) ? Number(object.predictionLeaderboardEntryType) : void 0,
      headerHoverText: isSet122(object.headerHoverText) ? String(object.headerHoverText) : void 0,
      wikiEditAge: isSet122(object.wikiEditAge) ? Number(object.wikiEditAge) : void 0,
      allowChatPostCreation: isSet122(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowPredictionContributors: isSet122(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      allowDiscovery: isSet122(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      crowdControlPostLevel: isSet122(object.crowdControlPostLevel) ? Number(object.crowdControlPostLevel) : void 0,
      allowPredictionsTournament: isSet122(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0,
      wikiEditKarma: isSet122(object.wikiEditKarma) ? Number(object.wikiEditKarma) : void 0,
      showMediaPreview: isSet122(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      crowdControlFilter: isSet122(object.crowdControlFilter) ? Boolean(object.crowdControlFilter) : void 0,
      subredditType: isSet122(object.subredditType) ? String(object.subredditType) : void 0,
      allowPredictions: isSet122(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      userFlairPnsEnabled: isSet122(object.userFlairPnsEnabled) ? Boolean(object.userFlairPnsEnabled) : void 0,
      contentOptions: isSet122(object.contentOptions) ? String(object.contentOptions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.defaultSet !== void 0) {
      obj.defaultSet = message.defaultSet;
    }
    if (message.toxicityThresholdChatLevel !== void 0) {
      obj.toxicityThresholdChatLevel = message.toxicityThresholdChatLevel;
    }
    if (message.crowdControlChatLevel !== void 0) {
      obj.crowdControlChatLevel = message.crowdControlChatLevel;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.allowImages !== void 0) {
      obj.allowImages = message.allowImages;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.domain !== void 0) {
      obj.domain = message.domain;
    }
    if (message.originalContentTagEnabled !== void 0) {
      obj.originalContentTagEnabled = message.originalContentTagEnabled;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.excludeBannedModqueue !== void 0) {
      obj.excludeBannedModqueue = message.excludeBannedModqueue;
    }
    if (message.shouldArchivePosts !== void 0) {
      obj.shouldArchivePosts = message.shouldArchivePosts;
    }
    if (message.submitText !== void 0) {
      obj.submitText = message.submitText;
    }
    if (message.spamLinks !== void 0) {
      obj.spamLinks = message.spamLinks;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.collapseDeletedComments !== void 0) {
      obj.collapseDeletedComments = message.collapseDeletedComments;
    }
    if (message.wikimode !== void 0) {
      obj.wikimode = message.wikimode;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.allowVideos !== void 0) {
      obj.allowVideos = message.allowVideos;
    }
    if (message.allowGalleries !== void 0) {
      obj.allowGalleries = message.allowGalleries;
    }
    if (message.crowdControlLevel !== void 0) {
      obj.crowdControlLevel = message.crowdControlLevel;
    }
    if (message.banEvasionThreshold !== void 0) {
      obj.banEvasionThreshold = message.banEvasionThreshold;
    }
    if (message.crowdControlMode !== void 0) {
      obj.crowdControlMode = message.crowdControlMode;
    }
    if (message.welcomeMessageEnabled !== void 0) {
      obj.welcomeMessageEnabled = message.welcomeMessageEnabled;
    }
    if (message.welcomeMessageText !== void 0) {
      obj.welcomeMessageText = message.welcomeMessageText;
    }
    if (message.suggestedCommentSort !== void 0) {
      obj.suggestedCommentSort = message.suggestedCommentSort;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.allowTalks !== void 0) {
      obj.allowTalks = message.allowTalks;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.spoilersEnabled !== void 0) {
      obj.spoilersEnabled = message.spoilersEnabled;
    }
    if (message.allowPostCrossposts !== void 0) {
      obj.allowPostCrossposts = message.allowPostCrossposts;
    }
    if (message.spamComments !== void 0) {
      obj.spamComments = message.spamComments;
    }
    if (message.publicTraffic !== void 0) {
      obj.publicTraffic = message.publicTraffic;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.allowPolls !== void 0) {
      obj.allowPolls = message.allowPolls;
    }
    if (message.commentContributionSettings !== void 0) {
      obj.commentContributionSettings = CommentContributionSettings.toJSON(message.commentContributionSettings);
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.commentScoreHideMins !== void 0) {
      obj.commentScoreHideMins = message.commentScoreHideMins;
    }
    if (message.allOriginalContent !== void 0) {
      obj.allOriginalContent = message.allOriginalContent;
    }
    if (message.spamSelfposts !== void 0) {
      obj.spamSelfposts = message.spamSelfposts;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.language !== void 0) {
      obj.language = message.language;
    }
    if (message.newPinnedPostPnsEnabled !== void 0) {
      obj.newPinnedPostPnsEnabled = message.newPinnedPostPnsEnabled;
    }
    if (message.hideAds !== void 0) {
      obj.hideAds = message.hideAds;
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType;
    }
    if (message.headerHoverText !== void 0) {
      obj.headerHoverText = message.headerHoverText;
    }
    if (message.wikiEditAge !== void 0) {
      obj.wikiEditAge = message.wikiEditAge;
    }
    if (message.allowChatPostCreation !== void 0) {
      obj.allowChatPostCreation = message.allowChatPostCreation;
    }
    if (message.allowPredictionContributors !== void 0) {
      obj.allowPredictionContributors = message.allowPredictionContributors;
    }
    if (message.allowDiscovery !== void 0) {
      obj.allowDiscovery = message.allowDiscovery;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.crowdControlPostLevel !== void 0) {
      obj.crowdControlPostLevel = message.crowdControlPostLevel;
    }
    if (message.allowPredictionsTournament !== void 0) {
      obj.allowPredictionsTournament = message.allowPredictionsTournament;
    }
    if (message.wikiEditKarma !== void 0) {
      obj.wikiEditKarma = message.wikiEditKarma;
    }
    if (message.showMediaPreview !== void 0) {
      obj.showMediaPreview = message.showMediaPreview;
    }
    if (message.crowdControlFilter !== void 0) {
      obj.crowdControlFilter = message.crowdControlFilter;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.allowPredictions !== void 0) {
      obj.allowPredictions = message.allowPredictions;
    }
    if (message.userFlairPnsEnabled !== void 0) {
      obj.userFlairPnsEnabled = message.userFlairPnsEnabled;
    }
    if (message.contentOptions !== void 0) {
      obj.contentOptions = message.contentOptions;
    }
    return obj;
  },
  create(base) {
    return SubredditAboutEditResponse_SubredditSettings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutEditResponse_SubredditSettings();
    message.defaultSet = object.defaultSet ?? void 0;
    message.toxicityThresholdChatLevel = object.toxicityThresholdChatLevel ?? void 0;
    message.crowdControlChatLevel = object.crowdControlChatLevel ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.domain = object.domain ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.excludeBannedModqueue = object.excludeBannedModqueue ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.spamLinks = object.spamLinks ?? void 0;
    message.title = object.title ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.wikimode = object.wikimode ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.crowdControlLevel = object.crowdControlLevel ?? void 0;
    message.banEvasionThreshold = object.banEvasionThreshold ?? void 0;
    message.crowdControlMode = object.crowdControlMode ?? void 0;
    message.welcomeMessageEnabled = object.welcomeMessageEnabled ?? void 0;
    message.welcomeMessageText = object.welcomeMessageText ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.allowPostCrossposts = object.allowPostCrossposts ?? void 0;
    message.spamComments = object.spamComments ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.spamSelfposts = object.spamSelfposts ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.language = object.language ?? void 0;
    message.newPinnedPostPnsEnabled = object.newPinnedPostPnsEnabled ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.headerHoverText = object.headerHoverText ?? void 0;
    message.wikiEditAge = object.wikiEditAge ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.crowdControlPostLevel = object.crowdControlPostLevel ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    message.wikiEditKarma = object.wikiEditKarma ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.crowdControlFilter = object.crowdControlFilter ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.userFlairPnsEnabled = object.userFlairPnsEnabled ?? void 0;
    message.contentOptions = object.contentOptions ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutEditResponse_SubredditSettings.$type, SubredditAboutEditResponse_SubredditSettings);
function createBaseSubredditAboutRulesResponse() {
  return { rules: [], siteRules: [], siteRulesFlow: [] };
}
var SubredditAboutRulesResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.rules) {
      SubredditAboutRulesResponse_SubredditRule.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.siteRules) {
      StringValue.encode({ value: v }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.siteRulesFlow) {
      SubredditAboutRulesResponse_RuleFlow.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.rules.push(SubredditAboutRulesResponse_SubredditRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.siteRules.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.siteRulesFlow.push(SubredditAboutRulesResponse_RuleFlow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e) => SubredditAboutRulesResponse_SubredditRule.fromJSON(e)) : [],
      siteRules: globalThis.Array.isArray(object?.siteRules) ? object.siteRules.map((e) => String(e)) : [],
      siteRulesFlow: globalThis.Array.isArray(object?.siteRulesFlow) ? object.siteRulesFlow.map((e) => SubredditAboutRulesResponse_RuleFlow.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => SubredditAboutRulesResponse_SubredditRule.toJSON(e));
    }
    if (message.siteRules?.length) {
      obj.siteRules = message.siteRules;
    }
    if (message.siteRulesFlow?.length) {
      obj.siteRulesFlow = message.siteRulesFlow.map((e) => SubredditAboutRulesResponse_RuleFlow.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SubredditAboutRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutRulesResponse();
    message.rules = object.rules?.map((e) => SubredditAboutRulesResponse_SubredditRule.fromPartial(e)) || [];
    message.siteRules = object.siteRules?.map((e) => e) || [];
    message.siteRulesFlow = object.siteRulesFlow?.map((e) => SubredditAboutRulesResponse_RuleFlow.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutRulesResponse.$type, SubredditAboutRulesResponse);
function createBaseSubredditAboutRulesResponse_SubredditRule() {
  return {
    kind: void 0,
    description: void 0,
    shortName: void 0,
    violationReason: void 0,
    createdUtc: void 0,
    priority: void 0,
    descriptionHtml: void 0
  };
}
var SubredditAboutRulesResponse_SubredditRule = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.SubredditRule",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(18).fork()).ldelim();
    }
    if (message.shortName !== void 0) {
      StringValue.encode({ value: message.shortName }, writer.uint32(26).fork()).ldelim();
    }
    if (message.violationReason !== void 0) {
      StringValue.encode({ value: message.violationReason }, writer.uint32(34).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(42).fork()).ldelim();
    }
    if (message.priority !== void 0) {
      Int32Value.encode({ value: message.priority }, writer.uint32(50).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutRulesResponse_SubredditRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.shortName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.violationReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.priority = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      description: isSet122(object.description) ? String(object.description) : void 0,
      shortName: isSet122(object.shortName) ? String(object.shortName) : void 0,
      violationReason: isSet122(object.violationReason) ? String(object.violationReason) : void 0,
      createdUtc: isSet122(object.createdUtc) ? Number(object.createdUtc) : void 0,
      priority: isSet122(object.priority) ? Number(object.priority) : void 0,
      descriptionHtml: isSet122(object.descriptionHtml) ? String(object.descriptionHtml) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.shortName !== void 0) {
      obj.shortName = message.shortName;
    }
    if (message.violationReason !== void 0) {
      obj.violationReason = message.violationReason;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.priority !== void 0) {
      obj.priority = message.priority;
    }
    if (message.descriptionHtml !== void 0) {
      obj.descriptionHtml = message.descriptionHtml;
    }
    return obj;
  },
  create(base) {
    return SubredditAboutRulesResponse_SubredditRule.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutRulesResponse_SubredditRule();
    message.kind = object.kind ?? void 0;
    message.description = object.description ?? void 0;
    message.shortName = object.shortName ?? void 0;
    message.violationReason = object.violationReason ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.priority = object.priority ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutRulesResponse_SubredditRule.$type, SubredditAboutRulesResponse_SubredditRule);
function createBaseSubredditAboutRulesResponse_RuleFlow() {
  return {
    reasonTextToShow: void 0,
    reasonText: void 0,
    nextStepHeader: void 0,
    nextStepReasons: [],
    complaintButtonText: void 0,
    complaintUrl: void 0,
    complaintPageTitle: void 0,
    fileComplaint: void 0,
    complaintPrompt: void 0,
    canWriteNotes: void 0,
    isAbuseOfReportButton: void 0,
    notesInputTitle: void 0,
    usernamesInputTitle: void 0,
    canSpecifyUsernames: void 0,
    requestCrisisSupport: void 0,
    oneUsername: void 0
  };
}
var SubredditAboutRulesResponse_RuleFlow = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.RuleFlow",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.reasonTextToShow !== void 0) {
      StringValue.encode({ value: message.reasonTextToShow }, writer.uint32(10).fork()).ldelim();
    }
    if (message.reasonText !== void 0) {
      StringValue.encode({ value: message.reasonText }, writer.uint32(18).fork()).ldelim();
    }
    if (message.nextStepHeader !== void 0) {
      StringValue.encode({ value: message.nextStepHeader }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.nextStepReasons) {
      SubredditAboutRulesResponse_RuleFlow.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.complaintButtonText !== void 0) {
      StringValue.encode({ value: message.complaintButtonText }, writer.uint32(42).fork()).ldelim();
    }
    if (message.complaintUrl !== void 0) {
      StringValue.encode({ value: message.complaintUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.complaintPageTitle !== void 0) {
      StringValue.encode({ value: message.complaintPageTitle }, writer.uint32(58).fork()).ldelim();
    }
    if (message.fileComplaint !== void 0) {
      BoolValue.encode({ value: message.fileComplaint }, writer.uint32(66).fork()).ldelim();
    }
    if (message.complaintPrompt !== void 0) {
      StringValue.encode({ value: message.complaintPrompt }, writer.uint32(74).fork()).ldelim();
    }
    if (message.canWriteNotes !== void 0) {
      BoolValue.encode({ value: message.canWriteNotes }, writer.uint32(82).fork()).ldelim();
    }
    if (message.isAbuseOfReportButton !== void 0) {
      BoolValue.encode({ value: message.isAbuseOfReportButton }, writer.uint32(90).fork()).ldelim();
    }
    if (message.notesInputTitle !== void 0) {
      StringValue.encode({ value: message.notesInputTitle }, writer.uint32(98).fork()).ldelim();
    }
    if (message.usernamesInputTitle !== void 0) {
      StringValue.encode({ value: message.usernamesInputTitle }, writer.uint32(106).fork()).ldelim();
    }
    if (message.canSpecifyUsernames !== void 0) {
      BoolValue.encode({ value: message.canSpecifyUsernames }, writer.uint32(114).fork()).ldelim();
    }
    if (message.requestCrisisSupport !== void 0) {
      BoolValue.encode({ value: message.requestCrisisSupport }, writer.uint32(122).fork()).ldelim();
    }
    if (message.oneUsername !== void 0) {
      BoolValue.encode({ value: message.oneUsername }, writer.uint32(130).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutRulesResponse_RuleFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.reasonTextToShow = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reasonText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.nextStepHeader = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.nextStepReasons.push(SubredditAboutRulesResponse_RuleFlow.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.complaintButtonText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.complaintUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.complaintPageTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.fileComplaint = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.complaintPrompt = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.canWriteNotes = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.isAbuseOfReportButton = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.notesInputTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.usernamesInputTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.canSpecifyUsernames = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.requestCrisisSupport = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.oneUsername = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      reasonTextToShow: isSet122(object.reasonTextToShow) ? String(object.reasonTextToShow) : void 0,
      reasonText: isSet122(object.reasonText) ? String(object.reasonText) : void 0,
      nextStepHeader: isSet122(object.nextStepHeader) ? String(object.nextStepHeader) : void 0,
      nextStepReasons: globalThis.Array.isArray(object?.nextStepReasons) ? object.nextStepReasons.map((e) => SubredditAboutRulesResponse_RuleFlow.fromJSON(e)) : [],
      complaintButtonText: isSet122(object.complaintButtonText) ? String(object.complaintButtonText) : void 0,
      complaintUrl: isSet122(object.complaintUrl) ? String(object.complaintUrl) : void 0,
      complaintPageTitle: isSet122(object.complaintPageTitle) ? String(object.complaintPageTitle) : void 0,
      fileComplaint: isSet122(object.fileComplaint) ? Boolean(object.fileComplaint) : void 0,
      complaintPrompt: isSet122(object.complaintPrompt) ? String(object.complaintPrompt) : void 0,
      canWriteNotes: isSet122(object.canWriteNotes) ? Boolean(object.canWriteNotes) : void 0,
      isAbuseOfReportButton: isSet122(object.isAbuseOfReportButton) ? Boolean(object.isAbuseOfReportButton) : void 0,
      notesInputTitle: isSet122(object.notesInputTitle) ? String(object.notesInputTitle) : void 0,
      usernamesInputTitle: isSet122(object.usernamesInputTitle) ? String(object.usernamesInputTitle) : void 0,
      canSpecifyUsernames: isSet122(object.canSpecifyUsernames) ? Boolean(object.canSpecifyUsernames) : void 0,
      requestCrisisSupport: isSet122(object.requestCrisisSupport) ? Boolean(object.requestCrisisSupport) : void 0,
      oneUsername: isSet122(object.oneUsername) ? Boolean(object.oneUsername) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.reasonTextToShow !== void 0) {
      obj.reasonTextToShow = message.reasonTextToShow;
    }
    if (message.reasonText !== void 0) {
      obj.reasonText = message.reasonText;
    }
    if (message.nextStepHeader !== void 0) {
      obj.nextStepHeader = message.nextStepHeader;
    }
    if (message.nextStepReasons?.length) {
      obj.nextStepReasons = message.nextStepReasons.map((e) => SubredditAboutRulesResponse_RuleFlow.toJSON(e));
    }
    if (message.complaintButtonText !== void 0) {
      obj.complaintButtonText = message.complaintButtonText;
    }
    if (message.complaintUrl !== void 0) {
      obj.complaintUrl = message.complaintUrl;
    }
    if (message.complaintPageTitle !== void 0) {
      obj.complaintPageTitle = message.complaintPageTitle;
    }
    if (message.fileComplaint !== void 0) {
      obj.fileComplaint = message.fileComplaint;
    }
    if (message.complaintPrompt !== void 0) {
      obj.complaintPrompt = message.complaintPrompt;
    }
    if (message.canWriteNotes !== void 0) {
      obj.canWriteNotes = message.canWriteNotes;
    }
    if (message.isAbuseOfReportButton !== void 0) {
      obj.isAbuseOfReportButton = message.isAbuseOfReportButton;
    }
    if (message.notesInputTitle !== void 0) {
      obj.notesInputTitle = message.notesInputTitle;
    }
    if (message.usernamesInputTitle !== void 0) {
      obj.usernamesInputTitle = message.usernamesInputTitle;
    }
    if (message.canSpecifyUsernames !== void 0) {
      obj.canSpecifyUsernames = message.canSpecifyUsernames;
    }
    if (message.requestCrisisSupport !== void 0) {
      obj.requestCrisisSupport = message.requestCrisisSupport;
    }
    if (message.oneUsername !== void 0) {
      obj.oneUsername = message.oneUsername;
    }
    return obj;
  },
  create(base) {
    return SubredditAboutRulesResponse_RuleFlow.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutRulesResponse_RuleFlow();
    message.reasonTextToShow = object.reasonTextToShow ?? void 0;
    message.reasonText = object.reasonText ?? void 0;
    message.nextStepHeader = object.nextStepHeader ?? void 0;
    message.nextStepReasons = object.nextStepReasons?.map((e) => SubredditAboutRulesResponse_RuleFlow.fromPartial(e)) || [];
    message.complaintButtonText = object.complaintButtonText ?? void 0;
    message.complaintUrl = object.complaintUrl ?? void 0;
    message.complaintPageTitle = object.complaintPageTitle ?? void 0;
    message.fileComplaint = object.fileComplaint ?? void 0;
    message.complaintPrompt = object.complaintPrompt ?? void 0;
    message.canWriteNotes = object.canWriteNotes ?? void 0;
    message.isAbuseOfReportButton = object.isAbuseOfReportButton ?? void 0;
    message.notesInputTitle = object.notesInputTitle ?? void 0;
    message.usernamesInputTitle = object.usernamesInputTitle ?? void 0;
    message.canSpecifyUsernames = object.canSpecifyUsernames ?? void 0;
    message.requestCrisisSupport = object.requestCrisisSupport ?? void 0;
    message.oneUsername = object.oneUsername ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutRulesResponse_RuleFlow.$type, SubredditAboutRulesResponse_RuleFlow);
function createBaseSubredditAboutTrafficResponse() {
  return { day: [], hour: [], month: [] };
}
var SubredditAboutTrafficResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.day) {
      SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.hour) {
      SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.month) {
      SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutTrafficResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.day.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.hour.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.month.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      day: globalThis.Array.isArray(object?.day) ? object.day.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : [],
      hour: globalThis.Array.isArray(object?.hour) ? object.hour.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : [],
      month: globalThis.Array.isArray(object?.month) ? object.month.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.day?.length) {
      obj.day = message.day.map((e) => SubredditAboutTrafficResponse_Data.toJSON(e));
    }
    if (message.hour?.length) {
      obj.hour = message.hour.map((e) => SubredditAboutTrafficResponse_Data.toJSON(e));
    }
    if (message.month?.length) {
      obj.month = message.month.map((e) => SubredditAboutTrafficResponse_Data.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SubredditAboutTrafficResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutTrafficResponse();
    message.day = object.day?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
    message.hour = object.hour?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
    message.month = object.month?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutTrafficResponse.$type, SubredditAboutTrafficResponse);
function createBaseSubredditAboutTrafficResponse_Data() {
  return { values: [] };
}
var SubredditAboutTrafficResponse_Data = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse.Data",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    for (const v of message.values) {
      Int64Value.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutTrafficResponse_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.values.push(Int64Value.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => Number(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return SubredditAboutTrafficResponse_Data.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutTrafficResponse_Data();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditAboutTrafficResponse_Data.$type, SubredditAboutTrafficResponse_Data);
function createBaseStickyResponse() {
  return { kind: void 0, data: void 0 };
}
var StickyResponse = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      StickyResponse_StickyResponseData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = StickyResponse_StickyResponseData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? StickyResponse_StickyResponseData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = StickyResponse_StickyResponseData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return StickyResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStickyResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? StickyResponse_StickyResponseData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StickyResponse.$type, StickyResponse);
function createBaseStickyResponse_LinkData() {
  return {
    authorFlairBackgroundColor: void 0,
    approvedAtUtc: void 0,
    subreddit: void 0,
    selftext: void 0,
    userReports: [],
    saved: void 0,
    modReasonTitle: void 0,
    gilded: void 0,
    clicked: void 0,
    title: void 0,
    linkFlairRichtext: [],
    subredditNamePrefixed: void 0,
    hidden: void 0,
    pwls: void 0,
    linkFlairCssClass: void 0,
    downs: void 0,
    thumbnailHeight: void 0,
    topAwardedType: void 0,
    parentWhitelistStatus: void 0,
    hideScore: void 0,
    name: void 0,
    quarantine: void 0,
    linkFlairTextColor: void 0,
    upvoteRatio: void 0,
    ignoreReports: void 0,
    ups: void 0,
    domain: void 0,
    mediaEmbed: void 0,
    thumbnailWidth: void 0,
    authorFlairTemplateId: void 0,
    isOriginalContent: void 0,
    authorFullname: void 0,
    secureMedia: void 0,
    isRedditMediaDomain: void 0,
    isMeta: void 0,
    category: void 0,
    secureMediaEmbed: void 0,
    linkFlairText: void 0,
    canModPost: void 0,
    score: void 0,
    approvedBy: void 0,
    isCreatedFromAdsUi: void 0,
    authorPremium: void 0,
    thumbnail: void 0,
    edited: void 0,
    authorFlairCssClass: void 0,
    previousVisits: [],
    authorFlairRichtext: [],
    gildings: void 0,
    contentCategories: void 0,
    isSelf: void 0,
    subredditType: void 0,
    created: void 0,
    linkFlairType: void 0,
    wls: void 0,
    removedByCategory: void 0,
    bannedBy: void 0,
    authorFlairType: void 0,
    totalAwardsReceived: void 0,
    allowLiveComments: void 0,
    selftextHtml: void 0,
    likes: void 0,
    suggestedSort: void 0,
    bannedAtUtc: void 0,
    viewCount: void 0,
    archived: void 0,
    noFollow: void 0,
    spam: void 0,
    isCrosspostable: void 0,
    pinned: void 0,
    over18: void 0,
    allAwardings: [],
    awarders: [],
    mediaOnly: void 0,
    canGild: void 0,
    removed: void 0,
    spoiler: void 0,
    locked: void 0,
    authorFlairText: void 0,
    treatmentTags: [],
    rteMode: void 0,
    visited: void 0,
    removedBy: void 0,
    modNote: void 0,
    distinguished: void 0,
    subredditId: void 0,
    authorIsBlocked: void 0,
    modReasonBy: void 0,
    numReports: void 0,
    removalReason: void 0,
    linkFlairBackgroundColor: void 0,
    id: void 0,
    isRobotIndexable: void 0,
    numDuplicates: void 0,
    reportReasons: [],
    author: void 0,
    discussionType: void 0,
    numComments: void 0,
    sendReplies: void 0,
    media: void 0,
    contestMode: void 0,
    authorPatreonFlair: void 0,
    approved: void 0,
    authorFlairTextColor: void 0,
    permalink: void 0,
    whitelistStatus: void 0,
    stickied: void 0,
    url: void 0,
    subredditSubscribers: void 0,
    createdUtc: void 0,
    numCrossposts: void 0,
    modReports: [],
    isVideo: void 0
  };
}
var StickyResponse_LinkData = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse.LinkData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(26).fork()).ldelim();
    }
    if (message.selftext !== void 0) {
      StringValue.encode({ value: message.selftext }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.userReports) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(50).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(58).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int64Value.encode({ value: message.gilded }, writer.uint32(66).fork()).ldelim();
    }
    if (message.clicked !== void 0) {
      BoolValue.encode({ value: message.clicked }, writer.uint32(74).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.linkFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(90).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(98).fork()).ldelim();
    }
    if (message.hidden !== void 0) {
      BoolValue.encode({ value: message.hidden }, writer.uint32(106).fork()).ldelim();
    }
    if (message.pwls !== void 0) {
      StringValue.encode({ value: message.pwls }, writer.uint32(114).fork()).ldelim();
    }
    if (message.linkFlairCssClass !== void 0) {
      StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(122).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int64Value.encode({ value: message.downs }, writer.uint32(130).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(138).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(146).fork()).ldelim();
    }
    if (message.parentWhitelistStatus !== void 0) {
      BoolValue.encode({ value: message.parentWhitelistStatus }, writer.uint32(154).fork()).ldelim();
    }
    if (message.hideScore !== void 0) {
      BoolValue.encode({ value: message.hideScore }, writer.uint32(162).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(170).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(178).fork()).ldelim();
    }
    if (message.linkFlairTextColor !== void 0) {
      StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(186).fork()).ldelim();
    }
    if (message.upvoteRatio !== void 0) {
      Int64Value.encode({ value: message.upvoteRatio }, writer.uint32(194).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(202).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int64Value.encode({ value: message.ups }, writer.uint32(210).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(218).fork()).ldelim();
    }
    if (message.mediaEmbed !== void 0) {
      MediaEmbed.encode(message.mediaEmbed, writer.uint32(226).fork()).ldelim();
    }
    if (message.thumbnailWidth !== void 0) {
      Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(234).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isOriginalContent !== void 0) {
      BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(250).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(258).fork()).ldelim();
    }
    if (message.secureMedia !== void 0) {
      BoolValue.encode({ value: message.secureMedia }, writer.uint32(266).fork()).ldelim();
    }
    if (message.isRedditMediaDomain !== void 0) {
      BoolValue.encode({ value: message.isRedditMediaDomain }, writer.uint32(274).fork()).ldelim();
    }
    if (message.isMeta !== void 0) {
      BoolValue.encode({ value: message.isMeta }, writer.uint32(282).fork()).ldelim();
    }
    if (message.category !== void 0) {
      StringValue.encode({ value: message.category }, writer.uint32(290).fork()).ldelim();
    }
    if (message.secureMediaEmbed !== void 0) {
      MediaEmbed.encode(message.secureMediaEmbed, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairText !== void 0) {
      StringValue.encode({ value: message.linkFlairText }, writer.uint32(306).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(314).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int64Value.encode({ value: message.score }, writer.uint32(322).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(330).fork()).ldelim();
    }
    if (message.isCreatedFromAdsUi !== void 0) {
      BoolValue.encode({ value: message.isCreatedFromAdsUi }, writer.uint32(338).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(346).fork()).ldelim();
    }
    if (message.thumbnail !== void 0) {
      StringValue.encode({ value: message.thumbnail }, writer.uint32(354).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(362).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(370).fork()).ldelim();
    }
    for (const v of message.previousVisits) {
      Int64Value.encode({ value: v }, writer.uint32(378).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(386).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Any.encode(message.gildings, writer.uint32(394).fork()).ldelim();
    }
    if (message.contentCategories !== void 0) {
      StringValue.encode({ value: message.contentCategories }, writer.uint32(402).fork()).ldelim();
    }
    if (message.isSelf !== void 0) {
      BoolValue.encode({ value: message.isSelf }, writer.uint32(410).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(418).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(426).fork()).ldelim();
    }
    if (message.linkFlairType !== void 0) {
      StringValue.encode({ value: message.linkFlairType }, writer.uint32(434).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      StringValue.encode({ value: message.wls }, writer.uint32(442).fork()).ldelim();
    }
    if (message.removedByCategory !== void 0) {
      StringValue.encode({ value: message.removedByCategory }, writer.uint32(450).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(458).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(466).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int64Value.encode({ value: message.totalAwardsReceived }, writer.uint32(474).fork()).ldelim();
    }
    if (message.allowLiveComments !== void 0) {
      BoolValue.encode({ value: message.allowLiveComments }, writer.uint32(482).fork()).ldelim();
    }
    if (message.selftextHtml !== void 0) {
      StringValue.encode({ value: message.selftextHtml }, writer.uint32(490).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(498).fork()).ldelim();
    }
    if (message.suggestedSort !== void 0) {
      StringValue.encode({ value: message.suggestedSort }, writer.uint32(506).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(514).fork()).ldelim();
    }
    if (message.viewCount !== void 0) {
      Int32Value.encode({ value: message.viewCount }, writer.uint32(522).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(530).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(538).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(546).fork()).ldelim();
    }
    if (message.isCrosspostable !== void 0) {
      BoolValue.encode({ value: message.isCrosspostable }, writer.uint32(554).fork()).ldelim();
    }
    if (message.pinned !== void 0) {
      BoolValue.encode({ value: message.pinned }, writer.uint32(562).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(570).fork()).ldelim();
    }
    for (const v of message.allAwardings) {
      Any.encode(v, writer.uint32(578).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(586).fork()).ldelim();
    }
    if (message.mediaOnly !== void 0) {
      BoolValue.encode({ value: message.mediaOnly }, writer.uint32(594).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(602).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(610).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      BoolValue.encode({ value: message.spoiler }, writer.uint32(618).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(626).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(634).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      Any.encode(v, writer.uint32(642).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(650).fork()).ldelim();
    }
    if (message.visited !== void 0) {
      BoolValue.encode({ value: message.visited }, writer.uint32(658).fork()).ldelim();
    }
    if (message.removedBy !== void 0) {
      StringValue.encode({ value: message.removedBy }, writer.uint32(666).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(674).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(682).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(690).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(698).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(706).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int64Value.encode({ value: message.numReports }, writer.uint32(714).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(722).fork()).ldelim();
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(730).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(738).fork()).ldelim();
    }
    if (message.isRobotIndexable !== void 0) {
      BoolValue.encode({ value: message.isRobotIndexable }, writer.uint32(746).fork()).ldelim();
    }
    if (message.numDuplicates !== void 0) {
      Int32Value.encode({ value: message.numDuplicates }, writer.uint32(754).fork()).ldelim();
    }
    for (const v of message.reportReasons) {
      Any.encode(v, writer.uint32(762).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(770).fork()).ldelim();
    }
    if (message.discussionType !== void 0) {
      StringValue.encode({ value: message.discussionType }, writer.uint32(778).fork()).ldelim();
    }
    if (message.numComments !== void 0) {
      Int64Value.encode({ value: message.numComments }, writer.uint32(786).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(794).fork()).ldelim();
    }
    if (message.media !== void 0) {
      StringValue.encode({ value: message.media }, writer.uint32(802).fork()).ldelim();
    }
    if (message.contestMode !== void 0) {
      BoolValue.encode({ value: message.contestMode }, writer.uint32(810).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(818).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(826).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(834).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(842).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      BoolValue.encode({ value: message.whitelistStatus }, writer.uint32(850).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(858).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(866).fork()).ldelim();
    }
    if (message.subredditSubscribers !== void 0) {
      Int64Value.encode({ value: message.subredditSubscribers }, writer.uint32(874).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(882).fork()).ldelim();
    }
    if (message.numCrossposts !== void 0) {
      Int64Value.encode({ value: message.numCrossposts }, writer.uint32(890).fork()).ldelim();
    }
    for (const v of message.modReports) {
      Any.encode(v, writer.uint32(898).fork()).ldelim();
    }
    if (message.isVideo !== void 0) {
      BoolValue.encode({ value: message.isVideo }, writer.uint32(906).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse_LinkData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.selftext = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.userReports.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.gilded = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.clicked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.linkFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.hidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.pwls = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.downs = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.parentWhitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.hideScore = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.upvoteRatio = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.ups = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.mediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.secureMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.isRedditMediaDomain = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.isMeta = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.category = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.secureMediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.score = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.isCreatedFromAdsUi = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.previousVisits.push(Int64Value.decode(reader, reader.uint32()).value);
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.authorFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.gildings = Any.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.contentCategories = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.isSelf = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.wls = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.totalAwardsReceived = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.allowLiveComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.suggestedSort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.viewCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.isCrosspostable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.pinned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.allAwardings.push(Any.decode(reader, reader.uint32()));
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.mediaOnly = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.treatmentTags.push(Any.decode(reader, reader.uint32()));
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }
          message.visited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }
          message.removedBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 85:
          if (tag !== 682) {
            break;
          }
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 86:
          if (tag !== 690) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 88:
          if (tag !== 706) {
            break;
          }
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 89:
          if (tag !== 714) {
            break;
          }
          message.numReports = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }
          message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 92:
          if (tag !== 738) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }
          message.isRobotIndexable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 94:
          if (tag !== 754) {
            break;
          }
          message.numDuplicates = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 95:
          if (tag !== 762) {
            break;
          }
          message.reportReasons.push(Any.decode(reader, reader.uint32()));
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }
          message.author = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }
          message.discussionType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }
          message.numComments = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.media = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.contestMode = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.whitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }
          message.subredditSubscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }
          message.numCrossposts = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 112:
          if (tag !== 898) {
            break;
          }
          message.modReports.push(Any.decode(reader, reader.uint32()));
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }
          message.isVideo = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorFlairBackgroundColor: isSet122(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      approvedAtUtc: isSet122(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      subreddit: isSet122(object.subreddit) ? String(object.subreddit) : void 0,
      selftext: isSet122(object.selftext) ? String(object.selftext) : void 0,
      userReports: globalThis.Array.isArray(object?.userReports) ? object.userReports.map((e) => String(e)) : [],
      saved: isSet122(object.saved) ? Boolean(object.saved) : void 0,
      modReasonTitle: isSet122(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      gilded: isSet122(object.gilded) ? Number(object.gilded) : void 0,
      clicked: isSet122(object.clicked) ? Boolean(object.clicked) : void 0,
      title: isSet122(object.title) ? String(object.title) : void 0,
      linkFlairRichtext: globalThis.Array.isArray(object?.linkFlairRichtext) ? object.linkFlairRichtext.map((e) => String(e)) : [],
      subredditNamePrefixed: isSet122(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      hidden: isSet122(object.hidden) ? Boolean(object.hidden) : void 0,
      pwls: isSet122(object.pwls) ? String(object.pwls) : void 0,
      linkFlairCssClass: isSet122(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : void 0,
      downs: isSet122(object.downs) ? Number(object.downs) : void 0,
      thumbnailHeight: isSet122(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      topAwardedType: isSet122(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      parentWhitelistStatus: isSet122(object.parentWhitelistStatus) ? Boolean(object.parentWhitelistStatus) : void 0,
      hideScore: isSet122(object.hideScore) ? Boolean(object.hideScore) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      quarantine: isSet122(object.quarantine) ? Boolean(object.quarantine) : void 0,
      linkFlairTextColor: isSet122(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : void 0,
      upvoteRatio: isSet122(object.upvoteRatio) ? Number(object.upvoteRatio) : void 0,
      ignoreReports: isSet122(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      ups: isSet122(object.ups) ? Number(object.ups) : void 0,
      domain: isSet122(object.domain) ? String(object.domain) : void 0,
      mediaEmbed: isSet122(object.mediaEmbed) ? MediaEmbed.fromJSON(object.mediaEmbed) : void 0,
      thumbnailWidth: isSet122(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      authorFlairTemplateId: isSet122(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      isOriginalContent: isSet122(object.isOriginalContent) ? Boolean(object.isOriginalContent) : void 0,
      authorFullname: isSet122(object.authorFullname) ? String(object.authorFullname) : void 0,
      secureMedia: isSet122(object.secureMedia) ? Boolean(object.secureMedia) : void 0,
      isRedditMediaDomain: isSet122(object.isRedditMediaDomain) ? Boolean(object.isRedditMediaDomain) : void 0,
      isMeta: isSet122(object.isMeta) ? Boolean(object.isMeta) : void 0,
      category: isSet122(object.category) ? String(object.category) : void 0,
      secureMediaEmbed: isSet122(object.secureMediaEmbed) ? MediaEmbed.fromJSON(object.secureMediaEmbed) : void 0,
      linkFlairText: isSet122(object.linkFlairText) ? String(object.linkFlairText) : void 0,
      canModPost: isSet122(object.canModPost) ? Boolean(object.canModPost) : void 0,
      score: isSet122(object.score) ? Number(object.score) : void 0,
      approvedBy: isSet122(object.approvedBy) ? String(object.approvedBy) : void 0,
      isCreatedFromAdsUi: isSet122(object.isCreatedFromAdsUi) ? Boolean(object.isCreatedFromAdsUi) : void 0,
      authorPremium: isSet122(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      thumbnail: isSet122(object.thumbnail) ? String(object.thumbnail) : void 0,
      edited: isSet122(object.edited) ? Boolean(object.edited) : void 0,
      authorFlairCssClass: isSet122(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      previousVisits: globalThis.Array.isArray(object?.previousVisits) ? object.previousVisits.map((e) => Number(e)) : [],
      authorFlairRichtext: globalThis.Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => String(e)) : [],
      gildings: isSet122(object.gildings) ? Any.fromJSON(object.gildings) : void 0,
      contentCategories: isSet122(object.contentCategories) ? String(object.contentCategories) : void 0,
      isSelf: isSet122(object.isSelf) ? Boolean(object.isSelf) : void 0,
      subredditType: isSet122(object.subredditType) ? String(object.subredditType) : void 0,
      created: isSet122(object.created) ? Number(object.created) : void 0,
      linkFlairType: isSet122(object.linkFlairType) ? String(object.linkFlairType) : void 0,
      wls: isSet122(object.wls) ? String(object.wls) : void 0,
      removedByCategory: isSet122(object.removedByCategory) ? String(object.removedByCategory) : void 0,
      bannedBy: isSet122(object.bannedBy) ? String(object.bannedBy) : void 0,
      authorFlairType: isSet122(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      totalAwardsReceived: isSet122(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      allowLiveComments: isSet122(object.allowLiveComments) ? Boolean(object.allowLiveComments) : void 0,
      selftextHtml: isSet122(object.selftextHtml) ? String(object.selftextHtml) : void 0,
      likes: isSet122(object.likes) ? Boolean(object.likes) : void 0,
      suggestedSort: isSet122(object.suggestedSort) ? String(object.suggestedSort) : void 0,
      bannedAtUtc: isSet122(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      viewCount: isSet122(object.viewCount) ? Number(object.viewCount) : void 0,
      archived: isSet122(object.archived) ? Boolean(object.archived) : void 0,
      noFollow: isSet122(object.noFollow) ? Boolean(object.noFollow) : void 0,
      spam: isSet122(object.spam) ? Boolean(object.spam) : void 0,
      isCrosspostable: isSet122(object.isCrosspostable) ? Boolean(object.isCrosspostable) : void 0,
      pinned: isSet122(object.pinned) ? Boolean(object.pinned) : void 0,
      over18: isSet122(object.over18) ? Boolean(object.over18) : void 0,
      allAwardings: globalThis.Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Any.fromJSON(e)) : [],
      awarders: globalThis.Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      mediaOnly: isSet122(object.mediaOnly) ? Boolean(object.mediaOnly) : void 0,
      canGild: isSet122(object.canGild) ? Boolean(object.canGild) : void 0,
      removed: isSet122(object.removed) ? Boolean(object.removed) : void 0,
      spoiler: isSet122(object.spoiler) ? Boolean(object.spoiler) : void 0,
      locked: isSet122(object.locked) ? Boolean(object.locked) : void 0,
      authorFlairText: isSet122(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      treatmentTags: globalThis.Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => Any.fromJSON(e)) : [],
      rteMode: isSet122(object.rteMode) ? String(object.rteMode) : void 0,
      visited: isSet122(object.visited) ? Boolean(object.visited) : void 0,
      removedBy: isSet122(object.removedBy) ? String(object.removedBy) : void 0,
      modNote: isSet122(object.modNote) ? String(object.modNote) : void 0,
      distinguished: isSet122(object.distinguished) ? String(object.distinguished) : void 0,
      subredditId: isSet122(object.subredditId) ? String(object.subredditId) : void 0,
      authorIsBlocked: isSet122(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      modReasonBy: isSet122(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      numReports: isSet122(object.numReports) ? Number(object.numReports) : void 0,
      removalReason: isSet122(object.removalReason) ? String(object.removalReason) : void 0,
      linkFlairBackgroundColor: isSet122(object.linkFlairBackgroundColor) ? String(object.linkFlairBackgroundColor) : void 0,
      id: isSet122(object.id) ? String(object.id) : void 0,
      isRobotIndexable: isSet122(object.isRobotIndexable) ? Boolean(object.isRobotIndexable) : void 0,
      numDuplicates: isSet122(object.numDuplicates) ? Number(object.numDuplicates) : void 0,
      reportReasons: globalThis.Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => Any.fromJSON(e)) : [],
      author: isSet122(object.author) ? String(object.author) : void 0,
      discussionType: isSet122(object.discussionType) ? String(object.discussionType) : void 0,
      numComments: isSet122(object.numComments) ? Number(object.numComments) : void 0,
      sendReplies: isSet122(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      media: isSet122(object.media) ? String(object.media) : void 0,
      contestMode: isSet122(object.contestMode) ? Boolean(object.contestMode) : void 0,
      authorPatreonFlair: isSet122(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      approved: isSet122(object.approved) ? Boolean(object.approved) : void 0,
      authorFlairTextColor: isSet122(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      permalink: isSet122(object.permalink) ? String(object.permalink) : void 0,
      whitelistStatus: isSet122(object.whitelistStatus) ? Boolean(object.whitelistStatus) : void 0,
      stickied: isSet122(object.stickied) ? Boolean(object.stickied) : void 0,
      url: isSet122(object.url) ? String(object.url) : void 0,
      subredditSubscribers: isSet122(object.subredditSubscribers) ? Number(object.subredditSubscribers) : void 0,
      createdUtc: isSet122(object.createdUtc) ? Number(object.createdUtc) : void 0,
      numCrossposts: isSet122(object.numCrossposts) ? Number(object.numCrossposts) : void 0,
      modReports: globalThis.Array.isArray(object?.modReports) ? object.modReports.map((e) => Any.fromJSON(e)) : [],
      isVideo: isSet122(object.isVideo) ? Boolean(object.isVideo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.authorFlairBackgroundColor !== void 0) {
      obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor;
    }
    if (message.approvedAtUtc !== void 0) {
      obj.approvedAtUtc = message.approvedAtUtc;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.selftext !== void 0) {
      obj.selftext = message.selftext;
    }
    if (message.userReports?.length) {
      obj.userReports = message.userReports;
    }
    if (message.saved !== void 0) {
      obj.saved = message.saved;
    }
    if (message.modReasonTitle !== void 0) {
      obj.modReasonTitle = message.modReasonTitle;
    }
    if (message.gilded !== void 0) {
      obj.gilded = message.gilded;
    }
    if (message.clicked !== void 0) {
      obj.clicked = message.clicked;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.linkFlairRichtext?.length) {
      obj.linkFlairRichtext = message.linkFlairRichtext;
    }
    if (message.subredditNamePrefixed !== void 0) {
      obj.subredditNamePrefixed = message.subredditNamePrefixed;
    }
    if (message.hidden !== void 0) {
      obj.hidden = message.hidden;
    }
    if (message.pwls !== void 0) {
      obj.pwls = message.pwls;
    }
    if (message.linkFlairCssClass !== void 0) {
      obj.linkFlairCssClass = message.linkFlairCssClass;
    }
    if (message.downs !== void 0) {
      obj.downs = message.downs;
    }
    if (message.thumbnailHeight !== void 0) {
      obj.thumbnailHeight = message.thumbnailHeight;
    }
    if (message.topAwardedType !== void 0) {
      obj.topAwardedType = message.topAwardedType;
    }
    if (message.parentWhitelistStatus !== void 0) {
      obj.parentWhitelistStatus = message.parentWhitelistStatus;
    }
    if (message.hideScore !== void 0) {
      obj.hideScore = message.hideScore;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.linkFlairTextColor !== void 0) {
      obj.linkFlairTextColor = message.linkFlairTextColor;
    }
    if (message.upvoteRatio !== void 0) {
      obj.upvoteRatio = message.upvoteRatio;
    }
    if (message.ignoreReports !== void 0) {
      obj.ignoreReports = message.ignoreReports;
    }
    if (message.ups !== void 0) {
      obj.ups = message.ups;
    }
    if (message.domain !== void 0) {
      obj.domain = message.domain;
    }
    if (message.mediaEmbed !== void 0) {
      obj.mediaEmbed = MediaEmbed.toJSON(message.mediaEmbed);
    }
    if (message.thumbnailWidth !== void 0) {
      obj.thumbnailWidth = message.thumbnailWidth;
    }
    if (message.authorFlairTemplateId !== void 0) {
      obj.authorFlairTemplateId = message.authorFlairTemplateId;
    }
    if (message.isOriginalContent !== void 0) {
      obj.isOriginalContent = message.isOriginalContent;
    }
    if (message.authorFullname !== void 0) {
      obj.authorFullname = message.authorFullname;
    }
    if (message.secureMedia !== void 0) {
      obj.secureMedia = message.secureMedia;
    }
    if (message.isRedditMediaDomain !== void 0) {
      obj.isRedditMediaDomain = message.isRedditMediaDomain;
    }
    if (message.isMeta !== void 0) {
      obj.isMeta = message.isMeta;
    }
    if (message.category !== void 0) {
      obj.category = message.category;
    }
    if (message.secureMediaEmbed !== void 0) {
      obj.secureMediaEmbed = MediaEmbed.toJSON(message.secureMediaEmbed);
    }
    if (message.linkFlairText !== void 0) {
      obj.linkFlairText = message.linkFlairText;
    }
    if (message.canModPost !== void 0) {
      obj.canModPost = message.canModPost;
    }
    if (message.score !== void 0) {
      obj.score = message.score;
    }
    if (message.approvedBy !== void 0) {
      obj.approvedBy = message.approvedBy;
    }
    if (message.isCreatedFromAdsUi !== void 0) {
      obj.isCreatedFromAdsUi = message.isCreatedFromAdsUi;
    }
    if (message.authorPremium !== void 0) {
      obj.authorPremium = message.authorPremium;
    }
    if (message.thumbnail !== void 0) {
      obj.thumbnail = message.thumbnail;
    }
    if (message.edited !== void 0) {
      obj.edited = message.edited;
    }
    if (message.authorFlairCssClass !== void 0) {
      obj.authorFlairCssClass = message.authorFlairCssClass;
    }
    if (message.previousVisits?.length) {
      obj.previousVisits = message.previousVisits;
    }
    if (message.authorFlairRichtext?.length) {
      obj.authorFlairRichtext = message.authorFlairRichtext;
    }
    if (message.gildings !== void 0) {
      obj.gildings = Any.toJSON(message.gildings);
    }
    if (message.contentCategories !== void 0) {
      obj.contentCategories = message.contentCategories;
    }
    if (message.isSelf !== void 0) {
      obj.isSelf = message.isSelf;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.linkFlairType !== void 0) {
      obj.linkFlairType = message.linkFlairType;
    }
    if (message.wls !== void 0) {
      obj.wls = message.wls;
    }
    if (message.removedByCategory !== void 0) {
      obj.removedByCategory = message.removedByCategory;
    }
    if (message.bannedBy !== void 0) {
      obj.bannedBy = message.bannedBy;
    }
    if (message.authorFlairType !== void 0) {
      obj.authorFlairType = message.authorFlairType;
    }
    if (message.totalAwardsReceived !== void 0) {
      obj.totalAwardsReceived = message.totalAwardsReceived;
    }
    if (message.allowLiveComments !== void 0) {
      obj.allowLiveComments = message.allowLiveComments;
    }
    if (message.selftextHtml !== void 0) {
      obj.selftextHtml = message.selftextHtml;
    }
    if (message.likes !== void 0) {
      obj.likes = message.likes;
    }
    if (message.suggestedSort !== void 0) {
      obj.suggestedSort = message.suggestedSort;
    }
    if (message.bannedAtUtc !== void 0) {
      obj.bannedAtUtc = message.bannedAtUtc;
    }
    if (message.viewCount !== void 0) {
      obj.viewCount = message.viewCount;
    }
    if (message.archived !== void 0) {
      obj.archived = message.archived;
    }
    if (message.noFollow !== void 0) {
      obj.noFollow = message.noFollow;
    }
    if (message.spam !== void 0) {
      obj.spam = message.spam;
    }
    if (message.isCrosspostable !== void 0) {
      obj.isCrosspostable = message.isCrosspostable;
    }
    if (message.pinned !== void 0) {
      obj.pinned = message.pinned;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.allAwardings?.length) {
      obj.allAwardings = message.allAwardings.map((e) => Any.toJSON(e));
    }
    if (message.awarders?.length) {
      obj.awarders = message.awarders;
    }
    if (message.mediaOnly !== void 0) {
      obj.mediaOnly = message.mediaOnly;
    }
    if (message.canGild !== void 0) {
      obj.canGild = message.canGild;
    }
    if (message.removed !== void 0) {
      obj.removed = message.removed;
    }
    if (message.spoiler !== void 0) {
      obj.spoiler = message.spoiler;
    }
    if (message.locked !== void 0) {
      obj.locked = message.locked;
    }
    if (message.authorFlairText !== void 0) {
      obj.authorFlairText = message.authorFlairText;
    }
    if (message.treatmentTags?.length) {
      obj.treatmentTags = message.treatmentTags.map((e) => Any.toJSON(e));
    }
    if (message.rteMode !== void 0) {
      obj.rteMode = message.rteMode;
    }
    if (message.visited !== void 0) {
      obj.visited = message.visited;
    }
    if (message.removedBy !== void 0) {
      obj.removedBy = message.removedBy;
    }
    if (message.modNote !== void 0) {
      obj.modNote = message.modNote;
    }
    if (message.distinguished !== void 0) {
      obj.distinguished = message.distinguished;
    }
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.authorIsBlocked !== void 0) {
      obj.authorIsBlocked = message.authorIsBlocked;
    }
    if (message.modReasonBy !== void 0) {
      obj.modReasonBy = message.modReasonBy;
    }
    if (message.numReports !== void 0) {
      obj.numReports = message.numReports;
    }
    if (message.removalReason !== void 0) {
      obj.removalReason = message.removalReason;
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.isRobotIndexable !== void 0) {
      obj.isRobotIndexable = message.isRobotIndexable;
    }
    if (message.numDuplicates !== void 0) {
      obj.numDuplicates = message.numDuplicates;
    }
    if (message.reportReasons?.length) {
      obj.reportReasons = message.reportReasons.map((e) => Any.toJSON(e));
    }
    if (message.author !== void 0) {
      obj.author = message.author;
    }
    if (message.discussionType !== void 0) {
      obj.discussionType = message.discussionType;
    }
    if (message.numComments !== void 0) {
      obj.numComments = message.numComments;
    }
    if (message.sendReplies !== void 0) {
      obj.sendReplies = message.sendReplies;
    }
    if (message.media !== void 0) {
      obj.media = message.media;
    }
    if (message.contestMode !== void 0) {
      obj.contestMode = message.contestMode;
    }
    if (message.authorPatreonFlair !== void 0) {
      obj.authorPatreonFlair = message.authorPatreonFlair;
    }
    if (message.approved !== void 0) {
      obj.approved = message.approved;
    }
    if (message.authorFlairTextColor !== void 0) {
      obj.authorFlairTextColor = message.authorFlairTextColor;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.whitelistStatus !== void 0) {
      obj.whitelistStatus = message.whitelistStatus;
    }
    if (message.stickied !== void 0) {
      obj.stickied = message.stickied;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.subredditSubscribers !== void 0) {
      obj.subredditSubscribers = message.subredditSubscribers;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.numCrossposts !== void 0) {
      obj.numCrossposts = message.numCrossposts;
    }
    if (message.modReports?.length) {
      obj.modReports = message.modReports.map((e) => Any.toJSON(e));
    }
    if (message.isVideo !== void 0) {
      obj.isVideo = message.isVideo;
    }
    return obj;
  },
  create(base) {
    return StickyResponse_LinkData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStickyResponse_LinkData();
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.selftext = object.selftext ?? void 0;
    message.userReports = object.userReports?.map((e) => e) || [];
    message.saved = object.saved ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.clicked = object.clicked ?? void 0;
    message.title = object.title ?? void 0;
    message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => e) || [];
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.hidden = object.hidden ?? void 0;
    message.pwls = object.pwls ?? void 0;
    message.linkFlairCssClass = object.linkFlairCssClass ?? void 0;
    message.downs = object.downs ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.parentWhitelistStatus = object.parentWhitelistStatus ?? void 0;
    message.hideScore = object.hideScore ?? void 0;
    message.name = object.name ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.linkFlairTextColor = object.linkFlairTextColor ?? void 0;
    message.upvoteRatio = object.upvoteRatio ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.ups = object.ups ?? void 0;
    message.domain = object.domain ?? void 0;
    message.mediaEmbed = object.mediaEmbed !== void 0 && object.mediaEmbed !== null ? MediaEmbed.fromPartial(object.mediaEmbed) : void 0;
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.isOriginalContent = object.isOriginalContent ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.secureMedia = object.secureMedia ?? void 0;
    message.isRedditMediaDomain = object.isRedditMediaDomain ?? void 0;
    message.isMeta = object.isMeta ?? void 0;
    message.category = object.category ?? void 0;
    message.secureMediaEmbed = object.secureMediaEmbed !== void 0 && object.secureMediaEmbed !== null ? MediaEmbed.fromPartial(object.secureMediaEmbed) : void 0;
    message.linkFlairText = object.linkFlairText ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.score = object.score ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.isCreatedFromAdsUi = object.isCreatedFromAdsUi ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.thumbnail = object.thumbnail ?? void 0;
    message.edited = object.edited ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.previousVisits = object.previousVisits?.map((e) => e) || [];
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => e) || [];
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Any.fromPartial(object.gildings) : void 0;
    message.contentCategories = object.contentCategories ?? void 0;
    message.isSelf = object.isSelf ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.created = object.created ?? void 0;
    message.linkFlairType = object.linkFlairType ?? void 0;
    message.wls = object.wls ?? void 0;
    message.removedByCategory = object.removedByCategory ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.allowLiveComments = object.allowLiveComments ?? void 0;
    message.selftextHtml = object.selftextHtml ?? void 0;
    message.likes = object.likes ?? void 0;
    message.suggestedSort = object.suggestedSort ?? void 0;
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.viewCount = object.viewCount ?? void 0;
    message.archived = object.archived ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.spam = object.spam ?? void 0;
    message.isCrosspostable = object.isCrosspostable ?? void 0;
    message.pinned = object.pinned ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.allAwardings = object.allAwardings?.map((e) => Any.fromPartial(e)) || [];
    message.awarders = object.awarders?.map((e) => e) || [];
    message.mediaOnly = object.mediaOnly ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.removed = object.removed ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.locked = object.locked ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => Any.fromPartial(e)) || [];
    message.rteMode = object.rteMode ?? void 0;
    message.visited = object.visited ?? void 0;
    message.removedBy = object.removedBy ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? void 0;
    message.id = object.id ?? void 0;
    message.isRobotIndexable = object.isRobotIndexable ?? void 0;
    message.numDuplicates = object.numDuplicates ?? void 0;
    message.reportReasons = object.reportReasons?.map((e) => Any.fromPartial(e)) || [];
    message.author = object.author ?? void 0;
    message.discussionType = object.discussionType ?? void 0;
    message.numComments = object.numComments ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.media = object.media ?? void 0;
    message.contestMode = object.contestMode ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.approved = object.approved ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.url = object.url ?? void 0;
    message.subredditSubscribers = object.subredditSubscribers ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.numCrossposts = object.numCrossposts ?? void 0;
    message.modReports = object.modReports?.map((e) => Any.fromPartial(e)) || [];
    message.isVideo = object.isVideo ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(StickyResponse_LinkData.$type, StickyResponse_LinkData);
function createBaseStickyResponse_WrappedStickyListing() {
  return { kind: void 0, data: void 0 };
}
var StickyResponse_WrappedStickyListing = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse.WrappedStickyListing",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      StickyResponse_LinkData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse_WrappedStickyListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = StickyResponse_LinkData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? StickyResponse_LinkData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = StickyResponse_LinkData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return StickyResponse_WrappedStickyListing.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStickyResponse_WrappedStickyListing();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? StickyResponse_LinkData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StickyResponse_WrappedStickyListing.$type, StickyResponse_WrappedStickyListing);
function createBaseStickyResponse_StickyResponseData() {
  return {
    after: void 0,
    before: void 0,
    dist: void 0,
    modhash: void 0,
    geoFilter: void 0,
    children: []
  };
}
var StickyResponse_StickyResponseData = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse.StickyResponseData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
    }
    if (message.modhash !== void 0) {
      StringValue.encode({ value: message.modhash }, writer.uint32(34).fork()).ldelim();
    }
    if (message.geoFilter !== void 0) {
      StringValue.encode({ value: message.geoFilter }, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.children) {
      StickyResponse_WrappedStickyListing.encode(v, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse_StickyResponseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.modhash = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.children.push(StickyResponse_WrappedStickyListing.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      dist: isSet122(object.dist) ? Number(object.dist) : void 0,
      modhash: isSet122(object.modhash) ? String(object.modhash) : void 0,
      geoFilter: isSet122(object.geoFilter) ? String(object.geoFilter) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => StickyResponse_WrappedStickyListing.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    if (message.modhash !== void 0) {
      obj.modhash = message.modhash;
    }
    if (message.geoFilter !== void 0) {
      obj.geoFilter = message.geoFilter;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => StickyResponse_WrappedStickyListing.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return StickyResponse_StickyResponseData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStickyResponse_StickyResponseData();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.dist = object.dist ?? void 0;
    message.modhash = object.modhash ?? void 0;
    message.geoFilter = object.geoFilter ?? void 0;
    message.children = object.children?.map((e) => StickyResponse_WrappedStickyListing.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(StickyResponse_StickyResponseData.$type, StickyResponse_StickyResponseData);
function createBaseFullSubredditObject() {
  return {
    userFlairBackgroundColor: void 0,
    submitTextHtml: void 0,
    restrictPosting: void 0,
    userIsBanned: void 0,
    freeFormReports: void 0,
    wikiEnabled: void 0,
    userIsMuted: void 0,
    userCanFlairInSr: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    allowGalleries: void 0,
    iconSize: [],
    primaryColor: void 0,
    activeUserCount: void 0,
    iconImg: void 0,
    displayNamePrefixed: void 0,
    accountsActive: void 0,
    publicTraffic: void 0,
    subscribers: void 0,
    userFlairRichtext: [],
    videostreamLinksCount: void 0,
    name: void 0,
    quarantine: void 0,
    hideAds: void 0,
    predictionLeaderboardEntryType: void 0,
    emojisEnabled: void 0,
    advertiserCategory: void 0,
    publicDescription: void 0,
    commentScoreHideMins: void 0,
    allowPredictions: void 0,
    userHasFavorited: void 0,
    userFlairTemplateId: void 0,
    communityIcon: void 0,
    bannerBackgroundImage: void 0,
    originalContentTagEnabled: void 0,
    communityReviewed: void 0,
    submitText: void 0,
    descriptionHtml: void 0,
    spoilersEnabled: void 0,
    commentContributionSettings: void 0,
    allowTalks: void 0,
    headerSize: [],
    userFlairPosition: void 0,
    allOriginalContent: void 0,
    hasMenuWidget: void 0,
    isEnrolledInNewModmail: void 0,
    keyColor: void 0,
    canAssignUserFlair: void 0,
    created: void 0,
    wls: void 0,
    showMediaPreview: void 0,
    submissionType: void 0,
    userIsSubscriber: void 0,
    allowedMediaInComments: [],
    allowVideogifs: void 0,
    shouldArchivePosts: void 0,
    userFlairType: void 0,
    allowPolls: void 0,
    collapseDeletedComments: void 0,
    emojisCustomSize: [],
    publicDescriptionHtml: void 0,
    allowVideos: void 0,
    isCrosspostableSubreddit: void 0,
    notificationLevel: void 0,
    shouldShowMediaInCommentsSetting: void 0,
    canAssignLinkFlair: void 0,
    accountsActiveIsFuzzed: void 0,
    allowPredictionContributors: void 0,
    submitTextLabel: void 0,
    linkFlairPosition: void 0,
    userSrFlairEnabled: void 0,
    userFlairEnabledInSr: void 0,
    allowChatPostCreation: void 0,
    allowDiscovery: void 0,
    acceptFollowers: void 0,
    userSrThemeEnabled: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    suggestedCommentSort: void 0,
    bannerImg: void 0,
    userFlairText: void 0,
    contentCategory: void 0,
    bannerBackgroundColor: void 0,
    showMedia: void 0,
    id: void 0,
    userIsModerator: void 0,
    over18: void 0,
    headerTitle: void 0,
    description: void 0,
    isChatPostFeatureEnabled: void 0,
    submitLinkLabel: void 0,
    userFlairTextColor: void 0,
    restrictCommenting: void 0,
    userFlairCssClass: void 0,
    allowImages: void 0,
    lang: void 0,
    whitelistStatus: void 0,
    url: void 0,
    createdUtc: void 0,
    bannerSize: [],
    mobileBannerImage: void 0,
    userIsContributor: void 0,
    allowPredictionsTournament: void 0
  };
}
var FullSubredditObject = {
  $type: "devvit.plugin.redditapi.subreddits.FullSubredditObject",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.userFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(26).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(34).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(42).fork()).ldelim();
    }
    if (message.wikiEnabled !== void 0) {
      BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(50).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(58).fork()).ldelim();
    }
    if (message.userCanFlairInSr !== void 0) {
      BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(66).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(74).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(82).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(90).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int64Value.encode({ value: v }, writer.uint32(106).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(114).fork()).ldelim();
    }
    if (message.activeUserCount !== void 0) {
      Int64Value.encode({ value: message.activeUserCount }, writer.uint32(122).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(130).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(138).fork()).ldelim();
    }
    if (message.accountsActive !== void 0) {
      Int64Value.encode({ value: message.accountsActive }, writer.uint32(146).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(154).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.userFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(170).fork()).ldelim();
    }
    if (message.videostreamLinksCount !== void 0) {
      Int64Value.encode({ value: message.videostreamLinksCount }, writer.uint32(178).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(186).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(194).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(202).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(210).fork()).ldelim();
    }
    if (message.emojisEnabled !== void 0) {
      BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(218).fork()).ldelim();
    }
    if (message.advertiserCategory !== void 0) {
      StringValue.encode({ value: message.advertiserCategory }, writer.uint32(226).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(234).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(242).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(250).fork()).ldelim();
    }
    if (message.userHasFavorited !== void 0) {
      BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(258).fork()).ldelim();
    }
    if (message.userFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(266).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(274).fork()).ldelim();
    }
    if (message.bannerBackgroundImage !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(282).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(290).fork()).ldelim();
    }
    if (message.communityReviewed !== void 0) {
      BoolValue.encode({ value: message.communityReviewed }, writer.uint32(298).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(314).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(322).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(330).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(338).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(346).fork()).ldelim();
    }
    for (const v of message.headerSize) {
      Int64Value.encode({ value: v }, writer.uint32(354).fork()).ldelim();
    }
    if (message.userFlairPosition !== void 0) {
      StringValue.encode({ value: message.userFlairPosition }, writer.uint32(362).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(370).fork()).ldelim();
    }
    if (message.hasMenuWidget !== void 0) {
      BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(378).fork()).ldelim();
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(386).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(394).fork()).ldelim();
    }
    if (message.canAssignUserFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(402).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(410).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      Int32Value.encode({ value: message.wls }, writer.uint32(418).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(426).fork()).ldelim();
    }
    if (message.submissionType !== void 0) {
      StringValue.encode({ value: message.submissionType }, writer.uint32(434).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(442).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(450).fork()).ldelim();
    }
    if (message.allowVideogifs !== void 0) {
      BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(458).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(466).fork()).ldelim();
    }
    if (message.userFlairType !== void 0) {
      StringValue.encode({ value: message.userFlairType }, writer.uint32(474).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(482).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(490).fork()).ldelim();
    }
    for (const v of message.emojisCustomSize) {
      Int64Value.encode({ value: v }, writer.uint32(498).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(506).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(514).fork()).ldelim();
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(522).fork()).ldelim();
    }
    if (message.notificationLevel !== void 0) {
      StringValue.encode({ value: message.notificationLevel }, writer.uint32(530).fork()).ldelim();
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(538).fork()).ldelim();
    }
    if (message.canAssignLinkFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(546).fork()).ldelim();
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(554).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(562).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(570).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(578).fork()).ldelim();
    }
    if (message.userSrFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(586).fork()).ldelim();
    }
    if (message.userFlairEnabledInSr !== void 0) {
      BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(594).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(602).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(610).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(618).fork()).ldelim();
    }
    if (message.userSrThemeEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(626).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(634).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(642).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(650).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(658).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(666).fork()).ldelim();
    }
    if (message.userFlairText !== void 0) {
      StringValue.encode({ value: message.userFlairText }, writer.uint32(674).fork()).ldelim();
    }
    if (message.contentCategory !== void 0) {
      StringValue.encode({ value: message.contentCategory }, writer.uint32(682).fork()).ldelim();
    }
    if (message.bannerBackgroundColor !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(690).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(698).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(706).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(714).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(722).fork()).ldelim();
    }
    if (message.headerTitle !== void 0) {
      StringValue.encode({ value: message.headerTitle }, writer.uint32(730).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(738).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(746).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(754).fork()).ldelim();
    }
    if (message.userFlairTextColor !== void 0) {
      StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(762).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(770).fork()).ldelim();
    }
    if (message.userFlairCssClass !== void 0) {
      StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(778).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(786).fork()).ldelim();
    }
    if (message.lang !== void 0) {
      StringValue.encode({ value: message.lang }, writer.uint32(794).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      StringValue.encode({ value: message.whitelistStatus }, writer.uint32(802).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(810).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(818).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(826).fork()).ldelim();
    }
    if (message.mobileBannerImage !== void 0) {
      StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(834).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(842).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(850).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullSubredditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.iconSize.push(Int64Value.decode(reader, reader.uint32()).value);
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.activeUserCount = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.accountsActive = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.userFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.videostreamLinksCount = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }
          message.headerSize.push(Int64Value.decode(reader, reader.uint32()).value);
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }
          message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }
          message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }
          message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }
          message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }
          message.wls = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }
          message.submissionType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }
          message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }
          message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }
          message.emojisCustomSize.push(Int64Value.decode(reader, reader.uint32()).value);
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }
          message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }
          message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }
          message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }
          message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 69:
          if (tag !== 554) {
            break;
          }
          message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }
          message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }
          message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }
          message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }
          message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }
          message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 85:
          if (tag !== 682) {
            break;
          }
          message.contentCategory = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 86:
          if (tag !== 690) {
            break;
          }
          message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 88:
          if (tag !== 706) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 89:
          if (tag !== 714) {
            break;
          }
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }
          message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 92:
          if (tag !== 738) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 94:
          if (tag !== 754) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 95:
          if (tag !== 762) {
            break;
          }
          message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }
          message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }
          message.lang = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }
          message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }
          message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userFlairBackgroundColor: isSet122(object.userFlairBackgroundColor) ? String(object.userFlairBackgroundColor) : void 0,
      submitTextHtml: isSet122(object.submitTextHtml) ? String(object.submitTextHtml) : void 0,
      restrictPosting: isSet122(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      userIsBanned: isSet122(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet122(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      wikiEnabled: isSet122(object.wikiEnabled) ? Boolean(object.wikiEnabled) : void 0,
      userIsMuted: isSet122(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      userCanFlairInSr: isSet122(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : void 0,
      displayName: isSet122(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet122(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet122(object.title) ? String(object.title) : void 0,
      allowGalleries: isSet122(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      iconSize: globalThis.Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet122(object.primaryColor) ? String(object.primaryColor) : void 0,
      activeUserCount: isSet122(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      displayNamePrefixed: isSet122(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      accountsActive: isSet122(object.accountsActive) ? Number(object.accountsActive) : void 0,
      publicTraffic: isSet122(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      subscribers: isSet122(object.subscribers) ? Number(object.subscribers) : void 0,
      userFlairRichtext: globalThis.Array.isArray(object?.userFlairRichtext) ? object.userFlairRichtext.map((e) => String(e)) : [],
      videostreamLinksCount: isSet122(object.videostreamLinksCount) ? Number(object.videostreamLinksCount) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      quarantine: isSet122(object.quarantine) ? Boolean(object.quarantine) : void 0,
      hideAds: isSet122(object.hideAds) ? Boolean(object.hideAds) : void 0,
      predictionLeaderboardEntryType: isSet122(object.predictionLeaderboardEntryType) ? String(object.predictionLeaderboardEntryType) : void 0,
      emojisEnabled: isSet122(object.emojisEnabled) ? Boolean(object.emojisEnabled) : void 0,
      advertiserCategory: isSet122(object.advertiserCategory) ? String(object.advertiserCategory) : void 0,
      publicDescription: isSet122(object.publicDescription) ? String(object.publicDescription) : void 0,
      commentScoreHideMins: isSet122(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      allowPredictions: isSet122(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      userHasFavorited: isSet122(object.userHasFavorited) ? Boolean(object.userHasFavorited) : void 0,
      userFlairTemplateId: isSet122(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : void 0,
      communityIcon: isSet122(object.communityIcon) ? String(object.communityIcon) : void 0,
      bannerBackgroundImage: isSet122(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : void 0,
      originalContentTagEnabled: isSet122(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : void 0,
      communityReviewed: isSet122(object.communityReviewed) ? Boolean(object.communityReviewed) : void 0,
      submitText: isSet122(object.submitText) ? String(object.submitText) : void 0,
      descriptionHtml: isSet122(object.descriptionHtml) ? String(object.descriptionHtml) : void 0,
      spoilersEnabled: isSet122(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      commentContributionSettings: isSet122(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      allowTalks: isSet122(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      headerSize: globalThis.Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
      userFlairPosition: isSet122(object.userFlairPosition) ? String(object.userFlairPosition) : void 0,
      allOriginalContent: isSet122(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      hasMenuWidget: isSet122(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : void 0,
      isEnrolledInNewModmail: isSet122(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : void 0,
      keyColor: isSet122(object.keyColor) ? String(object.keyColor) : void 0,
      canAssignUserFlair: isSet122(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : void 0,
      created: isSet122(object.created) ? Number(object.created) : void 0,
      wls: isSet122(object.wls) ? Number(object.wls) : void 0,
      showMediaPreview: isSet122(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      submissionType: isSet122(object.submissionType) ? String(object.submissionType) : void 0,
      userIsSubscriber: isSet122(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      allowedMediaInComments: globalThis.Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      allowVideogifs: isSet122(object.allowVideogifs) ? Boolean(object.allowVideogifs) : void 0,
      shouldArchivePosts: isSet122(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      userFlairType: isSet122(object.userFlairType) ? String(object.userFlairType) : void 0,
      allowPolls: isSet122(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      collapseDeletedComments: isSet122(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      emojisCustomSize: globalThis.Array.isArray(object?.emojisCustomSize) ? object.emojisCustomSize.map((e) => Number(e)) : [],
      publicDescriptionHtml: isSet122(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      allowVideos: isSet122(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      isCrosspostableSubreddit: isSet122(object.isCrosspostableSubreddit) ? Boolean(object.isCrosspostableSubreddit) : void 0,
      notificationLevel: isSet122(object.notificationLevel) ? String(object.notificationLevel) : void 0,
      shouldShowMediaInCommentsSetting: isSet122(object.shouldShowMediaInCommentsSetting) ? Boolean(object.shouldShowMediaInCommentsSetting) : void 0,
      canAssignLinkFlair: isSet122(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : void 0,
      accountsActiveIsFuzzed: isSet122(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : void 0,
      allowPredictionContributors: isSet122(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      submitTextLabel: isSet122(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      linkFlairPosition: isSet122(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      userSrFlairEnabled: isSet122(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : void 0,
      userFlairEnabledInSr: isSet122(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : void 0,
      allowChatPostCreation: isSet122(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowDiscovery: isSet122(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      userSrThemeEnabled: isSet122(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : void 0,
      linkFlairEnabled: isSet122(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet122(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet122(object.subredditType) ? String(object.subredditType) : void 0,
      suggestedCommentSort: isSet122(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : void 0,
      bannerImg: isSet122(object.bannerImg) ? String(object.bannerImg) : void 0,
      userFlairText: isSet122(object.userFlairText) ? String(object.userFlairText) : void 0,
      contentCategory: isSet122(object.contentCategory) ? String(object.contentCategory) : void 0,
      bannerBackgroundColor: isSet122(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : void 0,
      showMedia: isSet122(object.showMedia) ? Boolean(object.showMedia) : void 0,
      id: isSet122(object.id) ? String(object.id) : void 0,
      userIsModerator: isSet122(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      over18: isSet122(object.over18) ? Boolean(object.over18) : void 0,
      headerTitle: isSet122(object.headerTitle) ? String(object.headerTitle) : void 0,
      description: isSet122(object.description) ? String(object.description) : void 0,
      isChatPostFeatureEnabled: isSet122(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      submitLinkLabel: isSet122(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      userFlairTextColor: isSet122(object.userFlairTextColor) ? String(object.userFlairTextColor) : void 0,
      restrictCommenting: isSet122(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      userFlairCssClass: isSet122(object.userFlairCssClass) ? String(object.userFlairCssClass) : void 0,
      allowImages: isSet122(object.allowImages) ? Boolean(object.allowImages) : void 0,
      lang: isSet122(object.lang) ? String(object.lang) : void 0,
      whitelistStatus: isSet122(object.whitelistStatus) ? String(object.whitelistStatus) : void 0,
      url: isSet122(object.url) ? String(object.url) : void 0,
      createdUtc: isSet122(object.createdUtc) ? Number(object.createdUtc) : void 0,
      bannerSize: globalThis.Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      mobileBannerImage: isSet122(object.mobileBannerImage) ? String(object.mobileBannerImage) : void 0,
      userIsContributor: isSet122(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      allowPredictionsTournament: isSet122(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userFlairBackgroundColor !== void 0) {
      obj.userFlairBackgroundColor = message.userFlairBackgroundColor;
    }
    if (message.submitTextHtml !== void 0) {
      obj.submitTextHtml = message.submitTextHtml;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.userIsBanned !== void 0) {
      obj.userIsBanned = message.userIsBanned;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.wikiEnabled !== void 0) {
      obj.wikiEnabled = message.wikiEnabled;
    }
    if (message.userIsMuted !== void 0) {
      obj.userIsMuted = message.userIsMuted;
    }
    if (message.userCanFlairInSr !== void 0) {
      obj.userCanFlairInSr = message.userCanFlairInSr;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.headerImg !== void 0) {
      obj.headerImg = message.headerImg;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.allowGalleries !== void 0) {
      obj.allowGalleries = message.allowGalleries;
    }
    if (message.iconSize?.length) {
      obj.iconSize = message.iconSize;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.activeUserCount !== void 0) {
      obj.activeUserCount = message.activeUserCount;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.displayNamePrefixed !== void 0) {
      obj.displayNamePrefixed = message.displayNamePrefixed;
    }
    if (message.accountsActive !== void 0) {
      obj.accountsActive = message.accountsActive;
    }
    if (message.publicTraffic !== void 0) {
      obj.publicTraffic = message.publicTraffic;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.userFlairRichtext?.length) {
      obj.userFlairRichtext = message.userFlairRichtext;
    }
    if (message.videostreamLinksCount !== void 0) {
      obj.videostreamLinksCount = message.videostreamLinksCount;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.hideAds !== void 0) {
      obj.hideAds = message.hideAds;
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType;
    }
    if (message.emojisEnabled !== void 0) {
      obj.emojisEnabled = message.emojisEnabled;
    }
    if (message.advertiserCategory !== void 0) {
      obj.advertiserCategory = message.advertiserCategory;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.commentScoreHideMins !== void 0) {
      obj.commentScoreHideMins = message.commentScoreHideMins;
    }
    if (message.allowPredictions !== void 0) {
      obj.allowPredictions = message.allowPredictions;
    }
    if (message.userHasFavorited !== void 0) {
      obj.userHasFavorited = message.userHasFavorited;
    }
    if (message.userFlairTemplateId !== void 0) {
      obj.userFlairTemplateId = message.userFlairTemplateId;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.bannerBackgroundImage !== void 0) {
      obj.bannerBackgroundImage = message.bannerBackgroundImage;
    }
    if (message.originalContentTagEnabled !== void 0) {
      obj.originalContentTagEnabled = message.originalContentTagEnabled;
    }
    if (message.communityReviewed !== void 0) {
      obj.communityReviewed = message.communityReviewed;
    }
    if (message.submitText !== void 0) {
      obj.submitText = message.submitText;
    }
    if (message.descriptionHtml !== void 0) {
      obj.descriptionHtml = message.descriptionHtml;
    }
    if (message.spoilersEnabled !== void 0) {
      obj.spoilersEnabled = message.spoilersEnabled;
    }
    if (message.commentContributionSettings !== void 0) {
      obj.commentContributionSettings = CommentContributionSettings.toJSON(message.commentContributionSettings);
    }
    if (message.allowTalks !== void 0) {
      obj.allowTalks = message.allowTalks;
    }
    if (message.headerSize?.length) {
      obj.headerSize = message.headerSize;
    }
    if (message.userFlairPosition !== void 0) {
      obj.userFlairPosition = message.userFlairPosition;
    }
    if (message.allOriginalContent !== void 0) {
      obj.allOriginalContent = message.allOriginalContent;
    }
    if (message.hasMenuWidget !== void 0) {
      obj.hasMenuWidget = message.hasMenuWidget;
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.canAssignUserFlair !== void 0) {
      obj.canAssignUserFlair = message.canAssignUserFlair;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.wls !== void 0) {
      obj.wls = message.wls;
    }
    if (message.showMediaPreview !== void 0) {
      obj.showMediaPreview = message.showMediaPreview;
    }
    if (message.submissionType !== void 0) {
      obj.submissionType = message.submissionType;
    }
    if (message.userIsSubscriber !== void 0) {
      obj.userIsSubscriber = message.userIsSubscriber;
    }
    if (message.allowedMediaInComments?.length) {
      obj.allowedMediaInComments = message.allowedMediaInComments;
    }
    if (message.allowVideogifs !== void 0) {
      obj.allowVideogifs = message.allowVideogifs;
    }
    if (message.shouldArchivePosts !== void 0) {
      obj.shouldArchivePosts = message.shouldArchivePosts;
    }
    if (message.userFlairType !== void 0) {
      obj.userFlairType = message.userFlairType;
    }
    if (message.allowPolls !== void 0) {
      obj.allowPolls = message.allowPolls;
    }
    if (message.collapseDeletedComments !== void 0) {
      obj.collapseDeletedComments = message.collapseDeletedComments;
    }
    if (message.emojisCustomSize?.length) {
      obj.emojisCustomSize = message.emojisCustomSize;
    }
    if (message.publicDescriptionHtml !== void 0) {
      obj.publicDescriptionHtml = message.publicDescriptionHtml;
    }
    if (message.allowVideos !== void 0) {
      obj.allowVideos = message.allowVideos;
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit;
    }
    if (message.notificationLevel !== void 0) {
      obj.notificationLevel = message.notificationLevel;
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting;
    }
    if (message.canAssignLinkFlair !== void 0) {
      obj.canAssignLinkFlair = message.canAssignLinkFlair;
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed;
    }
    if (message.allowPredictionContributors !== void 0) {
      obj.allowPredictionContributors = message.allowPredictionContributors;
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.linkFlairPosition !== void 0) {
      obj.linkFlairPosition = message.linkFlairPosition;
    }
    if (message.userSrFlairEnabled !== void 0) {
      obj.userSrFlairEnabled = message.userSrFlairEnabled;
    }
    if (message.userFlairEnabledInSr !== void 0) {
      obj.userFlairEnabledInSr = message.userFlairEnabledInSr;
    }
    if (message.allowChatPostCreation !== void 0) {
      obj.allowChatPostCreation = message.allowChatPostCreation;
    }
    if (message.allowDiscovery !== void 0) {
      obj.allowDiscovery = message.allowDiscovery;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.userSrThemeEnabled !== void 0) {
      obj.userSrThemeEnabled = message.userSrThemeEnabled;
    }
    if (message.linkFlairEnabled !== void 0) {
      obj.linkFlairEnabled = message.linkFlairEnabled;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.suggestedCommentSort !== void 0) {
      obj.suggestedCommentSort = message.suggestedCommentSort;
    }
    if (message.bannerImg !== void 0) {
      obj.bannerImg = message.bannerImg;
    }
    if (message.userFlairText !== void 0) {
      obj.userFlairText = message.userFlairText;
    }
    if (message.contentCategory !== void 0) {
      obj.contentCategory = message.contentCategory;
    }
    if (message.bannerBackgroundColor !== void 0) {
      obj.bannerBackgroundColor = message.bannerBackgroundColor;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.userIsModerator !== void 0) {
      obj.userIsModerator = message.userIsModerator;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.headerTitle !== void 0) {
      obj.headerTitle = message.headerTitle;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.userFlairTextColor !== void 0) {
      obj.userFlairTextColor = message.userFlairTextColor;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.userFlairCssClass !== void 0) {
      obj.userFlairCssClass = message.userFlairCssClass;
    }
    if (message.allowImages !== void 0) {
      obj.allowImages = message.allowImages;
    }
    if (message.lang !== void 0) {
      obj.lang = message.lang;
    }
    if (message.whitelistStatus !== void 0) {
      obj.whitelistStatus = message.whitelistStatus;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.bannerSize?.length) {
      obj.bannerSize = message.bannerSize;
    }
    if (message.mobileBannerImage !== void 0) {
      obj.mobileBannerImage = message.mobileBannerImage;
    }
    if (message.userIsContributor !== void 0) {
      obj.userIsContributor = message.userIsContributor;
    }
    if (message.allowPredictionsTournament !== void 0) {
      obj.allowPredictionsTournament = message.allowPredictionsTournament;
    }
    return obj;
  },
  create(base) {
    return FullSubredditObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFullSubredditObject();
    message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.wikiEnabled = object.wikiEnabled ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.userCanFlairInSr = object.userCanFlairInSr ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.accountsActive = object.accountsActive ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.userFlairRichtext = object.userFlairRichtext?.map((e) => e) || [];
    message.videostreamLinksCount = object.videostreamLinksCount ?? void 0;
    message.name = object.name ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.emojisEnabled = object.emojisEnabled ?? void 0;
    message.advertiserCategory = object.advertiserCategory ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.userHasFavorited = object.userHasFavorited ?? void 0;
    message.userFlairTemplateId = object.userFlairTemplateId ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.bannerBackgroundImage = object.bannerBackgroundImage ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.communityReviewed = object.communityReviewed ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.headerSize = object.headerSize?.map((e) => e) || [];
    message.userFlairPosition = object.userFlairPosition ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.hasMenuWidget = object.hasMenuWidget ?? void 0;
    message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.canAssignUserFlair = object.canAssignUserFlair ?? void 0;
    message.created = object.created ?? void 0;
    message.wls = object.wls ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.submissionType = object.submissionType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.allowVideogifs = object.allowVideogifs ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.userFlairType = object.userFlairType ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.emojisCustomSize = object.emojisCustomSize?.map((e) => e) || [];
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? void 0;
    message.notificationLevel = object.notificationLevel ?? void 0;
    message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? void 0;
    message.canAssignLinkFlair = object.canAssignLinkFlair ?? void 0;
    message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.userSrFlairEnabled = object.userSrFlairEnabled ?? void 0;
    message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.userSrThemeEnabled = object.userSrThemeEnabled ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.userFlairText = object.userFlairText ?? void 0;
    message.contentCategory = object.contentCategory ?? void 0;
    message.bannerBackgroundColor = object.bannerBackgroundColor ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.id = object.id ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.headerTitle = object.headerTitle ?? void 0;
    message.description = object.description ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.userFlairTextColor = object.userFlairTextColor ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.userFlairCssClass = object.userFlairCssClass ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.lang = object.lang ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.url = object.url ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.mobileBannerImage = object.mobileBannerImage ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(FullSubredditObject.$type, FullSubredditObject);
function createBaseSubredditsSearchResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditsSearchResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditsSearchResponse_WrappedSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = SubredditsSearchResponse_WrappedSubredditObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? SubredditsSearchResponse_WrappedSubredditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = SubredditsSearchResponse_WrappedSubredditObject.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditsSearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditsSearchResponse_WrappedSubredditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditsSearchResponse.$type, SubredditsSearchResponse);
function createBaseSubredditsSearchResponse_WrappedSubredditObject() {
  return { after: void 0, before: void 0, dist: void 0, geoFilter: void 0, children: [] };
}
var SubredditsSearchResponse_WrappedSubredditObject = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
    }
    if (message.geoFilter !== void 0) {
      StringValue.encode({ value: message.geoFilter }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.children) {
      SubredditsSearchResponse_WrappedSubredditObject_SubredditData.encode(v, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.children.push(SubredditsSearchResponse_WrappedSubredditObject_SubredditData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      before: isSet122(object.before) ? String(object.before) : void 0,
      dist: isSet122(object.dist) ? Number(object.dist) : void 0,
      geoFilter: isSet122(object.geoFilter) ? String(object.geoFilter) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    if (message.geoFilter !== void 0) {
      obj.geoFilter = message.geoFilter;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SubredditsSearchResponse_WrappedSubredditObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.dist = object.dist ?? void 0;
    message.geoFilter = object.geoFilter ?? void 0;
    message.children = object.children?.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditsSearchResponse_WrappedSubredditObject.$type, SubredditsSearchResponse_WrappedSubredditObject);
function createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData() {
  return { kind: void 0, data: void 0 };
}
var SubredditsSearchResponse_WrappedSubredditObject_SubredditData = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject.SubredditData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      FullSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = FullSubredditObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? FullSubredditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = FullSubredditObject.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? FullSubredditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditsSearchResponse_WrappedSubredditObject_SubredditData.$type, SubredditsSearchResponse_WrappedSubredditObject_SubredditData);
function createBaseUserSearchResponse() {
  return { kind: void 0, data: void 0 };
}
var UserSearchResponse = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserSearchResponse_AccData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = UserSearchResponse_AccData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? UserSearchResponse_AccData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = UserSearchResponse_AccData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return UserSearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserSearchResponse_AccData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserSearchResponse.$type, UserSearchResponse);
function createBaseUserSearchResponse_AccData() {
  return {
    after: void 0,
    dist: void 0,
    modhash: void 0,
    geoFilter: void 0,
    children: [],
    before: void 0
  };
}
var UserSearchResponse_AccData = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int64Value.encode({ value: message.dist }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modhash !== void 0) {
      StringValue.encode({ value: message.modhash }, writer.uint32(26).fork()).ldelim();
    }
    if (message.geoFilter !== void 0) {
      StringValue.encode({ value: message.geoFilter }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.children) {
      UserSearchResponse_Account.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_AccData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dist = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.modhash = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.children.push(UserSearchResponse_Account.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet122(object.after) ? String(object.after) : void 0,
      dist: isSet122(object.dist) ? Number(object.dist) : void 0,
      modhash: isSet122(object.modhash) ? String(object.modhash) : void 0,
      geoFilter: isSet122(object.geoFilter) ? String(object.geoFilter) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => UserSearchResponse_Account.fromJSON(e)) : [],
      before: isSet122(object.before) ? String(object.before) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    if (message.modhash !== void 0) {
      obj.modhash = message.modhash;
    }
    if (message.geoFilter !== void 0) {
      obj.geoFilter = message.geoFilter;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => UserSearchResponse_Account.toJSON(e));
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    return obj;
  },
  create(base) {
    return UserSearchResponse_AccData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_AccData();
    message.after = object.after ?? void 0;
    message.dist = object.dist ?? void 0;
    message.modhash = object.modhash ?? void 0;
    message.geoFilter = object.geoFilter ?? void 0;
    message.children = object.children?.map((e) => UserSearchResponse_Account.fromPartial(e)) || [];
    message.before = object.before ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserSearchResponse_AccData.$type, UserSearchResponse_AccData);
function createBaseUserSearchResponse_Account() {
  return { kind: void 0, data: void 0 };
}
var UserSearchResponse_Account = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.Account",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserSearchResponse_AccountData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_Account();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = UserSearchResponse_AccountData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet122(object.kind) ? String(object.kind) : void 0,
      data: isSet122(object.data) ? UserSearchResponse_AccountData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== void 0) {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = UserSearchResponse_AccountData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return UserSearchResponse_Account.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_Account();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserSearchResponse_AccountData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserSearchResponse_Account.$type, UserSearchResponse_Account);
function createBaseUserSearchResponse_AccountData() {
  return {
    isEmployee: void 0,
    isFriend: void 0,
    snoovatarSize: [],
    id: void 0,
    verified: void 0,
    isGold: void 0,
    isMod: void 0,
    hasVerifiedEmail: void 0,
    iconImg: void 0,
    hideFromRobots: void 0,
    linkKarma: void 0,
    acceptChats: void 0,
    isBlocked: void 0,
    prefShowSnoovatar: void 0,
    name: void 0,
    created: void 0,
    createdUtc: void 0,
    snoovatarImg: void 0,
    commentKarma: void 0,
    acceptFollowers: void 0,
    hasSubscribed: void 0,
    acceptPms: void 0,
    isSuspended: void 0,
    subreddit: void 0
  };
}
var UserSearchResponse_AccountData = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.isEmployee !== void 0) {
      BoolValue.encode({ value: message.isEmployee }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isFriend !== void 0) {
      BoolValue.encode({ value: message.isFriend }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.snoovatarSize) {
      Int32Value.encode({ value: v }, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
    }
    if (message.verified !== void 0) {
      BoolValue.encode({ value: message.verified }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isGold !== void 0) {
      BoolValue.encode({ value: message.isGold }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(58).fork()).ldelim();
    }
    if (message.hasVerifiedEmail !== void 0) {
      BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(74).fork()).ldelim();
    }
    if (message.hideFromRobots !== void 0) {
      BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(82).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int32Value.encode({ value: message.linkKarma }, writer.uint32(90).fork()).ldelim();
    }
    if (message.acceptChats !== void 0) {
      BoolValue.encode({ value: message.acceptChats }, writer.uint32(98).fork()).ldelim();
    }
    if (message.isBlocked !== void 0) {
      BoolValue.encode({ value: message.isBlocked }, writer.uint32(106).fork()).ldelim();
    }
    if (message.prefShowSnoovatar !== void 0) {
      BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(114).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(122).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(130).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(138).fork()).ldelim();
    }
    if (message.snoovatarImg !== void 0) {
      StringValue.encode({ value: message.snoovatarImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int64Value.encode({ value: message.commentKarma }, writer.uint32(154).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(162).fork()).ldelim();
    }
    if (message.hasSubscribed !== void 0) {
      BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(170).fork()).ldelim();
    }
    if (message.acceptPms !== void 0) {
      BoolValue.encode({ value: message.acceptPms }, writer.uint32(178).fork()).ldelim();
    }
    if (message.isSuspended !== void 0) {
      BoolValue.encode({ value: message.isSuspended }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      UserSearchResponse_AccountData_Subreddit.encode(message.subreddit, writer.uint32(194).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_AccountData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.snoovatarSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isGold = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.subreddit = UserSearchResponse_AccountData_Subreddit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isEmployee: isSet122(object.isEmployee) ? Boolean(object.isEmployee) : void 0,
      isFriend: isSet122(object.isFriend) ? Boolean(object.isFriend) : void 0,
      snoovatarSize: globalThis.Array.isArray(object?.snoovatarSize) ? object.snoovatarSize.map((e) => Number(e)) : [],
      id: isSet122(object.id) ? String(object.id) : void 0,
      verified: isSet122(object.verified) ? Boolean(object.verified) : void 0,
      isGold: isSet122(object.isGold) ? Boolean(object.isGold) : void 0,
      isMod: isSet122(object.isMod) ? Boolean(object.isMod) : void 0,
      hasVerifiedEmail: isSet122(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      hideFromRobots: isSet122(object.hideFromRobots) ? Boolean(object.hideFromRobots) : void 0,
      linkKarma: isSet122(object.linkKarma) ? Number(object.linkKarma) : void 0,
      acceptChats: isSet122(object.acceptChats) ? Boolean(object.acceptChats) : void 0,
      isBlocked: isSet122(object.isBlocked) ? Boolean(object.isBlocked) : void 0,
      prefShowSnoovatar: isSet122(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      created: isSet122(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet122(object.createdUtc) ? Number(object.createdUtc) : void 0,
      snoovatarImg: isSet122(object.snoovatarImg) ? String(object.snoovatarImg) : void 0,
      commentKarma: isSet122(object.commentKarma) ? Number(object.commentKarma) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      hasSubscribed: isSet122(object.hasSubscribed) ? Boolean(object.hasSubscribed) : void 0,
      acceptPms: isSet122(object.acceptPms) ? Boolean(object.acceptPms) : void 0,
      isSuspended: isSet122(object.isSuspended) ? Boolean(object.isSuspended) : void 0,
      subreddit: isSet122(object.subreddit) ? UserSearchResponse_AccountData_Subreddit.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isEmployee !== void 0) {
      obj.isEmployee = message.isEmployee;
    }
    if (message.isFriend !== void 0) {
      obj.isFriend = message.isFriend;
    }
    if (message.snoovatarSize?.length) {
      obj.snoovatarSize = message.snoovatarSize;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.verified !== void 0) {
      obj.verified = message.verified;
    }
    if (message.isGold !== void 0) {
      obj.isGold = message.isGold;
    }
    if (message.isMod !== void 0) {
      obj.isMod = message.isMod;
    }
    if (message.hasVerifiedEmail !== void 0) {
      obj.hasVerifiedEmail = message.hasVerifiedEmail;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.hideFromRobots !== void 0) {
      obj.hideFromRobots = message.hideFromRobots;
    }
    if (message.linkKarma !== void 0) {
      obj.linkKarma = message.linkKarma;
    }
    if (message.acceptChats !== void 0) {
      obj.acceptChats = message.acceptChats;
    }
    if (message.isBlocked !== void 0) {
      obj.isBlocked = message.isBlocked;
    }
    if (message.prefShowSnoovatar !== void 0) {
      obj.prefShowSnoovatar = message.prefShowSnoovatar;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.snoovatarImg !== void 0) {
      obj.snoovatarImg = message.snoovatarImg;
    }
    if (message.commentKarma !== void 0) {
      obj.commentKarma = message.commentKarma;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.hasSubscribed !== void 0) {
      obj.hasSubscribed = message.hasSubscribed;
    }
    if (message.acceptPms !== void 0) {
      obj.acceptPms = message.acceptPms;
    }
    if (message.isSuspended !== void 0) {
      obj.isSuspended = message.isSuspended;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = UserSearchResponse_AccountData_Subreddit.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return UserSearchResponse_AccountData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_AccountData();
    message.isEmployee = object.isEmployee ?? void 0;
    message.isFriend = object.isFriend ?? void 0;
    message.snoovatarSize = object.snoovatarSize?.map((e) => e) || [];
    message.id = object.id ?? void 0;
    message.verified = object.verified ?? void 0;
    message.isGold = object.isGold ?? void 0;
    message.isMod = object.isMod ?? void 0;
    message.hasVerifiedEmail = object.hasVerifiedEmail ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.hideFromRobots = object.hideFromRobots ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.acceptChats = object.acceptChats ?? void 0;
    message.isBlocked = object.isBlocked ?? void 0;
    message.prefShowSnoovatar = object.prefShowSnoovatar ?? void 0;
    message.name = object.name ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.snoovatarImg = object.snoovatarImg ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.hasSubscribed = object.hasSubscribed ?? void 0;
    message.acceptPms = object.acceptPms ?? void 0;
    message.isSuspended = object.isSuspended ?? void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? UserSearchResponse_AccountData_Subreddit.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(UserSearchResponse_AccountData.$type, UserSearchResponse_AccountData);
function createBaseUserSearchResponse_AccountData_Subreddit() {
  return {
    defaultSet: void 0,
    userIsContributor: void 0,
    bannerImg: void 0,
    allowedMediaInComments: [],
    userIsBanned: void 0,
    freeFormReports: void 0,
    communityIcon: void 0,
    showMedia: void 0,
    iconColor: void 0,
    userIsMuted: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    previousNames: [],
    over18: void 0,
    iconSize: [],
    primaryColor: void 0,
    iconImg: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    headerSize: [],
    restrictPosting: void 0,
    restrictCommenting: void 0,
    subscribers: void 0,
    submitTextLabel: void 0,
    isDefaultIcon: void 0,
    linkFlairPosition: void 0,
    displayNamePrefixed: void 0,
    keyColor: void 0,
    name: void 0,
    isDefaultBanner: void 0,
    url: void 0,
    quarantine: void 0,
    bannerSize: [],
    userIsModerator: void 0,
    acceptFollowers: void 0,
    publicDescription: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    userIsSubscriber: void 0
  };
}
var UserSearchResponse_AccountData_Subreddit = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData.Subreddit",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(130).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(138).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(154).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.headerSize) {
      Int32Value.encode({ value: v }, writer.uint32(170).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(178).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(218).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(274).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_AccountData_Subreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }
          message.headerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet122(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      userIsContributor: isSet122(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      bannerImg: isSet122(object.bannerImg) ? String(object.bannerImg) : void 0,
      allowedMediaInComments: globalThis.Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      userIsBanned: isSet122(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet122(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      communityIcon: isSet122(object.communityIcon) ? String(object.communityIcon) : void 0,
      showMedia: isSet122(object.showMedia) ? Boolean(object.showMedia) : void 0,
      iconColor: isSet122(object.iconColor) ? String(object.iconColor) : void 0,
      userIsMuted: isSet122(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      displayName: isSet122(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet122(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet122(object.title) ? String(object.title) : void 0,
      previousNames: globalThis.Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      over18: isSet122(object.over18) ? Boolean(object.over18) : void 0,
      iconSize: globalThis.Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet122(object.primaryColor) ? String(object.primaryColor) : void 0,
      iconImg: isSet122(object.iconImg) ? String(object.iconImg) : void 0,
      description: isSet122(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet122(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      headerSize: globalThis.Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
      restrictPosting: isSet122(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      restrictCommenting: isSet122(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      subscribers: isSet122(object.subscribers) ? Number(object.subscribers) : void 0,
      submitTextLabel: isSet122(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      isDefaultIcon: isSet122(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      linkFlairPosition: isSet122(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      displayNamePrefixed: isSet122(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      keyColor: isSet122(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet122(object.name) ? String(object.name) : void 0,
      isDefaultBanner: isSet122(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      url: isSet122(object.url) ? String(object.url) : void 0,
      quarantine: isSet122(object.quarantine) ? Boolean(object.quarantine) : void 0,
      bannerSize: globalThis.Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      userIsModerator: isSet122(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      acceptFollowers: isSet122(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      publicDescription: isSet122(object.publicDescription) ? String(object.publicDescription) : void 0,
      linkFlairEnabled: isSet122(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet122(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet122(object.subredditType) ? String(object.subredditType) : void 0,
      userIsSubscriber: isSet122(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.defaultSet !== void 0) {
      obj.defaultSet = message.defaultSet;
    }
    if (message.userIsContributor !== void 0) {
      obj.userIsContributor = message.userIsContributor;
    }
    if (message.bannerImg !== void 0) {
      obj.bannerImg = message.bannerImg;
    }
    if (message.allowedMediaInComments?.length) {
      obj.allowedMediaInComments = message.allowedMediaInComments;
    }
    if (message.userIsBanned !== void 0) {
      obj.userIsBanned = message.userIsBanned;
    }
    if (message.freeFormReports !== void 0) {
      obj.freeFormReports = message.freeFormReports;
    }
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.showMedia !== void 0) {
      obj.showMedia = message.showMedia;
    }
    if (message.iconColor !== void 0) {
      obj.iconColor = message.iconColor;
    }
    if (message.userIsMuted !== void 0) {
      obj.userIsMuted = message.userIsMuted;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.headerImg !== void 0) {
      obj.headerImg = message.headerImg;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.previousNames?.length) {
      obj.previousNames = message.previousNames;
    }
    if (message.over18 !== void 0) {
      obj.over18 = message.over18;
    }
    if (message.iconSize?.length) {
      obj.iconSize = message.iconSize;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.iconImg !== void 0) {
      obj.iconImg = message.iconImg;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.submitLinkLabel !== void 0) {
      obj.submitLinkLabel = message.submitLinkLabel;
    }
    if (message.headerSize?.length) {
      obj.headerSize = message.headerSize;
    }
    if (message.restrictPosting !== void 0) {
      obj.restrictPosting = message.restrictPosting;
    }
    if (message.restrictCommenting !== void 0) {
      obj.restrictCommenting = message.restrictCommenting;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.submitTextLabel !== void 0) {
      obj.submitTextLabel = message.submitTextLabel;
    }
    if (message.isDefaultIcon !== void 0) {
      obj.isDefaultIcon = message.isDefaultIcon;
    }
    if (message.linkFlairPosition !== void 0) {
      obj.linkFlairPosition = message.linkFlairPosition;
    }
    if (message.displayNamePrefixed !== void 0) {
      obj.displayNamePrefixed = message.displayNamePrefixed;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.isDefaultBanner !== void 0) {
      obj.isDefaultBanner = message.isDefaultBanner;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.quarantine !== void 0) {
      obj.quarantine = message.quarantine;
    }
    if (message.bannerSize?.length) {
      obj.bannerSize = message.bannerSize;
    }
    if (message.userIsModerator !== void 0) {
      obj.userIsModerator = message.userIsModerator;
    }
    if (message.acceptFollowers !== void 0) {
      obj.acceptFollowers = message.acceptFollowers;
    }
    if (message.publicDescription !== void 0) {
      obj.publicDescription = message.publicDescription;
    }
    if (message.linkFlairEnabled !== void 0) {
      obj.linkFlairEnabled = message.linkFlairEnabled;
    }
    if (message.disableContributorRequests !== void 0) {
      obj.disableContributorRequests = message.disableContributorRequests;
    }
    if (message.subredditType !== void 0) {
      obj.subredditType = message.subredditType;
    }
    if (message.userIsSubscriber !== void 0) {
      obj.userIsSubscriber = message.userIsSubscriber;
    }
    return obj;
  },
  create(base) {
    return UserSearchResponse_AccountData_Subreddit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_AccountData_Subreddit();
    message.defaultSet = object.defaultSet ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.over18 = object.over18 ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.headerSize = object.headerSize?.map((e) => e) || [];
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.url = object.url ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UserSearchResponse_AccountData_Subreddit.$type, UserSearchResponse_AccountData_Subreddit);
function createBaseSubredditAddRemovalReasonRequest() {
  return { subreddit: "", message: "", title: "" };
}
var SubredditAddRemovalReasonRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAddRemovalReasonRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : "",
      message: isSet122(object.message) ? globalThis.String(object.message) : "",
      title: isSet122(object.title) ? globalThis.String(object.title) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return SubredditAddRemovalReasonRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAddRemovalReasonRequest();
    message.subreddit = object.subreddit ?? "";
    message.message = object.message ?? "";
    message.title = object.title ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditAddRemovalReasonRequest.$type, SubredditAddRemovalReasonRequest);
function createBaseSubredditAddRemovalReasonResponse() {
  return { id: "" };
}
var SubredditAddRemovalReasonResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAddRemovalReasonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet122(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return SubredditAddRemovalReasonResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditAddRemovalReasonResponse();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditAddRemovalReasonResponse.$type, SubredditAddRemovalReasonResponse);
function createBaseSubredditGetRemovalReasonsRequest() {
  return { subreddit: "" };
}
var SubredditGetRemovalReasonsRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsRequest",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditGetRemovalReasonsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet122(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return SubredditGetRemovalReasonsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditGetRemovalReasonsRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditGetRemovalReasonsRequest.$type, SubredditGetRemovalReasonsRequest);
function createBaseSubredditGetRemovalReasonsResponse() {
  return { data: {}, order: [] };
}
var SubredditGetRemovalReasonsResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    Object.entries(message.data).forEach(([key, value]) => {
      SubredditGetRemovalReasonsResponse_DataEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    for (const v of message.order) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditGetRemovalReasonsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = SubredditGetRemovalReasonsResponse_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.order.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isObject30(object.data) ? Object.entries(object.data).reduce((acc, [key, value]) => {
        acc[key] = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromJSON(value);
        return acc;
      }, {}) : {},
      order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.toJSON(v);
        });
      }
    }
    if (message.order?.length) {
      obj.order = message.order;
    }
    return obj;
  },
  create(base) {
    return SubredditGetRemovalReasonsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditGetRemovalReasonsResponse();
    message.data = Object.entries(object.data ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromPartial(value);
      }
      return acc;
    }, {});
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(SubredditGetRemovalReasonsResponse.$type, SubredditGetRemovalReasonsResponse);
function createBaseSubredditGetRemovalReasonsResponse_SubredditRemovalReason() {
  return { id: "", message: "", title: "" };
}
var SubredditGetRemovalReasonsResponse_SubredditRemovalReason = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.SubredditRemovalReason",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditGetRemovalReasonsResponse_SubredditRemovalReason();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet122(object.id) ? globalThis.String(object.id) : "",
      message: isSet122(object.message) ? globalThis.String(object.message) : "",
      title: isSet122(object.title) ? globalThis.String(object.title) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditGetRemovalReasonsResponse_SubredditRemovalReason();
    message.id = object.id ?? "";
    message.message = object.message ?? "";
    message.title = object.title ?? "";
    return message;
  }
};
messageTypeRegistry.set(SubredditGetRemovalReasonsResponse_SubredditRemovalReason.$type, SubredditGetRemovalReasonsResponse_SubredditRemovalReason);
function createBaseSubredditGetRemovalReasonsResponse_DataEntry() {
  return { key: "", value: void 0 };
}
var SubredditGetRemovalReasonsResponse_DataEntry = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.DataEntry",
  encode(message, writer = import_minimal135.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      SubredditGetRemovalReasonsResponse_SubredditRemovalReason.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal135.default.Reader ? input : import_minimal135.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditGetRemovalReasonsResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet122(object.key) ? globalThis.String(object.key) : "",
      value: isSet122(object.value) ? SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return SubredditGetRemovalReasonsResponse_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditGetRemovalReasonsResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditGetRemovalReasonsResponse_DataEntry.$type, SubredditGetRemovalReasonsResponse_DataEntry);
function longToNumber15(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal135.default.util.Long !== import_long15.default) {
  import_minimal135.default.util.Long = import_long15.default;
  import_minimal135.default.configure();
}
function isObject30(value) {
  return typeof value === "object" && value !== null;
}
function isSet122(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/privatemessages/privatemessages_svc.js
var import_minimal138 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/privatemessages/privatemessages_msg.js
var import_minimal137 = __toESM(require_minimal2(), 1);
function createBaseGenericPrivateMessagesRequest() {
  return { id: "" };
}
var GenericPrivateMessagesRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest",
  encode(message, writer = import_minimal137.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal137.default.Reader ? input : import_minimal137.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericPrivateMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet123(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return GenericPrivateMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGenericPrivateMessagesRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(GenericPrivateMessagesRequest.$type, GenericPrivateMessagesRequest);
function createBaseComposeRequest() {
  return { to: "", subject: "", text: "", fromSr: "" };
}
var ComposeRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.ComposeRequest",
  encode(message, writer = import_minimal137.default.Writer.create()) {
    if (message.to !== "") {
      writer.uint32(10).string(message.to);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.fromSr !== "") {
      writer.uint32(34).string(message.fromSr);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal137.default.Reader ? input : import_minimal137.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseComposeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.to = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subject = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.fromSr = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      to: isSet123(object.to) ? globalThis.String(object.to) : "",
      subject: isSet123(object.subject) ? globalThis.String(object.subject) : "",
      text: isSet123(object.text) ? globalThis.String(object.text) : "",
      fromSr: isSet123(object.fromSr) ? globalThis.String(object.fromSr) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.fromSr !== "") {
      obj.fromSr = message.fromSr;
    }
    return obj;
  },
  create(base) {
    return ComposeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseComposeRequest();
    message.to = object.to ?? "";
    message.subject = object.subject ?? "";
    message.text = object.text ?? "";
    message.fromSr = object.fromSr ?? "";
    return message;
  }
};
messageTypeRegistry.set(ComposeRequest.$type, ComposeRequest);
function createBaseReadAllMessagesRequest() {
  return { filterTypes: "" };
}
var ReadAllMessagesRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.ReadAllMessagesRequest",
  encode(message, writer = import_minimal137.default.Writer.create()) {
    if (message.filterTypes !== "") {
      writer.uint32(10).string(message.filterTypes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal137.default.Reader ? input : import_minimal137.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReadAllMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.filterTypes = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { filterTypes: isSet123(object.filterTypes) ? globalThis.String(object.filterTypes) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterTypes !== "") {
      obj.filterTypes = message.filterTypes;
    }
    return obj;
  },
  create(base) {
    return ReadAllMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReadAllMessagesRequest();
    message.filterTypes = object.filterTypes ?? "";
    return message;
  }
};
messageTypeRegistry.set(ReadAllMessagesRequest.$type, ReadAllMessagesRequest);
function createBaseMessageWhereRequest() {
  return {
    where: "",
    mark: void 0,
    mid: void 0,
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0
  };
}
var MessageWhereRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.MessageWhereRequest",
  encode(message, writer = import_minimal137.default.Writer.create()) {
    if (message.where !== "") {
      writer.uint32(10).string(message.where);
    }
    if (message.mark !== void 0) {
      BoolValue.encode({ value: message.mark }, writer.uint32(18).fork()).ldelim();
    }
    if (message.mid !== void 0) {
      StringValue.encode({ value: message.mid }, writer.uint32(26).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(34).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(58).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal137.default.Reader ? input : import_minimal137.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.where = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.mark = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.mid = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      where: isSet123(object.where) ? globalThis.String(object.where) : "",
      mark: isSet123(object.mark) ? Boolean(object.mark) : void 0,
      mid: isSet123(object.mid) ? String(object.mid) : void 0,
      after: isSet123(object.after) ? String(object.after) : void 0,
      before: isSet123(object.before) ? String(object.before) : void 0,
      count: isSet123(object.count) ? Number(object.count) : void 0,
      limit: isSet123(object.limit) ? Number(object.limit) : void 0,
      show: isSet123(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.where !== "") {
      obj.where = message.where;
    }
    if (message.mark !== void 0) {
      obj.mark = message.mark;
    }
    if (message.mid !== void 0) {
      obj.mid = message.mid;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    return obj;
  },
  create(base) {
    return MessageWhereRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageWhereRequest();
    message.where = object.where ?? "";
    message.mark = object.mark ?? void 0;
    message.mid = object.mid ?? void 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(MessageWhereRequest.$type, MessageWhereRequest);
function isSet123(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/postcollections/postcollections_svc.js
var import_minimal139 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/newmodmail/newmodmail_svc.js
var import_minimal141 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/newmodmail/newmodmail_msg.js
var import_minimal140 = __toESM(require_minimal2(), 1);
function createBaseConversationData() {
  return {
    isAuto: void 0,
    participant: void 0,
    objIds: [],
    isRepliable: void 0,
    lastUserUpdate: void 0,
    isInternal: void 0,
    lastModUpdate: void 0,
    authors: [],
    lastUpdated: void 0,
    legacyFirstMessageId: void 0,
    state: void 0,
    conversationType: void 0,
    lastUnread: void 0,
    owner: void 0,
    subject: void 0,
    id: void 0,
    isHighlighted: void 0,
    numMessages: void 0,
    modActions: {}
  };
}
var ConversationData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.isAuto !== void 0) {
      BoolValue.encode({ value: message.isAuto }, writer.uint32(10).fork()).ldelim();
    }
    if (message.participant !== void 0) {
      Participant.encode(message.participant, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.objIds) {
      ConversationData_ObjId.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.isRepliable !== void 0) {
      BoolValue.encode({ value: message.isRepliable }, writer.uint32(34).fork()).ldelim();
    }
    if (message.lastUserUpdate !== void 0) {
      StringValue.encode({ value: message.lastUserUpdate }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isInternal !== void 0) {
      BoolValue.encode({ value: message.isInternal }, writer.uint32(50).fork()).ldelim();
    }
    if (message.lastModUpdate !== void 0) {
      StringValue.encode({ value: message.lastModUpdate }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.authors) {
      Participant.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.lastUpdated !== void 0) {
      StringValue.encode({ value: message.lastUpdated }, writer.uint32(74).fork()).ldelim();
    }
    if (message.legacyFirstMessageId !== void 0) {
      StringValue.encode({ value: message.legacyFirstMessageId }, writer.uint32(82).fork()).ldelim();
    }
    if (message.state !== void 0) {
      Int32Value.encode({ value: message.state }, writer.uint32(90).fork()).ldelim();
    }
    if (message.conversationType !== void 0) {
      StringValue.encode({ value: message.conversationType }, writer.uint32(98).fork()).ldelim();
    }
    if (message.lastUnread !== void 0) {
      StringValue.encode({ value: message.lastUnread }, writer.uint32(106).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      ConversationData_Owner.encode(message.owner, writer.uint32(114).fork()).ldelim();
    }
    if (message.subject !== void 0) {
      StringValue.encode({ value: message.subject }, writer.uint32(122).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
    }
    if (message.isHighlighted !== void 0) {
      BoolValue.encode({ value: message.isHighlighted }, writer.uint32(138).fork()).ldelim();
    }
    if (message.numMessages !== void 0) {
      Int64Value.encode({ value: message.numMessages }, writer.uint32(146).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      ConversationData_ModActionsEntry.encode({ key, value }, writer.uint32(154).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isAuto = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.participant = Participant.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.objIds.push(ConversationData_ObjId.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.isRepliable = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.lastUserUpdate = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.lastModUpdate = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.authors.push(Participant.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.legacyFirstMessageId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.conversationType = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.lastUnread = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.owner = ConversationData_Owner.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.subject = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.isHighlighted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.numMessages = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          const entry19 = ConversationData_ModActionsEntry.decode(reader, reader.uint32());
          if (entry19.value !== void 0) {
            message.modActions[entry19.key] = entry19.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isAuto: isSet124(object.isAuto) ? Boolean(object.isAuto) : void 0,
      participant: isSet124(object.participant) ? Participant.fromJSON(object.participant) : void 0,
      objIds: globalThis.Array.isArray(object?.objIds) ? object.objIds.map((e) => ConversationData_ObjId.fromJSON(e)) : [],
      isRepliable: isSet124(object.isRepliable) ? Boolean(object.isRepliable) : void 0,
      lastUserUpdate: isSet124(object.lastUserUpdate) ? String(object.lastUserUpdate) : void 0,
      isInternal: isSet124(object.isInternal) ? Boolean(object.isInternal) : void 0,
      lastModUpdate: isSet124(object.lastModUpdate) ? String(object.lastModUpdate) : void 0,
      authors: globalThis.Array.isArray(object?.authors) ? object.authors.map((e) => Participant.fromJSON(e)) : [],
      lastUpdated: isSet124(object.lastUpdated) ? String(object.lastUpdated) : void 0,
      legacyFirstMessageId: isSet124(object.legacyFirstMessageId) ? String(object.legacyFirstMessageId) : void 0,
      state: isSet124(object.state) ? Number(object.state) : void 0,
      conversationType: isSet124(object.conversationType) ? String(object.conversationType) : void 0,
      lastUnread: isSet124(object.lastUnread) ? String(object.lastUnread) : void 0,
      owner: isSet124(object.owner) ? ConversationData_Owner.fromJSON(object.owner) : void 0,
      subject: isSet124(object.subject) ? String(object.subject) : void 0,
      id: isSet124(object.id) ? String(object.id) : void 0,
      isHighlighted: isSet124(object.isHighlighted) ? Boolean(object.isHighlighted) : void 0,
      numMessages: isSet124(object.numMessages) ? Number(object.numMessages) : void 0,
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isAuto !== void 0) {
      obj.isAuto = message.isAuto;
    }
    if (message.participant !== void 0) {
      obj.participant = Participant.toJSON(message.participant);
    }
    if (message.objIds?.length) {
      obj.objIds = message.objIds.map((e) => ConversationData_ObjId.toJSON(e));
    }
    if (message.isRepliable !== void 0) {
      obj.isRepliable = message.isRepliable;
    }
    if (message.lastUserUpdate !== void 0) {
      obj.lastUserUpdate = message.lastUserUpdate;
    }
    if (message.isInternal !== void 0) {
      obj.isInternal = message.isInternal;
    }
    if (message.lastModUpdate !== void 0) {
      obj.lastModUpdate = message.lastModUpdate;
    }
    if (message.authors?.length) {
      obj.authors = message.authors.map((e) => Participant.toJSON(e));
    }
    if (message.lastUpdated !== void 0) {
      obj.lastUpdated = message.lastUpdated;
    }
    if (message.legacyFirstMessageId !== void 0) {
      obj.legacyFirstMessageId = message.legacyFirstMessageId;
    }
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    if (message.conversationType !== void 0) {
      obj.conversationType = message.conversationType;
    }
    if (message.lastUnread !== void 0) {
      obj.lastUnread = message.lastUnread;
    }
    if (message.owner !== void 0) {
      obj.owner = ConversationData_Owner.toJSON(message.owner);
    }
    if (message.subject !== void 0) {
      obj.subject = message.subject;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.isHighlighted !== void 0) {
      obj.isHighlighted = message.isHighlighted;
    }
    if (message.numMessages !== void 0) {
      obj.numMessages = message.numMessages;
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return ConversationData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationData();
    message.isAuto = object.isAuto ?? void 0;
    message.participant = object.participant !== void 0 && object.participant !== null ? Participant.fromPartial(object.participant) : void 0;
    message.objIds = object.objIds?.map((e) => ConversationData_ObjId.fromPartial(e)) || [];
    message.isRepliable = object.isRepliable ?? void 0;
    message.lastUserUpdate = object.lastUserUpdate ?? void 0;
    message.isInternal = object.isInternal ?? void 0;
    message.lastModUpdate = object.lastModUpdate ?? void 0;
    message.authors = object.authors?.map((e) => Participant.fromPartial(e)) || [];
    message.lastUpdated = object.lastUpdated ?? void 0;
    message.legacyFirstMessageId = object.legacyFirstMessageId ?? void 0;
    message.state = object.state ?? void 0;
    message.conversationType = object.conversationType ?? void 0;
    message.lastUnread = object.lastUnread ?? void 0;
    message.owner = object.owner !== void 0 && object.owner !== null ? ConversationData_Owner.fromPartial(object.owner) : void 0;
    message.subject = object.subject ?? void 0;
    message.id = object.id ?? void 0;
    message.isHighlighted = object.isHighlighted ?? void 0;
    message.numMessages = object.numMessages ?? void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ConversationData.$type, ConversationData);
function createBaseConversationData_ObjId() {
  return { id: void 0, key: void 0 };
}
var ConversationData_ObjId = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ObjId",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.key !== void 0) {
      StringValue.encode({ value: message.key }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData_ObjId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.key = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet124(object.id) ? String(object.id) : void 0,
      key: isSet124(object.key) ? String(object.key) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.key !== void 0) {
      obj.key = message.key;
    }
    return obj;
  },
  create(base) {
    return ConversationData_ObjId.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationData_ObjId();
    message.id = object.id ?? void 0;
    message.key = object.key ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationData_ObjId.$type, ConversationData_ObjId);
function createBaseConversationData_Owner() {
  return { displayName: void 0, type: void 0, id: void 0 };
}
var ConversationData_Owner = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData.Owner",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData_Owner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.type = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      displayName: isSet124(object.displayName) ? String(object.displayName) : void 0,
      type: isSet124(object.type) ? String(object.type) : void 0,
      id: isSet124(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.type !== void 0) {
      obj.type = message.type;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return ConversationData_Owner.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationData_Owner();
    message.displayName = object.displayName ?? void 0;
    message.type = object.type ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationData_Owner.$type, ConversationData_Owner);
function createBaseConversationData_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var ConversationData_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ConversationData_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationData_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationData_ModActionsEntry.$type, ConversationData_ModActionsEntry);
function createBaseMessageData() {
  return {
    body: void 0,
    author: void 0,
    isInternal: void 0,
    date: void 0,
    bodyMarkdown: void 0,
    id: void 0,
    participatingAs: void 0
  };
}
var MessageData = {
  $type: "devvit.plugin.redditapi.newmodmail.MessageData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      Participant.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.isInternal !== void 0) {
      BoolValue.encode({ value: message.isInternal }, writer.uint32(26).fork()).ldelim();
    }
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(34).fork()).ldelim();
    }
    if (message.bodyMarkdown !== void 0) {
      StringValue.encode({ value: message.bodyMarkdown }, writer.uint32(42).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
    }
    if (message.participatingAs !== void 0) {
      StringValue.encode({ value: message.participatingAs }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.body = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.author = Participant.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.date = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.bodyMarkdown = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.participatingAs = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet124(object.body) ? String(object.body) : void 0,
      author: isSet124(object.author) ? Participant.fromJSON(object.author) : void 0,
      isInternal: isSet124(object.isInternal) ? Boolean(object.isInternal) : void 0,
      date: isSet124(object.date) ? String(object.date) : void 0,
      bodyMarkdown: isSet124(object.bodyMarkdown) ? String(object.bodyMarkdown) : void 0,
      id: isSet124(object.id) ? String(object.id) : void 0,
      participatingAs: isSet124(object.participatingAs) ? String(object.participatingAs) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.body !== void 0) {
      obj.body = message.body;
    }
    if (message.author !== void 0) {
      obj.author = Participant.toJSON(message.author);
    }
    if (message.isInternal !== void 0) {
      obj.isInternal = message.isInternal;
    }
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.bodyMarkdown !== void 0) {
      obj.bodyMarkdown = message.bodyMarkdown;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.participatingAs !== void 0) {
      obj.participatingAs = message.participatingAs;
    }
    return obj;
  },
  create(base) {
    return MessageData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageData();
    message.body = object.body ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? Participant.fromPartial(object.author) : void 0;
    message.isInternal = object.isInternal ?? void 0;
    message.date = object.date ?? void 0;
    message.bodyMarkdown = object.bodyMarkdown ?? void 0;
    message.id = object.id ?? void 0;
    message.participatingAs = object.participatingAs ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(MessageData.$type, MessageData);
function createBaseConversationUserData() {
  return {
    recentComments: {},
    muteStatus: void 0,
    name: void 0,
    created: void 0,
    banStatus: void 0,
    isSuspended: void 0,
    approveStatus: void 0,
    isShadowBanned: void 0,
    recentPosts: {},
    recentConvos: {},
    id: void 0
  };
}
var ConversationUserData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    Object.entries(message.recentComments).forEach(([key, value]) => {
      ConversationUserData_RecentCommentsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.muteStatus !== void 0) {
      ConversationUserData_MuteStatus.encode(message.muteStatus, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.created !== void 0) {
      StringValue.encode({ value: message.created }, writer.uint32(34).fork()).ldelim();
    }
    if (message.banStatus !== void 0) {
      ConversationUserData_BanStatus.encode(message.banStatus, writer.uint32(42).fork()).ldelim();
    }
    if (message.isSuspended !== void 0) {
      BoolValue.encode({ value: message.isSuspended }, writer.uint32(50).fork()).ldelim();
    }
    if (message.approveStatus !== void 0) {
      ConversationUserData_ApproveStatus.encode(message.approveStatus, writer.uint32(58).fork()).ldelim();
    }
    if (message.isShadowBanned !== void 0) {
      BoolValue.encode({ value: message.isShadowBanned }, writer.uint32(66).fork()).ldelim();
    }
    Object.entries(message.recentPosts).forEach(([key, value]) => {
      ConversationUserData_RecentPostsEntry.encode({ key, value }, writer.uint32(74).fork()).ldelim();
    });
    Object.entries(message.recentConvos).forEach(([key, value]) => {
      ConversationUserData_RecentConvosEntry.encode({ key, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = ConversationUserData_RecentCommentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.recentComments[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.muteStatus = ConversationUserData_MuteStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.created = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.banStatus = ConversationUserData_BanStatus.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.approveStatus = ConversationUserData_ApproveStatus.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.isShadowBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          const entry9 = ConversationUserData_RecentPostsEntry.decode(reader, reader.uint32());
          if (entry9.value !== void 0) {
            message.recentPosts[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          const entry10 = ConversationUserData_RecentConvosEntry.decode(reader, reader.uint32());
          if (entry10.value !== void 0) {
            message.recentConvos[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      recentComments: isObject31(object.recentComments) ? Object.entries(object.recentComments).reduce((acc, [key, value]) => {
        acc[key] = ConversationUserData_CommentData.fromJSON(value);
        return acc;
      }, {}) : {},
      muteStatus: isSet124(object.muteStatus) ? ConversationUserData_MuteStatus.fromJSON(object.muteStatus) : void 0,
      name: isSet124(object.name) ? String(object.name) : void 0,
      created: isSet124(object.created) ? String(object.created) : void 0,
      banStatus: isSet124(object.banStatus) ? ConversationUserData_BanStatus.fromJSON(object.banStatus) : void 0,
      isSuspended: isSet124(object.isSuspended) ? Boolean(object.isSuspended) : void 0,
      approveStatus: isSet124(object.approveStatus) ? ConversationUserData_ApproveStatus.fromJSON(object.approveStatus) : void 0,
      isShadowBanned: isSet124(object.isShadowBanned) ? Boolean(object.isShadowBanned) : void 0,
      recentPosts: isObject31(object.recentPosts) ? Object.entries(object.recentPosts).reduce((acc, [key, value]) => {
        acc[key] = ConversationUserData_PostData.fromJSON(value);
        return acc;
      }, {}) : {},
      recentConvos: isObject31(object.recentConvos) ? Object.entries(object.recentConvos).reduce((acc, [key, value]) => {
        acc[key] = ConversationUserData_ConvoData.fromJSON(value);
        return acc;
      }, {}) : {},
      id: isSet124(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.recentComments) {
      const entries = Object.entries(message.recentComments);
      if (entries.length > 0) {
        obj.recentComments = {};
        entries.forEach(([k, v]) => {
          obj.recentComments[k] = ConversationUserData_CommentData.toJSON(v);
        });
      }
    }
    if (message.muteStatus !== void 0) {
      obj.muteStatus = ConversationUserData_MuteStatus.toJSON(message.muteStatus);
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.created !== void 0) {
      obj.created = message.created;
    }
    if (message.banStatus !== void 0) {
      obj.banStatus = ConversationUserData_BanStatus.toJSON(message.banStatus);
    }
    if (message.isSuspended !== void 0) {
      obj.isSuspended = message.isSuspended;
    }
    if (message.approveStatus !== void 0) {
      obj.approveStatus = ConversationUserData_ApproveStatus.toJSON(message.approveStatus);
    }
    if (message.isShadowBanned !== void 0) {
      obj.isShadowBanned = message.isShadowBanned;
    }
    if (message.recentPosts) {
      const entries = Object.entries(message.recentPosts);
      if (entries.length > 0) {
        obj.recentPosts = {};
        entries.forEach(([k, v]) => {
          obj.recentPosts[k] = ConversationUserData_PostData.toJSON(v);
        });
      }
    }
    if (message.recentConvos) {
      const entries = Object.entries(message.recentConvos);
      if (entries.length > 0) {
        obj.recentConvos = {};
        entries.forEach(([k, v]) => {
          obj.recentConvos[k] = ConversationUserData_ConvoData.toJSON(v);
        });
      }
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData();
    message.recentComments = Object.entries(object.recentComments ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationUserData_CommentData.fromPartial(value);
      }
      return acc;
    }, {});
    message.muteStatus = object.muteStatus !== void 0 && object.muteStatus !== null ? ConversationUserData_MuteStatus.fromPartial(object.muteStatus) : void 0;
    message.name = object.name ?? void 0;
    message.created = object.created ?? void 0;
    message.banStatus = object.banStatus !== void 0 && object.banStatus !== null ? ConversationUserData_BanStatus.fromPartial(object.banStatus) : void 0;
    message.isSuspended = object.isSuspended ?? void 0;
    message.approveStatus = object.approveStatus !== void 0 && object.approveStatus !== null ? ConversationUserData_ApproveStatus.fromPartial(object.approveStatus) : void 0;
    message.isShadowBanned = object.isShadowBanned ?? void 0;
    message.recentPosts = Object.entries(object.recentPosts ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationUserData_PostData.fromPartial(value);
      }
      return acc;
    }, {});
    message.recentConvos = Object.entries(object.recentConvos ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationUserData_ConvoData.fromPartial(value);
      }
      return acc;
    }, {});
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData.$type, ConversationUserData);
function createBaseConversationUserData_CommentData() {
  return { comment: void 0, date: void 0, permalink: void 0, title: void 0 };
}
var ConversationUserData_CommentData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.comment !== void 0) {
      StringValue.encode({ value: message.comment }, writer.uint32(10).fork()).ldelim();
    }
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(18).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(26).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_CommentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.comment = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.date = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet124(object.comment) ? String(object.comment) : void 0,
      date: isSet124(object.date) ? String(object.date) : void 0,
      permalink: isSet124(object.permalink) ? String(object.permalink) : void 0,
      title: isSet124(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.comment !== void 0) {
      obj.comment = message.comment;
    }
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_CommentData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_CommentData();
    message.comment = object.comment ?? void 0;
    message.date = object.date ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_CommentData.$type, ConversationUserData_CommentData);
function createBaseConversationUserData_MuteStatus() {
  return { muteCount: void 0, isMuted: void 0, endDate: void 0, reason: void 0 };
}
var ConversationUserData_MuteStatus = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.muteCount !== void 0) {
      Int64Value.encode({ value: message.muteCount }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isMuted !== void 0) {
      BoolValue.encode({ value: message.isMuted }, writer.uint32(18).fork()).ldelim();
    }
    if (message.endDate !== void 0) {
      StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_MuteStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.muteCount = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.isMuted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.endDate = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      muteCount: isSet124(object.muteCount) ? Number(object.muteCount) : void 0,
      isMuted: isSet124(object.isMuted) ? Boolean(object.isMuted) : void 0,
      endDate: isSet124(object.endDate) ? String(object.endDate) : void 0,
      reason: isSet124(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.muteCount !== void 0) {
      obj.muteCount = message.muteCount;
    }
    if (message.isMuted !== void 0) {
      obj.isMuted = message.isMuted;
    }
    if (message.endDate !== void 0) {
      obj.endDate = message.endDate;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_MuteStatus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_MuteStatus();
    message.muteCount = object.muteCount ?? void 0;
    message.isMuted = object.isMuted ?? void 0;
    message.endDate = object.endDate ?? void 0;
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_MuteStatus.$type, ConversationUserData_MuteStatus);
function createBaseConversationUserData_BanStatus() {
  return { isBanned: void 0, isPermanent: void 0, endDate: void 0, reason: void 0 };
}
var ConversationUserData_BanStatus = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.isBanned !== void 0) {
      BoolValue.encode({ value: message.isBanned }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isPermanent !== void 0) {
      BoolValue.encode({ value: message.isPermanent }, writer.uint32(18).fork()).ldelim();
    }
    if (message.endDate !== void 0) {
      StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_BanStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isBanned = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.isPermanent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.endDate = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isBanned: isSet124(object.isBanned) ? Boolean(object.isBanned) : void 0,
      isPermanent: isSet124(object.isPermanent) ? Boolean(object.isPermanent) : void 0,
      endDate: isSet124(object.endDate) ? String(object.endDate) : void 0,
      reason: isSet124(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isBanned !== void 0) {
      obj.isBanned = message.isBanned;
    }
    if (message.isPermanent !== void 0) {
      obj.isPermanent = message.isPermanent;
    }
    if (message.endDate !== void 0) {
      obj.endDate = message.endDate;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_BanStatus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_BanStatus();
    message.isBanned = object.isBanned ?? void 0;
    message.isPermanent = object.isPermanent ?? void 0;
    message.endDate = object.endDate ?? void 0;
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_BanStatus.$type, ConversationUserData_BanStatus);
function createBaseConversationUserData_ApproveStatus() {
  return { isApproved: void 0 };
}
var ConversationUserData_ApproveStatus = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.isApproved !== void 0) {
      BoolValue.encode({ value: message.isApproved }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_ApproveStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { isApproved: isSet124(object.isApproved) ? Boolean(object.isApproved) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.isApproved !== void 0) {
      obj.isApproved = message.isApproved;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_ApproveStatus.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_ApproveStatus();
    message.isApproved = object.isApproved ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_ApproveStatus.$type, ConversationUserData_ApproveStatus);
function createBaseConversationUserData_PostData() {
  return { date: void 0, permalink: void 0, title: void 0 };
}
var ConversationUserData_PostData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_PostData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.date = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet124(object.date) ? String(object.date) : void 0,
      permalink: isSet124(object.permalink) ? String(object.permalink) : void 0,
      title: isSet124(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_PostData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_PostData();
    message.date = object.date ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_PostData.$type, ConversationUserData_PostData);
function createBaseConversationUserData_ConvoData() {
  return { date: void 0, permalink: void 0, id: void 0, subject: void 0 };
}
var ConversationUserData_ConvoData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.subject !== void 0) {
      StringValue.encode({ value: message.subject }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_ConvoData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.date = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.subject = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet124(object.date) ? String(object.date) : void 0,
      permalink: isSet124(object.permalink) ? String(object.permalink) : void 0,
      id: isSet124(object.id) ? String(object.id) : void 0,
      subject: isSet124(object.subject) ? String(object.subject) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.permalink !== void 0) {
      obj.permalink = message.permalink;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.subject !== void 0) {
      obj.subject = message.subject;
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_ConvoData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_ConvoData();
    message.date = object.date ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.id = object.id ?? void 0;
    message.subject = object.subject ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_ConvoData.$type, ConversationUserData_ConvoData);
function createBaseConversationUserData_RecentCommentsEntry() {
  return { key: "", value: void 0 };
}
var ConversationUserData_RecentCommentsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationUserData_CommentData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_RecentCommentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ConversationUserData_CommentData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ConversationUserData_CommentData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ConversationUserData_CommentData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_RecentCommentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_RecentCommentsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationUserData_CommentData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_RecentCommentsEntry.$type, ConversationUserData_RecentCommentsEntry);
function createBaseConversationUserData_RecentPostsEntry() {
  return { key: "", value: void 0 };
}
var ConversationUserData_RecentPostsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationUserData_PostData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_RecentPostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ConversationUserData_PostData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ConversationUserData_PostData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ConversationUserData_PostData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_RecentPostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_RecentPostsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationUserData_PostData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_RecentPostsEntry.$type, ConversationUserData_RecentPostsEntry);
function createBaseConversationUserData_RecentConvosEntry() {
  return { key: "", value: void 0 };
}
var ConversationUserData_RecentConvosEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationUserData_ConvoData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_RecentConvosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ConversationUserData_ConvoData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ConversationUserData_ConvoData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ConversationUserData_ConvoData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ConversationUserData_RecentConvosEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_RecentConvosEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationUserData_ConvoData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ConversationUserData_RecentConvosEntry.$type, ConversationUserData_RecentConvosEntry);
function createBaseParticipant() {
  return {
    isMod: void 0,
    isAdmin: void 0,
    name: void 0,
    isOp: void 0,
    isParticipant: void 0,
    isApproved: void 0,
    isHidden: void 0,
    id: void 0,
    isDeleted: void 0
  };
}
var Participant = {
  $type: "devvit.plugin.redditapi.newmodmail.Participant",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isAdmin !== void 0) {
      BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.isOp !== void 0) {
      BoolValue.encode({ value: message.isOp }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isParticipant !== void 0) {
      BoolValue.encode({ value: message.isParticipant }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isApproved !== void 0) {
      BoolValue.encode({ value: message.isApproved }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isHidden !== void 0) {
      BoolValue.encode({ value: message.isHidden }, writer.uint32(58).fork()).ldelim();
    }
    if (message.id !== void 0) {
      Int64Value.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
    }
    if (message.isDeleted !== void 0) {
      BoolValue.encode({ value: message.isDeleted }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.isOp = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.isParticipant = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.id = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isMod: isSet124(object.isMod) ? Boolean(object.isMod) : void 0,
      isAdmin: isSet124(object.isAdmin) ? Boolean(object.isAdmin) : void 0,
      name: isSet124(object.name) ? String(object.name) : void 0,
      isOp: isSet124(object.isOp) ? Boolean(object.isOp) : void 0,
      isParticipant: isSet124(object.isParticipant) ? Boolean(object.isParticipant) : void 0,
      isApproved: isSet124(object.isApproved) ? Boolean(object.isApproved) : void 0,
      isHidden: isSet124(object.isHidden) ? Boolean(object.isHidden) : void 0,
      id: isSet124(object.id) ? Number(object.id) : void 0,
      isDeleted: isSet124(object.isDeleted) ? Boolean(object.isDeleted) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isMod !== void 0) {
      obj.isMod = message.isMod;
    }
    if (message.isAdmin !== void 0) {
      obj.isAdmin = message.isAdmin;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.isOp !== void 0) {
      obj.isOp = message.isOp;
    }
    if (message.isParticipant !== void 0) {
      obj.isParticipant = message.isParticipant;
    }
    if (message.isApproved !== void 0) {
      obj.isApproved = message.isApproved;
    }
    if (message.isHidden !== void 0) {
      obj.isHidden = message.isHidden;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.isDeleted !== void 0) {
      obj.isDeleted = message.isDeleted;
    }
    return obj;
  },
  create(base) {
    return Participant.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseParticipant();
    message.isMod = object.isMod ?? void 0;
    message.isAdmin = object.isAdmin ?? void 0;
    message.name = object.name ?? void 0;
    message.isOp = object.isOp ?? void 0;
    message.isParticipant = object.isParticipant ?? void 0;
    message.isApproved = object.isApproved ?? void 0;
    message.isHidden = object.isHidden ?? void 0;
    message.id = object.id ?? void 0;
    message.isDeleted = object.isDeleted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(Participant.$type, Participant);
function createBaseModActionData() {
  return { date: void 0, actionTypeId: void 0, id: void 0, author: void 0 };
}
var ModActionData = {
  $type: "devvit.plugin.redditapi.newmodmail.ModActionData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.actionTypeId !== void 0) {
      Int32Value.encode({ value: message.actionTypeId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.author !== void 0) {
      ModActionData_ModActionAuthor.encode(message.author, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModActionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.date = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.actionTypeId = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.author = ModActionData_ModActionAuthor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet124(object.date) ? String(object.date) : void 0,
      actionTypeId: isSet124(object.actionTypeId) ? Number(object.actionTypeId) : void 0,
      id: isSet124(object.id) ? String(object.id) : void 0,
      author: isSet124(object.author) ? ModActionData_ModActionAuthor.fromJSON(object.author) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.date !== void 0) {
      obj.date = message.date;
    }
    if (message.actionTypeId !== void 0) {
      obj.actionTypeId = message.actionTypeId;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.author !== void 0) {
      obj.author = ModActionData_ModActionAuthor.toJSON(message.author);
    }
    return obj;
  },
  create(base) {
    return ModActionData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModActionData();
    message.date = object.date ?? void 0;
    message.actionTypeId = object.actionTypeId ?? void 0;
    message.id = object.id ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? ModActionData_ModActionAuthor.fromPartial(object.author) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ModActionData.$type, ModActionData);
function createBaseModActionData_ModActionAuthor() {
  return {
    isMod: void 0,
    isAdmin: void 0,
    name: void 0,
    isHidden: void 0,
    id: void 0,
    isDeleted: void 0
  };
}
var ModActionData_ModActionAuthor = {
  $type: "devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isAdmin !== void 0) {
      BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.isHidden !== void 0) {
      BoolValue.encode({ value: message.isHidden }, writer.uint32(34).fork()).ldelim();
    }
    if (message.id !== void 0) {
      Int64Value.encode({ value: message.id }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isDeleted !== void 0) {
      BoolValue.encode({ value: message.isDeleted }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModActionData_ModActionAuthor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.id = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isMod: isSet124(object.isMod) ? Boolean(object.isMod) : void 0,
      isAdmin: isSet124(object.isAdmin) ? Boolean(object.isAdmin) : void 0,
      name: isSet124(object.name) ? String(object.name) : void 0,
      isHidden: isSet124(object.isHidden) ? Boolean(object.isHidden) : void 0,
      id: isSet124(object.id) ? Number(object.id) : void 0,
      isDeleted: isSet124(object.isDeleted) ? Boolean(object.isDeleted) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.isMod !== void 0) {
      obj.isMod = message.isMod;
    }
    if (message.isAdmin !== void 0) {
      obj.isAdmin = message.isAdmin;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.isHidden !== void 0) {
      obj.isHidden = message.isHidden;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.isDeleted !== void 0) {
      obj.isDeleted = message.isDeleted;
    }
    return obj;
  },
  create(base) {
    return ModActionData_ModActionAuthor.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModActionData_ModActionAuthor();
    message.isMod = object.isMod ?? void 0;
    message.isAdmin = object.isAdmin ?? void 0;
    message.name = object.name ?? void 0;
    message.isHidden = object.isHidden ?? void 0;
    message.id = object.id ?? void 0;
    message.isDeleted = object.isDeleted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ModActionData_ModActionAuthor.$type, ModActionData_ModActionAuthor);
function createBaseBulkReadConversationsRequest() {
  return { entity: "", state: "" };
}
var BulkReadConversationsRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.entity !== "") {
      writer.uint32(10).string(message.entity);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBulkReadConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.entity = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.state = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      entity: isSet124(object.entity) ? globalThis.String(object.entity) : "",
      state: isSet124(object.state) ? globalThis.String(object.state) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },
  create(base) {
    return BulkReadConversationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBulkReadConversationsRequest();
    message.entity = object.entity ?? "";
    message.state = object.state ?? "";
    return message;
  }
};
messageTypeRegistry.set(BulkReadConversationsRequest.$type, BulkReadConversationsRequest);
function createBaseGetConversationsRequest() {
  return { after: void 0, entity: void 0, limit: void 0, sort: void 0, state: void 0 };
}
var GetConversationsRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.entity !== void 0) {
      StringValue.encode({ value: message.entity }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(34).fork()).ldelim();
    }
    if (message.state !== void 0) {
      StringValue.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.entity = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.state = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet124(object.after) ? String(object.after) : void 0,
      entity: isSet124(object.entity) ? String(object.entity) : void 0,
      limit: isSet124(object.limit) ? Number(object.limit) : void 0,
      sort: isSet124(object.sort) ? String(object.sort) : void 0,
      state: isSet124(object.state) ? String(object.state) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.entity !== void 0) {
      obj.entity = message.entity;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.state !== void 0) {
      obj.state = message.state;
    }
    return obj;
  },
  create(base) {
    return GetConversationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationsRequest();
    message.after = object.after ?? void 0;
    message.entity = object.entity ?? void 0;
    message.limit = object.limit ?? void 0;
    message.sort = object.sort ?? void 0;
    message.state = object.state ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetConversationsRequest.$type, GetConversationsRequest);
function createBaseCreateConversationRequest() {
  return { body: "", isAuthorHidden: false, srName: "", subject: "", to: void 0 };
}
var CreateConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.body !== "") {
      writer.uint32(10).string(message.body);
    }
    if (message.isAuthorHidden !== false) {
      writer.uint32(16).bool(message.isAuthorHidden);
    }
    if (message.srName !== "") {
      writer.uint32(26).string(message.srName);
    }
    if (message.subject !== "") {
      writer.uint32(34).string(message.subject);
    }
    if (message.to !== void 0) {
      StringValue.encode({ value: message.to }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.body = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.isAuthorHidden = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.srName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.subject = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.to = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet124(object.body) ? globalThis.String(object.body) : "",
      isAuthorHidden: isSet124(object.isAuthorHidden) ? globalThis.Boolean(object.isAuthorHidden) : false,
      srName: isSet124(object.srName) ? globalThis.String(object.srName) : "",
      subject: isSet124(object.subject) ? globalThis.String(object.subject) : "",
      to: isSet124(object.to) ? String(object.to) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.isAuthorHidden !== false) {
      obj.isAuthorHidden = message.isAuthorHidden;
    }
    if (message.srName !== "") {
      obj.srName = message.srName;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.to !== void 0) {
      obj.to = message.to;
    }
    return obj;
  },
  create(base) {
    return CreateConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationRequest();
    message.body = object.body ?? "";
    message.isAuthorHidden = object.isAuthorHidden ?? false;
    message.srName = object.srName ?? "";
    message.subject = object.subject ?? "";
    message.to = object.to ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateConversationRequest.$type, CreateConversationRequest);
function createBaseGetConversationRequest() {
  return { conversationId: "", markRead: false };
}
var GetConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.markRead !== false) {
      writer.uint32(16).bool(message.markRead);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.markRead = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationId: isSet124(object.conversationId) ? globalThis.String(object.conversationId) : "",
      markRead: isSet124(object.markRead) ? globalThis.Boolean(object.markRead) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.markRead !== false) {
      obj.markRead = message.markRead;
    }
    return obj;
  },
  create(base) {
    return GetConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.markRead = object.markRead ?? false;
    return message;
  }
};
messageTypeRegistry.set(GetConversationRequest.$type, GetConversationRequest);
function createBaseCreateConversationMessageRequest() {
  return { body: "", isAuthorHidden: false, isInternal: false, conversationId: "" };
}
var CreateConversationMessageRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.body !== "") {
      writer.uint32(10).string(message.body);
    }
    if (message.isAuthorHidden !== false) {
      writer.uint32(16).bool(message.isAuthorHidden);
    }
    if (message.isInternal !== false) {
      writer.uint32(24).bool(message.isInternal);
    }
    if (message.conversationId !== "") {
      writer.uint32(34).string(message.conversationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.body = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.isAuthorHidden = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.isInternal = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.conversationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet124(object.body) ? globalThis.String(object.body) : "",
      isAuthorHidden: isSet124(object.isAuthorHidden) ? globalThis.Boolean(object.isAuthorHidden) : false,
      isInternal: isSet124(object.isInternal) ? globalThis.Boolean(object.isInternal) : false,
      conversationId: isSet124(object.conversationId) ? globalThis.String(object.conversationId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.isAuthorHidden !== false) {
      obj.isAuthorHidden = message.isAuthorHidden;
    }
    if (message.isInternal !== false) {
      obj.isInternal = message.isInternal;
    }
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    return obj;
  },
  create(base) {
    return CreateConversationMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationMessageRequest();
    message.body = object.body ?? "";
    message.isAuthorHidden = object.isAuthorHidden ?? false;
    message.isInternal = object.isInternal ?? false;
    message.conversationId = object.conversationId ?? "";
    return message;
  }
};
messageTypeRegistry.set(CreateConversationMessageRequest.$type, CreateConversationMessageRequest);
function createBaseBasicConversationRequest() {
  return { conversationId: "" };
}
var BasicConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { conversationId: isSet124(object.conversationId) ? globalThis.String(object.conversationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    return obj;
  },
  create(base) {
    return BasicConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicConversationRequest();
    message.conversationId = object.conversationId ?? "";
    return message;
  }
};
messageTypeRegistry.set(BasicConversationRequest.$type, BasicConversationRequest);
function createBaseBasicConversationsRequest() {
  return { conversationIds: "" };
}
var BasicConversationsRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversationIds !== "") {
      writer.uint32(10).string(message.conversationIds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversationIds = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { conversationIds: isSet124(object.conversationIds) ? globalThis.String(object.conversationIds) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationIds !== "") {
      obj.conversationIds = message.conversationIds;
    }
    return obj;
  },
  create(base) {
    return BasicConversationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicConversationsRequest();
    message.conversationIds = object.conversationIds ?? "";
    return message;
  }
};
messageTypeRegistry.set(BasicConversationsRequest.$type, BasicConversationsRequest);
function createBaseMuteConversationRequest() {
  return { conversationId: "", numHours: 0 };
}
var MuteConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.numHours !== 0) {
      writer.uint32(16).int32(message.numHours);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.numHours = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationId: isSet124(object.conversationId) ? globalThis.String(object.conversationId) : "",
      numHours: isSet124(object.numHours) ? globalThis.Number(object.numHours) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.numHours !== 0) {
      obj.numHours = Math.round(message.numHours);
    }
    return obj;
  },
  create(base) {
    return MuteConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMuteConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.numHours = object.numHours ?? 0;
    return message;
  }
};
messageTypeRegistry.set(MuteConversationRequest.$type, MuteConversationRequest);
function createBaseTempBanRequest() {
  return { conversationId: "", duration: 0 };
}
var TempBanRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanRequest",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.duration !== 0) {
      writer.uint32(16).int32(message.duration);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.duration = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationId: isSet124(object.conversationId) ? globalThis.String(object.conversationId) : "",
      duration: isSet124(object.duration) ? globalThis.Number(object.duration) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    return obj;
  },
  create(base) {
    return TempBanRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTempBanRequest();
    message.conversationId = object.conversationId ?? "";
    message.duration = object.duration ?? 0;
    return message;
  }
};
messageTypeRegistry.set(TempBanRequest.$type, TempBanRequest);
function createBaseBulkReadConversationsResponse() {
  return { conversationIds: [] };
}
var BulkReadConversationsResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    for (const v of message.conversationIds) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBulkReadConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationIds: globalThis.Array.isArray(object?.conversationIds) ? object.conversationIds.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationIds?.length) {
      obj.conversationIds = message.conversationIds;
    }
    return obj;
  },
  create(base) {
    return BulkReadConversationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBulkReadConversationsResponse();
    message.conversationIds = object.conversationIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(BulkReadConversationsResponse.$type, BulkReadConversationsResponse);
function createBaseGetConversationsResponse() {
  return { conversations: {}, messages: {}, viewerId: void 0, conversationIds: [] };
}
var GetConversationsResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    Object.entries(message.conversations).forEach(([key, value]) => {
      GetConversationsResponse_ConversationsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    Object.entries(message.messages).forEach(([key, value]) => {
      GetConversationsResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.viewerId !== void 0) {
      StringValue.encode({ value: message.viewerId }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.conversationIds) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = GetConversationsResponse_ConversationsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.conversations[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = GetConversationsResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.viewerId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isObject31(object.conversations) ? Object.entries(object.conversations).reduce((acc, [key, value]) => {
        acc[key] = ConversationData.fromJSON(value);
        return acc;
      }, {}) : {},
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      viewerId: isSet124(object.viewerId) ? String(object.viewerId) : void 0,
      conversationIds: globalThis.Array.isArray(object?.conversationIds) ? object.conversationIds.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversations) {
      const entries = Object.entries(message.conversations);
      if (entries.length > 0) {
        obj.conversations = {};
        entries.forEach(([k, v]) => {
          obj.conversations[k] = ConversationData.toJSON(v);
        });
      }
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.viewerId !== void 0) {
      obj.viewerId = message.viewerId;
    }
    if (message.conversationIds?.length) {
      obj.conversationIds = message.conversationIds;
    }
    return obj;
  },
  create(base) {
    return GetConversationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationsResponse();
    message.conversations = Object.entries(object.conversations ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationData.fromPartial(value);
      }
      return acc;
    }, {});
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.viewerId = object.viewerId ?? void 0;
    message.conversationIds = object.conversationIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(GetConversationsResponse.$type, GetConversationsResponse);
function createBaseGetConversationsResponse_ConversationsEntry() {
  return { key: "", value: void 0 };
}
var GetConversationsResponse_ConversationsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse_ConversationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ConversationData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ConversationData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ConversationData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetConversationsResponse_ConversationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationsResponse_ConversationsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetConversationsResponse_ConversationsEntry.$type, GetConversationsResponse_ConversationsEntry);
function createBaseGetConversationsResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var GetConversationsResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetConversationsResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationsResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetConversationsResponse_MessagesEntry.$type, GetConversationsResponse_MessagesEntry);
function createBaseCreateConversationResponse() {
  return {
    conversation: void 0,
    messages: {},
    modActions: {},
    fields: [],
    reason: void 0,
    message: void 0,
    explanation: void 0,
    user: void 0
  };
}
var CreateConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      CreateConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      CreateConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(42).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(50).fork()).ldelim();
    }
    if (message.explanation !== void 0) {
      StringValue.encode({ value: message.explanation }, writer.uint32(58).fork()).ldelim();
    }
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversation = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = CreateConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = CreateConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.explanation = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.user = ConversationUserData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversation: isSet124(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      reason: isSet124(object.reason) ? String(object.reason) : void 0,
      message: isSet124(object.message) ? String(object.message) : void 0,
      explanation: isSet124(object.explanation) ? String(object.explanation) : void 0,
      user: isSet124(object.user) ? ConversationUserData.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversation !== void 0) {
      obj.conversation = ConversationData.toJSON(message.conversation);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    if (message.explanation !== void 0) {
      obj.explanation = message.explanation;
    }
    if (message.user !== void 0) {
      obj.user = ConversationUserData.toJSON(message.user);
    }
    return obj;
  },
  create(base) {
    return CreateConversationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationResponse();
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.fields = object.fields?.map((e) => e) || [];
    message.reason = object.reason ?? void 0;
    message.message = object.message ?? void 0;
    message.explanation = object.explanation ?? void 0;
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateConversationResponse.$type, CreateConversationResponse);
function createBaseCreateConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var CreateConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return CreateConversationResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateConversationResponse_MessagesEntry.$type, CreateConversationResponse_MessagesEntry);
function createBaseCreateConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var CreateConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return CreateConversationResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateConversationResponse_ModActionsEntry.$type, CreateConversationResponse_ModActionsEntry);
function createBaseGetConversationResponse() {
  return { conversation: void 0, messages: {}, modActions: {}, participantSubreddit: void 0, user: void 0 };
}
var GetConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      GetConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      GetConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.participantSubreddit !== void 0) {
      Any.encode(message.participantSubreddit, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversation = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = GetConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = GetConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.participantSubreddit = Any.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.user = ConversationUserData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversation: isSet124(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      participantSubreddit: isSet124(object.participantSubreddit) ? Any.fromJSON(object.participantSubreddit) : void 0,
      user: isSet124(object.user) ? ConversationUserData.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversation !== void 0) {
      obj.conversation = ConversationData.toJSON(message.conversation);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    if (message.participantSubreddit !== void 0) {
      obj.participantSubreddit = Any.toJSON(message.participantSubreddit);
    }
    if (message.user !== void 0) {
      obj.user = ConversationUserData.toJSON(message.user);
    }
    return obj;
  },
  create(base) {
    return GetConversationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationResponse();
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.participantSubreddit = object.participantSubreddit !== void 0 && object.participantSubreddit !== null ? Any.fromPartial(object.participantSubreddit) : void 0;
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetConversationResponse.$type, GetConversationResponse);
function createBaseGetConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var GetConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetConversationResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetConversationResponse_MessagesEntry.$type, GetConversationResponse_MessagesEntry);
function createBaseGetConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var GetConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return GetConversationResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetConversationResponse_ModActionsEntry.$type, GetConversationResponse_ModActionsEntry);
function createBaseCreateConversationMessageResponse() {
  return { conversation: void 0, messages: {}, user: void 0 };
}
var CreateConversationMessageResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      CreateConversationMessageResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversation = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = CreateConversationMessageResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = ConversationUserData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversation: isSet124(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet124(object.user) ? ConversationUserData.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversation !== void 0) {
      obj.conversation = ConversationData.toJSON(message.conversation);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.user !== void 0) {
      obj.user = ConversationUserData.toJSON(message.user);
    }
    return obj;
  },
  create(base) {
    return CreateConversationMessageResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationMessageResponse();
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateConversationMessageResponse.$type, CreateConversationMessageResponse);
function createBaseCreateConversationMessageResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var CreateConversationMessageResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationMessageResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return CreateConversationMessageResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateConversationMessageResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateConversationMessageResponse_MessagesEntry.$type, CreateConversationMessageResponse_MessagesEntry);
function createBaseApproveConversationResponse() {
  return {
    conversations: void 0,
    messages: {},
    user: void 0,
    modActions: {},
    fields: [],
    reason: void 0,
    message: void 0,
    explanation: void 0
  };
}
var ApproveConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      ApproveConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      ApproveConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
    }
    if (message.explanation !== void 0) {
      StringValue.encode({ value: message.explanation }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApproveConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversations = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = ApproveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = ConversationUserData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          const entry4 = ApproveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.modActions[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.explanation = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet124(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet124(object.user) ? ConversationUserData.fromJSON(object.user) : void 0,
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      reason: isSet124(object.reason) ? String(object.reason) : void 0,
      message: isSet124(object.message) ? String(object.message) : void 0,
      explanation: isSet124(object.explanation) ? String(object.explanation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversations !== void 0) {
      obj.conversations = ConversationData.toJSON(message.conversations);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.user !== void 0) {
      obj.user = ConversationUserData.toJSON(message.user);
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    if (message.explanation !== void 0) {
      obj.explanation = message.explanation;
    }
    return obj;
  },
  create(base) {
    return ApproveConversationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseApproveConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.fields = object.fields?.map((e) => e) || [];
    message.reason = object.reason ?? void 0;
    message.message = object.message ?? void 0;
    message.explanation = object.explanation ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ApproveConversationResponse.$type, ApproveConversationResponse);
function createBaseApproveConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var ApproveConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApproveConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ApproveConversationResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseApproveConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ApproveConversationResponse_MessagesEntry.$type, ApproveConversationResponse_MessagesEntry);
function createBaseApproveConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var ApproveConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApproveConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ApproveConversationResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseApproveConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ApproveConversationResponse_ModActionsEntry.$type, ApproveConversationResponse_ModActionsEntry);
function createBaseArchiveConversationResponse() {
  return { conversations: void 0, messages: {}, modActions: {}, conversation: void 0 };
}
var ArchiveConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      ArchiveConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      ArchiveConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArchiveConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversations = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = ArchiveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = ArchiveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.conversation = ConversationData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet124(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      conversation: isSet124(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversations !== void 0) {
      obj.conversations = ConversationData.toJSON(message.conversations);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    if (message.conversation !== void 0) {
      obj.conversation = ConversationData.toJSON(message.conversation);
    }
    return obj;
  },
  create(base) {
    return ArchiveConversationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseArchiveConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ArchiveConversationResponse.$type, ArchiveConversationResponse);
function createBaseArchiveConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var ArchiveConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArchiveConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ArchiveConversationResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseArchiveConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ArchiveConversationResponse_MessagesEntry.$type, ArchiveConversationResponse_MessagesEntry);
function createBaseArchiveConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var ArchiveConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArchiveConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ArchiveConversationResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseArchiveConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ArchiveConversationResponse_ModActionsEntry.$type, ArchiveConversationResponse_ModActionsEntry);
function createBaseHighlightConversationResponse() {
  return { conversations: void 0, messages: {}, modActions: {}, conversation: void 0 };
}
var HighlightConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      HighlightConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      HighlightConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHighlightConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversations = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = HighlightConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = HighlightConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.conversation = ConversationData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet124(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      conversation: isSet124(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversations !== void 0) {
      obj.conversations = ConversationData.toJSON(message.conversations);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    if (message.conversation !== void 0) {
      obj.conversation = ConversationData.toJSON(message.conversation);
    }
    return obj;
  },
  create(base) {
    return HighlightConversationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHighlightConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    return message;
  }
};
messageTypeRegistry.set(HighlightConversationResponse.$type, HighlightConversationResponse);
function createBaseHighlightConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var HighlightConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHighlightConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return HighlightConversationResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHighlightConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(HighlightConversationResponse_MessagesEntry.$type, HighlightConversationResponse_MessagesEntry);
function createBaseHighlightConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var HighlightConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHighlightConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return HighlightConversationResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHighlightConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(HighlightConversationResponse_ModActionsEntry.$type, HighlightConversationResponse_ModActionsEntry);
function createBaseMuteConversationResponse() {
  return { conversations: void 0, messages: {}, user: void 0, modActions: {} };
}
var MuteConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      MuteConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      MuteConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversations = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = MuteConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = ConversationUserData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          const entry4 = MuteConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.modActions[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet124(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet124(object.user) ? ConversationUserData.fromJSON(object.user) : void 0,
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversations !== void 0) {
      obj.conversations = ConversationData.toJSON(message.conversations);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.user !== void 0) {
      obj.user = ConversationUserData.toJSON(message.user);
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return MuteConversationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMuteConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(MuteConversationResponse.$type, MuteConversationResponse);
function createBaseMuteConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var MuteConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return MuteConversationResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMuteConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(MuteConversationResponse_MessagesEntry.$type, MuteConversationResponse_MessagesEntry);
function createBaseMuteConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var MuteConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return MuteConversationResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMuteConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(MuteConversationResponse_ModActionsEntry.$type, MuteConversationResponse_ModActionsEntry);
function createBaseTempBanResponse() {
  return {
    conversations: void 0,
    messages: {},
    user: void 0,
    modActions: {},
    fields: [],
    reason: void 0,
    message: void 0
  };
}
var TempBanResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      TempBanResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      TempBanResponse_ModActionsEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.conversations = ConversationData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = TempBanResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = ConversationUserData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          const entry4 = TempBanResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.modActions[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.message = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet124(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject31(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet124(object.user) ? ConversationUserData.fromJSON(object.user) : void 0,
      modActions: isObject31(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      reason: isSet124(object.reason) ? String(object.reason) : void 0,
      message: isSet124(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversations !== void 0) {
      obj.conversations = ConversationData.toJSON(message.conversations);
    }
    if (message.messages) {
      const entries = Object.entries(message.messages);
      if (entries.length > 0) {
        obj.messages = {};
        entries.forEach(([k, v]) => {
          obj.messages[k] = MessageData.toJSON(v);
        });
      }
    }
    if (message.user !== void 0) {
      obj.user = ConversationUserData.toJSON(message.user);
    }
    if (message.modActions) {
      const entries = Object.entries(message.modActions);
      if (entries.length > 0) {
        obj.modActions = {};
        entries.forEach(([k, v]) => {
          obj.modActions[k] = ModActionData.toJSON(v);
        });
      }
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    if (message.message !== void 0) {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return TempBanResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTempBanResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.fields = object.fields?.map((e) => e) || [];
    message.reason = object.reason ?? void 0;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(TempBanResponse.$type, TempBanResponse);
function createBaseTempBanResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var TempBanResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = MessageData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MessageData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return TempBanResponse_MessagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTempBanResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(TempBanResponse_MessagesEntry.$type, TempBanResponse_MessagesEntry);
function createBaseTempBanResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var TempBanResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = ModActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = ModActionData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return TempBanResponse_ModActionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTempBanResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(TempBanResponse_ModActionsEntry.$type, TempBanResponse_ModActionsEntry);
function createBaseSubredditsResponse() {
  return { subreddits: {} };
}
var SubredditsResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    Object.entries(message.subreddits).forEach(([key, value]) => {
      SubredditsResponse_SubredditsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = SubredditsResponse_SubredditsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.subreddits[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: isObject31(object.subreddits) ? Object.entries(object.subreddits).reduce((acc, [key, value]) => {
        acc[key] = SubredditsResponse_SubredditData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddits) {
      const entries = Object.entries(message.subreddits);
      if (entries.length > 0) {
        obj.subreddits = {};
        entries.forEach(([k, v]) => {
          obj.subreddits[k] = SubredditsResponse_SubredditData.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return SubredditsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsResponse();
    message.subreddits = Object.entries(object.subreddits ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = SubredditsResponse_SubredditData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(SubredditsResponse.$type, SubredditsResponse);
function createBaseSubredditsResponse_SubredditData() {
  return {
    communityIcon: void 0,
    keyColor: void 0,
    displayName: void 0,
    name: void 0,
    subscribers: void 0,
    primaryColor: void 0,
    id: void 0,
    lastUpdated: void 0,
    icon: void 0
  };
}
var SubredditsResponse_SubredditData = {
  $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(10).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int32Value.encode({ value: message.subscribers }, writer.uint32(42).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
    }
    if (message.lastUpdated !== void 0) {
      StringValue.encode({ value: message.lastUpdated }, writer.uint32(66).fork()).ldelim();
    }
    if (message.icon !== void 0) {
      StringValue.encode({ value: message.icon }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsResponse_SubredditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.subscribers = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.icon = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      communityIcon: isSet124(object.communityIcon) ? String(object.communityIcon) : void 0,
      keyColor: isSet124(object.keyColor) ? String(object.keyColor) : void 0,
      displayName: isSet124(object.displayName) ? String(object.displayName) : void 0,
      name: isSet124(object.name) ? String(object.name) : void 0,
      subscribers: isSet124(object.subscribers) ? Number(object.subscribers) : void 0,
      primaryColor: isSet124(object.primaryColor) ? String(object.primaryColor) : void 0,
      id: isSet124(object.id) ? String(object.id) : void 0,
      lastUpdated: isSet124(object.lastUpdated) ? String(object.lastUpdated) : void 0,
      icon: isSet124(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.communityIcon !== void 0) {
      obj.communityIcon = message.communityIcon;
    }
    if (message.keyColor !== void 0) {
      obj.keyColor = message.keyColor;
    }
    if (message.displayName !== void 0) {
      obj.displayName = message.displayName;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.subscribers !== void 0) {
      obj.subscribers = message.subscribers;
    }
    if (message.primaryColor !== void 0) {
      obj.primaryColor = message.primaryColor;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.lastUpdated !== void 0) {
      obj.lastUpdated = message.lastUpdated;
    }
    if (message.icon !== void 0) {
      obj.icon = message.icon;
    }
    return obj;
  },
  create(base) {
    return SubredditsResponse_SubredditData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsResponse_SubredditData();
    message.communityIcon = object.communityIcon ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.name = object.name ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.primaryColor = object.primaryColor ?? void 0;
    message.id = object.id ?? void 0;
    message.lastUpdated = object.lastUpdated ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditsResponse_SubredditData.$type, SubredditsResponse_SubredditData);
function createBaseSubredditsResponse_SubredditsEntry() {
  return { key: "", value: void 0 };
}
var SubredditsResponse_SubredditsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      SubredditsResponse_SubredditData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsResponse_SubredditsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = SubredditsResponse_SubredditData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet124(object.key) ? globalThis.String(object.key) : "",
      value: isSet124(object.value) ? SubredditsResponse_SubredditData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = SubredditsResponse_SubredditData.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return SubredditsResponse_SubredditsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubredditsResponse_SubredditsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? SubredditsResponse_SubredditData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubredditsResponse_SubredditsEntry.$type, SubredditsResponse_SubredditsEntry);
function createBaseUnreadCountResponse() {
  return {
    archived: void 0,
    appeals: void 0,
    highlighted: void 0,
    notifications: void 0,
    joinRequests: void 0,
    filtered: void 0,
    new: void 0,
    inprogress: void 0,
    mod: void 0
  };
}
var UnreadCountResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.UnreadCountResponse",
  encode(message, writer = import_minimal140.default.Writer.create()) {
    if (message.archived !== void 0) {
      Int32Value.encode({ value: message.archived }, writer.uint32(10).fork()).ldelim();
    }
    if (message.appeals !== void 0) {
      Int32Value.encode({ value: message.appeals }, writer.uint32(18).fork()).ldelim();
    }
    if (message.highlighted !== void 0) {
      Int32Value.encode({ value: message.highlighted }, writer.uint32(26).fork()).ldelim();
    }
    if (message.notifications !== void 0) {
      Int32Value.encode({ value: message.notifications }, writer.uint32(34).fork()).ldelim();
    }
    if (message.joinRequests !== void 0) {
      Int32Value.encode({ value: message.joinRequests }, writer.uint32(42).fork()).ldelim();
    }
    if (message.filtered !== void 0) {
      Int32Value.encode({ value: message.filtered }, writer.uint32(50).fork()).ldelim();
    }
    if (message.new !== void 0) {
      Int32Value.encode({ value: message.new }, writer.uint32(58).fork()).ldelim();
    }
    if (message.inprogress !== void 0) {
      Int32Value.encode({ value: message.inprogress }, writer.uint32(66).fork()).ldelim();
    }
    if (message.mod !== void 0) {
      Int32Value.encode({ value: message.mod }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal140.default.Reader ? input : import_minimal140.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnreadCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.archived = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.appeals = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.highlighted = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.notifications = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.joinRequests = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.filtered = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.new = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.inprogress = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.mod = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      archived: isSet124(object.archived) ? Number(object.archived) : void 0,
      appeals: isSet124(object.appeals) ? Number(object.appeals) : void 0,
      highlighted: isSet124(object.highlighted) ? Number(object.highlighted) : void 0,
      notifications: isSet124(object.notifications) ? Number(object.notifications) : void 0,
      joinRequests: isSet124(object.joinRequests) ? Number(object.joinRequests) : void 0,
      filtered: isSet124(object.filtered) ? Number(object.filtered) : void 0,
      new: isSet124(object.new) ? Number(object.new) : void 0,
      inprogress: isSet124(object.inprogress) ? Number(object.inprogress) : void 0,
      mod: isSet124(object.mod) ? Number(object.mod) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.archived !== void 0) {
      obj.archived = message.archived;
    }
    if (message.appeals !== void 0) {
      obj.appeals = message.appeals;
    }
    if (message.highlighted !== void 0) {
      obj.highlighted = message.highlighted;
    }
    if (message.notifications !== void 0) {
      obj.notifications = message.notifications;
    }
    if (message.joinRequests !== void 0) {
      obj.joinRequests = message.joinRequests;
    }
    if (message.filtered !== void 0) {
      obj.filtered = message.filtered;
    }
    if (message.new !== void 0) {
      obj.new = message.new;
    }
    if (message.inprogress !== void 0) {
      obj.inprogress = message.inprogress;
    }
    if (message.mod !== void 0) {
      obj.mod = message.mod;
    }
    return obj;
  },
  create(base) {
    return UnreadCountResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUnreadCountResponse();
    message.archived = object.archived ?? void 0;
    message.appeals = object.appeals ?? void 0;
    message.highlighted = object.highlighted ?? void 0;
    message.notifications = object.notifications ?? void 0;
    message.joinRequests = object.joinRequests ?? void 0;
    message.filtered = object.filtered ?? void 0;
    message.new = object.new ?? void 0;
    message.inprogress = object.inprogress ?? void 0;
    message.mod = object.mod ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(UnreadCountResponse.$type, UnreadCountResponse);
function isObject31(value) {
  return typeof value === "object" && value !== null;
}
function isSet124(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/modnote/modnote_svc.js
var import_minimal143 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/modnote/modnote_msg.js
var import_minimal142 = __toESM(require_minimal2(), 1);
function createBaseDeleteNotesRequest() {
  return { subreddit: "", noteId: "", user: "" };
}
var DeleteNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.DeleteNotesRequest",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.noteId !== "") {
      writer.uint32(18).string(message.noteId);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.noteId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet125(object.subreddit) ? globalThis.String(object.subreddit) : "",
      noteId: isSet125(object.noteId) ? globalThis.String(object.noteId) : "",
      user: isSet125(object.user) ? globalThis.String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.noteId !== "") {
      obj.noteId = message.noteId;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },
  create(base) {
    return DeleteNotesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteNotesRequest();
    message.subreddit = object.subreddit ?? "";
    message.noteId = object.noteId ?? "";
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set(DeleteNotesRequest.$type, DeleteNotesRequest);
function createBaseGetNotesRequest() {
  return { subreddit: "", before: void 0, filter: void 0, limit: void 0, user: "" };
}
var GetNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.GetNotesRequest",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.filter !== void 0) {
      StringValue.encode({ value: message.filter }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.filter = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet125(object.subreddit) ? globalThis.String(object.subreddit) : "",
      before: isSet125(object.before) ? String(object.before) : void 0,
      filter: isSet125(object.filter) ? String(object.filter) : void 0,
      limit: isSet125(object.limit) ? Number(object.limit) : void 0,
      user: isSet125(object.user) ? globalThis.String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.filter !== void 0) {
      obj.filter = message.filter;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },
  create(base) {
    return GetNotesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetNotesRequest();
    message.subreddit = object.subreddit ?? "";
    message.before = object.before ?? void 0;
    message.filter = object.filter ?? void 0;
    message.limit = object.limit ?? void 0;
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetNotesRequest.$type, GetNotesRequest);
function createBasePostNotesRequest() {
  return { subreddit: "", label: "", note: "", redditId: void 0, user: "" };
}
var PostNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.PostNotesRequest",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.note !== "") {
      writer.uint32(26).string(message.note);
    }
    if (message.redditId !== void 0) {
      StringValue.encode({ value: message.redditId }, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.note = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.redditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet125(object.subreddit) ? globalThis.String(object.subreddit) : "",
      label: isSet125(object.label) ? globalThis.String(object.label) : "",
      note: isSet125(object.note) ? globalThis.String(object.note) : "",
      redditId: isSet125(object.redditId) ? String(object.redditId) : void 0,
      user: isSet125(object.user) ? globalThis.String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    if (message.redditId !== void 0) {
      obj.redditId = message.redditId;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },
  create(base) {
    return PostNotesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostNotesRequest();
    message.subreddit = object.subreddit ?? "";
    message.label = object.label ?? "";
    message.note = object.note ?? "";
    message.redditId = object.redditId ?? void 0;
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set(PostNotesRequest.$type, PostNotesRequest);
function createBaseRecentNotesRequest() {
  return { subreddits: "", users: "" };
}
var RecentNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.RecentNotesRequest",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.subreddits !== "") {
      writer.uint32(10).string(message.subreddits);
    }
    if (message.users !== "") {
      writer.uint32(18).string(message.users);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecentNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddits = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.users = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: isSet125(object.subreddits) ? globalThis.String(object.subreddits) : "",
      users: isSet125(object.users) ? globalThis.String(object.users) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddits !== "") {
      obj.subreddits = message.subreddits;
    }
    if (message.users !== "") {
      obj.users = message.users;
    }
    return obj;
  },
  create(base) {
    return RecentNotesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRecentNotesRequest();
    message.subreddits = object.subreddits ?? "";
    message.users = object.users ?? "";
    return message;
  }
};
messageTypeRegistry.set(RecentNotesRequest.$type, RecentNotesRequest);
function createBasePostRemovalNoteRequest() {
  return { itemIds: [], reasonId: "", modNote: void 0 };
}
var PostRemovalNoteRequest = {
  $type: "devvit.plugin.redditapi.modnote.PostRemovalNoteRequest",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    for (const v of message.itemIds) {
      writer.uint32(10).string(v);
    }
    if (message.reasonId !== "") {
      writer.uint32(18).string(message.reasonId);
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostRemovalNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.itemIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reasonId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e) => globalThis.String(e)) : [],
      reasonId: isSet125(object.reasonId) ? globalThis.String(object.reasonId) : "",
      modNote: isSet125(object.modNote) ? String(object.modNote) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds;
    }
    if (message.reasonId !== "") {
      obj.reasonId = message.reasonId;
    }
    if (message.modNote !== void 0) {
      obj.modNote = message.modNote;
    }
    return obj;
  },
  create(base) {
    return PostRemovalNoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostRemovalNoteRequest();
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.reasonId = object.reasonId ?? "";
    message.modNote = object.modNote ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(PostRemovalNoteRequest.$type, PostRemovalNoteRequest);
function createBaseModNotesResponse() {
  return { modNotes: [], startCursor: void 0, endCursor: void 0, hasNextPage: void 0 };
}
var ModNotesResponse = {
  $type: "devvit.plugin.redditapi.modnote.ModNotesResponse",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    for (const v of message.modNotes) {
      ModNoteObject.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.startCursor !== void 0) {
      StringValue.encode({ value: message.startCursor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.endCursor !== void 0) {
      StringValue.encode({ value: message.endCursor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.hasNextPage !== void 0) {
      BoolValue.encode({ value: message.hasNextPage }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.modNotes.push(ModNoteObject.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.startCursor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.endCursor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.hasNextPage = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      modNotes: globalThis.Array.isArray(object?.modNotes) ? object.modNotes.map((e) => ModNoteObject.fromJSON(e)) : [],
      startCursor: isSet125(object.startCursor) ? String(object.startCursor) : void 0,
      endCursor: isSet125(object.endCursor) ? String(object.endCursor) : void 0,
      hasNextPage: isSet125(object.hasNextPage) ? Boolean(object.hasNextPage) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.modNotes?.length) {
      obj.modNotes = message.modNotes.map((e) => ModNoteObject.toJSON(e));
    }
    if (message.startCursor !== void 0) {
      obj.startCursor = message.startCursor;
    }
    if (message.endCursor !== void 0) {
      obj.endCursor = message.endCursor;
    }
    if (message.hasNextPage !== void 0) {
      obj.hasNextPage = message.hasNextPage;
    }
    return obj;
  },
  create(base) {
    return ModNotesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModNotesResponse();
    message.modNotes = object.modNotes?.map((e) => ModNoteObject.fromPartial(e)) || [];
    message.startCursor = object.startCursor ?? void 0;
    message.endCursor = object.endCursor ?? void 0;
    message.hasNextPage = object.hasNextPage ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ModNotesResponse.$type, ModNotesResponse);
function createBaseDeleteNotesResponse() {
  return { deleted: void 0 };
}
var DeleteNotesResponse = {
  $type: "devvit.plugin.redditapi.modnote.DeleteNotesResponse",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.deleted !== void 0) {
      BoolValue.encode({ value: message.deleted }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.deleted = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { deleted: isSet125(object.deleted) ? Boolean(object.deleted) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.deleted !== void 0) {
      obj.deleted = message.deleted;
    }
    return obj;
  },
  create(base) {
    return DeleteNotesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeleteNotesResponse();
    message.deleted = object.deleted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(DeleteNotesResponse.$type, DeleteNotesResponse);
function createBaseModNoteObject() {
  return {
    subredditId: void 0,
    operatorId: void 0,
    modActionData: void 0,
    userNoteData: void 0,
    subreddit: void 0,
    user: void 0,
    operator: void 0,
    id: void 0,
    userId: void 0,
    createdAt: void 0,
    cursor: void 0,
    type: void 0
  };
}
var ModNoteObject = {
  $type: "devvit.plugin.redditapi.modnote.ModNoteObject",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.operatorId !== void 0) {
      StringValue.encode({ value: message.operatorId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modActionData !== void 0) {
      ModNoteObject_ModActionData.encode(message.modActionData, writer.uint32(26).fork()).ldelim();
    }
    if (message.userNoteData !== void 0) {
      ModNoteObject_UserNoteData.encode(message.userNoteData, writer.uint32(34).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(50).fork()).ldelim();
    }
    if (message.operator !== void 0) {
      StringValue.encode({ value: message.operator }, writer.uint32(58).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
    }
    if (message.userId !== void 0) {
      StringValue.encode({ value: message.userId }, writer.uint32(74).fork()).ldelim();
    }
    if (message.createdAt !== void 0) {
      Int64Value.encode({ value: message.createdAt }, writer.uint32(82).fork()).ldelim();
    }
    if (message.cursor !== void 0) {
      StringValue.encode({ value: message.cursor }, writer.uint32(90).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNoteObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.operatorId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.modActionData = ModNoteObject_ModActionData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.userNoteData = ModNoteObject_UserNoteData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.user = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.operator = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.userId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.createdAt = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.cursor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.type = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subredditId: isSet125(object.subredditId) ? String(object.subredditId) : void 0,
      operatorId: isSet125(object.operatorId) ? String(object.operatorId) : void 0,
      modActionData: isSet125(object.modActionData) ? ModNoteObject_ModActionData.fromJSON(object.modActionData) : void 0,
      userNoteData: isSet125(object.userNoteData) ? ModNoteObject_UserNoteData.fromJSON(object.userNoteData) : void 0,
      subreddit: isSet125(object.subreddit) ? String(object.subreddit) : void 0,
      user: isSet125(object.user) ? String(object.user) : void 0,
      operator: isSet125(object.operator) ? String(object.operator) : void 0,
      id: isSet125(object.id) ? String(object.id) : void 0,
      userId: isSet125(object.userId) ? String(object.userId) : void 0,
      createdAt: isSet125(object.createdAt) ? Number(object.createdAt) : void 0,
      cursor: isSet125(object.cursor) ? String(object.cursor) : void 0,
      type: isSet125(object.type) ? String(object.type) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subredditId !== void 0) {
      obj.subredditId = message.subredditId;
    }
    if (message.operatorId !== void 0) {
      obj.operatorId = message.operatorId;
    }
    if (message.modActionData !== void 0) {
      obj.modActionData = ModNoteObject_ModActionData.toJSON(message.modActionData);
    }
    if (message.userNoteData !== void 0) {
      obj.userNoteData = ModNoteObject_UserNoteData.toJSON(message.userNoteData);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.user !== void 0) {
      obj.user = message.user;
    }
    if (message.operator !== void 0) {
      obj.operator = message.operator;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.userId !== void 0) {
      obj.userId = message.userId;
    }
    if (message.createdAt !== void 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.cursor !== void 0) {
      obj.cursor = message.cursor;
    }
    if (message.type !== void 0) {
      obj.type = message.type;
    }
    return obj;
  },
  create(base) {
    return ModNoteObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModNoteObject();
    message.subredditId = object.subredditId ?? void 0;
    message.operatorId = object.operatorId ?? void 0;
    message.modActionData = object.modActionData !== void 0 && object.modActionData !== null ? ModNoteObject_ModActionData.fromPartial(object.modActionData) : void 0;
    message.userNoteData = object.userNoteData !== void 0 && object.userNoteData !== null ? ModNoteObject_UserNoteData.fromPartial(object.userNoteData) : void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.user = object.user ?? void 0;
    message.operator = object.operator ?? void 0;
    message.id = object.id ?? void 0;
    message.userId = object.userId ?? void 0;
    message.createdAt = object.createdAt ?? void 0;
    message.cursor = object.cursor ?? void 0;
    message.type = object.type ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ModNoteObject.$type, ModNoteObject);
function createBaseModNoteObject_ModActionData() {
  return { action: void 0, redditId: void 0, details: void 0, description: void 0 };
}
var ModNoteObject_ModActionData = {
  $type: "devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.action !== void 0) {
      StringValue.encode({ value: message.action }, writer.uint32(10).fork()).ldelim();
    }
    if (message.redditId !== void 0) {
      StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.details !== void 0) {
      StringValue.encode({ value: message.details }, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNoteObject_ModActionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.action = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.redditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.details = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet125(object.action) ? String(object.action) : void 0,
      redditId: isSet125(object.redditId) ? String(object.redditId) : void 0,
      details: isSet125(object.details) ? String(object.details) : void 0,
      description: isSet125(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.action !== void 0) {
      obj.action = message.action;
    }
    if (message.redditId !== void 0) {
      obj.redditId = message.redditId;
    }
    if (message.details !== void 0) {
      obj.details = message.details;
    }
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return ModNoteObject_ModActionData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModNoteObject_ModActionData();
    message.action = object.action ?? void 0;
    message.redditId = object.redditId ?? void 0;
    message.details = object.details ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ModNoteObject_ModActionData.$type, ModNoteObject_ModActionData);
function createBaseModNoteObject_UserNoteData() {
  return { note: void 0, redditId: void 0, label: void 0 };
}
var ModNoteObject_UserNoteData = {
  $type: "devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.note !== void 0) {
      StringValue.encode({ value: message.note }, writer.uint32(10).fork()).ldelim();
    }
    if (message.redditId !== void 0) {
      StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.label !== void 0) {
      StringValue.encode({ value: message.label }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNoteObject_UserNoteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.note = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.redditId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.label = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      note: isSet125(object.note) ? String(object.note) : void 0,
      redditId: isSet125(object.redditId) ? String(object.redditId) : void 0,
      label: isSet125(object.label) ? String(object.label) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.note !== void 0) {
      obj.note = message.note;
    }
    if (message.redditId !== void 0) {
      obj.redditId = message.redditId;
    }
    if (message.label !== void 0) {
      obj.label = message.label;
    }
    return obj;
  },
  create(base) {
    return ModNoteObject_UserNoteData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseModNoteObject_UserNoteData();
    message.note = object.note ?? void 0;
    message.redditId = object.redditId ?? void 0;
    message.label = object.label ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ModNoteObject_UserNoteData.$type, ModNoteObject_UserNoteData);
function createBasePostModNotesResponse() {
  return { created: void 0 };
}
var PostModNotesResponse = {
  $type: "devvit.plugin.redditapi.modnote.PostModNotesResponse",
  encode(message, writer = import_minimal142.default.Writer.create()) {
    if (message.created !== void 0) {
      ModNoteObject.encode(message.created, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal142.default.Reader ? input : import_minimal142.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostModNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.created = ModNoteObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { created: isSet125(object.created) ? ModNoteObject.fromJSON(object.created) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.created !== void 0) {
      obj.created = ModNoteObject.toJSON(message.created);
    }
    return obj;
  },
  create(base) {
    return PostModNotesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePostModNotesResponse();
    message.created = object.created !== void 0 && object.created !== null ? ModNoteObject.fromPartial(object.created) : void 0;
    return message;
  }
};
messageTypeRegistry.set(PostModNotesResponse.$type, PostModNotesResponse);
function isSet125(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/moderation/moderation_svc.js
var import_minimal145 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/moderation/moderation_msg.js
var import_minimal144 = __toESM(require_minimal2(), 1);
function createBaseAboutLogRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0,
    mod: void 0,
    type: void 0,
    subreddit: void 0
  };
}
var AboutLogRequest = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    if (message.mod !== void 0) {
      StringValue.encode({ value: message.mod }, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(66).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.mod = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.type = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet126(object.after) ? String(object.after) : void 0,
      before: isSet126(object.before) ? String(object.before) : void 0,
      count: isSet126(object.count) ? Number(object.count) : void 0,
      limit: isSet126(object.limit) ? Number(object.limit) : void 0,
      show: isSet126(object.show) ? String(object.show) : void 0,
      mod: isSet126(object.mod) ? String(object.mod) : void 0,
      type: isSet126(object.type) ? String(object.type) : void 0,
      subreddit: isSet126(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.mod !== void 0) {
      obj.mod = message.mod;
    }
    if (message.type !== void 0) {
      obj.type = message.type;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return AboutLogRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutLogRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    message.mod = object.mod ?? void 0;
    message.type = object.type ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AboutLogRequest.$type, AboutLogRequest);
function createBaseAboutLocationRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    location: "",
    only: void 0,
    show: void 0,
    subreddit: ""
  };
}
var AboutLocationRequest = {
  $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.location !== "") {
      writer.uint32(42).string(message.location);
    }
    if (message.only !== void 0) {
      StringValue.encode({ value: message.only }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.subreddit !== "") {
      writer.uint32(66).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.location = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.only = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet126(object.after) ? String(object.after) : void 0,
      before: isSet126(object.before) ? String(object.before) : void 0,
      count: isSet126(object.count) ? Number(object.count) : void 0,
      limit: isSet126(object.limit) ? Number(object.limit) : void 0,
      location: isSet126(object.location) ? globalThis.String(object.location) : "",
      only: isSet126(object.only) ? String(object.only) : void 0,
      show: isSet126(object.show) ? String(object.show) : void 0,
      subreddit: isSet126(object.subreddit) ? globalThis.String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.only !== void 0) {
      obj.only = message.only;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return AboutLocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutLocationRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.location = object.location ?? "";
    message.only = object.only ?? void 0;
    message.show = object.show ?? void 0;
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(AboutLocationRequest.$type, AboutLocationRequest);
function createBaseAcceptModeratorInviteRequest() {
  return { subreddit: "" };
}
var AcceptModeratorInviteRequest = {
  $type: "devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAcceptModeratorInviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet126(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return AcceptModeratorInviteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAcceptModeratorInviteRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(AcceptModeratorInviteRequest.$type, AcceptModeratorInviteRequest);
function createBaseBasicModerationIdRequest() {
  return { id: "" };
}
var BasicModerationIdRequest = {
  $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicModerationIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet126(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return BasicModerationIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicModerationIdRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(BasicModerationIdRequest.$type, BasicModerationIdRequest);
function createBaseDistinguishRequest() {
  return { how: "", id: "", sticky: false };
}
var DistinguishRequest = {
  $type: "devvit.plugin.redditapi.moderation.DistinguishRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.how !== "") {
      writer.uint32(10).string(message.how);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.sticky !== false) {
      writer.uint32(24).bool(message.sticky);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDistinguishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.how = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.sticky = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      how: isSet126(object.how) ? globalThis.String(object.how) : "",
      id: isSet126(object.id) ? globalThis.String(object.id) : "",
      sticky: isSet126(object.sticky) ? globalThis.Boolean(object.sticky) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.how !== "") {
      obj.how = message.how;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sticky !== false) {
      obj.sticky = message.sticky;
    }
    return obj;
  },
  create(base) {
    return DistinguishRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDistinguishRequest();
    message.how = object.how ?? "";
    message.id = object.id ?? "";
    message.sticky = object.sticky ?? false;
    return message;
  }
};
messageTypeRegistry.set(DistinguishRequest.$type, DistinguishRequest);
function createBaseRemoveRequest() {
  return { id: "", spam: false };
}
var RemoveRequest = {
  $type: "devvit.plugin.redditapi.moderation.RemoveRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.spam !== false) {
      writer.uint32(16).bool(message.spam);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.spam = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet126(object.id) ? globalThis.String(object.id) : "",
      spam: isSet126(object.spam) ? globalThis.Boolean(object.spam) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.spam !== false) {
      obj.spam = message.spam;
    }
    return obj;
  },
  create(base) {
    return RemoveRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoveRequest();
    message.id = object.id ?? "";
    message.spam = object.spam ?? false;
    return message;
  }
};
messageTypeRegistry.set(RemoveRequest.$type, RemoveRequest);
function createBaseSnoozeReportsRequest() {
  return { id: "", reason: "" };
}
var SnoozeReportsRequest = {
  $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnoozeReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet126(object.id) ? globalThis.String(object.id) : "",
      reason: isSet126(object.reason) ? globalThis.String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return SnoozeReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSnoozeReportsRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set(SnoozeReportsRequest.$type, SnoozeReportsRequest);
function createBaseUpdateCrowdControlLevelRequest() {
  return { id: "", level: 0 };
}
var UpdateCrowdControlLevelRequest = {
  $type: "devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCrowdControlLevelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.level = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet126(object.id) ? globalThis.String(object.id) : "",
      level: isSet126(object.level) ? globalThis.Number(object.level) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    return obj;
  },
  create(base) {
    return UpdateCrowdControlLevelRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCrowdControlLevelRequest();
    message.id = object.id ?? "";
    message.level = object.level ?? 0;
    return message;
  }
};
messageTypeRegistry.set(UpdateCrowdControlLevelRequest.$type, UpdateCrowdControlLevelRequest);
function createBaseStylesheetRequest() {
  return { subreddit: "" };
}
var StylesheetRequest = {
  $type: "devvit.plugin.redditapi.moderation.StylesheetRequest",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStylesheetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet126(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return StylesheetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStylesheetRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(StylesheetRequest.$type, StylesheetRequest);
function createBaseAboutLogResponse() {
  return { kind: "", data: void 0 };
}
var AboutLogResponse = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      AboutLogResponse_AboutLogListing.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = AboutLogResponse_AboutLogListing.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet126(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet126(object.data) ? AboutLogResponse_AboutLogListing.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = AboutLogResponse_AboutLogListing.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return AboutLogResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? AboutLogResponse_AboutLogListing.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AboutLogResponse.$type, AboutLogResponse);
function createBaseAboutLogResponse_LogObject() {
  return {
    description: void 0,
    targetBody: void 0,
    modId36: void 0,
    createdUtc: void 0,
    subreddit: void 0,
    targetTitle: void 0,
    targetPermalink: void 0,
    subredditNamePrefixed: void 0,
    details: void 0,
    action: void 0,
    targetAuthor: void 0,
    targetFullname: void 0,
    srId36: void 0,
    id: void 0,
    mod: void 0
  };
}
var AboutLogResponse_LogObject = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(10).fork()).ldelim();
    }
    if (message.targetBody !== void 0) {
      StringValue.encode({ value: message.targetBody }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modId36 !== void 0) {
      StringValue.encode({ value: message.modId36 }, writer.uint32(26).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(34).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.targetTitle !== void 0) {
      StringValue.encode({ value: message.targetTitle }, writer.uint32(50).fork()).ldelim();
    }
    if (message.targetPermalink !== void 0) {
      StringValue.encode({ value: message.targetPermalink }, writer.uint32(58).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(66).fork()).ldelim();
    }
    if (message.details !== void 0) {
      StringValue.encode({ value: message.details }, writer.uint32(74).fork()).ldelim();
    }
    if (message.action !== void 0) {
      StringValue.encode({ value: message.action }, writer.uint32(82).fork()).ldelim();
    }
    if (message.targetAuthor !== void 0) {
      StringValue.encode({ value: message.targetAuthor }, writer.uint32(90).fork()).ldelim();
    }
    if (message.targetFullname !== void 0) {
      StringValue.encode({ value: message.targetFullname }, writer.uint32(98).fork()).ldelim();
    }
    if (message.srId36 !== void 0) {
      StringValue.encode({ value: message.srId36 }, writer.uint32(106).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(114).fork()).ldelim();
    }
    if (message.mod !== void 0) {
      StringValue.encode({ value: message.mod }, writer.uint32(122).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse_LogObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.targetBody = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.modId36 = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.targetTitle = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.targetPermalink = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.details = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.action = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.targetAuthor = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.targetFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.srId36 = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.mod = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      description: isSet126(object.description) ? String(object.description) : void 0,
      targetBody: isSet126(object.targetBody) ? String(object.targetBody) : void 0,
      modId36: isSet126(object.modId36) ? String(object.modId36) : void 0,
      createdUtc: isSet126(object.createdUtc) ? Number(object.createdUtc) : void 0,
      subreddit: isSet126(object.subreddit) ? String(object.subreddit) : void 0,
      targetTitle: isSet126(object.targetTitle) ? String(object.targetTitle) : void 0,
      targetPermalink: isSet126(object.targetPermalink) ? String(object.targetPermalink) : void 0,
      subredditNamePrefixed: isSet126(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      details: isSet126(object.details) ? String(object.details) : void 0,
      action: isSet126(object.action) ? String(object.action) : void 0,
      targetAuthor: isSet126(object.targetAuthor) ? String(object.targetAuthor) : void 0,
      targetFullname: isSet126(object.targetFullname) ? String(object.targetFullname) : void 0,
      srId36: isSet126(object.srId36) ? String(object.srId36) : void 0,
      id: isSet126(object.id) ? String(object.id) : void 0,
      mod: isSet126(object.mod) ? String(object.mod) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.description !== void 0) {
      obj.description = message.description;
    }
    if (message.targetBody !== void 0) {
      obj.targetBody = message.targetBody;
    }
    if (message.modId36 !== void 0) {
      obj.modId36 = message.modId36;
    }
    if (message.createdUtc !== void 0) {
      obj.createdUtc = message.createdUtc;
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.targetTitle !== void 0) {
      obj.targetTitle = message.targetTitle;
    }
    if (message.targetPermalink !== void 0) {
      obj.targetPermalink = message.targetPermalink;
    }
    if (message.subredditNamePrefixed !== void 0) {
      obj.subredditNamePrefixed = message.subredditNamePrefixed;
    }
    if (message.details !== void 0) {
      obj.details = message.details;
    }
    if (message.action !== void 0) {
      obj.action = message.action;
    }
    if (message.targetAuthor !== void 0) {
      obj.targetAuthor = message.targetAuthor;
    }
    if (message.targetFullname !== void 0) {
      obj.targetFullname = message.targetFullname;
    }
    if (message.srId36 !== void 0) {
      obj.srId36 = message.srId36;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.mod !== void 0) {
      obj.mod = message.mod;
    }
    return obj;
  },
  create(base) {
    return AboutLogResponse_LogObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse_LogObject();
    message.description = object.description ?? void 0;
    message.targetBody = object.targetBody ?? void 0;
    message.modId36 = object.modId36 ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.targetTitle = object.targetTitle ?? void 0;
    message.targetPermalink = object.targetPermalink ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.details = object.details ?? void 0;
    message.action = object.action ?? void 0;
    message.targetAuthor = object.targetAuthor ?? void 0;
    message.targetFullname = object.targetFullname ?? void 0;
    message.srId36 = object.srId36 ?? void 0;
    message.id = object.id ?? void 0;
    message.mod = object.mod ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AboutLogResponse_LogObject.$type, AboutLogResponse_LogObject);
function createBaseAboutLogResponse_AboutLogListing() {
  return { after: void 0, before: void 0, children: [], dist: void 0 };
}
var AboutLogResponse_AboutLogListing = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      AboutLogResponse_AboutLogListing_WrappedLogObject.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse_AboutLogListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.children.push(AboutLogResponse_AboutLogListing_WrappedLogObject.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet126(object.after) ? String(object.after) : void 0,
      before: isSet126(object.before) ? String(object.before) : void 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromJSON(e)) : [],
      dist: isSet126(object.dist) ? Number(object.dist) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.toJSON(e));
    }
    if (message.dist !== void 0) {
      obj.dist = message.dist;
    }
    return obj;
  },
  create(base) {
    return AboutLogResponse_AboutLogListing.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse_AboutLogListing();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.children = object.children?.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromPartial(e)) || [];
    message.dist = object.dist ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(AboutLogResponse_AboutLogListing.$type, AboutLogResponse_AboutLogListing);
function createBaseAboutLogResponse_AboutLogListing_WrappedLogObject() {
  return { kind: "", data: void 0 };
}
var AboutLogResponse_AboutLogListing_WrappedLogObject = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject",
  encode(message, writer = import_minimal144.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      AboutLogResponse_LogObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal144.default.Reader ? input : import_minimal144.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = AboutLogResponse_LogObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet126(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet126(object.data) ? AboutLogResponse_LogObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = AboutLogResponse_LogObject.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return AboutLogResponse_AboutLogListing_WrappedLogObject.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? AboutLogResponse_LogObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AboutLogResponse_AboutLogListing_WrappedLogObject.$type, AboutLogResponse_AboutLogListing_WrappedLogObject);
function isSet126(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/listings/listings_svc.js
var import_minimal147 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/listings/listings_msg.js
var import_minimal146 = __toESM(require_minimal2(), 1);
function createBaseGetBestRequest() {
  return { after: void 0, before: void 0, count: void 0, limit: void 0, show: void 0 };
}
var GetBestRequest = {
  $type: "devvit.plugin.redditapi.listings.GetBestRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet127(object.after) ? String(object.after) : void 0,
      before: isSet127(object.before) ? String(object.before) : void 0,
      count: isSet127(object.count) ? Number(object.count) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      show: isSet127(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    return obj;
  },
  create(base) {
    return GetBestRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetBestRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetBestRequest.$type, GetBestRequest);
function createBaseGetSortRequest() {
  return {
    subreddit: void 0,
    sort: "",
    after: void 0,
    before: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    t: void 0
  };
}
var GetSortRequest = {
  $type: "devvit.plugin.redditapi.listings.GetSortRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.sort !== "") {
      writer.uint32(18).string(message.sort);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetSortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.sort = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.t = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet127(object.subreddit) ? String(object.subreddit) : void 0,
      sort: isSet127(object.sort) ? globalThis.String(object.sort) : "",
      after: isSet127(object.after) ? String(object.after) : void 0,
      before: isSet127(object.before) ? String(object.before) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      count: isSet127(object.count) ? Number(object.count) : void 0,
      show: isSet127(object.show) ? String(object.show) : void 0,
      t: isSet127(object.t) ? String(object.t) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.t !== void 0) {
      obj.t = message.t;
    }
    return obj;
  },
  create(base) {
    return GetSortRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetSortRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.sort = object.sort ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetSortRequest.$type, GetSortRequest);
function createBaseGetCommentsRequest() {
  return {
    article: "",
    comment: void 0,
    context: void 0,
    depth: void 0,
    limit: void 0,
    sort: void 0,
    threaded: void 0,
    truncate: void 0
  };
}
var GetCommentsRequest = {
  $type: "devvit.plugin.redditapi.listings.GetCommentsRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.article !== "") {
      writer.uint32(10).string(message.article);
    }
    if (message.comment !== void 0) {
      StringValue.encode({ value: message.comment }, writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== void 0) {
      Int64Value.encode({ value: message.context }, writer.uint32(26).fork()).ldelim();
    }
    if (message.depth !== void 0) {
      Int64Value.encode({ value: message.depth }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
    }
    if (message.threaded !== void 0) {
      BoolValue.encode({ value: message.threaded }, writer.uint32(58).fork()).ldelim();
    }
    if (message.truncate !== void 0) {
      Int64Value.encode({ value: message.truncate }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.article = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.comment = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.context = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.depth = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.threaded = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.truncate = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      article: isSet127(object.article) ? globalThis.String(object.article) : "",
      comment: isSet127(object.comment) ? String(object.comment) : void 0,
      context: isSet127(object.context) ? Number(object.context) : void 0,
      depth: isSet127(object.depth) ? Number(object.depth) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      sort: isSet127(object.sort) ? String(object.sort) : void 0,
      threaded: isSet127(object.threaded) ? Boolean(object.threaded) : void 0,
      truncate: isSet127(object.truncate) ? Number(object.truncate) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.article !== "") {
      obj.article = message.article;
    }
    if (message.comment !== void 0) {
      obj.comment = message.comment;
    }
    if (message.context !== void 0) {
      obj.context = message.context;
    }
    if (message.depth !== void 0) {
      obj.depth = message.depth;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.threaded !== void 0) {
      obj.threaded = message.threaded;
    }
    if (message.truncate !== void 0) {
      obj.truncate = message.truncate;
    }
    return obj;
  },
  create(base) {
    return GetCommentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetCommentsRequest();
    message.article = object.article ?? "";
    message.comment = object.comment ?? void 0;
    message.context = object.context ?? void 0;
    message.depth = object.depth ?? void 0;
    message.limit = object.limit ?? void 0;
    message.sort = object.sort ?? void 0;
    message.threaded = object.threaded ?? void 0;
    message.truncate = object.truncate ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetCommentsRequest.$type, GetCommentsRequest);
function createBaseGetByIdRequest() {
  return { postIds: "" };
}
var GetByIdRequest = {
  $type: "devvit.plugin.redditapi.listings.GetByIdRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.postIds !== "") {
      writer.uint32(10).string(message.postIds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.postIds = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { postIds: isSet127(object.postIds) ? globalThis.String(object.postIds) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.postIds !== "") {
      obj.postIds = message.postIds;
    }
    return obj;
  },
  create(base) {
    return GetByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetByIdRequest();
    message.postIds = object.postIds ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetByIdRequest.$type, GetByIdRequest);
function createBaseGetDuplicatesRequest() {
  return {
    article: "",
    before: void 0,
    after: void 0,
    limit: void 0,
    sort: void 0,
    sr: void 0,
    count: void 0,
    crosspostsOnly: void 0,
    show: void 0
  };
}
var GetDuplicatesRequest = {
  $type: "devvit.plugin.redditapi.listings.GetDuplicatesRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.article !== "") {
      writer.uint32(10).string(message.article);
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(42).fork()).ldelim();
    }
    if (message.sr !== void 0) {
      StringValue.encode({ value: message.sr }, writer.uint32(50).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(58).fork()).ldelim();
    }
    if (message.crosspostsOnly !== void 0) {
      BoolValue.encode({ value: message.crosspostsOnly }, writer.uint32(66).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDuplicatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.article = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.sr = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.crosspostsOnly = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      article: isSet127(object.article) ? globalThis.String(object.article) : "",
      before: isSet127(object.before) ? String(object.before) : void 0,
      after: isSet127(object.after) ? String(object.after) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      sort: isSet127(object.sort) ? String(object.sort) : void 0,
      sr: isSet127(object.sr) ? String(object.sr) : void 0,
      count: isSet127(object.count) ? Number(object.count) : void 0,
      crosspostsOnly: isSet127(object.crosspostsOnly) ? Boolean(object.crosspostsOnly) : void 0,
      show: isSet127(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.article !== "") {
      obj.article = message.article;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.sr !== void 0) {
      obj.sr = message.sr;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.crosspostsOnly !== void 0) {
      obj.crosspostsOnly = message.crosspostsOnly;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    return obj;
  },
  create(base) {
    return GetDuplicatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDuplicatesRequest();
    message.article = object.article ?? "";
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    message.limit = object.limit ?? void 0;
    message.sort = object.sort ?? void 0;
    message.sr = object.sr ?? void 0;
    message.count = object.count ?? void 0;
    message.crosspostsOnly = object.crosspostsOnly ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetDuplicatesRequest.$type, GetDuplicatesRequest);
function createBaseGetHotRequest() {
  return {
    subreddit: void 0,
    before: void 0,
    after: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    g: void 0
  };
}
var GetHotRequest = {
  $type: "devvit.plugin.redditapi.listings.GetHotRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    if (message.g !== void 0) {
      StringValue.encode({ value: message.g }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetHotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.g = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet127(object.subreddit) ? String(object.subreddit) : void 0,
      before: isSet127(object.before) ? String(object.before) : void 0,
      after: isSet127(object.after) ? String(object.after) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      count: isSet127(object.count) ? Number(object.count) : void 0,
      show: isSet127(object.show) ? String(object.show) : void 0,
      g: isSet127(object.g) ? String(object.g) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    if (message.g !== void 0) {
      obj.g = message.g;
    }
    return obj;
  },
  create(base) {
    return GetHotRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetHotRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.g = object.g ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetHotRequest.$type, GetHotRequest);
function createBaseGetNewRequest() {
  return {
    subreddit: void 0,
    before: void 0,
    after: void 0,
    limit: void 0,
    count: void 0,
    show: void 0
  };
}
var GetNewRequest = {
  $type: "devvit.plugin.redditapi.listings.GetNewRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetNewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet127(object.subreddit) ? String(object.subreddit) : void 0,
      before: isSet127(object.before) ? String(object.before) : void 0,
      after: isSet127(object.after) ? String(object.after) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      count: isSet127(object.count) ? Number(object.count) : void 0,
      show: isSet127(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    return obj;
  },
  create(base) {
    return GetNewRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetNewRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetNewRequest.$type, GetNewRequest);
function createBaseGetRisingRequest() {
  return {
    subreddit: void 0,
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0
  };
}
var GetRisingRequest = {
  $type: "devvit.plugin.redditapi.listings.GetRisingRequest",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetRisingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.after = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.before = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.show = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet127(object.subreddit) ? String(object.subreddit) : void 0,
      after: isSet127(object.after) ? String(object.after) : void 0,
      before: isSet127(object.before) ? String(object.before) : void 0,
      count: isSet127(object.count) ? Number(object.count) : void 0,
      limit: isSet127(object.limit) ? Number(object.limit) : void 0,
      show: isSet127(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== void 0) {
      obj.subreddit = message.subreddit;
    }
    if (message.after !== void 0) {
      obj.after = message.after;
    }
    if (message.before !== void 0) {
      obj.before = message.before;
    }
    if (message.count !== void 0) {
      obj.count = message.count;
    }
    if (message.limit !== void 0) {
      obj.limit = message.limit;
    }
    if (message.show !== void 0) {
      obj.show = message.show;
    }
    return obj;
  },
  create(base) {
    return GetRisingRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetRisingRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(GetRisingRequest.$type, GetRisingRequest);
function createBaseListingResponse() {
  return { listings: [] };
}
var ListingResponse = {
  $type: "devvit.plugin.redditapi.listings.ListingResponse",
  encode(message, writer = import_minimal146.default.Writer.create()) {
    for (const v of message.listings) {
      Listing.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal146.default.Reader ? input : import_minimal146.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.listings.push(Listing.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      listings: globalThis.Array.isArray(object?.listings) ? object.listings.map((e) => Listing.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.listings?.length) {
      obj.listings = message.listings.map((e) => Listing.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ListingResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListingResponse();
    message.listings = object.listings?.map((e) => Listing.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ListingResponse.$type, ListingResponse);
function isSet127(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/linksandcomments/linksandcomments_svc.js
var import_minimal149 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/linksandcomments/linksandcomments_msg.js
var import_minimal148 = __toESM(require_minimal2(), 1);
function createBaseCommentRequest() {
  return { richtextJson: void 0, text: "", thingId: "" };
}
var CommentRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.CommentRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.richtextJson !== void 0) {
      StringValue.encode({ value: message.richtextJson }, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.thingId !== "") {
      writer.uint32(26).string(message.thingId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.richtextJson = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.thingId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      richtextJson: isSet128(object.richtextJson) ? String(object.richtextJson) : void 0,
      text: isSet128(object.text) ? globalThis.String(object.text) : "",
      thingId: isSet128(object.thingId) ? globalThis.String(object.thingId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.richtextJson !== void 0) {
      obj.richtextJson = message.richtextJson;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.thingId !== "") {
      obj.thingId = message.thingId;
    }
    return obj;
  },
  create(base) {
    return CommentRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommentRequest();
    message.richtextJson = object.richtextJson ?? void 0;
    message.text = object.text ?? "";
    message.thingId = object.thingId ?? "";
    return message;
  }
};
messageTypeRegistry.set(CommentRequest.$type, CommentRequest);
function createBaseFollowPostRequest() {
  return { follow: false, fullname: "" };
}
var FollowPostRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.FollowPostRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.follow !== false) {
      writer.uint32(8).bool(message.follow);
    }
    if (message.fullname !== "") {
      writer.uint32(18).string(message.fullname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFollowPostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.follow = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fullname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      follow: isSet128(object.follow) ? globalThis.Boolean(object.follow) : false,
      fullname: isSet128(object.fullname) ? globalThis.String(object.fullname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.follow !== false) {
      obj.follow = message.follow;
    }
    if (message.fullname !== "") {
      obj.fullname = message.fullname;
    }
    return obj;
  },
  create(base) {
    return FollowPostRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFollowPostRequest();
    message.follow = object.follow ?? false;
    message.fullname = object.fullname ?? "";
    return message;
  }
};
messageTypeRegistry.set(FollowPostRequest.$type, FollowPostRequest);
function createBaseBasicIdRequest() {
  return { id: "" };
}
var BasicIdRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet128(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return BasicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBasicIdRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(BasicIdRequest.$type, BasicIdRequest);
function createBaseInfoRequest() {
  return { subreddits: [], thingIds: [], url: void 0 };
}
var InfoRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.InfoRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    for (const v of message.subreddits) {
      writer.uint32(10).string(v);
    }
    for (const v of message.thingIds) {
      writer.uint32(18).string(v);
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddits.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.thingIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: globalThis.Array.isArray(object?.subreddits) ? object.subreddits.map((e) => globalThis.String(e)) : [],
      thingIds: globalThis.Array.isArray(object?.thingIds) ? object.thingIds.map((e) => globalThis.String(e)) : [],
      url: isSet128(object.url) ? String(object.url) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddits?.length) {
      obj.subreddits = message.subreddits;
    }
    if (message.thingIds?.length) {
      obj.thingIds = message.thingIds;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return InfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInfoRequest();
    message.subreddits = object.subreddits?.map((e) => e) || [];
    message.thingIds = object.thingIds?.map((e) => e) || [];
    message.url = object.url ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(InfoRequest.$type, InfoRequest);
function createBaseMoreChildrenRequest() {
  return { children: [], depth: void 0, limitChildren: void 0, linkId: "", sort: void 0, id: void 0 };
}
var MoreChildrenRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    for (const v of message.children) {
      writer.uint32(10).string(v);
    }
    if (message.depth !== void 0) {
      Int32Value.encode({ value: message.depth }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limitChildren !== void 0) {
      BoolValue.encode({ value: message.limitChildren }, writer.uint32(34).fork()).ldelim();
    }
    if (message.linkId !== "") {
      writer.uint32(42).string(message.linkId);
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMoreChildrenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.children.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.depth = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.limitChildren = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.linkId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e) => globalThis.String(e)) : [],
      depth: isSet128(object.depth) ? Number(object.depth) : void 0,
      limitChildren: isSet128(object.limitChildren) ? Boolean(object.limitChildren) : void 0,
      linkId: isSet128(object.linkId) ? globalThis.String(object.linkId) : "",
      sort: isSet128(object.sort) ? String(object.sort) : void 0,
      id: isSet128(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.children?.length) {
      obj.children = message.children;
    }
    if (message.depth !== void 0) {
      obj.depth = message.depth;
    }
    if (message.limitChildren !== void 0) {
      obj.limitChildren = message.limitChildren;
    }
    if (message.linkId !== "") {
      obj.linkId = message.linkId;
    }
    if (message.sort !== void 0) {
      obj.sort = message.sort;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return MoreChildrenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMoreChildrenRequest();
    message.children = object.children?.map((e) => e) || [];
    message.depth = object.depth ?? void 0;
    message.limitChildren = object.limitChildren ?? void 0;
    message.linkId = object.linkId ?? "";
    message.sort = object.sort ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(MoreChildrenRequest.$type, MoreChildrenRequest);
function createBaseReportRequest() {
  return {
    additionalInfo: void 0,
    customText: void 0,
    modmailConvId: void 0,
    otherReason: void 0,
    reason: "",
    ruleReason: void 0,
    siteReason: void 0,
    srName: void 0,
    thingId: "",
    usernames: void 0
  };
}
var ReportRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.ReportRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.additionalInfo !== void 0) {
      StringValue.encode({ value: message.additionalInfo }, writer.uint32(10).fork()).ldelim();
    }
    if (message.customText !== void 0) {
      StringValue.encode({ value: message.customText }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modmailConvId !== void 0) {
      StringValue.encode({ value: message.modmailConvId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.otherReason !== void 0) {
      StringValue.encode({ value: message.otherReason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.reason !== "") {
      writer.uint32(58).string(message.reason);
    }
    if (message.ruleReason !== void 0) {
      StringValue.encode({ value: message.ruleReason }, writer.uint32(66).fork()).ldelim();
    }
    if (message.siteReason !== void 0) {
      StringValue.encode({ value: message.siteReason }, writer.uint32(74).fork()).ldelim();
    }
    if (message.srName !== void 0) {
      StringValue.encode({ value: message.srName }, writer.uint32(82).fork()).ldelim();
    }
    if (message.thingId !== "") {
      writer.uint32(90).string(message.thingId);
    }
    if (message.usernames !== void 0) {
      StringValue.encode({ value: message.usernames }, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.additionalInfo = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.customText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.modmailConvId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.otherReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.reason = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.ruleReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.siteReason = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.srName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.thingId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.usernames = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      additionalInfo: isSet128(object.additionalInfo) ? String(object.additionalInfo) : void 0,
      customText: isSet128(object.customText) ? String(object.customText) : void 0,
      modmailConvId: isSet128(object.modmailConvId) ? String(object.modmailConvId) : void 0,
      otherReason: isSet128(object.otherReason) ? String(object.otherReason) : void 0,
      reason: isSet128(object.reason) ? globalThis.String(object.reason) : "",
      ruleReason: isSet128(object.ruleReason) ? String(object.ruleReason) : void 0,
      siteReason: isSet128(object.siteReason) ? String(object.siteReason) : void 0,
      srName: isSet128(object.srName) ? String(object.srName) : void 0,
      thingId: isSet128(object.thingId) ? globalThis.String(object.thingId) : "",
      usernames: isSet128(object.usernames) ? String(object.usernames) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.additionalInfo !== void 0) {
      obj.additionalInfo = message.additionalInfo;
    }
    if (message.customText !== void 0) {
      obj.customText = message.customText;
    }
    if (message.modmailConvId !== void 0) {
      obj.modmailConvId = message.modmailConvId;
    }
    if (message.otherReason !== void 0) {
      obj.otherReason = message.otherReason;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.ruleReason !== void 0) {
      obj.ruleReason = message.ruleReason;
    }
    if (message.siteReason !== void 0) {
      obj.siteReason = message.siteReason;
    }
    if (message.srName !== void 0) {
      obj.srName = message.srName;
    }
    if (message.thingId !== "") {
      obj.thingId = message.thingId;
    }
    if (message.usernames !== void 0) {
      obj.usernames = message.usernames;
    }
    return obj;
  },
  create(base) {
    return ReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReportRequest();
    message.additionalInfo = object.additionalInfo ?? void 0;
    message.customText = object.customText ?? void 0;
    message.modmailConvId = object.modmailConvId ?? void 0;
    message.otherReason = object.otherReason ?? void 0;
    message.reason = object.reason ?? "";
    message.ruleReason = object.ruleReason ?? void 0;
    message.siteReason = object.siteReason ?? void 0;
    message.srName = object.srName ?? void 0;
    message.thingId = object.thingId ?? "";
    message.usernames = object.usernames ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ReportRequest.$type, ReportRequest);
function createBaseReportAwardRequest() {
  return { awardId: "", reason: void 0 };
}
var ReportAwardRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.ReportAwardRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.awardId !== "") {
      writer.uint32(10).string(message.awardId);
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReportAwardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.awardId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      awardId: isSet128(object.awardId) ? globalThis.String(object.awardId) : "",
      reason: isSet128(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.awardId !== "") {
      obj.awardId = message.awardId;
    }
    if (message.reason !== void 0) {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return ReportAwardRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReportAwardRequest();
    message.awardId = object.awardId ?? "";
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(ReportAwardRequest.$type, ReportAwardRequest);
function createBaseSaveRequest() {
  return { id: "" };
}
var SaveRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SaveRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSaveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet128(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return SaveRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSaveRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(SaveRequest.$type, SaveRequest);
function createBaseSendRepliesRequest() {
  return { id: "", state: false };
}
var SendRepliesRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SendRepliesRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state !== false) {
      writer.uint32(16).bool(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSendRepliesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.state = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet128(object.id) ? globalThis.String(object.id) : "",
      state: isSet128(object.state) ? globalThis.Boolean(object.state) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.state !== false) {
      obj.state = message.state;
    }
    return obj;
  },
  create(base) {
    return SendRepliesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSendRepliesRequest();
    message.id = object.id ?? "";
    message.state = object.state ?? false;
    return message;
  }
};
messageTypeRegistry.set(SendRepliesRequest.$type, SendRepliesRequest);
function createBaseSetContestModeRequest() {
  return { id: "", state: false };
}
var SetContestModeRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SetContestModeRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state !== false) {
      writer.uint32(16).bool(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetContestModeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.state = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet128(object.id) ? globalThis.String(object.id) : "",
      state: isSet128(object.state) ? globalThis.Boolean(object.state) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.state !== false) {
      obj.state = message.state;
    }
    return obj;
  },
  create(base) {
    return SetContestModeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetContestModeRequest();
    message.id = object.id ?? "";
    message.state = object.state ?? false;
    return message;
  }
};
messageTypeRegistry.set(SetContestModeRequest.$type, SetContestModeRequest);
function createBaseSetSubredditStickyRequest() {
  return { id: "", num: void 0, state: false, toProfile: void 0 };
}
var SetSubredditStickyRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.num !== void 0) {
      Int32Value.encode({ value: message.num }, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== false) {
      writer.uint32(24).bool(message.state);
    }
    if (message.toProfile !== void 0) {
      BoolValue.encode({ value: message.toProfile }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetSubredditStickyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.num = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.state = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.toProfile = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet128(object.id) ? globalThis.String(object.id) : "",
      num: isSet128(object.num) ? Number(object.num) : void 0,
      state: isSet128(object.state) ? globalThis.Boolean(object.state) : false,
      toProfile: isSet128(object.toProfile) ? Boolean(object.toProfile) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.num !== void 0) {
      obj.num = message.num;
    }
    if (message.state !== false) {
      obj.state = message.state;
    }
    if (message.toProfile !== void 0) {
      obj.toProfile = message.toProfile;
    }
    return obj;
  },
  create(base) {
    return SetSubredditStickyRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetSubredditStickyRequest();
    message.id = object.id ?? "";
    message.num = object.num ?? void 0;
    message.state = object.state ?? false;
    message.toProfile = object.toProfile ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SetSubredditStickyRequest.$type, SetSubredditStickyRequest);
function createBaseSetSuggestedSortRequest() {
  return { id: "", sort: "" };
}
var SetSuggestedSortRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sort !== "") {
      writer.uint32(18).string(message.sort);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetSuggestedSortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.sort = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet128(object.id) ? globalThis.String(object.id) : "",
      sort: isSet128(object.sort) ? globalThis.String(object.sort) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    return obj;
  },
  create(base) {
    return SetSuggestedSortRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetSuggestedSortRequest();
    message.id = object.id ?? "";
    message.sort = object.sort ?? "";
    return message;
  }
};
messageTypeRegistry.set(SetSuggestedSortRequest.$type, SetSuggestedSortRequest);
function createBaseSubmitRequest() {
  return {
    collectionId: void 0,
    flairId: void 0,
    flairText: void 0,
    kind: "",
    nsfw: void 0,
    richtextJson: void 0,
    sendreplies: void 0,
    spoiler: void 0,
    sr: "",
    text: void 0,
    title: "",
    url: void 0,
    videoPosterUrl: void 0,
    crosspostFullname: void 0
  };
}
var SubmitRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.flairId !== void 0) {
      StringValue.encode({ value: message.flairId }, writer.uint32(58).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(66).fork()).ldelim();
    }
    if (message.kind !== "") {
      writer.uint32(74).string(message.kind);
    }
    if (message.nsfw !== void 0) {
      BoolValue.encode({ value: message.nsfw }, writer.uint32(82).fork()).ldelim();
    }
    if (message.richtextJson !== void 0) {
      StringValue.encode({ value: message.richtextJson }, writer.uint32(98).fork()).ldelim();
    }
    if (message.sendreplies !== void 0) {
      BoolValue.encode({ value: message.sendreplies }, writer.uint32(106).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      BoolValue.encode({ value: message.spoiler }, writer.uint32(114).fork()).ldelim();
    }
    if (message.sr !== "") {
      writer.uint32(122).string(message.sr);
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(130).fork()).ldelim();
    }
    if (message.title !== "") {
      writer.uint32(138).string(message.title);
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(146).fork()).ldelim();
    }
    if (message.videoPosterUrl !== void 0) {
      StringValue.encode({ value: message.videoPosterUrl }, writer.uint32(154).fork()).ldelim();
    }
    if (message.crosspostFullname !== void 0) {
      StringValue.encode({ value: message.crosspostFullname }, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.flairId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.nsfw = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.richtextJson = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.sendreplies = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.sr = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.text = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }
          message.title = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }
          message.videoPosterUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }
          message.crosspostFullname = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet128(object.collectionId) ? String(object.collectionId) : void 0,
      flairId: isSet128(object.flairId) ? String(object.flairId) : void 0,
      flairText: isSet128(object.flairText) ? String(object.flairText) : void 0,
      kind: isSet128(object.kind) ? globalThis.String(object.kind) : "",
      nsfw: isSet128(object.nsfw) ? Boolean(object.nsfw) : void 0,
      richtextJson: isSet128(object.richtextJson) ? String(object.richtextJson) : void 0,
      sendreplies: isSet128(object.sendreplies) ? Boolean(object.sendreplies) : void 0,
      spoiler: isSet128(object.spoiler) ? Boolean(object.spoiler) : void 0,
      sr: isSet128(object.sr) ? globalThis.String(object.sr) : "",
      text: isSet128(object.text) ? String(object.text) : void 0,
      title: isSet128(object.title) ? globalThis.String(object.title) : "",
      url: isSet128(object.url) ? String(object.url) : void 0,
      videoPosterUrl: isSet128(object.videoPosterUrl) ? String(object.videoPosterUrl) : void 0,
      crosspostFullname: isSet128(object.crosspostFullname) ? String(object.crosspostFullname) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.collectionId !== void 0) {
      obj.collectionId = message.collectionId;
    }
    if (message.flairId !== void 0) {
      obj.flairId = message.flairId;
    }
    if (message.flairText !== void 0) {
      obj.flairText = message.flairText;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.nsfw !== void 0) {
      obj.nsfw = message.nsfw;
    }
    if (message.richtextJson !== void 0) {
      obj.richtextJson = message.richtextJson;
    }
    if (message.sendreplies !== void 0) {
      obj.sendreplies = message.sendreplies;
    }
    if (message.spoiler !== void 0) {
      obj.spoiler = message.spoiler;
    }
    if (message.sr !== "") {
      obj.sr = message.sr;
    }
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.videoPosterUrl !== void 0) {
      obj.videoPosterUrl = message.videoPosterUrl;
    }
    if (message.crosspostFullname !== void 0) {
      obj.crosspostFullname = message.crosspostFullname;
    }
    return obj;
  },
  create(base) {
    return SubmitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmitRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.flairId = object.flairId ?? void 0;
    message.flairText = object.flairText ?? void 0;
    message.kind = object.kind ?? "";
    message.nsfw = object.nsfw ?? void 0;
    message.richtextJson = object.richtextJson ?? void 0;
    message.sendreplies = object.sendreplies ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.sr = object.sr ?? "";
    message.text = object.text ?? void 0;
    message.title = object.title ?? "";
    message.url = object.url ?? void 0;
    message.videoPosterUrl = object.videoPosterUrl ?? void 0;
    message.crosspostFullname = object.crosspostFullname ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmitRequest.$type, SubmitRequest);
function createBaseVoteRequest() {
  return { dir: 0, id: "" };
}
var VoteRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.VoteRequest",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.dir !== 0) {
      writer.uint32(8).int32(message.dir);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.dir = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dir: isSet128(object.dir) ? globalThis.Number(object.dir) : 0,
      id: isSet128(object.id) ? globalThis.String(object.id) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dir !== 0) {
      obj.dir = Math.round(message.dir);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return VoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVoteRequest();
    message.dir = object.dir ?? 0;
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(VoteRequest.$type, VoteRequest);
function createBaseJsonWrappedComment() {
  return { json: void 0 };
}
var JsonWrappedComment = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.json !== void 0) {
      JsonWrappedComment_Json.encode(message.json, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.json = JsonWrappedComment_Json.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet128(object.json) ? JsonWrappedComment_Json.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.json !== void 0) {
      obj.json = JsonWrappedComment_Json.toJSON(message.json);
    }
    return obj;
  },
  create(base) {
    return JsonWrappedComment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment();
    message.json = object.json !== void 0 && object.json !== null ? JsonWrappedComment_Json.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set(JsonWrappedComment.$type, JsonWrappedComment);
function createBaseJsonWrappedComment_WrappedComment() {
  return { kind: "", data: void 0 };
}
var JsonWrappedComment_WrappedComment = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.WrappedComment",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      Comment.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment_WrappedComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = Comment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet128(object.kind) ? globalThis.String(object.kind) : "",
      data: isSet128(object.data) ? Comment.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.data !== void 0) {
      obj.data = Comment.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return JsonWrappedComment_WrappedComment.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment_WrappedComment();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? Comment.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(JsonWrappedComment_WrappedComment.$type, JsonWrappedComment_WrappedComment);
function createBaseJsonWrappedComment_JsonData() {
  return { things: [] };
}
var JsonWrappedComment_JsonData = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.JsonData",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    for (const v of message.things) {
      JsonWrappedComment_WrappedComment.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment_JsonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.things.push(JsonWrappedComment_WrappedComment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      things: globalThis.Array.isArray(object?.things) ? object.things.map((e) => JsonWrappedComment_WrappedComment.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.things?.length) {
      obj.things = message.things.map((e) => JsonWrappedComment_WrappedComment.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return JsonWrappedComment_JsonData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment_JsonData();
    message.things = object.things?.map((e) => JsonWrappedComment_WrappedComment.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(JsonWrappedComment_JsonData.$type, JsonWrappedComment_JsonData);
function createBaseJsonWrappedComment_Json() {
  return { errors: [], data: void 0 };
}
var JsonWrappedComment_Json = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.Json",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    for (const v of message.errors) {
      writer.uint32(10).string(v);
    }
    if (message.data !== void 0) {
      JsonWrappedComment_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment_Json();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.errors.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = JsonWrappedComment_JsonData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => globalThis.String(e)) : [],
      data: isSet128(object.data) ? JsonWrappedComment_JsonData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    if (message.data !== void 0) {
      obj.data = JsonWrappedComment_JsonData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return JsonWrappedComment_Json.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment_Json();
    message.errors = object.errors?.map((e) => e) || [];
    message.data = object.data !== void 0 && object.data !== null ? JsonWrappedComment_JsonData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(JsonWrappedComment_Json.$type, JsonWrappedComment_Json);
function createBaseSubmitResponse() {
  return { json: void 0 };
}
var SubmitResponse = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.json !== void 0) {
      SubmitResponse_JsonType.encode(message.json, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }
          message.json = SubmitResponse_JsonType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet128(object.json) ? SubmitResponse_JsonType.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.json !== void 0) {
      obj.json = SubmitResponse_JsonType.toJSON(message.json);
    }
    return obj;
  },
  create(base) {
    return SubmitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmitResponse();
    message.json = object.json !== void 0 && object.json !== null ? SubmitResponse_JsonType.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmitResponse.$type, SubmitResponse);
function createBaseSubmitResponse_JsonType() {
  return { errors: [], data: void 0 };
}
var SubmitResponse_JsonType = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    for (const v of message.errors) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubmitResponse_JsonType_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitResponse_JsonType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.errors.push(Any.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = SubmitResponse_JsonType_JsonData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e) => Any.fromJSON(e)) : [],
      data: isSet128(object.data) ? SubmitResponse_JsonType_JsonData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Any.toJSON(e));
    }
    if (message.data !== void 0) {
      obj.data = SubmitResponse_JsonType_JsonData.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return SubmitResponse_JsonType.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmitResponse_JsonType();
    message.errors = object.errors?.map((e) => Any.fromPartial(e)) || [];
    message.data = object.data !== void 0 && object.data !== null ? SubmitResponse_JsonType_JsonData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmitResponse_JsonType.$type, SubmitResponse_JsonType);
function createBaseSubmitResponse_JsonType_JsonData() {
  return { url: void 0, draftsCount: void 0, id: void 0, name: void 0 };
}
var SubmitResponse_JsonType_JsonData = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType.JsonData",
  encode(message, writer = import_minimal148.default.Writer.create()) {
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
    }
    if (message.draftsCount !== void 0) {
      Int32Value.encode({ value: message.draftsCount }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal148.default.Reader ? input : import_minimal148.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitResponse_JsonType_JsonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.draftsCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet128(object.url) ? String(object.url) : void 0,
      draftsCount: isSet128(object.draftsCount) ? Number(object.draftsCount) : void 0,
      id: isSet128(object.id) ? String(object.id) : void 0,
      name: isSet128(object.name) ? String(object.name) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== void 0) {
      obj.url = message.url;
    }
    if (message.draftsCount !== void 0) {
      obj.draftsCount = message.draftsCount;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return SubmitResponse_JsonType_JsonData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSubmitResponse_JsonType_JsonData();
    message.url = object.url ?? void 0;
    message.draftsCount = object.draftsCount ?? void 0;
    message.id = object.id ?? void 0;
    message.name = object.name ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(SubmitResponse_JsonType_JsonData.$type, SubmitResponse_JsonType_JsonData);
function isSet128(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/graphql/graphql_svc.js
var import_minimal151 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/graphql/graphql_msg.js
var import_minimal150 = __toESM(require_minimal2(), 1);
function createBaseQueryRequest() {
  return { query: "", variables: void 0 };
}
var QueryRequest = {
  $type: "devvit.plugin.redditapi.graphql.QueryRequest",
  encode(message, writer = import_minimal150.default.Writer.create()) {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.variables !== void 0) {
      Struct.encode(Struct.wrap(message.variables), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal150.default.Reader ? input : import_minimal150.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.variables = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      query: isSet129(object.query) ? globalThis.String(object.query) : "",
      variables: isObject32(object.variables) ? object.variables : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.variables !== void 0) {
      obj.variables = message.variables;
    }
    return obj;
  },
  create(base) {
    return QueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueryRequest();
    message.query = object.query ?? "";
    message.variables = object.variables ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(QueryRequest.$type, QueryRequest);
function createBasePersistedQueryRequest() {
  return { id: "", variables: void 0, operationName: "" };
}
var PersistedQueryRequest = {
  $type: "devvit.plugin.redditapi.graphql.PersistedQueryRequest",
  encode(message, writer = import_minimal150.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.variables !== void 0) {
      Struct.encode(Struct.wrap(message.variables), writer.uint32(18).fork()).ldelim();
    }
    if (message.operationName !== "") {
      writer.uint32(26).string(message.operationName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal150.default.Reader ? input : import_minimal150.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePersistedQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.variables = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.operationName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet129(object.id) ? globalThis.String(object.id) : "",
      variables: isObject32(object.variables) ? object.variables : void 0,
      operationName: isSet129(object.operationName) ? globalThis.String(object.operationName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.variables !== void 0) {
      obj.variables = message.variables;
    }
    if (message.operationName !== "") {
      obj.operationName = message.operationName;
    }
    return obj;
  },
  create(base) {
    return PersistedQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePersistedQueryRequest();
    message.id = object.id ?? "";
    message.variables = object.variables ?? void 0;
    message.operationName = object.operationName ?? "";
    return message;
  }
};
messageTypeRegistry.set(PersistedQueryRequest.$type, PersistedQueryRequest);
function createBaseQueryResponse() {
  return { data: void 0 };
}
var QueryResponse = {
  $type: "devvit.plugin.redditapi.graphql.QueryResponse",
  encode(message, writer = import_minimal150.default.Writer.create()) {
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal150.default.Reader ? input : import_minimal150.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { data: isObject32(object.data) ? object.data : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    return obj;
  },
  create(base) {
    return QueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueryResponse();
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(QueryResponse.$type, QueryResponse);
function isObject32(value) {
  return typeof value === "object" && value !== null;
}
function isSet129(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/flair/flair_svc.js
var import_minimal152 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/gateway/utils/v1alpha/utilities.js
var import_long16 = __toESM(require_long(), 1);
var import_minimal153 = __toESM(require_minimal2(), 1);
function createBaseAccessKeyPurgeRequest() {
  return { userId: "", includeRefresh: false };
}
var AccessKeyPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.AccessKeyPurgeRequest",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.includeRefresh !== false) {
      writer.uint32(16).bool(message.includeRefresh);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAccessKeyPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.includeRefresh = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet130(object.userId) ? globalThis.String(object.userId) : "",
      includeRefresh: isSet130(object.includeRefresh) ? globalThis.Boolean(object.includeRefresh) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.includeRefresh !== false) {
      obj.includeRefresh = message.includeRefresh;
    }
    return obj;
  },
  create(base) {
    return AccessKeyPurgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAccessKeyPurgeRequest();
    message.userId = object.userId ?? "";
    message.includeRefresh = object.includeRefresh ?? false;
    return message;
  }
};
messageTypeRegistry.set(AccessKeyPurgeRequest.$type, AccessKeyPurgeRequest);
function createBaseInstallationsPurgeRequest() {
  return { subreddit: "" };
}
var InstallationsPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.InstallationsPurgeRequest",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationsPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subreddit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet130(object.subreddit) ? globalThis.String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddit !== "") {
      obj.subreddit = message.subreddit;
    }
    return obj;
  },
  create(base) {
    return InstallationsPurgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationsPurgeRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set(InstallationsPurgeRequest.$type, InstallationsPurgeRequest);
function createBaseInstallationPurgeRequest() {
  return { installationId: "" };
}
var InstallationPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.InstallationPurgeRequest",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.installationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet130(object.installationId) ? globalThis.String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    return obj;
  },
  create(base) {
    return InstallationPurgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInstallationPurgeRequest();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set(InstallationPurgeRequest.$type, InstallationPurgeRequest);
function createBaseAppVersionPurgeRequest() {
  return { appVersionId: "" };
}
var AppVersionPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.AppVersionPurgeRequest",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.appVersionId !== "") {
      writer.uint32(10).string(message.appVersionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appVersionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appVersionId: isSet130(object.appVersionId) ? globalThis.String(object.appVersionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appVersionId !== "") {
      obj.appVersionId = message.appVersionId;
    }
    return obj;
  },
  create(base) {
    return AppVersionPurgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppVersionPurgeRequest();
    message.appVersionId = object.appVersionId ?? "";
    return message;
  }
};
messageTypeRegistry.set(AppVersionPurgeRequest.$type, AppVersionPurgeRequest);
function createBaseAppPurgeRequest() {
  return { appId: "" };
}
var AppPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.AppPurgeRequest",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet130(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppPurgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppPurgeRequest();
    message.appId = object.appId ?? "";
    return message;
  }
};
messageTypeRegistry.set(AppPurgeRequest.$type, AppPurgeRequest);
function createBasePurgeResult() {
  return { count: 0 };
}
var PurgeResult = {
  $type: "devvit.gateway.utils.v1alpha.PurgeResult",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePurgeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.count = longToNumber16(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { count: isSet130(object.count) ? globalThis.Number(object.count) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },
  create(base) {
    return PurgeResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePurgeResult();
    message.count = object.count ?? 0;
    return message;
  }
};
messageTypeRegistry.set(PurgeResult.$type, PurgeResult);
function createBaseAcceptInviteRequest() {
  return { subredditName: "", appAccountId: "" };
}
var AcceptInviteRequest = {
  $type: "devvit.gateway.utils.v1alpha.AcceptInviteRequest",
  encode(message, writer = import_minimal153.default.Writer.create()) {
    if (message.subredditName !== "") {
      writer.uint32(10).string(message.subredditName);
    }
    if (message.appAccountId !== "") {
      writer.uint32(18).string(message.appAccountId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAcceptInviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.subredditName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.appAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      subredditName: isSet130(object.subredditName) ? globalThis.String(object.subredditName) : "",
      appAccountId: isSet130(object.appAccountId) ? globalThis.String(object.appAccountId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subredditName !== "") {
      obj.subredditName = message.subredditName;
    }
    if (message.appAccountId !== "") {
      obj.appAccountId = message.appAccountId;
    }
    return obj;
  },
  create(base) {
    return AcceptInviteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAcceptInviteRequest();
    message.subredditName = object.subredditName ?? "";
    message.appAccountId = object.appAccountId ?? "";
    return message;
  }
};
messageTypeRegistry.set(AcceptInviteRequest.$type, AcceptInviteRequest);
function createBaseAcceptInviteResponse() {
  return {};
}
var AcceptInviteResponse = {
  $type: "devvit.gateway.utils.v1alpha.AcceptInviteResponse",
  encode(_, writer = import_minimal153.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal153.default.Reader ? input : import_minimal153.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAcceptInviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return AcceptInviteResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseAcceptInviteResponse();
    return message;
  }
};
messageTypeRegistry.set(AcceptInviteResponse.$type, AcceptInviteResponse);
function longToNumber16(long) {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal153.default.util.Long !== import_long16.default) {
  import_minimal153.default.util.Long = import_long16.default;
  import_minimal153.default.configure();
}
function isSet130(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/internal/media/media.js
var import_minimal154 = __toESM(require_minimal2(), 1);
var AssetStatus;
(function(AssetStatus2) {
  AssetStatus2[AssetStatus2["MISSING"] = 0] = "MISSING";
  AssetStatus2[AssetStatus2["PROCESSING"] = 1] = "PROCESSING";
  AssetStatus2[AssetStatus2["READY"] = 2] = "READY";
  AssetStatus2[AssetStatus2["REJECTED"] = 3] = "REJECTED";
  AssetStatus2[AssetStatus2["ERROR"] = 4] = "ERROR";
  AssetStatus2[AssetStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AssetStatus || (AssetStatus = {}));
function assetStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "MISSING":
      return AssetStatus.MISSING;
    case 1:
    case "PROCESSING":
      return AssetStatus.PROCESSING;
    case 2:
    case "READY":
      return AssetStatus.READY;
    case 3:
    case "REJECTED":
      return AssetStatus.REJECTED;
    case 4:
    case "ERROR":
      return AssetStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetStatus.UNRECOGNIZED;
  }
}
function assetStatusToJSON(object) {
  switch (object) {
    case AssetStatus.MISSING:
      return 0;
    case AssetStatus.PROCESSING:
      return 1;
    case AssetStatus.READY:
      return 2;
    case AssetStatus.REJECTED:
      return 3;
    case AssetStatus.ERROR:
      return 4;
    case AssetStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseUpdateAssetStatusRequest() {
  return { mediaId: "", newStatus: 0, url: "" };
}
var UpdateAssetStatusRequest = {
  $type: "devvit.dev_portal.internal.media.UpdateAssetStatusRequest",
  encode(message, writer = import_minimal154.default.Writer.create()) {
    if (message.mediaId !== "") {
      writer.uint32(10).string(message.mediaId);
    }
    if (message.newStatus !== 0) {
      writer.uint32(16).int32(message.newStatus);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal154.default.Reader ? input : import_minimal154.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssetStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.mediaId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.newStatus = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      mediaId: isSet131(object.mediaId) ? globalThis.String(object.mediaId) : "",
      newStatus: isSet131(object.newStatus) ? assetStatusFromJSON(object.newStatus) : 0,
      url: isSet131(object.url) ? globalThis.String(object.url) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.mediaId !== "") {
      obj.mediaId = message.mediaId;
    }
    if (message.newStatus !== 0) {
      obj.newStatus = assetStatusToJSON(message.newStatus);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return UpdateAssetStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateAssetStatusRequest();
    message.mediaId = object.mediaId ?? "";
    message.newStatus = object.newStatus ?? 0;
    message.url = object.url ?? "";
    return message;
  }
};
messageTypeRegistry.set(UpdateAssetStatusRequest.$type, UpdateAssetStatusRequest);
function createBaseUpdateAssetStatusResponse() {
  return {};
}
var UpdateAssetStatusResponse = {
  $type: "devvit.dev_portal.internal.media.UpdateAssetStatusResponse",
  encode(_, writer = import_minimal154.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal154.default.Reader ? input : import_minimal154.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssetStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return UpdateAssetStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseUpdateAssetStatusResponse();
    return message;
  }
};
messageTypeRegistry.set(UpdateAssetStatusResponse.$type, UpdateAssetStatusResponse);
function isSet131(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/api/v1alpha/intake.js
var import_minimal155 = __toESM(require_minimal2(), 1);
function createBaseIntakeEvent() {
  return { topic: "", id: "", event: void 0 };
}
var IntakeEvent = {
  $type: "devvit.data.api.v1alpha.IntakeEvent",
  encode(message, writer = import_minimal155.default.Writer.create()) {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.event !== void 0) {
      Any.encode(message.event, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal155.default.Reader ? input : import_minimal155.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIntakeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.event = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      topic: isSet132(object.topic) ? globalThis.String(object.topic) : "",
      id: isSet132(object.id) ? globalThis.String(object.id) : "",
      event: isSet132(object.event) ? Any.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.event !== void 0) {
      obj.event = Any.toJSON(message.event);
    }
    return obj;
  },
  create(base) {
    return IntakeEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseIntakeEvent();
    message.topic = object.topic ?? "";
    message.id = object.id ?? "";
    message.event = object.event !== void 0 && object.event !== null ? Any.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set(IntakeEvent.$type, IntakeEvent);
function createBaseIntakeResponse() {
  return {};
}
var IntakeResponse = {
  $type: "devvit.data.api.v1alpha.IntakeResponse",
  encode(_, writer = import_minimal155.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal155.default.Reader ? input : import_minimal155.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIntakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return IntakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseIntakeResponse();
    return message;
  }
};
messageTypeRegistry.set(IntakeResponse.$type, IntakeResponse);
function isSet132(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/api/v1alpha/filter.js
var import_minimal156 = __toESM(require_minimal2(), 1);
var FirehoseFilterData_ApprovalStatus;
(function(FirehoseFilterData_ApprovalStatus2) {
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["UNKNOWN_APPROVAL_STATUS"] = 0] = "UNKNOWN_APPROVAL_STATUS";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["MOD_APPROVED"] = 1] = "MOD_APPROVED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["MOD_REMOVED"] = 2] = "MOD_REMOVED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["MOD_SPAMMED"] = 3] = "MOD_SPAMMED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["ADMIN_APPROVED"] = 4] = "ADMIN_APPROVED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["ADMIN_REMOVED"] = 5] = "ADMIN_REMOVED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["ADMIN_SPAMMED"] = 6] = "ADMIN_SPAMMED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["AUTHOR_REMOVED"] = 7] = "AUTHOR_REMOVED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["AUTHOR_SPAMMED"] = 8] = "AUTHOR_SPAMMED";
  FirehoseFilterData_ApprovalStatus2[FirehoseFilterData_ApprovalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FirehoseFilterData_ApprovalStatus || (FirehoseFilterData_ApprovalStatus = {}));
function firehoseFilterData_ApprovalStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_APPROVAL_STATUS":
      return FirehoseFilterData_ApprovalStatus.UNKNOWN_APPROVAL_STATUS;
    case 1:
    case "MOD_APPROVED":
      return FirehoseFilterData_ApprovalStatus.MOD_APPROVED;
    case 2:
    case "MOD_REMOVED":
      return FirehoseFilterData_ApprovalStatus.MOD_REMOVED;
    case 3:
    case "MOD_SPAMMED":
      return FirehoseFilterData_ApprovalStatus.MOD_SPAMMED;
    case 4:
    case "ADMIN_APPROVED":
      return FirehoseFilterData_ApprovalStatus.ADMIN_APPROVED;
    case 5:
    case "ADMIN_REMOVED":
      return FirehoseFilterData_ApprovalStatus.ADMIN_REMOVED;
    case 6:
    case "ADMIN_SPAMMED":
      return FirehoseFilterData_ApprovalStatus.ADMIN_SPAMMED;
    case 7:
    case "AUTHOR_REMOVED":
      return FirehoseFilterData_ApprovalStatus.AUTHOR_REMOVED;
    case 8:
    case "AUTHOR_SPAMMED":
      return FirehoseFilterData_ApprovalStatus.AUTHOR_SPAMMED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FirehoseFilterData_ApprovalStatus.UNRECOGNIZED;
  }
}
function firehoseFilterData_ApprovalStatusToJSON(object) {
  switch (object) {
    case FirehoseFilterData_ApprovalStatus.UNKNOWN_APPROVAL_STATUS:
      return 0;
    case FirehoseFilterData_ApprovalStatus.MOD_APPROVED:
      return 1;
    case FirehoseFilterData_ApprovalStatus.MOD_REMOVED:
      return 2;
    case FirehoseFilterData_ApprovalStatus.MOD_SPAMMED:
      return 3;
    case FirehoseFilterData_ApprovalStatus.ADMIN_APPROVED:
      return 4;
    case FirehoseFilterData_ApprovalStatus.ADMIN_REMOVED:
      return 5;
    case FirehoseFilterData_ApprovalStatus.ADMIN_SPAMMED:
      return 6;
    case FirehoseFilterData_ApprovalStatus.AUTHOR_REMOVED:
      return 7;
    case FirehoseFilterData_ApprovalStatus.AUTHOR_SPAMMED:
      return 8;
    case FirehoseFilterData_ApprovalStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseFirehoseFilterData() {
  return { event: 0, subredditId: "", subredditRating: 0, post: void 0, comment: void 0, subredditType: 0 };
}
var FirehoseFilterData = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.event !== 0) {
      writer.uint32(8).int32(message.event);
    }
    if (message.subredditId !== "") {
      writer.uint32(18).string(message.subredditId);
    }
    if (message.subredditRating !== 0) {
      writer.uint32(24).int32(message.subredditRating);
    }
    if (message.post !== void 0) {
      FirehoseFilterData_PostFilterData.encode(message.post, writer.uint32(34).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      FirehoseFilterData_CommentFilterData.encode(message.comment, writer.uint32(42).fork()).ldelim();
    }
    if (message.subredditType !== 0) {
      writer.uint32(48).int32(message.subredditType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.event = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.subredditId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.subredditRating = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.post = FirehoseFilterData_PostFilterData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.comment = FirehoseFilterData_CommentFilterData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.subredditType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      event: isSet133(object.event) ? firehoseEventFromJSON(object.event) : 0,
      subredditId: isSet133(object.subredditId) ? globalThis.String(object.subredditId) : "",
      subredditRating: isSet133(object.subredditRating) ? subredditRatingFromJSON(object.subredditRating) : 0,
      post: isSet133(object.post) ? FirehoseFilterData_PostFilterData.fromJSON(object.post) : void 0,
      comment: isSet133(object.comment) ? FirehoseFilterData_CommentFilterData.fromJSON(object.comment) : void 0,
      subredditType: isSet133(object.subredditType) ? subredditTypeFromJSON(object.subredditType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.event !== 0) {
      obj.event = firehoseEventToJSON(message.event);
    }
    if (message.subredditId !== "") {
      obj.subredditId = message.subredditId;
    }
    if (message.subredditRating !== 0) {
      obj.subredditRating = subredditRatingToJSON(message.subredditRating);
    }
    if (message.post !== void 0) {
      obj.post = FirehoseFilterData_PostFilterData.toJSON(message.post);
    }
    if (message.comment !== void 0) {
      obj.comment = FirehoseFilterData_CommentFilterData.toJSON(message.comment);
    }
    if (message.subredditType !== 0) {
      obj.subredditType = subredditTypeToJSON(message.subredditType);
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData();
    message.event = object.event ?? 0;
    message.subredditId = object.subredditId ?? "";
    message.subredditRating = object.subredditRating ?? 0;
    message.post = object.post !== void 0 && object.post !== null ? FirehoseFilterData_PostFilterData.fromPartial(object.post) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? FirehoseFilterData_CommentFilterData.fromPartial(object.comment) : void 0;
    message.subredditType = object.subredditType ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData.$type, FirehoseFilterData);
function createBaseFirehoseFilterData_SafetyTag() {
  return { versions: {}, score: 0 };
}
var FirehoseFilterData_SafetyTag = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.SafetyTag",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    Object.entries(message.versions).forEach(([key, value]) => {
      FirehoseFilterData_SafetyTag_VersionsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.score !== 0) {
      writer.uint32(17).double(message.score);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_SafetyTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          const entry1 = FirehoseFilterData_SafetyTag_VersionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.versions[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.score = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      versions: isObject33(object.versions) ? Object.entries(object.versions).reduce((acc, [key, value]) => {
        acc[key] = Number(value);
        return acc;
      }, {}) : {},
      score: isSet133(object.score) ? globalThis.Number(object.score) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.versions) {
      const entries = Object.entries(message.versions);
      if (entries.length > 0) {
        obj.versions = {};
        entries.forEach(([k, v]) => {
          obj.versions[k] = v;
        });
      }
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_SafetyTag.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_SafetyTag();
    message.versions = Object.entries(object.versions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.score = object.score ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_SafetyTag.$type, FirehoseFilterData_SafetyTag);
function createBaseFirehoseFilterData_SafetyTag_VersionsEntry() {
  return { key: "", value: 0 };
}
var FirehoseFilterData_SafetyTag_VersionsEntry = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.SafetyTag.VersionsEntry",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_SafetyTag_VersionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet133(object.key) ? globalThis.String(object.key) : "",
      value: isSet133(object.value) ? globalThis.Number(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_SafetyTag_VersionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_SafetyTag_VersionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_SafetyTag_VersionsEntry.$type, FirehoseFilterData_SafetyTag_VersionsEntry);
function createBaseFirehoseFilterData_PostFilterData() {
  return {
    adminTakedown: false,
    perspectiveScoresTitle: {},
    perspectiveScoresBody: {},
    safetyXTag: void 0,
    safetyVTag: void 0,
    approvalStatus: 0,
    sexuallyExplicit: false,
    mediaIds: [],
    languageCode: ""
  };
}
var FirehoseFilterData_PostFilterData = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.PostFilterData",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.adminTakedown !== false) {
      writer.uint32(8).bool(message.adminTakedown);
    }
    Object.entries(message.perspectiveScoresTitle).forEach(([key, value]) => {
      FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.perspectiveScoresBody).forEach(([key, value]) => {
      FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.safetyXTag !== void 0) {
      FirehoseFilterData_SafetyTag.encode(message.safetyXTag, writer.uint32(34).fork()).ldelim();
    }
    if (message.safetyVTag !== void 0) {
      FirehoseFilterData_SafetyTag.encode(message.safetyVTag, writer.uint32(42).fork()).ldelim();
    }
    if (message.approvalStatus !== 0) {
      writer.uint32(48).int32(message.approvalStatus);
    }
    if (message.sexuallyExplicit !== false) {
      writer.uint32(56).bool(message.sexuallyExplicit);
    }
    for (const v of message.mediaIds) {
      writer.uint32(66).string(v);
    }
    if (message.languageCode !== "") {
      writer.uint32(74).string(message.languageCode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_PostFilterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.adminTakedown = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.perspectiveScoresTitle[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.perspectiveScoresBody[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.safetyXTag = FirehoseFilterData_SafetyTag.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.safetyVTag = FirehoseFilterData_SafetyTag.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.approvalStatus = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.sexuallyExplicit = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.mediaIds.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      adminTakedown: isSet133(object.adminTakedown) ? globalThis.Boolean(object.adminTakedown) : false,
      perspectiveScoresTitle: isObject33(object.perspectiveScoresTitle) ? Object.entries(object.perspectiveScoresTitle).reduce((acc, [key, value]) => {
        acc[key] = Number(value);
        return acc;
      }, {}) : {},
      perspectiveScoresBody: isObject33(object.perspectiveScoresBody) ? Object.entries(object.perspectiveScoresBody).reduce((acc, [key, value]) => {
        acc[key] = Number(value);
        return acc;
      }, {}) : {},
      safetyXTag: isSet133(object.safetyXTag) ? FirehoseFilterData_SafetyTag.fromJSON(object.safetyXTag) : void 0,
      safetyVTag: isSet133(object.safetyVTag) ? FirehoseFilterData_SafetyTag.fromJSON(object.safetyVTag) : void 0,
      approvalStatus: isSet133(object.approvalStatus) ? firehoseFilterData_ApprovalStatusFromJSON(object.approvalStatus) : 0,
      sexuallyExplicit: isSet133(object.sexuallyExplicit) ? globalThis.Boolean(object.sexuallyExplicit) : false,
      mediaIds: globalThis.Array.isArray(object?.mediaIds) ? object.mediaIds.map((e) => globalThis.String(e)) : [],
      languageCode: isSet133(object.languageCode) ? globalThis.String(object.languageCode) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.adminTakedown !== false) {
      obj.adminTakedown = message.adminTakedown;
    }
    if (message.perspectiveScoresTitle) {
      const entries = Object.entries(message.perspectiveScoresTitle);
      if (entries.length > 0) {
        obj.perspectiveScoresTitle = {};
        entries.forEach(([k, v]) => {
          obj.perspectiveScoresTitle[k] = v;
        });
      }
    }
    if (message.perspectiveScoresBody) {
      const entries = Object.entries(message.perspectiveScoresBody);
      if (entries.length > 0) {
        obj.perspectiveScoresBody = {};
        entries.forEach(([k, v]) => {
          obj.perspectiveScoresBody[k] = v;
        });
      }
    }
    if (message.safetyXTag !== void 0) {
      obj.safetyXTag = FirehoseFilterData_SafetyTag.toJSON(message.safetyXTag);
    }
    if (message.safetyVTag !== void 0) {
      obj.safetyVTag = FirehoseFilterData_SafetyTag.toJSON(message.safetyVTag);
    }
    if (message.approvalStatus !== 0) {
      obj.approvalStatus = firehoseFilterData_ApprovalStatusToJSON(message.approvalStatus);
    }
    if (message.sexuallyExplicit !== false) {
      obj.sexuallyExplicit = message.sexuallyExplicit;
    }
    if (message.mediaIds?.length) {
      obj.mediaIds = message.mediaIds;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_PostFilterData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_PostFilterData();
    message.adminTakedown = object.adminTakedown ?? false;
    message.perspectiveScoresTitle = Object.entries(object.perspectiveScoresTitle ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.perspectiveScoresBody = Object.entries(object.perspectiveScoresBody ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.safetyXTag = object.safetyXTag !== void 0 && object.safetyXTag !== null ? FirehoseFilterData_SafetyTag.fromPartial(object.safetyXTag) : void 0;
    message.safetyVTag = object.safetyVTag !== void 0 && object.safetyVTag !== null ? FirehoseFilterData_SafetyTag.fromPartial(object.safetyVTag) : void 0;
    message.approvalStatus = object.approvalStatus ?? 0;
    message.sexuallyExplicit = object.sexuallyExplicit ?? false;
    message.mediaIds = object.mediaIds?.map((e) => e) || [];
    message.languageCode = object.languageCode ?? "";
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_PostFilterData.$type, FirehoseFilterData_PostFilterData);
function createBaseFirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry() {
  return { key: "", value: 0 };
}
var FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.PostFilterData.PerspectiveScoresTitleEntry",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet133(object.key) ? globalThis.String(object.key) : "",
      value: isSet133(object.value) ? globalThis.Number(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry.$type, FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry);
function createBaseFirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry() {
  return { key: "", value: 0 };
}
var FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.PostFilterData.PerspectiveScoresBodyEntry",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet133(object.key) ? globalThis.String(object.key) : "",
      value: isSet133(object.value) ? globalThis.Number(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry.$type, FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry);
function createBaseFirehoseFilterData_CommentFilterData() {
  return {
    adminTakedown: false,
    abuseScore: 0,
    perspectiveScores: {},
    approvalStatus: 0,
    safetyXTag: void 0,
    safetyVTag: void 0,
    sexuallyExplicit: false,
    mediaIds: []
  };
}
var FirehoseFilterData_CommentFilterData = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.CommentFilterData",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.adminTakedown !== false) {
      writer.uint32(8).bool(message.adminTakedown);
    }
    if (message.abuseScore !== 0) {
      writer.uint32(17).double(message.abuseScore);
    }
    Object.entries(message.perspectiveScores).forEach(([key, value]) => {
      FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.approvalStatus !== 0) {
      writer.uint32(32).int32(message.approvalStatus);
    }
    if (message.safetyXTag !== void 0) {
      FirehoseFilterData_SafetyTag.encode(message.safetyXTag, writer.uint32(42).fork()).ldelim();
    }
    if (message.safetyVTag !== void 0) {
      FirehoseFilterData_SafetyTag.encode(message.safetyVTag, writer.uint32(50).fork()).ldelim();
    }
    if (message.sexuallyExplicit !== false) {
      writer.uint32(56).bool(message.sexuallyExplicit);
    }
    for (const v of message.mediaIds) {
      writer.uint32(66).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_CommentFilterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.adminTakedown = reader.bool();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.abuseScore = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          const entry3 = FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.perspectiveScores[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.approvalStatus = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.safetyXTag = FirehoseFilterData_SafetyTag.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.safetyVTag = FirehoseFilterData_SafetyTag.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.sexuallyExplicit = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.mediaIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      adminTakedown: isSet133(object.adminTakedown) ? globalThis.Boolean(object.adminTakedown) : false,
      abuseScore: isSet133(object.abuseScore) ? globalThis.Number(object.abuseScore) : 0,
      perspectiveScores: isObject33(object.perspectiveScores) ? Object.entries(object.perspectiveScores).reduce((acc, [key, value]) => {
        acc[key] = Number(value);
        return acc;
      }, {}) : {},
      approvalStatus: isSet133(object.approvalStatus) ? firehoseFilterData_ApprovalStatusFromJSON(object.approvalStatus) : 0,
      safetyXTag: isSet133(object.safetyXTag) ? FirehoseFilterData_SafetyTag.fromJSON(object.safetyXTag) : void 0,
      safetyVTag: isSet133(object.safetyVTag) ? FirehoseFilterData_SafetyTag.fromJSON(object.safetyVTag) : void 0,
      sexuallyExplicit: isSet133(object.sexuallyExplicit) ? globalThis.Boolean(object.sexuallyExplicit) : false,
      mediaIds: globalThis.Array.isArray(object?.mediaIds) ? object.mediaIds.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.adminTakedown !== false) {
      obj.adminTakedown = message.adminTakedown;
    }
    if (message.abuseScore !== 0) {
      obj.abuseScore = message.abuseScore;
    }
    if (message.perspectiveScores) {
      const entries = Object.entries(message.perspectiveScores);
      if (entries.length > 0) {
        obj.perspectiveScores = {};
        entries.forEach(([k, v]) => {
          obj.perspectiveScores[k] = v;
        });
      }
    }
    if (message.approvalStatus !== 0) {
      obj.approvalStatus = firehoseFilterData_ApprovalStatusToJSON(message.approvalStatus);
    }
    if (message.safetyXTag !== void 0) {
      obj.safetyXTag = FirehoseFilterData_SafetyTag.toJSON(message.safetyXTag);
    }
    if (message.safetyVTag !== void 0) {
      obj.safetyVTag = FirehoseFilterData_SafetyTag.toJSON(message.safetyVTag);
    }
    if (message.sexuallyExplicit !== false) {
      obj.sexuallyExplicit = message.sexuallyExplicit;
    }
    if (message.mediaIds?.length) {
      obj.mediaIds = message.mediaIds;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_CommentFilterData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_CommentFilterData();
    message.adminTakedown = object.adminTakedown ?? false;
    message.abuseScore = object.abuseScore ?? 0;
    message.perspectiveScores = Object.entries(object.perspectiveScores ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.approvalStatus = object.approvalStatus ?? 0;
    message.safetyXTag = object.safetyXTag !== void 0 && object.safetyXTag !== null ? FirehoseFilterData_SafetyTag.fromPartial(object.safetyXTag) : void 0;
    message.safetyVTag = object.safetyVTag !== void 0 && object.safetyVTag !== null ? FirehoseFilterData_SafetyTag.fromPartial(object.safetyVTag) : void 0;
    message.sexuallyExplicit = object.sexuallyExplicit ?? false;
    message.mediaIds = object.mediaIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_CommentFilterData.$type, FirehoseFilterData_CommentFilterData);
function createBaseFirehoseFilterData_CommentFilterData_PerspectiveScoresEntry() {
  return { key: "", value: 0 };
}
var FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry = {
  $type: "devvit.data.api.v1alpha.FirehoseFilterData.CommentFilterData.PerspectiveScoresEntry",
  encode(message, writer = import_minimal156.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal156.default.Reader ? input : import_minimal156.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseFilterData_CommentFilterData_PerspectiveScoresEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet133(object.key) ? globalThis.String(object.key) : "",
      value: isSet133(object.value) ? globalThis.Number(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFirehoseFilterData_CommentFilterData_PerspectiveScoresEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set(FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry.$type, FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry);
function isObject33(value) {
  return typeof value === "object" && value !== null;
}
function isSet133(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/settings/v1alpha/shared.js
var import_minimal157 = __toESM(require_minimal2(), 1);
function createBaseGetFieldsRequest() {
  return { editing: false };
}
var GetFieldsRequest = {
  $type: "devvit.actor.settings.v1alpha.GetFieldsRequest",
  encode(message, writer = import_minimal157.default.Writer.create()) {
    if (message.editing !== false) {
      writer.uint32(8).bool(message.editing);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal157.default.Reader ? input : import_minimal157.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetFieldsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.editing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { editing: isSet134(object.editing) ? globalThis.Boolean(object.editing) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.editing !== false) {
      obj.editing = message.editing;
    }
    return obj;
  },
  create(base) {
    return GetFieldsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetFieldsRequest();
    message.editing = object.editing ?? false;
    return message;
  }
};
messageTypeRegistry.set(GetFieldsRequest.$type, GetFieldsRequest);
function createBaseGetFieldsResponse() {
  return { fields: void 0 };
}
var GetFieldsResponse = {
  $type: "devvit.actor.settings.v1alpha.GetFieldsResponse",
  encode(message, writer = import_minimal157.default.Writer.create()) {
    if (message.fields !== void 0) {
      Form.encode(message.fields, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal157.default.Reader ? input : import_minimal157.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetFieldsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.fields = Form.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fields: isSet134(object.fields) ? Form.fromJSON(object.fields) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields !== void 0) {
      obj.fields = Form.toJSON(message.fields);
    }
    return obj;
  },
  create(base) {
    return GetFieldsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetFieldsResponse();
    message.fields = object.fields !== void 0 && object.fields !== null ? Form.fromPartial(object.fields) : void 0;
    return message;
  }
};
messageTypeRegistry.set(GetFieldsResponse.$type, GetFieldsResponse);
function createBaseValidateFormRequest() {
  return { editing: false, fieldValues: {} };
}
var ValidateFormRequest = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormRequest",
  encode(message, writer = import_minimal157.default.Writer.create()) {
    if (message.editing !== false) {
      writer.uint32(8).bool(message.editing);
    }
    Object.entries(message.fieldValues).forEach(([key, value]) => {
      ValidateFormRequest_FieldValuesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal157.default.Reader ? input : import_minimal157.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.editing = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = ValidateFormRequest_FieldValuesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.fieldValues[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      editing: isSet134(object.editing) ? globalThis.Boolean(object.editing) : false,
      fieldValues: isObject34(object.fieldValues) ? Object.entries(object.fieldValues).reduce((acc, [key, value]) => {
        acc[key] = FormFieldValue.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.editing !== false) {
      obj.editing = message.editing;
    }
    if (message.fieldValues) {
      const entries = Object.entries(message.fieldValues);
      if (entries.length > 0) {
        obj.fieldValues = {};
        entries.forEach(([k, v]) => {
          obj.fieldValues[k] = FormFieldValue.toJSON(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return ValidateFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateFormRequest();
    message.editing = object.editing ?? false;
    message.fieldValues = Object.entries(object.fieldValues ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FormFieldValue.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ValidateFormRequest.$type, ValidateFormRequest);
function createBaseValidateFormRequest_FieldValuesEntry() {
  return { key: "", value: void 0 };
}
var ValidateFormRequest_FieldValuesEntry = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormRequest.FieldValuesEntry",
  encode(message, writer = import_minimal157.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FormFieldValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal157.default.Reader ? input : import_minimal157.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormRequest_FieldValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = FormFieldValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet134(object.key) ? globalThis.String(object.key) : "",
      value: isSet134(object.value) ? FormFieldValue.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = FormFieldValue.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return ValidateFormRequest_FieldValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateFormRequest_FieldValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FormFieldValue.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set(ValidateFormRequest_FieldValuesEntry.$type, ValidateFormRequest_FieldValuesEntry);
function createBaseValidateFormResponse() {
  return { success: false, errors: {} };
}
var ValidateFormResponse = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormResponse",
  encode(message, writer = import_minimal157.default.Writer.create()) {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      ValidateFormResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal157.default.Reader ? input : import_minimal157.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          const entry2 = ValidateFormResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet134(object.success) ? globalThis.Boolean(object.success) : false,
      errors: isObject34(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errors) {
      const entries = Object.entries(message.errors);
      if (entries.length > 0) {
        obj.errors = {};
        entries.forEach(([k, v]) => {
          obj.errors[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return ValidateFormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateFormResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set(ValidateFormResponse.$type, ValidateFormResponse);
function createBaseValidateFormResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var ValidateFormResponse_ErrorsEntry = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormResponse.ErrorsEntry",
  encode(message, writer = import_minimal157.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal157.default.Reader ? input : import_minimal157.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet134(object.key) ? globalThis.String(object.key) : "",
      value: isSet134(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ValidateFormResponse_ErrorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValidateFormResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set(ValidateFormResponse_ErrorsEntry.$type, ValidateFormResponse_ErrorsEntry);
function isObject34(value) {
  return typeof value === "object" && value !== null;
}
function isSet134(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/settings/v1alpha/instance_settings.js
var import_minimal158 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/settings/v1alpha/installation_settings.js
var import_minimal159 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/settings/v1alpha/app_settings.js
var import_minimal160 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/automation/v2alpha/automation_ui_builder.js
var import_minimal164 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation.js
var import_minimal163 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/automation/v1alpha/step.js
var import_minimal161 = __toESM(require_minimal2(), 1);
function createBaseStepDescription() {
  return { actor: "", config: void 0 };
}
var StepDescription = {
  $type: "devvit.actor.automation.v1alpha.StepDescription",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.config !== void 0) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet135(object.actor) ? globalThis.String(object.actor) : "",
      config: isObject35(object.config) ? object.config : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.config !== void 0) {
      obj.config = message.config;
    }
    return obj;
  },
  create(base) {
    return StepDescription.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepDescription();
    message.actor = object.actor ?? "";
    message.config = object.config ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(StepDescription.$type, StepDescription);
function createBaseStepInput() {
  return { config: void 0, prev: void 0 };
}
var StepInput = {
  $type: "devvit.actor.automation.v1alpha.StepInput",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.config !== void 0) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(10).fork()).ldelim();
    }
    if (message.prev !== void 0) {
      Struct.encode(Struct.wrap(message.prev), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.prev = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      config: isObject35(object.config) ? object.config : void 0,
      prev: isObject35(object.prev) ? object.prev : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.config !== void 0) {
      obj.config = message.config;
    }
    if (message.prev !== void 0) {
      obj.prev = message.prev;
    }
    return obj;
  },
  create(base) {
    return StepInput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepInput();
    message.config = object.config ?? void 0;
    message.prev = object.prev ?? void 0;
    return message;
  }
};
messageTypeRegistry.set(StepInput.$type, StepInput);
function createBaseStepCommentInput() {
  return { input: void 0, comment: void 0 };
}
var StepCommentInput = {
  $type: "devvit.actor.automation.v1alpha.StepCommentInput",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.input !== void 0) {
      StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepCommentInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.input = StepInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.comment = Comment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet135(object.input) ? StepInput.fromJSON(object.input) : void 0,
      comment: isSet135(object.comment) ? Comment.fromJSON(object.comment) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.input !== void 0) {
      obj.input = StepInput.toJSON(message.input);
    }
    if (message.comment !== void 0) {
      obj.comment = Comment.toJSON(message.comment);
    }
    return obj;
  },
  create(base) {
    return StepCommentInput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepCommentInput();
    message.input = object.input !== void 0 && object.input !== null ? StepInput.fromPartial(object.input) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? Comment.fromPartial(object.comment) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StepCommentInput.$type, StepCommentInput);
function createBaseStepPostInput() {
  return { input: void 0, post: void 0 };
}
var StepPostInput = {
  $type: "devvit.actor.automation.v1alpha.StepPostInput",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.input !== void 0) {
      StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
    }
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepPostInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.input = StepInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.post = Post.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet135(object.input) ? StepInput.fromJSON(object.input) : void 0,
      post: isSet135(object.post) ? Post.fromJSON(object.post) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.input !== void 0) {
      obj.input = StepInput.toJSON(message.input);
    }
    if (message.post !== void 0) {
      obj.post = Post.toJSON(message.post);
    }
    return obj;
  },
  create(base) {
    return StepPostInput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepPostInput();
    message.input = object.input !== void 0 && object.input !== null ? StepInput.fromPartial(object.input) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StepPostInput.$type, StepPostInput);
function createBaseStepUserInput() {
  return { input: void 0, user: void 0 };
}
var StepUserInput = {
  $type: "devvit.actor.automation.v1alpha.StepUserInput",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.input !== void 0) {
      StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
    }
    if (message.user !== void 0) {
      User.encode(message.user, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepUserInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.input = StepInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet135(object.input) ? StepInput.fromJSON(object.input) : void 0,
      user: isSet135(object.user) ? User.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.input !== void 0) {
      obj.input = StepInput.toJSON(message.input);
    }
    if (message.user !== void 0) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },
  create(base) {
    return StepUserInput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepUserInput();
    message.input = object.input !== void 0 && object.input !== null ? StepInput.fromPartial(object.input) : void 0;
    message.user = object.user !== void 0 && object.user !== null ? User.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StepUserInput.$type, StepUserInput);
function createBaseStepResult() {
  return { output: void 0, stop: false };
}
var StepResult = {
  $type: "devvit.actor.automation.v1alpha.StepResult",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.output !== void 0) {
      Struct.encode(Struct.wrap(message.output), writer.uint32(10).fork()).ldelim();
    }
    if (message.stop !== false) {
      writer.uint32(16).bool(message.stop);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.output = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.stop = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      output: isObject35(object.output) ? object.output : void 0,
      stop: isSet135(object.stop) ? globalThis.Boolean(object.stop) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.output !== void 0) {
      obj.output = message.output;
    }
    if (message.stop !== false) {
      obj.stop = message.stop;
    }
    return obj;
  },
  create(base) {
    return StepResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepResult();
    message.output = object.output ?? void 0;
    message.stop = object.stop ?? false;
    return message;
  }
};
messageTypeRegistry.set(StepResult.$type, StepResult);
function createBaseStepReport() {
  return { actor: "", message: "", duration: 0, success: false, data: void 0 };
}
var StepReport = {
  $type: "devvit.actor.automation.v1alpha.StepReport",
  encode(message, writer = import_minimal161.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.duration !== 0) {
      writer.uint32(29).float(message.duration);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    if (message.data !== void 0) {
      StepResult.encode(message.data, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal161.default.Reader ? input : import_minimal161.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }
          message.duration = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.success = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.data = StepResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet135(object.actor) ? globalThis.String(object.actor) : "",
      message: isSet135(object.message) ? globalThis.String(object.message) : "",
      duration: isSet135(object.duration) ? globalThis.Number(object.duration) : 0,
      success: isSet135(object.success) ? globalThis.Boolean(object.success) : false,
      data: isSet135(object.data) ? StepResult.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.data !== void 0) {
      obj.data = StepResult.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return StepReport.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepReport();
    message.actor = object.actor ?? "";
    message.message = object.message ?? "";
    message.duration = object.duration ?? 0;
    message.success = object.success ?? false;
    message.data = object.data !== void 0 && object.data !== null ? StepResult.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set(StepReport.$type, StepReport);
function isObject35(value) {
  return typeof value === "object" && value !== null;
}
function isSet135(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/trigger.js
var import_minimal162 = __toESM(require_minimal2(), 1);
var TriggerType;
(function(TriggerType2) {
  TriggerType2[TriggerType2["POST"] = 0] = "POST";
  TriggerType2[TriggerType2["COMMENT"] = 1] = "COMMENT";
  TriggerType2[TriggerType2["USER"] = 2] = "USER";
  TriggerType2[TriggerType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TriggerType || (TriggerType = {}));
function triggerTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "POST":
      return TriggerType.POST;
    case 1:
    case "COMMENT":
      return TriggerType.COMMENT;
    case 2:
    case "USER":
      return TriggerType.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TriggerType.UNRECOGNIZED;
  }
}
function triggerTypeToJSON(object) {
  switch (object) {
    case TriggerType.POST:
      return 0;
    case TriggerType.COMMENT:
      return 1;
    case TriggerType.USER:
      return 2;
    case TriggerType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseTrigger() {
  return { id: "", name: "", label: "", type: 0 };
}
var Trigger = {
  $type: "devvit.actor.automation.v1alpha.Trigger",
  encode(message, writer = import_minimal162.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal162.default.Reader ? input : import_minimal162.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet136(object.id) ? globalThis.String(object.id) : "",
      name: isSet136(object.name) ? globalThis.String(object.name) : "",
      label: isSet136(object.label) ? globalThis.String(object.label) : "",
      type: isSet136(object.type) ? triggerTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.type !== 0) {
      obj.type = triggerTypeToJSON(message.type);
    }
    return obj;
  },
  create(base) {
    return Trigger.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTrigger();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set(Trigger.$type, Trigger);
function isSet136(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation.js
var AutomationStatus;
(function(AutomationStatus2) {
  AutomationStatus2[AutomationStatus2["INSTALLED"] = 0] = "INSTALLED";
  AutomationStatus2[AutomationStatus2["ENABLED"] = 1] = "ENABLED";
  AutomationStatus2[AutomationStatus2["DISABLED"] = 2] = "DISABLED";
  AutomationStatus2[AutomationStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationStatus || (AutomationStatus = {}));
function automationStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "INSTALLED":
      return AutomationStatus.INSTALLED;
    case 1:
    case "ENABLED":
      return AutomationStatus.ENABLED;
    case 2:
    case "DISABLED":
      return AutomationStatus.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationStatus.UNRECOGNIZED;
  }
}
function automationStatusToJSON(object) {
  switch (object) {
    case AutomationStatus.INSTALLED:
      return 0;
    case AutomationStatus.ENABLED:
      return 1;
    case AutomationStatus.DISABLED:
      return 2;
    case AutomationStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
var AutomationVisibility;
(function(AutomationVisibility2) {
  AutomationVisibility2[AutomationVisibility2["PRIVATE"] = 0] = "PRIVATE";
  AutomationVisibility2[AutomationVisibility2["PUBLIC"] = 1] = "PUBLIC";
  AutomationVisibility2[AutomationVisibility2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationVisibility || (AutomationVisibility = {}));
function automationVisibilityFromJSON(object) {
  switch (object) {
    case 0:
    case "PRIVATE":
      return AutomationVisibility.PRIVATE;
    case 1:
    case "PUBLIC":
      return AutomationVisibility.PUBLIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationVisibility.UNRECOGNIZED;
  }
}
function automationVisibilityToJSON(object) {
  switch (object) {
    case AutomationVisibility.PRIVATE:
      return 0;
    case AutomationVisibility.PUBLIC:
      return 1;
    case AutomationVisibility.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAutomation() {
  return { id: "", name: "", description: "", status: 0, visibility: 0, trigger: void 0, steps: [] };
}
var Automation = {
  $type: "devvit.actor.automation.v1alpha.Automation",
  encode(message, writer = import_minimal163.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.visibility !== 0) {
      writer.uint32(40).int32(message.visibility);
    }
    if (message.trigger !== void 0) {
      Trigger.encode(message.trigger, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.steps) {
      StepDescription.encode(v, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal163.default.Reader ? input : import_minimal163.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.status = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.visibility = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.trigger = Trigger.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.steps.push(StepDescription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet137(object.id) ? globalThis.String(object.id) : "",
      name: isSet137(object.name) ? globalThis.String(object.name) : "",
      description: isSet137(object.description) ? globalThis.String(object.description) : "",
      status: isSet137(object.status) ? automationStatusFromJSON(object.status) : 0,
      visibility: isSet137(object.visibility) ? automationVisibilityFromJSON(object.visibility) : 0,
      trigger: isSet137(object.trigger) ? Trigger.fromJSON(object.trigger) : void 0,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e) => StepDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.status !== 0) {
      obj.status = automationStatusToJSON(message.status);
    }
    if (message.visibility !== 0) {
      obj.visibility = automationVisibilityToJSON(message.visibility);
    }
    if (message.trigger !== void 0) {
      obj.trigger = Trigger.toJSON(message.trigger);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => StepDescription.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Automation.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomation();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.status = object.status ?? 0;
    message.visibility = object.visibility ?? 0;
    message.trigger = object.trigger !== void 0 && object.trigger !== null ? Trigger.fromPartial(object.trigger) : void 0;
    message.steps = object.steps?.map((e) => StepDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(Automation.$type, Automation);
function createBaseAutomationResult() {
  return { id: "", steps: [] };
}
var AutomationResult = {
  $type: "devvit.actor.automation.v1alpha.AutomationResult",
  encode(message, writer = import_minimal163.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.steps) {
      StepReport.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal163.default.Reader ? input : import_minimal163.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.steps.push(StepReport.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet137(object.id) ? globalThis.String(object.id) : "",
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e) => StepReport.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => StepReport.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AutomationResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationResult();
    message.id = object.id ?? "";
    message.steps = object.steps?.map((e) => StepReport.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(AutomationResult.$type, AutomationResult);
function createBaseAutomationInvocation() {
  return { id: "", automation: void 0, comment: void 0, post: void 0, user: void 0, subreddit: void 0 };
}
var AutomationInvocation = {
  $type: "devvit.actor.automation.v1alpha.AutomationInvocation",
  encode(message, writer = import_minimal163.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(18).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      Comment.encode(message.comment, writer.uint32(26).fork()).ldelim();
    }
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== void 0) {
      User.encode(message.user, writer.uint32(42).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      Subreddit.encode(message.subreddit, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal163.default.Reader ? input : import_minimal163.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.automation = Automation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.comment = Comment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.post = Post.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.user = User.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.subreddit = Subreddit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet137(object.id) ? globalThis.String(object.id) : "",
      automation: isSet137(object.automation) ? Automation.fromJSON(object.automation) : void 0,
      comment: isSet137(object.comment) ? Comment.fromJSON(object.comment) : void 0,
      post: isSet137(object.post) ? Post.fromJSON(object.post) : void 0,
      user: isSet137(object.user) ? User.fromJSON(object.user) : void 0,
      subreddit: isSet137(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.automation !== void 0) {
      obj.automation = Automation.toJSON(message.automation);
    }
    if (message.comment !== void 0) {
      obj.comment = Comment.toJSON(message.comment);
    }
    if (message.post !== void 0) {
      obj.post = Post.toJSON(message.post);
    }
    if (message.user !== void 0) {
      obj.user = User.toJSON(message.user);
    }
    if (message.subreddit !== void 0) {
      obj.subreddit = Subreddit.toJSON(message.subreddit);
    }
    return obj;
  },
  create(base) {
    return AutomationInvocation.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationInvocation();
    message.id = object.id ?? "";
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? Comment.fromPartial(object.comment) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    message.user = object.user !== void 0 && object.user !== null ? User.fromPartial(object.user) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? Subreddit.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AutomationInvocation.$type, AutomationInvocation);
function isSet137(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v2alpha/automation_ui_builder.js
var AutomationUIBuilderStepType;
(function(AutomationUIBuilderStepType2) {
  AutomationUIBuilderStepType2[AutomationUIBuilderStepType2["ACTION"] = 0] = "ACTION";
  AutomationUIBuilderStepType2[AutomationUIBuilderStepType2["FILTER"] = 1] = "FILTER";
  AutomationUIBuilderStepType2[AutomationUIBuilderStepType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationUIBuilderStepType || (AutomationUIBuilderStepType = {}));
function automationUIBuilderStepTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTION":
      return AutomationUIBuilderStepType.ACTION;
    case 1:
    case "FILTER":
      return AutomationUIBuilderStepType.FILTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationUIBuilderStepType.UNRECOGNIZED;
  }
}
function automationUIBuilderStepTypeToJSON(object) {
  switch (object) {
    case AutomationUIBuilderStepType.ACTION:
      return 0;
    case AutomationUIBuilderStepType.FILTER:
      return 1;
    case AutomationUIBuilderStepType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAutomationUIBuilderListTriggersRequest() {
  return {};
}
var AutomationUIBuilderListTriggersRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListTriggersRequest",
  encode(_, writer = import_minimal164.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListTriggersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return AutomationUIBuilderListTriggersRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseAutomationUIBuilderListTriggersRequest();
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderListTriggersRequest.$type, AutomationUIBuilderListTriggersRequest);
function createBaseAutomationUIBuilderListTriggersResponse() {
  return { triggers: [] };
}
var AutomationUIBuilderListTriggersResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListTriggersResponse",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    for (const v of message.triggers) {
      Trigger.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListTriggersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.triggers.push(Trigger.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      triggers: globalThis.Array.isArray(object?.triggers) ? object.triggers.map((e) => Trigger.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => Trigger.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderListTriggersResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListTriggersResponse();
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderListTriggersResponse.$type, AutomationUIBuilderListTriggersResponse);
function createBaseAutomationUIBuilderListStepsRequest() {
  return { location: "", triggerType: 0, stepType: 0 };
}
var AutomationUIBuilderListStepsRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListStepsRequest",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.triggerType !== 0) {
      writer.uint32(16).int32(message.triggerType);
    }
    if (message.stepType !== 0) {
      writer.uint32(24).int32(message.stepType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListStepsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.location = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.triggerType = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.stepType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: isSet138(object.location) ? globalThis.String(object.location) : "",
      triggerType: isSet138(object.triggerType) ? triggerTypeFromJSON(object.triggerType) : 0,
      stepType: isSet138(object.stepType) ? automationUIBuilderStepTypeFromJSON(object.stepType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.triggerType !== 0) {
      obj.triggerType = triggerTypeToJSON(message.triggerType);
    }
    if (message.stepType !== 0) {
      obj.stepType = automationUIBuilderStepTypeToJSON(message.stepType);
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderListStepsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListStepsRequest();
    message.location = object.location ?? "";
    message.triggerType = object.triggerType ?? 0;
    message.stepType = object.stepType ?? 0;
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderListStepsRequest.$type, AutomationUIBuilderListStepsRequest);
function createBaseAutomationUIBuilderStepActor() {
  return { actor: "", label: "", description: "", type: 0 };
}
var AutomationUIBuilderStepActor = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderStepActor",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderStepActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet138(object.actor) ? globalThis.String(object.actor) : "",
      label: isSet138(object.label) ? globalThis.String(object.label) : "",
      description: isSet138(object.description) ? globalThis.String(object.description) : "",
      type: isSet138(object.type) ? automationUIBuilderStepTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = automationUIBuilderStepTypeToJSON(message.type);
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderStepActor.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderStepActor();
    message.actor = object.actor ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderStepActor.$type, AutomationUIBuilderStepActor);
function createBaseAutomationUIBuilderListStepsResponse() {
  return { steps: [] };
}
var AutomationUIBuilderListStepsResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListStepsResponse",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    for (const v of message.steps) {
      AutomationUIBuilderStepActor.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListStepsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.steps.push(AutomationUIBuilderStepActor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e) => AutomationUIBuilderStepActor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => AutomationUIBuilderStepActor.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderListStepsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListStepsResponse();
    message.steps = object.steps?.map((e) => AutomationUIBuilderStepActor.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderListStepsResponse.$type, AutomationUIBuilderListStepsResponse);
function createBaseAutomationUIBuilderListAutomationsRequest() {
  return { location: "" };
}
var AutomationUIBuilderListAutomationsRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListAutomationsRequest",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListAutomationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { location: isSet138(object.location) ? globalThis.String(object.location) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderListAutomationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListAutomationsRequest();
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderListAutomationsRequest.$type, AutomationUIBuilderListAutomationsRequest);
function createBaseAutomationUIBuilderListAutomationsResponse() {
  return { automations: [] };
}
var AutomationUIBuilderListAutomationsResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListAutomationsResponse",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    for (const v of message.automations) {
      Automation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListAutomationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.automations.push(Automation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      automations: globalThis.Array.isArray(object?.automations) ? object.automations.map((e) => Automation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.automations?.length) {
      obj.automations = message.automations.map((e) => Automation.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderListAutomationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListAutomationsResponse();
    message.automations = object.automations?.map((e) => Automation.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderListAutomationsResponse.$type, AutomationUIBuilderListAutomationsResponse);
function createBaseAutomationUIBuilderGetAutomationRequest() {
  return { id: "" };
}
var AutomationUIBuilderGetAutomationRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetAutomationRequest",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet138(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderGetAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetAutomationRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderGetAutomationRequest.$type, AutomationUIBuilderGetAutomationRequest);
function createBaseAutomationUIBuilderGetAutomationResponse() {
  return { automation: void 0 };
}
var AutomationUIBuilderGetAutomationResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetAutomationResponse",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetAutomationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.automation = Automation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { automation: isSet138(object.automation) ? Automation.fromJSON(object.automation) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.automation !== void 0) {
      obj.automation = Automation.toJSON(message.automation);
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderGetAutomationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetAutomationResponse();
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderGetAutomationResponse.$type, AutomationUIBuilderGetAutomationResponse);
function createBaseAutomationUIBuilderGetStepFormRequest() {
  return { actor: "" };
}
var AutomationUIBuilderGetStepFormRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetStepFormRequest",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetStepFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { actor: isSet138(object.actor) ? globalThis.String(object.actor) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderGetStepFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetStepFormRequest();
    message.actor = object.actor ?? "";
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderGetStepFormRequest.$type, AutomationUIBuilderGetStepFormRequest);
function createBaseAutomationUIBuilderGetStepFormResponse() {
  return { form: void 0 };
}
var AutomationUIBuilderGetStepFormResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetStepFormResponse",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.form !== void 0) {
      Form.encode(message.form, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetStepFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.form = Form.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { form: isSet138(object.form) ? Form.fromJSON(object.form) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.form !== void 0) {
      obj.form = Form.toJSON(message.form);
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderGetStepFormResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetStepFormResponse();
    message.form = object.form !== void 0 && object.form !== null ? Form.fromPartial(object.form) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderGetStepFormResponse.$type, AutomationUIBuilderGetStepFormResponse);
function createBaseAutomationUIBuilderUpdateAutomationRequest() {
  return { id: "", automation: void 0 };
}
var AutomationUIBuilderUpdateAutomationRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderUpdateAutomationRequest",
  encode(message, writer = import_minimal164.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderUpdateAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.automation = Automation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet138(object.id) ? globalThis.String(object.id) : "",
      automation: isSet138(object.automation) ? Automation.fromJSON(object.automation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.automation !== void 0) {
      obj.automation = Automation.toJSON(message.automation);
    }
    return obj;
  },
  create(base) {
    return AutomationUIBuilderUpdateAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderUpdateAutomationRequest();
    message.id = object.id ?? "";
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderUpdateAutomationRequest.$type, AutomationUIBuilderUpdateAutomationRequest);
function createBaseAutomationUIBuilderUpdateAutomationResponse() {
  return {};
}
var AutomationUIBuilderUpdateAutomationResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderUpdateAutomationResponse",
  encode(_, writer = import_minimal164.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal164.default.Reader ? input : import_minimal164.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderUpdateAutomationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return AutomationUIBuilderUpdateAutomationResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseAutomationUIBuilderUpdateAutomationResponse();
    return message;
  }
};
messageTypeRegistry.set(AutomationUIBuilderUpdateAutomationResponse.$type, AutomationUIBuilderUpdateAutomationResponse);
function isSet138(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/event_handlers.js
var import_minimal165 = __toESM(require_minimal2(), 1);
function createBaseHandlerResult() {
  return {};
}
var HandlerResult = {
  $type: "devvit.actor.automation.v1alpha.HandlerResult",
  encode(_, writer = import_minimal165.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal165.default.Reader ? input : import_minimal165.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHandlerResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return HandlerResult.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseHandlerResult();
    return message;
  }
};
messageTypeRegistry.set(HandlerResult.$type, HandlerResult);

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation_builder.js
var import_minimal166 = __toESM(require_minimal2(), 1);
var StepType;
(function(StepType2) {
  StepType2[StepType2["ACTION"] = 0] = "ACTION";
  StepType2[StepType2["FILTER"] = 1] = "FILTER";
  StepType2[StepType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StepType || (StepType = {}));
function stepTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTION":
      return StepType.ACTION;
    case 1:
    case "FILTER":
      return StepType.FILTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StepType.UNRECOGNIZED;
  }
}
function stepTypeToJSON(object) {
  switch (object) {
    case StepType.ACTION:
      return 0;
    case StepType.FILTER:
      return 1;
    case StepType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseGetTriggersRequest() {
  return {};
}
var GetTriggersRequest = {
  $type: "devvit.actor.automation.v1alpha.GetTriggersRequest",
  encode(_, writer = import_minimal166.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetTriggersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetTriggersRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetTriggersRequest();
    return message;
  }
};
messageTypeRegistry.set(GetTriggersRequest.$type, GetTriggersRequest);
function createBaseListStepsRequest() {
  return { location: "", triggerType: 0, stepType: 0 };
}
var ListStepsRequest = {
  $type: "devvit.actor.automation.v1alpha.ListStepsRequest",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.triggerType !== 0) {
      writer.uint32(16).int32(message.triggerType);
    }
    if (message.stepType !== 0) {
      writer.uint32(24).int32(message.stepType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListStepsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.location = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.triggerType = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.stepType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: isSet139(object.location) ? globalThis.String(object.location) : "",
      triggerType: isSet139(object.triggerType) ? triggerTypeFromJSON(object.triggerType) : 0,
      stepType: isSet139(object.stepType) ? stepTypeFromJSON(object.stepType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.triggerType !== 0) {
      obj.triggerType = triggerTypeToJSON(message.triggerType);
    }
    if (message.stepType !== 0) {
      obj.stepType = stepTypeToJSON(message.stepType);
    }
    return obj;
  },
  create(base) {
    return ListStepsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListStepsRequest();
    message.location = object.location ?? "";
    message.triggerType = object.triggerType ?? 0;
    message.stepType = object.stepType ?? 0;
    return message;
  }
};
messageTypeRegistry.set(ListStepsRequest.$type, ListStepsRequest);
function createBaseListAutomationRequest() {
  return { location: "" };
}
var ListAutomationRequest = {
  $type: "devvit.actor.automation.v1alpha.ListAutomationRequest",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { location: isSet139(object.location) ? globalThis.String(object.location) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },
  create(base) {
    return ListAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListAutomationRequest();
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set(ListAutomationRequest.$type, ListAutomationRequest);
function createBaseStepActor() {
  return { actor: "", label: "", description: "", type: 0 };
}
var StepActor = {
  $type: "devvit.actor.automation.v1alpha.StepActor",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet139(object.actor) ? globalThis.String(object.actor) : "",
      label: isSet139(object.label) ? globalThis.String(object.label) : "",
      description: isSet139(object.description) ? globalThis.String(object.description) : "",
      type: isSet139(object.type) ? stepTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = stepTypeToJSON(message.type);
    }
    return obj;
  },
  create(base) {
    return StepActor.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStepActor();
    message.actor = object.actor ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set(StepActor.$type, StepActor);
function createBaseActorList() {
  return { actors: [] };
}
var ActorList = {
  $type: "devvit.actor.automation.v1alpha.ActorList",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    for (const v of message.actors) {
      StepActor.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActorList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actors.push(StepActor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      actors: globalThis.Array.isArray(object?.actors) ? object.actors.map((e) => StepActor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actors?.length) {
      obj.actors = message.actors.map((e) => StepActor.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ActorList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseActorList();
    message.actors = object.actors?.map((e) => StepActor.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(ActorList.$type, ActorList);
function createBaseAutomationList() {
  return { automations: [] };
}
var AutomationList = {
  $type: "devvit.actor.automation.v1alpha.AutomationList",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    for (const v of message.automations) {
      Automation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.automations.push(Automation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      automations: globalThis.Array.isArray(object?.automations) ? object.automations.map((e) => Automation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.automations?.length) {
      obj.automations = message.automations.map((e) => Automation.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AutomationList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutomationList();
    message.automations = object.automations?.map((e) => Automation.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(AutomationList.$type, AutomationList);
function createBaseTriggerList() {
  return { triggers: [] };
}
var TriggerList = {
  $type: "devvit.actor.automation.v1alpha.TriggerList",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    for (const v of message.triggers) {
      Trigger.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.triggers.push(Trigger.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      triggers: globalThis.Array.isArray(object?.triggers) ? object.triggers.map((e) => Trigger.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => Trigger.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return TriggerList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTriggerList();
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set(TriggerList.$type, TriggerList);
function createBaseUpdateAutomationRequest() {
  return { automation: void 0, location: "" };
}
var UpdateAutomationRequest = {
  $type: "devvit.actor.automation.v1alpha.UpdateAutomationRequest",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(10).fork()).ldelim();
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.automation = Automation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      automation: isSet139(object.automation) ? Automation.fromJSON(object.automation) : void 0,
      location: isSet139(object.location) ? globalThis.String(object.location) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.automation !== void 0) {
      obj.automation = Automation.toJSON(message.automation);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },
  create(base) {
    return UpdateAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateAutomationRequest();
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set(UpdateAutomationRequest.$type, UpdateAutomationRequest);
function createBaseGetStepFormRequest() {
  return { actor: "" };
}
var GetStepFormRequest = {
  $type: "devvit.actor.automation.v1alpha.GetStepFormRequest",
  encode(message, writer = import_minimal166.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal166.default.Reader ? input : import_minimal166.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetStepFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.actor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { actor: isSet139(object.actor) ? globalThis.String(object.actor) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    return obj;
  },
  create(base) {
    return GetStepFormRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetStepFormRequest();
    message.actor = object.actor ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetStepFormRequest.$type, GetStepFormRequest);
function isSet139(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/internal/authorization/v1alpha/authorization.js
var import_minimal167 = __toESM(require_minimal2(), 1);
function createBaseDevPortalAuthInstalledAppResource() {
  return { app: void 0, location: void 0 };
}
var DevPortalAuthInstalledAppResource = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthInstalledAppResource",
  encode(message, writer = import_minimal167.default.Writer.create()) {
    if (message.app !== void 0) {
      DevPortalAuthAppVersionResource.encode(message.app, writer.uint32(10).fork()).ldelim();
    }
    if (message.location !== void 0) {
      DevPortalAuthLocationResource.encode(message.location, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal167.default.Reader ? input : import_minimal167.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthInstalledAppResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.app = DevPortalAuthAppVersionResource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.location = DevPortalAuthLocationResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      app: isSet140(object.app) ? DevPortalAuthAppVersionResource.fromJSON(object.app) : void 0,
      location: isSet140(object.location) ? DevPortalAuthLocationResource.fromJSON(object.location) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.app !== void 0) {
      obj.app = DevPortalAuthAppVersionResource.toJSON(message.app);
    }
    if (message.location !== void 0) {
      obj.location = DevPortalAuthLocationResource.toJSON(message.location);
    }
    return obj;
  },
  create(base) {
    return DevPortalAuthInstalledAppResource.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthInstalledAppResource();
    message.app = object.app !== void 0 && object.app !== null ? DevPortalAuthAppVersionResource.fromPartial(object.app) : void 0;
    message.location = object.location !== void 0 && object.location !== null ? DevPortalAuthLocationResource.fromPartial(object.location) : void 0;
    return message;
  }
};
messageTypeRegistry.set(DevPortalAuthInstalledAppResource.$type, DevPortalAuthInstalledAppResource);
function createBaseDevPortalAuthAppVersionResource() {
  return { name: "", version: "" };
}
var DevPortalAuthAppVersionResource = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthAppVersionResource",
  encode(message, writer = import_minimal167.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal167.default.Reader ? input : import_minimal167.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthAppVersionResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet140(object.name) ? globalThis.String(object.name) : "",
      version: isSet140(object.version) ? globalThis.String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },
  create(base) {
    return DevPortalAuthAppVersionResource.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthAppVersionResource();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set(DevPortalAuthAppVersionResource.$type, DevPortalAuthAppVersionResource);
function createBaseDevPortalAuthLocationResource() {
  return { id: "" };
}
var DevPortalAuthLocationResource = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthLocationResource",
  encode(message, writer = import_minimal167.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal167.default.Reader ? input : import_minimal167.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthLocationResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet140(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return DevPortalAuthLocationResource.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthLocationResource();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(DevPortalAuthLocationResource.$type, DevPortalAuthLocationResource);
function createBaseDevPortalAuthCanViewLogsRequest() {
  return { userId: "", id: void 0, app: void 0, type: 0 };
}
var DevPortalAuthCanViewLogsRequest = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthCanViewLogsRequest",
  encode(message, writer = import_minimal167.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.id !== void 0) {
      writer.uint32(18).string(message.id);
    }
    if (message.app !== void 0) {
      DevPortalAuthInstalledAppResource.encode(message.app, writer.uint32(26).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal167.default.Reader ? input : import_minimal167.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthCanViewLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.app = DevPortalAuthInstalledAppResource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet140(object.userId) ? globalThis.String(object.userId) : "",
      id: isSet140(object.id) ? globalThis.String(object.id) : void 0,
      app: isSet140(object.app) ? DevPortalAuthInstalledAppResource.fromJSON(object.app) : void 0,
      type: isSet140(object.type) ? remoteLogTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.app !== void 0) {
      obj.app = DevPortalAuthInstalledAppResource.toJSON(message.app);
    }
    if (message.type !== 0) {
      obj.type = remoteLogTypeToJSON(message.type);
    }
    return obj;
  },
  create(base) {
    return DevPortalAuthCanViewLogsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthCanViewLogsRequest();
    message.userId = object.userId ?? "";
    message.id = object.id ?? void 0;
    message.app = object.app !== void 0 && object.app !== null ? DevPortalAuthInstalledAppResource.fromPartial(object.app) : void 0;
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set(DevPortalAuthCanViewLogsRequest.$type, DevPortalAuthCanViewLogsRequest);
function createBaseDevPortalAuthorizationResponse() {
  return { allowed: false, reason: "" };
}
var DevPortalAuthorizationResponse = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthorizationResponse",
  encode(message, writer = import_minimal167.default.Writer.create()) {
    if (message.allowed !== false) {
      writer.uint32(8).bool(message.allowed);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal167.default.Reader ? input : import_minimal167.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthorizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.allowed = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowed: isSet140(object.allowed) ? globalThis.Boolean(object.allowed) : false,
      reason: isSet140(object.reason) ? globalThis.String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allowed !== false) {
      obj.allowed = message.allowed;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return DevPortalAuthorizationResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthorizationResponse();
    message.allowed = object.allowed ?? false;
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set(DevPortalAuthorizationResponse.$type, DevPortalAuthorizationResponse);
function isSet140(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/internal/data_api/v1alpha/admin/firehose_monitor.js
var import_minimal168 = __toESM(require_minimal2(), 1);
function createBaseCreateFirehoseMonitorDataTokenRequest() {
  return { expiresIn: void 0 };
}
var CreateFirehoseMonitorDataTokenRequest = {
  $type: "devvit.dev_portal.internal.data_api.v1alpha.admin.CreateFirehoseMonitorDataTokenRequest",
  encode(message, writer = import_minimal168.default.Writer.create()) {
    if (message.expiresIn !== void 0) {
      Duration.encode(message.expiresIn, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal168.default.Reader ? input : import_minimal168.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateFirehoseMonitorDataTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.expiresIn = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { expiresIn: isSet141(object.expiresIn) ? Duration.fromJSON(object.expiresIn) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.expiresIn !== void 0) {
      obj.expiresIn = Duration.toJSON(message.expiresIn);
    }
    return obj;
  },
  create(base) {
    return CreateFirehoseMonitorDataTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateFirehoseMonitorDataTokenRequest();
    message.expiresIn = object.expiresIn !== void 0 && object.expiresIn !== null ? Duration.fromPartial(object.expiresIn) : void 0;
    return message;
  }
};
messageTypeRegistry.set(CreateFirehoseMonitorDataTokenRequest.$type, CreateFirehoseMonitorDataTokenRequest);
function createBaseGetFirehoseMonitorSubscriptionByNameRequest() {
  return { name: "" };
}
var GetFirehoseMonitorSubscriptionByNameRequest = {
  $type: "devvit.dev_portal.internal.data_api.v1alpha.admin.GetFirehoseMonitorSubscriptionByNameRequest",
  encode(message, writer = import_minimal168.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal168.default.Reader ? input : import_minimal168.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetFirehoseMonitorSubscriptionByNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet141(object.name) ? globalThis.String(object.name) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return GetFirehoseMonitorSubscriptionByNameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetFirehoseMonitorSubscriptionByNameRequest();
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetFirehoseMonitorSubscriptionByNameRequest.$type, GetFirehoseMonitorSubscriptionByNameRequest);
function createBaseGetFirehoseMonitorSubscriptionByNameResponse() {
  return { id: "" };
}
var GetFirehoseMonitorSubscriptionByNameResponse = {
  $type: "devvit.dev_portal.internal.data_api.v1alpha.admin.GetFirehoseMonitorSubscriptionByNameResponse",
  encode(message, writer = import_minimal168.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal168.default.Reader ? input : import_minimal168.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetFirehoseMonitorSubscriptionByNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet141(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return GetFirehoseMonitorSubscriptionByNameResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetFirehoseMonitorSubscriptionByNameResponse();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set(GetFirehoseMonitorSubscriptionByNameResponse.$type, GetFirehoseMonitorSubscriptionByNameResponse);
function isSet141(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/internal/data_api/v1alpha/admin/admin.js
var import_minimal169 = __toESM(require_minimal2(), 1);

// src/lib/fetch.polyfill.ts
var import_buffer2 = __toESM(require_buffer(), 1);
var httpPlugin;
function getHttpPlugin() {
  if (httpPlugin !== void 0) {
    return httpPlugin;
  }
  const config2 = globalThis?.devvit?.config;
  if (!config2?.uses?.(HTTPDefinition)) {
    throw new Error(
      "Fetch is not enabled. You can enable it by passing `http: true` to `Devvit.configure`"
    );
  }
  const handler = config2?.use?.(HTTPDefinition, {}) ?? null;
  if (handler === null) {
    throw new Error("fetch polyfill failed to initialize HTTPPlugin");
  }
  return handler;
}
var _headers;
var _Headers = class _Headers {
  constructor(init) {
    __privateAdd(this, _headers, /* @__PURE__ */ new Map());
    if (init instanceof _Headers) {
      __privateSet(this, _headers, new Map(Object.entries(__privateGet(init, _headers))));
    } else if (typeof init === "object") {
      const h = Array.isArray(init) ? init : Object.entries(init);
      for (const [name, val] of h) {
        this.set(name, val);
      }
    }
  }
  entries() {
    return __privateGet(this, _headers).entries();
  }
  append(name, val) {
    const current = this.get(name) ?? "";
    this.set(name, `${current},${val}`);
  }
  set(name, val) {
    __privateGet(this, _headers).set(name.toLowerCase(), val);
  }
  get(name) {
    return __privateGet(this, _headers).get(name.toLowerCase()) ?? null;
  }
  delete(name) {
    __privateGet(this, _headers).delete(name.toLowerCase());
  }
  has(name) {
    return this.get(name) !== null;
  }
  forEach(cb, thisArg) {
    __privateGet(this, _headers).forEach((val, name) => {
      cb.call(thisArg, val, name, this);
    });
  }
  keys() {
    return __privateGet(this, _headers).keys();
  }
  values() {
    return __privateGet(this, _headers).values();
  }
};
_headers = new WeakMap();
var Headers = _Headers;
var _options, _url, _bodyUsed;
var Request = class {
  constructor(input, options) {
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _url, void 0);
    __privateAdd(this, _bodyUsed, false);
    if (typeof input === "string") {
      __privateSet(this, _url, input);
      __privateSet(this, _options, options ?? {});
    } else {
      __privateSet(this, _url, __privateGet(input, _url));
      __privateSet(this, _options, { ...__privateGet(input, _options), ...options ?? {} });
    }
    this.headers = new Headers(__privateGet(this, _options).headers);
  }
  get url() {
    return __privateGet(this, _url);
  }
  get method() {
    return __privateGet(this, _options).method ?? "GET";
  }
  // TODO: make this return ReadableStream, but that's a lot more to polyfill...
  get body() {
    throw new Error("Request.body is not implemented");
  }
  // NON-STANDARD way of getting the body as an ArrayBuffer to Avoid ReadableStreams
  getBodyAsArrayBuffer() {
    __privateSet(this, _bodyUsed, true);
    const body = __privateGet(this, _options).body;
    if (typeof body === "string") {
      return new TextEncoder().encode(body);
    } else if (body instanceof ArrayBuffer) {
      return body;
    } else if (typeof body === "object" && "buffer" in body && body.buffer instanceof ArrayBuffer) {
      return body.buffer;
    } else if (typeof body === "undefined") {
      return new ArrayBuffer(0);
    } else {
      throw new Error(
        "Request.body must be a TypedArray, DataView, ArrayBuffer, string, or undefined"
      );
    }
  }
  get bodyUsed() {
    return __privateGet(this, _bodyUsed);
  }
  get mode() {
    return "cors";
  }
  get cache() {
    return "no-cache";
  }
  get credentials() {
    return "omit";
  }
  get destination() {
    return "";
  }
  get integrity() {
    return "";
  }
  // this is expermiental
  get priority() {
    return "auto";
  }
  get redirect() {
    return "follow";
  }
  get referrer() {
    return "";
  }
  get referrerPolicy() {
    return "";
  }
};
_options = new WeakMap();
_url = new WeakMap();
_bodyUsed = new WeakMap();
var _pluginResponse, _headers2, _bodyUsed2, _resultMethodUnimplemented, resultMethodUnimplemented_fn;
var _Response = class _Response {
  constructor(unsupportedFileOrBlob) {
    __privateAdd(this, _resultMethodUnimplemented);
    __privateAdd(this, _pluginResponse, void 0);
    __privateAdd(this, _headers2, void 0);
    __privateAdd(this, _bodyUsed2, false);
    if (unsupportedFileOrBlob !== void 0) {
      throw new Error("Response does not support construction from File or Blob");
    }
  }
  clone() {
    if (__privateGet(this, _pluginResponse) == null) {
      return new _Response();
    }
    return _Response.fromPluginResponse(__privateGet(this, _pluginResponse));
  }
  async arrayBuffer() {
    if (__privateGet(this, _pluginResponse) == null) {
      return new ArrayBuffer(0);
    }
    return import_buffer2.Buffer.from(__privateGet(this, _pluginResponse).body);
  }
  async text() {
    __privateSet(this, _bodyUsed2, true);
    const body = await this.arrayBuffer();
    return new TextDecoder().decode(body);
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  get headers() {
    if (__privateGet(this, _headers2) != null) {
      return __privateGet(this, _headers2);
    }
    __privateSet(this, _headers2, new Headers(__privateGet(this, _pluginResponse)?.headers));
    return __privateGet(this, _headers2);
  }
  get bodyUsed() {
    return __privateGet(this, _bodyUsed2);
  }
  get status() {
    return __privateGet(this, _pluginResponse)?.status ?? 200;
  }
  get statusText() {
    throw new Error("Response.statusText() is not implemented, please use Response.status()");
  }
  get ok() {
    return 200 <= this.status && this.status < 300;
  }
  get redirected() {
    return false;
  }
  get type() {
    return "cors";
  }
  get url() {
    return __privateGet(this, _pluginResponse)?.url ?? "";
  }
  get body() {
    return __privateMethod(this, _resultMethodUnimplemented, resultMethodUnimplemented_fn).call(this, "body");
  }
  get blob() {
    return __privateMethod(this, _resultMethodUnimplemented, resultMethodUnimplemented_fn).call(this, "blob()");
  }
  formData() {
    __privateMethod(this, _resultMethodUnimplemented, resultMethodUnimplemented_fn).call(this, "formData()");
  }
  static error() {
    return _Response.fromPluginResponse({
      url: "",
      body: new Uint8Array(0),
      status: 0,
      headers: {}
    });
  }
  static redirect(url, status = 0) {
    return _Response.fromPluginResponse({
      url,
      status,
      body: new Uint8Array(0),
      headers: {}
    });
  }
  /**
   * This method allows us to construct a Response from a PluginResponse,
   * but this should not be considered part of the public api
   */
  static fromPluginResponse(pr) {
    const resp = new _Response();
    __privateSet(resp, _pluginResponse, pr);
    return resp;
  }
};
_pluginResponse = new WeakMap();
_headers2 = new WeakMap();
_bodyUsed2 = new WeakMap();
_resultMethodUnimplemented = new WeakSet();
resultMethodUnimplemented_fn = function(method) {
  throw new Error(
    `Response.${method} is not implemented! Please use Response.text() or Response.json().`
  );
};
var Response2 = _Response;
async function fetch(request, options) {
  const fetchPlugin = getHttpPlugin();
  if (typeof request === "string" || options !== void 0) {
    request = new Request(request, options);
  }
  const pluginResponse = await fetchPlugin.Fetch({
    url: request.url,
    data: {
      method: request.method,
      headers: Object.fromEntries([...request.headers.entries()]),
      body: new Uint8Array(request.getBodyAsArrayBuffer())
    }
  });
  return Response2.fromPluginResponse(pluginResponse);
}
var globalExports = {
  fetch,
  Request,
  Response: Response2,
  Headers
};
var global2 = globalThis;
Object.assign(global2, globalExports);

// ../shared-types/dist/NonNull.js
function assertNonNull(val, msg) {
  if (val == null)
    throw Error(msg ?? "Expected nonnullish value.");
}
function NonNull(val, msg) {
  assertNonNull(val, msg);
  return val;
}

// src/lib/BundleUtil.ts
function getUniqueNodes(node, getId, getChildren) {
  const seen = /* @__PURE__ */ new Set([getId(node)]);
  const toProcess = getChildren(node);
  while (toProcess.length > 0) {
    const curNode = toProcess.pop();
    const curId = getId(curNode);
    if (!seen.has(curId)) {
      seen.add(curId);
      toProcess.push(...getChildren(curNode));
    }
  }
  return seen;
}

// src/lib/DependencyGraph.ts
var _children, _parents, _getChildren, _getID;
var DependencyGraph = class {
  constructor(idFunc, childrenFunc) {
    __privateAdd(this, _children, void 0);
    __privateAdd(this, _parents, void 0);
    __privateAdd(this, _getChildren, void 0);
    __privateAdd(this, _getID, void 0);
    __privateSet(this, _getID, idFunc);
    __privateSet(this, _getChildren, childrenFunc);
    __privateSet(this, _children, {});
    __privateSet(this, _parents, {});
  }
  addNode(element, parent) {
    var _a;
    const elementID = __privateGet(this, _getID).call(this, element);
    const children = __privateGet(this, _getChildren).call(this, element);
    if (__privateGet(this, _parents)[elementID]) {
      if (parent != null) {
        __privateGet(this, _parents)[elementID].add(parent);
      }
      return /* @__PURE__ */ new Set();
    }
    const nodesAdded = children.reduce((added, node) => {
      return /* @__PURE__ */ new Set([...added, ...this.addNode(node, elementID)]);
    }, /* @__PURE__ */ new Set([element]));
    __privateGet(this, _children)[elementID] = new Set(children.map(__privateGet(this, _getID)));
    (_a = __privateGet(this, _parents))[elementID] ?? (_a[elementID] = /* @__PURE__ */ new Set());
    if (parent) {
      __privateGet(this, _parents)[elementID].add(parent);
    }
    return nodesAdded;
  }
  has(id) {
    return !!__privateGet(this, _parents)[id];
  }
  size() {
    return Object.keys(__privateGet(this, _parents)).length;
  }
  deleteRoots(roots) {
    return [...roots].reduce((deleted, root) => {
      return /* @__PURE__ */ new Set([...deleted, ...this.deleteNode(root)]);
    }, /* @__PURE__ */ new Set());
  }
  findRoots(id) {
    const roots = /* @__PURE__ */ new Set();
    const ancestors = [id];
    while (ancestors.length > 0) {
      const currentHostname = ancestors.shift();
      const parents = __privateGet(this, _parents)[currentHostname];
      if (parents) {
        if (parents.size === 0) {
          roots.add(currentHostname);
        } else {
          ancestors.push(...parents);
        }
      }
    }
    return roots;
  }
  deleteNode(id) {
    const parents = __privateGet(this, _parents)[id];
    for (const parent of parents) {
      __privateGet(this, _children)[parent].delete(id);
    }
    const entries = /* @__PURE__ */ new Set();
    const descendants = [id];
    while (descendants.length > 0) {
      const currentID = descendants.shift();
      if (!entries.has(currentID)) {
        descendants.push(
          ...[...__privateGet(this, _children)[currentID] ?? []].filter((childID) => {
            __privateGet(this, _parents)[childID]?.delete(currentID);
            return __privateGet(this, _parents)[childID].size === 0;
          })
        );
        entries.add(currentID);
      }
    }
    return new Set(
      [...entries].map((e) => {
        delete __privateGet(this, _parents)[e];
        delete __privateGet(this, _children)[e];
        return e;
      })
    );
  }
};
_children = new WeakMap();
_parents = new WeakMap();
_getChildren = new WeakMap();
_getID = new WeakMap();

// src/lib/HostnameUtil.ts
var RUNTIME_CNAME = "runtime";
var SUPERVISOR_CNAME = "supervisor";
function resolveSystemHostname(name, namespace) {
  return childHostname(name, Hostname.getSystemNamespace(namespace));
}
function childHostname(name, namespace) {
  if (namespace.hostname == null)
    throw Error("Unbound namespace.");
  return `${name}.${namespace.hostname}`.toLocaleLowerCase();
}
function siblingHostname(name, namespace) {
  if (namespace.hostname == null)
    throw Error("Unbound namespace.");
  if (parentHostname(namespace) === name)
    return name.toLocaleLowerCase();
  return `${name.toLocaleLowerCase()}.${parentHostname(namespace)}`;
}
function parentHostname(hostnameOrNamespace) {
  const hostname = typeof hostnameOrNamespace === "string" ? hostnameOrNamespace : hostnameOrNamespace.hostname;
  if (hostname == null)
    throw Error("Unbound namespace.");
  return hostname.split(".").slice(1).join(".").toLocaleLowerCase();
}
function isDescendantHostname(lhs, rhs) {
  const suffix = `.${rhs}`;
  return lhs === rhs || lhs.length > suffix.length && lhs.endsWith(suffix);
}
var Hostname;
((Hostname2) => {
  function getChild(hostname) {
    return hostname.split(".")[0];
  }
  Hostname2.getChild = getChild;
  function getRoot(hostname) {
    return NonNull(hostname.split(".").at(-1));
  }
  Hostname2.getRoot = getRoot;
  function getPluginNamespace(namespace) {
    return { hostname: childHostname("plugins", namespace) };
  }
  Hostname2.getPluginNamespace = getPluginNamespace;
  function getSystemNamespace(namespace) {
    return { hostname: childHostname("system", namespace) };
  }
  Hostname2.getSystemNamespace = getSystemNamespace;
  function isPlugin(hostname, namespace) {
    return isDescendantHostname(hostname, NonNull(getPluginNamespace(namespace).hostname));
  }
  Hostname2.isPlugin = isPlugin;
  function isSystem(hostname, namespace) {
    return isDescendantHostname(hostname, NonNull(getSystemNamespace(namespace).hostname));
  }
  Hostname2.isSystem = isSystem;
})(Hostname || (Hostname = {}));

// ../shared-types/dist/debugConfig.js
var isProd = false;
var prod = {
  flushNodeLogs: false,
  logAllEnvelopes: false,
  addDebugUtilsToEnv: false,
  assertEnvelopesPostable: false
};
var debug = {
  flushNodeLogs: true,
  // This environment may only be applied at compilation or only at runtime. For
  // build-only packaging, you must build the code for the environment you want.
  // Be mindful of build caching too. shared-types is a leaf dependency that may
  // not be rebuilt automatically when building another package.
  logAllEnvelopes: typeof process !== "undefined" && false,
  // to-do: add logFilteredEnvelopes.
  addDebugUtilsToEnv: true,
  assertEnvelopesPostable: true
};
var DEBUG_CONFIG = isProd ? prod : debug;

// ../shared-types/dist/PlatformUtil.js
function isWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope || // Go doesn't polyfill WorkerGlobalScope, but it doesn't execute non-worker code
  // so we know any code it executes is within a worker.
  isPlatformGo();
}
function isPlatformGo() {
  return globalThis.devvit?.compute?.platform === "go";
}
function isPlatformWeb() {
  return !isPlatformGo() && !isPlatformNode();
}
function isPlatformNode() {
  return typeof process !== "undefined" && process.release?.name === "node";
}
function isHeadless() {
  return typeof window === "undefined" || isPlatformGo() || isPlatformNode();
}
function isNativeWorker() {
  return isWorker() && isPlatformGo();
}

// ../shared-types/dist/StringUtil.js
var StringUtil;
(function(StringUtil2) {
  function ellipsize(str, limit) {
    return str.length <= limit ? str : `${str.slice(0, limit - 1)}\u2026`;
  }
  StringUtil2.ellipsize = ellipsize;
  function capitalize(str) {
    if (str[0] == null)
      return str;
    return `${str[0].toLocaleUpperCase()}${str.slice(1)}`;
  }
  StringUtil2.capitalize = capitalize;
  function isBlank(str) {
    return str == null || /^\s*$/.test(str);
  }
  StringUtil2.isBlank = isBlank;
  function caughtToString(val) {
    return val instanceof Error ? `${val.stack || val.message || val.name}` : String(val);
  }
  StringUtil2.caughtToString = caughtToString;
})(StringUtil || (StringUtil = {}));

// ../../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../shared-types/dist/Immutable.js
function Immutable(val) {
  if (val == null || typeof val !== "object")
    return val;
  for (const subVal of Object.values(val))
    Immutable(subVal);
  return Object.freeze(val);
}

// ../shared-types/dist/findUncloneable.js
var supportedObjectTypes = Immutable(new Set([
  Boolean,
  String,
  Date,
  // to-do: Blob,
  // to-do: File,
  // to-do: FileList,
  ArrayBuffer,
  DataView,
  // to-do: ImageBitmap,
  // to-do: ImageData,
  Array,
  Object,
  Map,
  Set,
  // TypedArray
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  BigInt64Array,
  BigUint64Array,
  // Errors
  // to-do: DOMException
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError
].map((type) => type.prototype)));
function findUncloneable(path, dat) {
  if (dat == null)
    return [];
  if (typeof dat === "bigint")
    return [];
  if (typeof dat === "boolean")
    return [];
  if (typeof dat === "function")
    return [path, `function: ${String(dat)}`];
  if (typeof dat === "number")
    return [];
  if (typeof dat === "string")
    return [];
  if (typeof dat === "symbol")
    return [path, `symbol: ${String(dat)}`];
  if (dat instanceof RegExp)
    return [path, `regex: ${String(dat)}`];
  const obj = dat;
  const proto = Object.getPrototypeOf(obj);
  if (obj instanceof Object && proto != null && !isSupportedObjectType(proto))
    return [path, dat];
  for (const [key, val] of Object.entries(obj)) {
    const descendant = findUncloneable(`${path}.${key}`, val);
    if (descendant.length > 0)
      return descendant;
  }
  return [];
}
function isSupportedObjectType(proto) {
  return supportedObjectTypes.has(proto);
}

// ../shared-types/dist/Header.js
var Header = Object.freeze({
  Actor: "devvit-actor",
  App: "devvit-app",
  AppUser: "devvit-app-user",
  AppViewerAuthToken: "devvit-app-viewer-authorization",
  Caller: "devvit-caller",
  CallerPortID: "devvit-caller-port-id",
  Canary: "devvit-canary",
  DebugRenderXML: "devvit-debug-render-xml",
  GQLHost: "devvit-gql-host",
  Installation: "devvit-installation",
  ModPermissions: "devvit-mod-permissions",
  R2Auth: "devvit-sec-authorization",
  R2Host: "devvit-r2-host",
  RemoteHostname: "devvit-remote-hostname",
  SettingsUri: "devvit-sec-settings-uri",
  StreamID: "devvit-stream-id",
  Subreddit: "devvit-subreddit",
  TraceID: "devvit-trace-id",
  User: "devvit-user",
  Version: "devvit-version"
});

// src/lib/Buffer.ts
var import_buffer3 = __toESM(require_buffer(), 1);
var bufferImpl = globalThis.Buffer ?? import_buffer3.Buffer;
var Buffer3 = bufferImpl;

// src/common/envelope/EnvelopeUtil.ts
function assertEnvelopePostable(envelope) {
  const [path, val] = findUncloneable("envelope", envelope);
  if (path != null)
    throw Error(
      `Envelope is not postable. See value at ${path}: ${String(val)}. This is likely an error in your messaging code or \`assertEnvelopePostable()\`. Only Protobuf generated messages and native Errors can be sent. Please verify you are using \`fromPartial()\` to generate request / response messages and only throwing Error itself, not subclasses.`
    );
}
function stripErrorPrefix(message) {
  return message.replaceAll(/^(Error: )*/g, "");
}
function isErrorish(err) {
  return !!err && typeof err === "object" && "name" in err && ("message" in err || "stack" in err);
}
var NULLISH_ERROR_MESSAGE = "<nullish>";
function envelopeAsError(envelope) {
  if (envelope.message == null) {
    return new Error(NULLISH_ERROR_MESSAGE);
  }
  if (envelope.message instanceof Error) {
    envelope.message.message = stripErrorPrefix(envelope.message.message);
    return envelope.message;
  }
  if (typeof envelope.message === "string") {
    return new Error(stripErrorPrefix(envelope.message));
  }
  if (isErrorish(envelope.message)) {
    return new Error(stripErrorPrefix(envelope.message.message));
  }
  return new Error(envelope.message.toString());
}
function getFromMetadata(key, metadata) {
  return metadata?.[key]?.values[0];
}
function extractMetadataTraceID(metadata) {
  return getFromMetadata(Header.TraceID, metadata);
}
function envelopeMethod(def, name) {
  const method = def.methods[name];
  return `/${def.fullName}/${method?.name ?? name}`;
}
function envelopeMethodToName(envelope) {
  const name = NonNull(envelope.method.split("/").at(-1));
  return name[0].toLocaleLowerCase() + name.slice(1);
}
function requestMessageToBinary(message, method) {
  if (message == null)
    return void 0;
  return Buffer3.from(method.requestType.encode(message).finish()).toString("base64");
}
function requestMessageFromBinary(envelope, method) {
  if (!envelope.success || envelope.message == null)
    return envelope.message;
  const bytes = Buffer3.from(envelope.message, "base64");
  return method.requestType.decode(bytes);
}
function responseMessageToBinary(message, method) {
  if (message == null)
    return void 0;
  return Buffer3.from(method.responseType.encode(message).finish()).toString("base64");
}
function responseMessageFromBinary(envelope, method) {
  if (!envelope.success || envelope.message == null || typeof envelope.message !== "string")
    return envelope.message;
  const bytes = Buffer3.from(envelope.message, "base64");
  return method.responseType.decode(bytes);
}
function sendEnvelopeMessageToStream(envelope, stream) {
  if (envelope.success) {
    if (envelope.complete) {
      if (envelope.message) {
        stream.next(envelope.message);
      }
      stream.complete();
    } else {
      stream.next(envelope.message);
    }
  } else {
    stream.error(envelope.message);
    stream.complete();
  }
}
var EnvelopeUtil;
((EnvelopeUtil2) => {
  function toLogString(envelope) {
    const path = envelope.request ? `${envelope.src} \u2192 ${envelope.dst}` : `${envelope.dst} \u2190 ${envelope.src}`;
    const streamIDOctet = envelope.streamId.split("-")[0];
    const method = StringUtil.capitalize(envelopeMethodToName(envelope));
    return `${path}@${streamIDOctet}/${method}`;
  }
  EnvelopeUtil2.toLogString = toLogString;
})(EnvelopeUtil || (EnvelopeUtil = {}));

// src/lib/loggers/Log.ts
var NAME = typeof self !== "undefined" && self.name || globalThis.location?.hostname || v4_default();
var LogLevel = Object.freeze({
  /**
   * Verbose logs are useful for tracing but usually a hindrance for others not
   * working where the log is placed. Keep our logs clean and add with care.
   *
   * These logs are disabled by default but can be enabled.
   */
  VERBOSE: 0,
  /**
   * Informational logs should be used to mark significant non-erroneous events.
   * Little information is significant.
   *
   * These logs are enabled by default in development builds but disabled in
   * production.
   */
  INFO: 1,
  /**
   * Debug logs should never be committed.
   *
   * These logs are always enabled in development builds but disabled in
   * production.
   */
  DEBUG: 2,
  /**
   * Warnings should be reported as long as they do not contain sensitive data.
   *
   * These logs are always enabled.
   */
  WARN: 3,
  /**
   * Errors should always be reported as long as they do not contain sensitive
   * data.
   *
   * These logs are always enabled.
   */
  ERROR: 4,
  SILENT: 10
});
var LEVEL = LogLevel.VERBOSE;
var LEVEL_PREFIX = Object.freeze({
  [LogLevel.VERBOSE]: "V",
  [LogLevel.INFO]: "I",
  [LogLevel.DEBUG]: "D",
  [LogLevel.WARN]: "W",
  [LogLevel.ERROR]: "E",
  [LogLevel.SILENT]: ""
});
var defaultEnvelopeLoggerConfig = {
  // When debugging local changes, abbreviating lengthy strings is helpful. For
  // unexpected errors in non-debug, it may be harmful.
  abbreviateStrings: !isProd,
  showClientAddress: true,
  showServerAddress: true,
  // We expect browser devtools to be able to compact messages nicely
  // even if they're huge. That's not the case on the server and, in the
  // browser, including messages impedes log aggregation so let's not display
  // them by default there.
  showAllRequestMessages: false,
  showAllResponseMessages: false,
  showAllErrorMessages: true,
  showAllSuccessMessages: false,
  showMetadata: LEVEL <= LogLevel.VERBOSE,
  // If we're in a browser and _not_ in a worker, then we have a much nicer
  // console.log() which allows clicking through the various fields in the
  // DevTools console. Everybody else must stringify.
  stringifyObjects: isHeadless(),
  point: ""
};
function prefix(level, config2 = {}) {
  config2 = { ...defaultEnvelopeLoggerConfig, ...config2 };
  return `${LEVEL_PREFIX[level]}[${config2.abbreviateStrings ? abbreviateName() : NAME}]`;
}
var nodeDebugConsole = Object.freeze({
  async debug(...args) {
    console.debug(...args);
    await flush(process.stdout);
  },
  async info(...args) {
    console.info(...args);
    await flush(process.stdout);
  },
  async log(...args) {
    console.log(...args);
    await flush(process.stdout);
  },
  async warn(...args) {
    console.warn(...args);
    await flush(process.stderr);
  },
  async error(...args) {
    console.error(...args);
    await flush(process.stderr);
  }
});
var voidConsole = Object.freeze({
  debug() {
  },
  info() {
  },
  log() {
  },
  warn() {
  },
  error() {
  }
});
var logger = DEBUG_CONFIG.flushNodeLogs && isPlatformNode() ? nodeDebugConsole : console;
var Log = {
  // These Log APIs are logical. The verbose implementation uses console.debug()
  // because it corresponds to the verbose logging level in Chromium. Similarly,
  // debug uses log as a default.
  verbose: LEVEL > LogLevel.VERBOSE ? () => {
  } : (...args) => logger.debug(prefix(LogLevel.VERBOSE), ...args),
  info: LEVEL > LogLevel.INFO ? () => {
  } : (...args) => logger.info(prefix(LogLevel.INFO), ...args),
  debug: LEVEL > LogLevel.DEBUG ? () => {
  } : (...args) => logger.log(prefix(LogLevel.DEBUG), ...args),
  warn: LEVEL > LogLevel.WARN ? () => {
  } : (...args) => logger.warn(prefix(LogLevel.WARN), ...args),
  error: LEVEL > LogLevel.ERROR ? () => {
  } : (...args) => logger.error(prefix(LogLevel.ERROR), ...args),
  /**
   * Update the base envelope config for all invocations of `Log.envelope()`
   */
  setDefaultConfig(config2) {
    Object.assign(defaultEnvelopeLoggerConfig, config2);
  },
  /**
   * Dump the contents of an envelope to the debug logs.
   *
   * Accepts a logger config partial, which will be mixed with the default logger config
   */
  envelope(envelope, config2 = {}) {
    config2 = { ...defaultEnvelopeLoggerConfig, ...config2 };
    if (isProd)
      return;
    const errSym = envelope.success ? "" : "\u{1F5D9}";
    let streamId = envelope.streamId;
    if (config2.abbreviateStrings)
      streamId = abbreviateUUID(streamId);
    let msg = "";
    if (envelope.request && config2.showAllRequestMessages || !envelope.request && config2.showAllResponseMessages || envelope.success && config2.showAllSuccessMessages || !envelope.success && config2.showAllErrorMessages) {
      msg = envelope.message || envelope;
    }
    if (msg !== "" && config2.stringifyObjects) {
      msg = JSON.stringify(msg);
      if (config2.abbreviateStrings)
        msg = `[msg (${msg.length}) ${StringUtil.ellipsize(msg, 80)}]`;
    }
    let path;
    if (envelope.request)
      path = [envelope.src, "\u2192", envelope.dst];
    else
      path = [envelope.dst, "\u2190", envelope.src];
    if (!config2.showClientAddress)
      path[0] = "Client";
    if (!config2.showServerAddress)
      path[2] = "Server";
    if (config2.abbreviateStrings) {
      path[0] = abbreviateClientHostname(path[0]);
    }
    const method = config2.abbreviateStrings ? envelopeMethodToName(envelope) : envelope.method;
    const requestResponse = `${path.join(" ")}@${streamId}/${method}`;
    let metadata = envelope.metadata;
    if (config2.stringifyObjects)
      metadata = stringifyMetadata(metadata);
    const logs = [
      `${errSym}${config2.point ? `${config2.point} ` : ""}${requestResponse}`
    ];
    if (msg)
      logs.push(msg);
    if (config2.showMetadata)
      logs.push(metadata);
    Log.debug(...logs);
  },
  setLogger(console2) {
    logger = console2;
  }
};
function abbreviateClientHostname(hostname) {
  const uuid = extractHostnameUUID(Hostname.getChild(hostname))[0];
  if (uuid == null)
    return hostname;
  const uuidAbbreviated = abbreviateUUID(uuid);
  const dispatcher2 = Hostname.getChild(parentHostname(hostname));
  return `${uuidAbbreviated}.${dispatcher2}`;
}
function abbreviateName() {
  if (isUUID(NAME))
    return abbreviateUUID(NAME);
  return NAME;
}
function abbreviateUUID(uuid) {
  return uuid.split("-")[0];
}
function extractHostnameUUID(hostname) {
  return hostname.match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i) ?? [];
}
function isUUID(str) {
  return /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i.test(str);
}
function stringifyMetadata(metadata) {
  const entries = Object.entries(metadata ?? {});
  if (entries.length === 0)
    return "";
  const entriesStr = entries.map(([header, { values }]) => `${header}: "${values.join(", ")}"`).join(", ");
  return `[meta ${entriesStr}]`;
}
async function flush(stream) {
  await new Promise((resolve) => stream.write("", resolve));
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// src/common/envelope/EnvelopeClientBuilder.ts
var EnvelopeClientBuilder = class {
  static build(serverHostname, knows, logger2 = new VoidSystemLogger(), idFactory = v4_default) {
    return new EnvelopeClient(serverHostname, knows, idFactory, logger2);
  }
};
var _idFactory, _dispatcher, _callbacksByStreamID, _logger, _createAsyncMethod, createAsyncMethod_fn, _createSourceHandler, createSourceHandler_fn, _createSinkHandler, createSinkHandler_fn, _createPipeHandler, createPipeHandler_fn, _emitRequestStreamAsEnvelopes, emitRequestStreamAsEnvelopes_fn, _postDispatcher, postDispatcher_fn;
var EnvelopeClient = class {
  constructor(serverHostname, knows, idFactory, logger2) {
    __privateAdd(this, _createAsyncMethod);
    // I emit a stream of values.  This is like a tail.
    __privateAdd(this, _createSourceHandler);
    // I expect a stream of values.  This might produce e.g. the sum of the input stream.
    __privateAdd(this, _createSinkHandler);
    __privateAdd(this, _createPipeHandler);
    __privateAdd(this, _emitRequestStreamAsEnvelopes);
    __privateAdd(this, _postDispatcher);
    this.type = "client";
    __privateAdd(this, _idFactory, void 0);
    __privateAdd(this, _dispatcher, void 0);
    __privateAdd(this, _callbacksByStreamID, {});
    __privateAdd(this, _logger, void 0);
    this.serverHostname = serverHostname;
    this.id = idFactory();
    __privateSet(this, _idFactory, idFactory);
    __privateSet(this, _logger, logger2);
    for (const definition of knows) {
      for (const method of Object.values(definition.methods)) {
        if (method.requestStream && method.responseStream) {
          this[method.name] = __privateMethod(this, _createPipeHandler, createPipeHandler_fn).call(this, definition, method).bind(this);
        } else if (method.requestStream && !method.responseStream) {
          this[method.name] = __privateMethod(this, _createSinkHandler, createSinkHandler_fn).call(this, definition, method).bind(this);
        } else if (!method.requestStream && method.responseStream) {
          this[method.name] = __privateMethod(this, _createSourceHandler, createSourceHandler_fn).call(this, definition, method).bind(this);
        } else if (!method.requestStream && !method.responseStream) {
          this[method.name] = __privateMethod(this, _createAsyncMethod, createAsyncMethod_fn).call(this, definition, method).bind(this);
        } else {
          throw new Error(
            `Unsupported "${definition.name}" client method request / response definition.`
          );
        }
      }
    }
  }
  /**
   * Client hostnames always match their dispatcher. This is not a property
   * unique to clients.
   *
   * |                         |                        |                         |                                                                    |
   * | ----------------------- | ---------------------- | ----------------------- | ------------------------------------------------------------------ |
   * | Client                  | Server                 | Dispatcher              | Description                                                        |
   * | local                   | inspector.plugins.node | local                   | One of the local runtime's clients to a remote server's inspector. |
   * | local                   | logger.plugins.local   | local                   | One of the local runtime's clients to a local logger.              |
   * | node                    | supervisor.system.node | node                    | One of the Node.js runtime's clients to the local supervisor.      |
   * | supervisor.system.local | runtime.system.local   | supervisor.system.local | One of the supervisor's clients to the local runtime.              |
   *
   * When issuing requests, this is the Envelope.src. When receiving responses,
   * this is the nondistinct Envelope.dst. The client's dispatcher is expected
   * resolve by stream ID since the hostname is not unique among its clients.
   */
  get hostname() {
    return __privateGet(this, _dispatcher)?.hostname;
  }
  async onBind(dispatcher2) {
    if (__privateGet(this, _dispatcher) != null) {
      throw Error(`Dispatcher: "${__privateGet(this, _dispatcher).hostname}" already bound.`);
    }
    __privateSet(this, _dispatcher, dispatcher2);
  }
  async onUnbind(_dispatcher4) {
    __privateSet(this, _dispatcher, void 0);
  }
  // Called by dispatcher only, to send responses to the client.
  post(_caller, envelope) {
    if (__privateGet(this, _callbacksByStreamID)[envelope.streamId] == null)
      throw Error(
        `Missing callbacks for stream ID "${envelope.streamId}" for envelope to ${envelope.dst} from ${envelope.src}.`
      );
    if (envelope.request)
      throw Error("Clients cannot be posted request Envelopes.");
    __privateGet(this, _callbacksByStreamID)[envelope.streamId](envelope);
    if (envelope.complete) {
      delete __privateGet(this, _callbacksByStreamID)[envelope.streamId];
    }
  }
  async dispose() {
    await __privateGet(this, _dispatcher)?.release(this);
  }
};
_idFactory = new WeakMap();
_dispatcher = new WeakMap();
_callbacksByStreamID = new WeakMap();
_logger = new WeakMap();
_createAsyncMethod = new WeakSet();
createAsyncMethod_fn = function(definition, method) {
  return (message, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    return new Promise((resolve, reject) => {
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        if (envelope.success) {
          const msg = responseMessageFromBinary(envelope, method);
          resolve(msg);
        } else {
          reject(envelopeAsError(envelope));
        }
      };
      __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
        complete: true,
        message: requestMessageToBinary(message, method),
        metadata,
        method: envelopeMethod(definition, method.name),
        request: true,
        streamId: streamID,
        success: true,
        traceId: traceID
      });
    });
  };
};
_createSourceHandler = new WeakSet();
createSourceHandler_fn = function(definition, method) {
  return (message, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    return new Observable((subscriber) => {
      if (__privateGet(this, _callbacksByStreamID)[streamID]) {
        throw new Error("Multiple subscribers to a source is not supported");
      }
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        envelope.message = responseMessageFromBinary(envelope, method);
        sendEnvelopeMessageToStream(envelope, subscriber);
      };
      __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
        complete: true,
        message: requestMessageToBinary(message, method),
        metadata,
        method: envelopeMethod(definition, method.name),
        request: true,
        streamId: streamID,
        success: true,
        traceId: traceID
      });
    });
  };
};
_createSinkHandler = new WeakSet();
createSinkHandler_fn = function(definition, method) {
  return (messages, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    const response = new Promise((resolve, reject) => {
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        if (envelope.success) {
          resolve(responseMessageFromBinary(envelope, method));
        } else {
          reject(envelopeAsError(envelope));
        }
      };
    });
    __privateMethod(this, _emitRequestStreamAsEnvelopes, emitRequestStreamAsEnvelopes_fn).call(this, definition, method, streamID, traceID, messages, metadata);
    return response;
  };
};
_createPipeHandler = new WeakSet();
createPipeHandler_fn = function(definition, method) {
  return (messages, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    return new Observable((subscriber) => {
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        envelope.message = responseMessageFromBinary(envelope, method);
        sendEnvelopeMessageToStream(envelope, subscriber);
      };
      __privateMethod(this, _emitRequestStreamAsEnvelopes, emitRequestStreamAsEnvelopes_fn).call(this, definition, method, streamID, traceID, messages, metadata);
    });
  };
};
_emitRequestStreamAsEnvelopes = new WeakSet();
emitRequestStreamAsEnvelopes_fn = function(definition, method, streamID, traceID, reqStream, metadata) {
  const envelope = {
    metadata,
    method: envelopeMethod(definition, method.name),
    request: true,
    streamId: streamID,
    traceId: traceID
  };
  reqStream.subscribe({
    next: (message) => __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
      ...envelope,
      complete: false,
      message: requestMessageToBinary(message, method),
      success: true
    }),
    error: (err) => __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
      ...envelope,
      complete: true,
      message: err.message,
      success: false
    }),
    complete: () => __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, { ...envelope, complete: true, message: void 0, success: true })
  });
};
_postDispatcher = new WeakSet();
postDispatcher_fn = function(partialEnvelope) {
  const envelope = Envelope.fromPartial({
    ...partialEnvelope,
    metadata: partialEnvelope.metadata ?? {},
    dst: this.serverHostname,
    id: __privateGet(this, _idFactory).call(this),
    src: this.hostname ?? ""
  });
  if (__privateGet(this, _dispatcher) == null)
    throw Error("No dispatcher bound to client:" + this.hostname);
  __privateGet(this, _dispatcher).post(this, envelope);
};

// src/plugins/logger/ConsoleLogger.ts
var voidConsole2 = Object.freeze({
  debug() {
  },
  error() {
  },
  info() {
  },
  verbose() {
  },
  warn() {
  }
});
var levelBySeverity = Object.freeze({
  [Severity.DEBUG]: "debug",
  [Severity.ERROR]: "error",
  [Severity.INFO]: "info",
  [Severity.UNRECOGNIZED]: "info",
  [Severity.VERBOSE]: "verbose",
  [Severity.WARN]: "warn"
});

// src/lib/loggers/SystemLogger.ts
var SystemLogTag = Object.freeze({
  /** A script lifecycle event such as loaded or unloaded. */
  ScriptLifecycle: "ScriptLifecycle",
  /**
   * A script threw an unhandled error when processing a request or response.
   */
  ScriptMessageError: "ScriptMessageError",
  /**
   * A log recorded by Compute. This may occur in any environment (web, Node.js,
   * worker, Go, etc). All SystemLog-recorded logs are expected to have this
   * tag.
   */
  System: "System"
});
var VoidSystemLogger = class {
  constructor() {
    this.bind = () => {
    };
    this.debug = async () => {
    };
    this.error = async () => {
    };
    this.event = async () => {
    };
    this.info = async () => {
    };
    this.messageError = async () => {
    };
    this.unbind = async () => {
    };
    this.verbose = async () => {
    };
    this.warn = async () => {
    };
  }
};

// src/common/envelope/filter/MetadataEnvelopeFilter.ts
var import_lru_cache = __toESM(require_lru_cache(), 1);

// src/lib/Header.ts
function isSystemHeader(header) {
  return header.startsWith("devvit-");
}
var allowlistedReadHeaders = Object.freeze([
  Header.App,
  Header.AppUser,
  Header.Caller,
  Header.Canary,
  Header.DebugRenderXML,
  Header.Installation,
  Header.ModPermissions,
  Header.StreamID,
  Header.Subreddit,
  Header.TraceID,
  Header.User
]);
function filterHeadersForDestination(namespace, metadata, destination) {
  if (isTrustedLocation(namespace, destination))
    return { ...metadata };
  const allowedEntries = Object.entries(metadata).filter(
    ([header]) => allowlistedReadHeaders.includes(header) || !isSystemHeader(header)
  );
  return Object.fromEntries(allowedEntries);
}
function isTrustedLocation(namespace, location) {
  return (
    // Allow runtime plugin clients, Studio, and test clients to send whatever
    // headers they wish. An actor trusts all Envelopes manufactured in its
    // own thread.
    location === namespace.hostname || Hostname.isPlugin(location, namespace) || Hostname.isSystem(location, namespace)
  );
}

// src/common/envelope/filter/MetadataEnvelopeFilter.ts
var _storeByStreamID, _namespace, _onStoreEvictingUserCallback, _filterHeadersForStore, filterHeadersForStore_fn, _onStoreEvicting, onStoreEvicting_fn;
var MetadataEnvelopeFilter = class {
  constructor(namespace, onStoreEvicting = () => {
  }, size = 1e4) {
    /**
     * Return a new shallow copy of metadata with store-restricted headers filtered
     * out.
     */
    __privateAdd(this, _filterHeadersForStore);
    /**
     * Called when metadata is about to be evicted. Do not modify the LRU.
     *
     * The Go worker filter does not support this functionality.
     */
    __privateAdd(this, _onStoreEvicting);
    /**
     * Metadata by Envelope.streamId store. Each stream shares a record across
     * all requests and responses in the stream. The path forms a call graph where
     * each new call (Envelope) aggregates the metadata of any predecessor
     * streams.
     *
     * .
     * |\
     * o o
     *   |
     *   O
     *
     * If metadata is not passed on new stream creation, a new empty record is
     * made.
     *
     * Envelope.id does not match stream semantics which may have many requests
     * but only one response. There's no "push / pop" scheme for envelope IDs
     * which are each unique.
     *
     * Envelope.traceId also isn't ideal because it may be shared across many
     * successor streams. Successors could mutate a distant predecessor.
     *
     * Envelope.streamId unsurprisingly matches the stream mechanics. Each
     * metadata record is layered (copied) by stream so that when a new stream is
     * created, a new copy is made using the predecessor's stream, if any. We
     * don't really care if multiple requests within a stream change their own
     * stream's shared record.
     *
     * `Envelope.streamId` does not match the metadata stream ID in these cases:
     *
     * - New stream creation: no prior metadata / root request. The metadata
     *   stream ID is empty.
     * - New stream creation: no passed metadata by client. The metadata stream ID
     *   is empty.
     * - New stream creation: client passes metadata but the Envelope hasn't been
     *   filtered by MetadataEnvelopeFilter store yet. The metadata stream ID
     *   points to the predecessor's record.
     *
     * In other words, when this header comes into a EnvelopeServer it means,
     * "this is the stream that caused your invocation" and it matches
     * `Envelope.streamId` because its already been filtered by the time it
     * arrives at the server.
     *
     * Subsequent client calls (`EnvelopeClient.post()`) _never_ specify this
     * header manually. Instead, they pass (or not) an entire Metadata set. This
     * `devvit-stream-id` does not match `Envelope.streamId` because it's the
     * predecessor's stream ID. For requests, the header specifies which stream to
     * propagate metadata from, not what stream the envelope that's being post()ed
     * should belong to.
     */
    __privateAdd(this, _storeByStreamID, void 0);
    __privateAdd(this, _namespace, void 0);
    __privateAdd(this, _onStoreEvictingUserCallback, void 0);
    __privateSet(this, _storeByStreamID, new import_lru_cache.default({
      max: size,
      dispose: __privateMethod(this, _onStoreEvicting, onStoreEvicting_fn).bind(this)
    }));
    __privateSet(this, _namespace, namespace);
    __privateSet(this, _onStoreEvictingUserCallback, onStoreEvicting);
  }
  async filter(envelope) {
    if (envelope.streamId === "")
      throw Error(`Missing stream ID on ${EnvelopeUtil.toLogString(envelope)}.`);
    const upID = envelope.metadata[Header.StreamID]?.values[0];
    const upMeta = upID == null ? void 0 : (
      // Refresh the LRU recency.
      __privateGet(this, _storeByStreamID).get(upID)?.metadata
    );
    const meta = {
      ...upMeta,
      ...__privateMethod(this, _filterHeadersForStore, filterHeadersForStore_fn).call(this, envelope.metadata, envelope.src),
      // When a successor client issues a request, this will be the metadata
      // store lookup ID.
      [Header.StreamID]: Strings.fromPartial({ values: [envelope.streamId] }),
      [Header.Caller]: Strings.fromPartial({ values: [envelope.src] }),
      // At any point in a trace, a client may opt-out. Always propagate the
      // current envelope's trace ID.
      [Header.TraceID]: Strings.fromPartial({ values: [envelope.traceId] })
    };
    if (envelope.request) {
      __privateGet(this, _storeByStreamID).set(envelope.streamId, {
        log: EnvelopeUtil.toLogString(envelope),
        metadata: meta
      });
    } else if (envelope.complete) {
      __privateGet(this, _storeByStreamID).delete(envelope.streamId);
    }
    envelope.metadata = filterHeadersForDestination(
      __privateGet(this, _namespace),
      {
        // Re-provide the original metadata, less hidden headers, with stored
        // metadata taking precedence. The original is necessary for headers
        // allowed to be read but not stored.
        ...filterHeadersForDestination(__privateGet(this, _namespace), envelope.metadata, envelope.src),
        ...meta
      },
      envelope.dst
    );
    return envelope;
  }
};
_storeByStreamID = new WeakMap();
_namespace = new WeakMap();
_onStoreEvictingUserCallback = new WeakMap();
_filterHeadersForStore = new WeakSet();
filterHeadersForStore_fn = function(metadata, source) {
  if (isTrustedLocation(__privateGet(this, _namespace), source))
    return { ...metadata };
  const allowedEntries = Object.entries(metadata).filter(([header]) => !isSystemHeader(header));
  return Object.fromEntries(allowedEntries);
};
_onStoreEvicting = new WeakSet();
onStoreEvicting_fn = function(store, streamID, reason) {
  if (reason === "delete")
    return;
  if (reason === "set")
    return;
  __privateGet(this, _onStoreEvictingUserCallback).call(this, store, streamID, reason);
  Log.warn(
    `Envelope metadata store overflow. Evicting least recently used metadata for stream ID ${streamID}. Last received ${store.log}.`
  );
};

// src/common/envelope/filter/RepeatEnvelopeFilter.ts
var import_lru_cache2 = __toESM(require_lru_cache(), 1);

// src/common/envelope/IDFactory.ts
var IDLength = 36;
function isIDish(str) {
  return str != null && str.length === IDLength;
}

// src/common/envelope/filter/RepeatEnvelopeFilter.ts
var Counter = class {
  constructor() {
    this.count = 0;
  }
  incrAndGet() {
    return ++this.count;
  }
};
var _max, _counters;
var RepeatEnvelopeFilter = class {
  constructor(max) {
    __privateAdd(this, _max, void 0);
    __privateAdd(this, _counters, new import_lru_cache2.default({
      max: 100,
      fetchMethod: async (key, _staleValue) => {
        return __privateGet(this, _counters).get(key) || new Counter();
      }
    }));
    __privateSet(this, _max, max);
  }
  async filter(envelope) {
    if (!isIDish(envelope.id))
      throw Error(`Missing ID on ${EnvelopeUtil.toLogString(envelope)}.`);
    const counter = NonNull(
      await __privateGet(this, _counters).fetch(envelope.id),
      `Missing counter for ${EnvelopeUtil.toLogString(envelope)}.`
    );
    const count = counter.incrAndGet();
    if (count >= __privateGet(this, _max)) {
      throw Error(`Envelope repeated ${count} times: ${EnvelopeUtil.toLogString(envelope)}.`);
    }
    return envelope;
  }
};
_max = new WeakMap();
_counters = new WeakMap();

// src/common/envelope/filter/SequenceEnvelopeFilter.ts
var _filters;
var SequenceEnvelopeFilter = class {
  constructor(filters) {
    __privateAdd(this, _filters, void 0);
    __privateSet(this, _filters, filters);
  }
  async filter(envelope) {
    for (const filter of __privateGet(this, _filters)) {
      envelope = await filter.filter(envelope);
    }
    return envelope;
  }
};
_filters = new WeakMap();

// src/common/actors/SupervisorActor.ts
function DefaultFilters(namespace) {
  const filters = [
    new MetadataEnvelopeFilter(namespace),
    new RepeatEnvelopeFilter(2)
  ];
  return new SequenceEnvelopeFilter(filters);
}
function containsCode(bundle) {
  return bundle.code.length > 0;
}
var _hostname, _runtimeClient, _maximumActors, _actorCount, _lruRoots, _dependencyGraph, _filter, _enforceActorLimit, enforceActorLimit_fn;
var SupervisorActor = class {
  constructor(dispatcher2, filter = DefaultFilters({
    hostname: Hostname.getRoot(NonNull(dispatcher2.hostname))
  })) {
    __privateAdd(this, _enforceActorLimit);
    __privateAdd(this, _hostname, void 0);
    __privateAdd(this, _runtimeClient, void 0);
    __privateAdd(this, _maximumActors, void 0);
    __privateAdd(this, _actorCount, void 0);
    __privateAdd(this, _lruRoots, void 0);
    __privateAdd(this, _dependencyGraph, void 0);
    __privateAdd(this, _filter, void 0);
    __privateSet(this, _maximumActors, 100);
    __privateSet(this, _actorCount, 0);
    __privateSet(this, _lruRoots, /* @__PURE__ */ new Set());
    __privateSet(this, _hostname, NonNull(dispatcher2.hostname));
    __privateSet(this, _dependencyGraph, new DependencyGraph(
      (linkedBundle) => linkedBundle.hostname,
      (linkedBundle) => linkedBundle.uses.filter(containsCode)
    ));
    __privateSet(this, _filter, filter);
    __privateSet(this, _runtimeClient, EnvelopeClientBuilder.build(siblingHostname(RUNTIME_CNAME, dispatcher2), [
      RuntimeActorDefinition
    ]));
    dispatcher2.bind(__privateGet(this, _runtimeClient));
  }
  Filter(envelope, _metadata) {
    if (isDescendantHostname(envelope.src, __privateGet(this, _hostname)))
      throw Error("The supervisor cannot filter envelopes from itself.");
    if (__privateGet(this, _lruRoots).has(envelope.dst)) {
      __privateGet(this, _lruRoots).delete(envelope.dst);
      __privateGet(this, _lruRoots).add(envelope.dst);
    }
    return __privateGet(this, _filter).filter(envelope);
  }
  /**
   * Communicates with the Runtime to unpack a LinkedBundle and spawn Workers
   */
  // RPC
  async Load(bundle, metadata) {
    await Log.verbose(
      `Loading ${bundle.hostname} v${bundle.actor?.version ?? "?.?.?"}.`,
      [SystemLogTag.ScriptLifecycle],
      metadata
    );
    const toLoad = await __privateMethod(this, _enforceActorLimit, enforceActorLimit_fn).call(this, bundle, metadata);
    __privateSet(this, _actorCount, __privateGet(this, _actorCount) + toLoad.size);
    __privateGet(this, _lruRoots).add(bundle.hostname);
    try {
      await Promise.all(
        [...toLoad].map((linkedBundle) => {
          return __privateGet(this, _runtimeClient).NewWorker(linkedBundle, metadata);
        })
      );
    } catch (err) {
      await this.Unload({ force: true, hostname: bundle.hostname }, metadata);
      throw err;
    }
    return Empty.fromPartial({});
  }
  /**
   * Unregisters an actor. This also unloads all actors that have it as a
   * downstream dependency and actors that it depends on if they would be
   * otherwise un-used.
   */
  // RPC
  async Unload(request, metadata) {
    const roots = __privateGet(this, _dependencyGraph).findRoots(request.hostname);
    const toUnload = __privateGet(this, _dependencyGraph).deleteRoots(roots);
    await Promise.all(
      [...toUnload].map((name) => {
        __privateGet(this, _lruRoots).delete(name);
        if (request.force) {
          return __privateGet(this, _runtimeClient).TerminateWorker(
            WorkerQuery.fromPartial({ hostname: name }),
            metadata
          );
        } else {
          return Promise.resolve();
        }
      })
    );
    __privateSet(this, _actorCount, __privateGet(this, _actorCount) - toUnload.size);
    return Empty.fromPartial({});
  }
};
_hostname = new WeakMap();
_runtimeClient = new WeakMap();
_maximumActors = new WeakMap();
_actorCount = new WeakMap();
_lruRoots = new WeakMap();
_dependencyGraph = new WeakMap();
_filter = new WeakMap();
_enforceActorLimit = new WeakSet();
enforceActorLimit_fn = async function(bundle, metadata) {
  const actorsInBundle = getUniqueNodes(
    bundle,
    (bundle2) => bundle2.hostname,
    (bundle2) => bundle2.uses.filter(containsCode)
  );
  if (actorsInBundle.size > __privateGet(this, _maximumActors)) {
    throw new Error(`${bundle.hostname} has more actors than the runtime supports`);
  }
  const toLoad = __privateGet(this, _dependencyGraph).addNode(bundle, void 0);
  while (__privateGet(this, _dependencyGraph).size() > __privateGet(this, _maximumActors)) {
    const toUnload = __privateGet(this, _lruRoots).keys().next().value;
    await this.Unload({ hostname: toUnload, force: true }, metadata);
  }
  return toLoad;
};

// src/common/envelope/dispatcher/CentralDispatcher.ts
var import_lru_cache3 = __toESM(require_lru_cache(), 1);
var _clients, _recipientsByHostname, _supervisor, _streamsByID, _bind2, bind_fn, _dispatchFiltered, dispatchFiltered_fn, _dispatchFilteredRequest, dispatchFilteredRequest_fn, _dispatchFilteredResponse, dispatchFilteredResponse_fn, _dispatchError404, dispatchError404_fn, _evictStreamIfComplete, evictStreamIfComplete_fn, _getSupervisorHostname, getSupervisorHostname_fn, _isFiltered, isFiltered_fn, _isLocalClient, isLocalClient_fn, _isSourceDispatcherOrSupervisor, isSourceDispatcherOrSupervisor_fn, _isWorker, isWorker_fn, _logEnvelope, logEnvelope_fn, _newClientCloseRequestError499, newClientCloseRequestError499_fn, _newFilterError500, newFilterError500_fn, _newStreamEvictionError503, newStreamEvictionError503_fn, _newServiceUnavailableError503, newServiceUnavailableError503_fn, _onStreamEvicting, onStreamEvicting_fn, _postAsync, postAsync_fn, _unbind, unbind_fn;
var CentralDispatcher = class {
  constructor(hostname) {
    __privateAdd(this, _bind2);
    __privateAdd(this, _dispatchFiltered);
    __privateAdd(this, _dispatchFilteredRequest);
    __privateAdd(this, _dispatchFilteredResponse);
    __privateAdd(this, _dispatchError404);
    __privateAdd(this, _evictStreamIfComplete);
    __privateAdd(this, _getSupervisorHostname);
    __privateAdd(this, _isFiltered);
    __privateAdd(this, _isLocalClient);
    __privateAdd(this, _isSourceDispatcherOrSupervisor);
    /** True if executing within a worker. */
    __privateAdd(this, _isWorker);
    __privateAdd(this, _logEnvelope);
    __privateAdd(this, _newClientCloseRequestError499);
    __privateAdd(this, _newFilterError500);
    __privateAdd(this, _newStreamEvictionError503);
    __privateAdd(this, _newServiceUnavailableError503);
    /**
     * Called when a stream is about to be evicted. Do not modify the LRU.
     */
    __privateAdd(this, _onStreamEvicting);
    __privateAdd(this, _postAsync);
    __privateAdd(this, _unbind);
    /**
     * Clients local to the dispatcher. Local clients have the same hostname as
     * the dispatcher and do not appear in #recipientsByHostname which does not
     * permit duplicates.
     */
    __privateAdd(this, _clients, /* @__PURE__ */ new Set());
    /**
     * All known recipients by hostname excluding local clients. Local clients
     * have the same hostname as the dispatcher. The primary worker server also
     * has the same hostname as the dispatcher (eg, supervisor.system.local) but
     * the runtime actor does not (eg, runtime.system.local).
     */
    __privateAdd(this, _recipientsByHostname, {});
    /** Nullish when in a worker, nonnullish in runtime. */
    __privateAdd(this, _supervisor, void 0);
    /**
     * *Response* recipients by stream ID. Never route a request by stream ID.
     * Requests should always be routed by hostname.
     *
     * The recipients may be local clients or external recipients.
     *
     * to-do: never evict local clients.
     */
    __privateAdd(this, _streamsByID, void 0);
    this.hostname = hostname;
    __privateSet(this, _streamsByID, new import_lru_cache3.default({ max: 8192, dispose: __privateMethod(this, _onStreamEvicting, onStreamEvicting_fn).bind(this) }));
  }
  /**
   * All known recipients by hostname excluding local clients. Only meant to be
   * used in a debug mode REPL.
   */
  get debugRecipientsByHostname() {
    return DEBUG_CONFIG.addDebugUtilsToEnv ? __privateGet(this, _recipientsByHostname) : void 0;
  }
  /** Local clients. Only meant to be used in a debug mode REPL. */
  get debugClients() {
    return DEBUG_CONFIG.addDebugUtilsToEnv ? __privateGet(this, _clients) : void 0;
  }
  onBind(recipient) {
    __privateMethod(this, _bind2, bind_fn).call(this, recipient);
  }
  onUnbind(other) {
    if (other.hostname == null) {
      throw Error("Cannot unbind from unbound dispatcher.");
    }
    __privateMethod(this, _unbind, unbind_fn).call(this, other);
  }
  bind(recipient) {
    if (!__privateMethod(this, _isLocalClient, isLocalClient_fn).call(this, recipient) && this.isBound(recipient)) {
      throw Error(`Recipient at ${recipient.hostname} already bound.`);
    }
    recipient.onBind(this);
    __privateMethod(this, _bind2, bind_fn).call(this, recipient);
  }
  /** For runtimes only, bind a supervisor client. */
  bindSupervisor(supervisor2) {
    __privateSet(this, _supervisor, supervisor2);
  }
  isBound(recipient) {
    return __privateGet(this, _clients).has(recipient) || recipient.hostname != null && recipient.hostname in __privateGet(this, _recipientsByHostname);
  }
  unbind(recipient) {
    if (!this.isBound(recipient)) {
      return;
    }
    __privateMethod(this, _unbind, unbind_fn).call(this, recipient);
    recipient.onUnbind(this);
  }
  async release(recipient) {
    this.unbind(recipient);
    await recipient.dispose();
  }
  post(caller, envelope) {
    if (!isIDish(envelope.id)) {
      throw Error(`Missing or invalid ID in envelope ${EnvelopeUtil.toLogString(envelope)}.`);
    }
    __privateMethod(this, _postAsync, postAsync_fn).call(this, caller, envelope);
  }
  async dispose() {
    for (const recipient of __privateGet(this, _clients)) {
      await this.release(recipient);
    }
    for (const recipient of Object.values(__privateGet(this, _recipientsByHostname))) {
      await this.release(recipient);
    }
    __privateSet(this, _supervisor, void 0);
  }
};
_clients = new WeakMap();
_recipientsByHostname = new WeakMap();
_supervisor = new WeakMap();
_streamsByID = new WeakMap();
_bind2 = new WeakSet();
bind_fn = function(recipient) {
  assertNonNull(recipient.hostname, "Recipient missing hostname.");
  if (__privateMethod(this, _isLocalClient, isLocalClient_fn).call(this, recipient)) {
    __privateGet(this, _clients).add(recipient);
    return;
  }
  if (recipient.hostname in __privateGet(this, _recipientsByHostname) && __privateGet(this, _recipientsByHostname)[recipient.hostname] !== recipient) {
    throw Error(`Server hostname ${recipient.hostname} already bound.`);
  }
  __privateGet(this, _recipientsByHostname)[recipient.hostname] = recipient;
};
_dispatchFiltered = new WeakSet();
dispatchFiltered_fn = function(caller, envelope) {
  __privateMethod(this, _logEnvelope, logEnvelope_fn).call(this, envelope);
  if (envelope.request) {
    __privateMethod(this, _dispatchFilteredRequest, dispatchFilteredRequest_fn).call(this, caller, envelope);
  } else {
    __privateMethod(this, _dispatchFilteredResponse, dispatchFilteredResponse_fn).call(this, caller, envelope);
  }
  __privateMethod(this, _evictStreamIfComplete, evictStreamIfComplete_fn).call(this, envelope);
};
_dispatchFilteredRequest = new WeakSet();
dispatchFilteredRequest_fn = function(caller, envelope) {
  if (!envelope.request) {
    throw Error("Expected request envelope.");
  }
  if (!this.isBound(caller)) {
    throw Error(`Caller ${caller.hostname} must be bound to dispatcher.`);
  }
  const stream = __privateGet(this, _streamsByID).get(envelope.streamId);
  if (stream == null) {
    __privateGet(this, _streamsByID).set(envelope.streamId, { requester: caller, request: envelope });
  } else if (stream.requester !== caller) {
    throw Error(
      `Client recipient ${envelope.src} with request to ${envelope.dst} changed on open stream ${envelope.streamId}.`
    );
  }
  let dst = envelope.dst;
  let searching = true;
  while (searching) {
    const recipient = __privateGet(this, _recipientsByHostname)[dst];
    if (recipient != null) {
      try {
        recipient.post(caller, envelope);
      } catch (err) {
        Log.error(
          `Failed to post request ${EnvelopeUtil.toLogString(
            envelope
          )}: ${StringUtil.caughtToString(err)}`
        );
        if (!isDispatcherErrorEnvelope(envelope)) {
          __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, __privateMethod(this, _newServiceUnavailableError503, newServiceUnavailableError503_fn).call(this, envelope, err));
        }
      }
      return;
    }
    searching = dst.length > 0;
    dst = parentHostname(dst);
  }
  if (!isDispatcherErrorEnvelope(envelope)) {
    __privateMethod(this, _dispatchError404, dispatchError404_fn).call(this, envelope);
  }
};
_dispatchFilteredResponse = new WeakSet();
dispatchFilteredResponse_fn = function(caller, envelope) {
  if (envelope.request) {
    throw Error("Expected response envelope.");
  }
  const stream = __privateGet(this, _streamsByID).get(envelope.streamId);
  if (stream != null) {
    try {
      stream.requester.post(caller, envelope);
    } catch (err) {
      Log.error(
        `Failed to post response ${EnvelopeUtil.toLogString(
          envelope
        )}: ${StringUtil.caughtToString(err)}`
      );
      if (!isDispatcherErrorEnvelope(envelope)) {
        if (err instanceof Error) {
          __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, __privateMethod(this, _newClientCloseRequestError499, newClientCloseRequestError499_fn).call(this, envelope, err));
        } else {
          __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, __privateMethod(this, _newClientCloseRequestError499, newClientCloseRequestError499_fn).call(this, envelope, new Error("unknown error")));
        }
      }
    }
  } else if (!isDispatcherErrorEnvelope(envelope)) {
    __privateMethod(this, _dispatchError404, dispatchError404_fn).call(this, envelope);
  }
};
_dispatchError404 = new WeakSet();
dispatchError404_fn = function(envelope) {
  const recipients = Object.keys(__privateGet(this, _recipientsByHostname)).sort((lhs, rhs) => lhs.localeCompare(rhs)).join(", ");
  Log.info(
    `Posting 404: ${this.hostname} cannot post envelope from ${envelope.src} for ${envelope.dst} with stream ID ${envelope.streamId}; recipients are ${recipients}.`
  );
  const destination = envelope.src;
  __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: `404 ${envelope.dst} not found.`,
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    request: false,
    src: envelope.dst,
    streamId: envelope.streamId,
    success: false,
    traceId: envelope.traceId
  }));
};
_evictStreamIfComplete = new WeakSet();
evictStreamIfComplete_fn = function(envelope) {
  if (envelope.complete && !envelope.request) {
    __privateGet(this, _streamsByID).delete(envelope.streamId);
  }
};
_getSupervisorHostname = new WeakSet();
getSupervisorHostname_fn = function() {
  return resolveSystemHostname(SUPERVISOR_CNAME, { hostname: Hostname.getRoot(this.hostname) });
};
_isFiltered = new WeakSet();
isFiltered_fn = function(caller, envelope) {
  return __privateMethod(this, _isWorker, isWorker_fn).call(this) || __privateMethod(this, _isSourceDispatcherOrSupervisor, isSourceDispatcherOrSupervisor_fn).call(this, caller, envelope);
};
_isLocalClient = new WeakSet();
isLocalClient_fn = function(recipient) {
  return recipient.type === "client";
};
_isSourceDispatcherOrSupervisor = new WeakSet();
isSourceDispatcherOrSupervisor_fn = function(caller, envelope) {
  return (
    // From CentralDispatcher to the supervisor.
    caller === __privateGet(this, _supervisor) || // Already filtered by or from the supervisor.
    envelope.src === __privateMethod(this, _getSupervisorHostname, getSupervisorHostname_fn).call(this)
  );
};
_isWorker = new WeakSet();
isWorker_fn = function() {
  return __privateGet(this, _supervisor) == null;
};
_logEnvelope = new WeakSet();
logEnvelope_fn = function(envelope) {
  const isCommonRuntime = !isWorker() && (isPlatformWeb() || isPlatformNode());
  const filterEnvelope = envelope.method === envelopeMethod(SupervisorDefinition, "filter");
  if (DEBUG_CONFIG.logAllEnvelopes && // Only log from the common runtime's global dispatcher and native
  // workers. Native runtimes _only_ execute TypeScript in workers. There's
  // no common runtime and the supervisor pretty much only filters so each
  // user worker must log itself.
  (isCommonRuntime || isNativeWorker()) && // Remove filterEnvelope to log envelope filter request/responses from the
  // runtime to the supervisor and back. This is super noisy and usually
  // interferes with debugging.
  !filterEnvelope) {
    Log.envelope(envelope);
  }
};
_newClientCloseRequestError499 = new WeakSet();
newClientCloseRequestError499_fn = function(envelope, err) {
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: err.message,
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    src: envelope.dst,
    streamId: envelope.streamId,
    traceId: envelope.traceId
  });
};
_newFilterError500 = new WeakSet();
newFilterError500_fn = function(envelope, error) {
  Log.error(StringUtil.caughtToString(error));
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: `500 filter error: ${error}`,
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    request: false,
    src: envelope.dst,
    streamId: envelope.streamId,
    success: false,
    traceId: envelope.traceId
  });
};
_newStreamEvictionError503 = new WeakSet();
newStreamEvictionError503_fn = function(envelope) {
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: "503 stream closed by dispatcher due to envelope stream overflow.",
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    src: envelope.dst,
    streamId: envelope.streamId,
    traceId: envelope.traceId
  });
};
_newServiceUnavailableError503 = new WeakSet();
newServiceUnavailableError503_fn = function(envelope, reason) {
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: `503 service unavailable: ${reason.message}`,
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    src: envelope.dst,
    streamId: envelope.streamId,
    traceId: envelope.traceId
  });
};
_onStreamEvicting = new WeakSet();
onStreamEvicting_fn = function(stream, streamID, reason) {
  if (reason === "delete") {
    return;
  }
  if (__privateGet(this, _clients).has(stream.requester)) {
    Log.error(
      `Envelope stream overflow. Evicting least recently used stream ${streamID} to local client at ${stream.requester.hostname}.`
    );
  } else {
    Log.warn(
      `Envelope stream overflow. Evicting least recently used stream ${streamID} associated with recipient at ${stream.requester.hostname}.`
    );
  }
  const envelope = __privateMethod(this, _newStreamEvictionError503, newStreamEvictionError503_fn).call(this, stream.request);
  __privateMethod(this, _logEnvelope, logEnvelope_fn).call(this, envelope);
  try {
    stream.requester.post(this, envelope);
  } catch (err) {
    Log.warn(
      `Failed to post stream eviction error ${EnvelopeUtil.toLogString(
        envelope
      )}. Giving up: ${StringUtil.caughtToString(err)}`
    );
  }
};
_postAsync = new WeakSet();
postAsync_fn = async function(caller, envelope) {
  if (DEBUG_CONFIG.assertEnvelopesPostable) {
    assertEnvelopePostable(envelope);
  }
  if (!__privateMethod(this, _isFiltered, isFiltered_fn).call(this, caller, envelope)) {
    assertNonNull(__privateGet(this, _supervisor), "Expected the supervisor to be set.");
    try {
      envelope = await __privateGet(this, _supervisor).Filter(envelope);
    } catch (err) {
      if (isDispatcherErrorEnvelope(envelope)) {
        Log.info(
          `A dispatch error occurred but the attempted envelope already contained a dispatcher error. Giving up: ${StringUtil.caughtToString(err)}`
        );
        __privateMethod(this, _evictStreamIfComplete, evictStreamIfComplete_fn).call(this, envelope);
        return;
      }
      Log.error(
        `Failed to filter envelope ${EnvelopeUtil.toLogString(
          envelope
        )}: ${StringUtil.caughtToString(err)}`
      );
      envelope = __privateMethod(this, _newFilterError500, newFilterError500_fn).call(this, envelope, err);
      __privateMethod(this, _logEnvelope, logEnvelope_fn).call(this, envelope);
      try {
        caller.post(caller, envelope);
      } catch (err2) {
        Log.error(
          `Failed to post envelope filter error ${EnvelopeUtil.toLogString(
            envelope
          )}. Giving up: ${StringUtil.caughtToString(err2)}.`
        );
      }
      __privateMethod(this, _evictStreamIfComplete, evictStreamIfComplete_fn).call(this, envelope);
      return;
    }
  }
  __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, caller, envelope);
};
_unbind = new WeakSet();
unbind_fn = function(recipient) {
  if (!this.isBound(recipient)) {
    return;
  }
  assertNonNull(recipient.hostname, "Recipient missing hostname.");
  if (__privateMethod(this, _isLocalClient, isLocalClient_fn).call(this, recipient)) {
    __privateGet(this, _clients).delete(recipient);
  } else {
    delete __privateGet(this, _recipientsByHostname)[recipient.hostname];
  }
};
CentralDispatcher.UNRESOLVED_HOSTNAMES = "";
function isDispatcherErrorEnvelope(envelope) {
  return envelope.complete === true && envelope.request === false && envelope.success === false;
}

// src/common/envelope/PortEnvelopeRecipient.ts
var _port, _dispatcher2;
var PortEnvelopeRecipient = class {
  constructor(hostname, port) {
    __privateAdd(this, _port, void 0);
    __privateAdd(this, _dispatcher2, void 0);
    this.hostname = hostname;
    __privateSet(this, _port, port);
  }
  post(_caller, envelope) {
    __privateGet(this, _port).postMessage(envelope);
  }
  dispose() {
    __privateGet(this, _port).terminate?.();
    return Promise.resolve();
  }
  onBind(dispatcher2) {
    __privateSet(this, _dispatcher2, dispatcher2);
    __privateGet(this, _port).onmessage = (event) => this.onMessage(event);
  }
  onUnbind(_dispatcher4) {
    __privateSet(this, _dispatcher2, void 0);
    __privateGet(this, _port).onmessage = null;
  }
  onMessage(event) {
    if (__privateGet(this, _dispatcher2) == null)
      throw Error("No dispatcher bound.");
    const envelope = event.data;
    if (!isDescendantHostname(envelope.src, this.hostname) && this.hostname !== CentralDispatcher.UNRESOLVED_HOSTNAMES) {
      throw new Error(`invalid src: ${envelope.src}, expected ${this.hostname}`);
    }
    __privateGet(this, _dispatcher2).post(this, envelope);
  }
};
_port = new WeakMap();
_dispatcher2 = new WeakMap();

// src/common/envelope/dispatcher/WorkerDispatcher.ts
var WorkerDispatcher = class extends CentralDispatcher {
  bindToWorkerPort(port) {
    this.bind(new PortEnvelopeRecipient(CentralDispatcher.UNRESOLVED_HOSTNAMES, port));
  }
  bindSupervisor() {
    throw Error("Workers should not attempt to filter on the supervisor.");
  }
};

// src/common/envelope/EnvelopeServerBuilder.ts
var EnvelopeServerBuilder = class {
  static build(name, provides, actor, logger2 = new VoidSystemLogger(), idFactory = v4_default) {
    return new EnvelopeServer(name, provides, actor, idFactory, logger2);
  }
};
var _dispatcher3, _requestStreamsById, _responseStreamsById, _actor, _id, _idFactory2, _methodsByName, _logger2, _handleAsync, handleAsync_fn, _handleSource, handleSource_fn, _handleSink, handleSink_fn, _handlePipe, handlePipe_fn, _emitResponseStreamAsEnvelopes, emitResponseStreamAsEnvelopes_fn, _postDispatcher2, postDispatcher_fn2;
var EnvelopeServer = class {
  constructor(hostname, provides, actor, idFactory, logger2) {
    __privateAdd(this, _handleAsync);
    /** You could implement `tail foo.text` with this. */
    __privateAdd(this, _handleSource);
    /** Accepts many request messages, returns a single response. i.e `tail foo > sink`. */
    __privateAdd(this, _handleSink);
    /** `echo foo|tail`. this is the pipe between echo and tail. */
    __privateAdd(this, _handlePipe);
    __privateAdd(this, _emitResponseStreamAsEnvelopes);
    __privateAdd(this, _postDispatcher2);
    __privateAdd(this, _dispatcher3, void 0);
    __privateAdd(this, _requestStreamsById, {});
    __privateAdd(this, _responseStreamsById, {});
    __privateAdd(this, _actor, void 0);
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _idFactory2, void 0);
    __privateAdd(this, _methodsByName, /* @__PURE__ */ Object.create(null));
    __privateAdd(this, _logger2, void 0);
    if (actor == null)
      throw Error(
        "EnvelopeServer requires a nonnullish actor to forward requests to and await responses from."
      );
    this.hostname = hostname;
    __privateSet(this, _actor, actor);
    __privateSet(this, _id, idFactory());
    __privateSet(this, _idFactory2, idFactory);
    __privateSet(this, _logger2, logger2);
    for (const definition of provides) {
      for (const method of Object.values(definition.methods)) {
        __privateGet(this, _methodsByName)[envelopeMethod(definition, method.name)] = method;
      }
    }
  }
  onBind(dispatcher2) {
    if (!dispatcher2.hostname || !isDescendantHostname(this.hostname, dispatcher2.hostname)) {
      throw new Error(
        `Server's hostname (${this.hostname}) must match or be under *.[dispatcher-hostname] (${dispatcher2.hostname}).`
      );
    }
    __privateSet(this, _dispatcher3, dispatcher2);
  }
  onUnbind(_dispatcher4) {
    __privateSet(this, _dispatcher3, void 0);
  }
  // Should only be called by the dispatcher
  post(_caller, envelope) {
    const definition = __privateGet(this, _methodsByName)[envelope.method];
    if (!definition) {
      throw new Error(`Service definition does not provide method "${envelope.method}".`);
    }
    const method = __privateGet(this, _actor)[definition.name]?.bind(__privateGet(this, _actor));
    if (method == null)
      throw Error(`Service does not implement "${definition.name}" method.`);
    if (definition.requestStream && definition.responseStream) {
      __privateMethod(this, _handlePipe, handlePipe_fn).call(this, method, envelope, definition);
    } else if (definition.requestStream && !definition.responseStream) {
      __privateMethod(this, _handleSink, handleSink_fn).call(this, method, envelope, definition);
    } else if (!definition.requestStream && definition.responseStream) {
      __privateMethod(this, _handleSource, handleSource_fn).call(this, method, envelope, definition);
    } else if (!definition.requestStream && !definition.responseStream) {
      __privateMethod(this, _handleAsync, handleAsync_fn).call(this, method, envelope, definition);
    } else {
      throw new Error(
        `Unsupported "${definition.name}" service method request / response definition.`
      );
    }
  }
  // todo: should this call this.#actor.dispose?.();
  async dispose() {
    for (const streamId of Object.keys(__privateGet(this, _responseStreamsById))) {
      __privateGet(this, _responseStreamsById)[streamId].unsubscribe();
    }
    for (const streamId of Object.keys(__privateGet(this, _requestStreamsById))) {
      __privateGet(this, _requestStreamsById)[streamId].error(new Error("EnvelopeServer is going away"));
    }
  }
};
_dispatcher3 = new WeakMap();
_requestStreamsById = new WeakMap();
_responseStreamsById = new WeakMap();
_actor = new WeakMap();
_id = new WeakMap();
_idFactory2 = new WeakMap();
_methodsByName = new WeakMap();
_logger2 = new WeakMap();
_handleAsync = new WeakSet();
handleAsync_fn = async function(method, req, definition) {
  const envelope = {
    complete: true,
    dst: req.src,
    metadata: req.metadata,
    method: req.method,
    request: false,
    src: req.dst,
    streamId: req.streamId,
    traceId: req.traceId
  };
  const msg = requestMessageFromBinary(req, definition);
  const promisedMessage = method(msg, req.metadata);
  assertPromise(promisedMessage);
  try {
    const message = await promisedMessage;
    __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
      ...envelope,
      message: responseMessageToBinary(message, definition),
      success: true
    });
  } catch (err) {
    let errMsg = err;
    if (err instanceof Error) {
      errMsg = err.message;
    }
    await __privateGet(this, _logger2).messageError(req, err);
    __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, { ...envelope, message: errMsg });
  }
};
_handleSource = new WeakSet();
handleSource_fn = function(method, req, definition) {
  if (!req.request || !req.success) {
    Log.warn(
      `Received response (${!req.request}) or erroneous envelope (${!req.success}). Closing stream ${req.streamId}.`
    );
    __privateGet(this, _responseStreamsById)[req.streamId]?.unsubscribe();
    delete __privateGet(this, _responseStreamsById)[req.streamId];
    return;
  }
  const responseStream = method(requestMessageFromBinary(req, definition), req.metadata);
  assertObservable(responseStream);
  __privateMethod(this, _emitResponseStreamAsEnvelopes, emitResponseStreamAsEnvelopes_fn).call(this, responseStream, req, definition);
};
_handleSink = new WeakSet();
handleSink_fn = async function(method, req, definition) {
  let requestStream = __privateGet(this, _requestStreamsById)[req.streamId];
  if (requestStream) {
    req.message = requestMessageFromBinary(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
  } else {
    __privateGet(this, _requestStreamsById)[req.streamId] = requestStream = new ReplaySubject(1);
    req.message = requestMessageFromBinary(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
    const envelope = {
      complete: true,
      dst: req.src,
      metadata: req.metadata,
      method: req.method,
      request: false,
      src: req.dst,
      streamId: req.streamId,
      traceId: req.traceId
    };
    const promisedMessage = method(requestStream, req.metadata);
    assertPromise(promisedMessage);
    try {
      const message = await promisedMessage;
      __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
        ...envelope,
        message: responseMessageToBinary(message, definition),
        success: true
      });
    } catch (err) {
      let errMsg = err;
      if (err instanceof Error) {
        errMsg = err.message;
      }
      __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
        ...envelope,
        message: errMsg,
        success: false
      });
    }
  }
};
_handlePipe = new WeakSet();
handlePipe_fn = function(method, req, definition) {
  let requestStream = __privateGet(this, _requestStreamsById)[req.streamId];
  if (requestStream) {
    req.message = requestMessageFromBinary(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
  } else {
    __privateGet(this, _requestStreamsById)[req.streamId] = requestStream = new ReplaySubject(1);
    req.message = requestMessageFromBinary(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
    const responseStream = method(requestStream, req.metadata);
    assertObservable(responseStream);
    __privateMethod(this, _emitResponseStreamAsEnvelopes, emitResponseStreamAsEnvelopes_fn).call(this, responseStream, req, definition);
  }
};
_emitResponseStreamAsEnvelopes = new WeakSet();
emitResponseStreamAsEnvelopes_fn = function(stream, req, definition) {
  const envelope = {
    dst: req.src,
    metadata: req.metadata,
    method: req.method,
    request: false,
    src: req.dst,
    streamId: req.streamId,
    traceId: req.traceId
  };
  if (__privateGet(this, _responseStreamsById)[req.streamId]) {
    console.warn("Already had a stream id for", req.streamId);
  }
  __privateGet(this, _responseStreamsById)[req.streamId] = stream.pipe(
    // Filter errors with something supporting async, then rethrow.
    catchError(async (err) => {
      await __privateGet(this, _logger2).messageError(req, err);
      throw err;
    })
  ).subscribe({
    next: (message) => {
      __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
        ...envelope,
        complete: false,
        message: responseMessageToBinary(message, definition),
        success: true
      });
    },
    error: (err) => __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
      ...envelope,
      complete: true,
      message: err.message,
      success: false
    }),
    complete: () => __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
      ...envelope,
      complete: true,
      message: void 0,
      success: true
    })
  });
};
_postDispatcher2 = new WeakSet();
postDispatcher_fn2 = function(partialEnvelope) {
  if (!__privateGet(this, _dispatcher3))
    throw Error("No dispatcher bound to server: " + this.hostname + " - " + __privateGet(this, _id));
  const envelope = Envelope.fromPartial({ ...partialEnvelope, id: __privateGet(this, _idFactory2).call(this) });
  __privateGet(this, _dispatcher3).post(this, envelope);
};
function assertPromise(val) {
  const keys = ["catch", "then"];
  if (val == null || typeof val !== "object" || keys.some((key) => !(key in val)))
    throw Error("Expected Promise.");
}
function assertObservable(val) {
  if (!isObservable(val))
    throw Error("Expected Observable.");
}

// src/workers/system/Supervisor.ts
var dispatcher = new WorkerDispatcher(self.name);
dispatcher.bindToWorkerPort(self);
var supervisor = new SupervisorActor(dispatcher);
var server = EnvelopeServerBuilder.build(self.name, [SupervisorDefinition], supervisor);
dispatcher.bind(server);
Log.info(`${self.name} ready.`);
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=worker.supervisor.cjs.map
