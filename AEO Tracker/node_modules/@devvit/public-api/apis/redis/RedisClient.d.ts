import { RedisAPI, Metadata, TransactionId, ZMember, HScanResponse } from '@devvit/protos';
import { RedisClient as RedisClientLike, SetOptions, ZRangeOptions } from '../../types/redis.js';
export interface TxClientLike {
    /**
     * Executes all previously queued commands in a transaction and
     * restores the connection state to normal. https://redis.io/commands/exec/
     */
    exec(): Promise<any[]>;
    /**
     * Marks the start of a transaction block. Subsequent commands will be
     * queued for atomic execution using EXEC. https://redis.io/commands/multi/
     */
    multi(): Promise<void>;
    discard(): Promise<void>;
    watch(...keys: string[]): Promise<TxClientLike>;
    unwatch(): Promise<TxClientLike>;
    get(key: string): Promise<TxClientLike>;
    set(key: string, value: string, options?: SetOptions): Promise<TxClientLike>;
    del(...keys: string[]): Promise<TxClientLike>;
    incrBy(key: string, value: number): Promise<TxClientLike>;
    type(key: string): Promise<TxClientLike>;
    getRange(key: string, start: number, end: number): Promise<TxClientLike>;
    setRange(key: string, offset: number, value: string): Promise<TxClientLike>;
    strlen(key: string): Promise<TxClientLike>;
    mget(keys: string[]): Promise<TxClientLike>;
    mset(keyValues: {
        [key: string]: string;
    }): Promise<TxClientLike>;
    expire(key: string, seconds: number): Promise<TxClientLike>;
    expireTime(key: string): Promise<TxClientLike>;
    zAdd(key: string, ...members: ZMember[]): Promise<TxClientLike>;
    zCard(key: string): Promise<TxClientLike>;
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<TxClientLike>;
    zRem(key: string, members: string[]): Promise<TxClientLike>;
    zRemRangeByLex(key: string, min: string, max: string): Promise<TxClientLike>;
    zRemRangeByRank(key: string, start: number, stop: number): Promise<TxClientLike>;
    zRemRangeByScore(key: string, min: number, max: number): Promise<TxClientLike>;
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<TxClientLike>;
    hget(key: string, field: string): Promise<TxClientLike>;
}
export declare class TxClient implements TxClientLike {
    #private;
    constructor(storage: RedisAPI, transactionId: TransactionId, metadata: Metadata);
    get(key: string): Promise<TxClientLike>;
    multi(): Promise<void>;
    set(key: string, value: string, options?: SetOptions): Promise<TxClientLike>;
    del(...keys: string[]): Promise<TxClientLike>;
    type(key: string): Promise<TxClientLike>;
    exec(): Promise<any[]>;
    discard(): Promise<void>;
    watch(...keys: string[]): Promise<TxClientLike>;
    unwatch(): Promise<TxClientLike>;
    getRange(key: string, start: number, end: number): Promise<TxClientLike>;
    setRange(key: string, offset: number, value: string): Promise<TxClientLike>;
    strlen(key: string): Promise<TxClientLike>;
    mget(keys: string[]): Promise<TxClientLike>;
    mset(keyValues: {
        [key: string]: string;
    }): Promise<TxClientLike>;
    incrBy(key: string, value: number): Promise<TxClientLike>;
    expire(key: string, seconds: number): Promise<TxClientLike>;
    expireTime(key: string): Promise<TxClientLike>;
    zAdd(key: string, ...members: ZMember[]): Promise<TxClientLike>;
    zCard(key: string): Promise<TxClientLike>;
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<TxClientLike>;
    zRem(key: string, members: string[]): Promise<TxClientLike>;
    zRemRangeByLex(key: string, min: string, max: string): Promise<TxClientLike>;
    zRemRangeByRank(key: string, start: number, stop: number): Promise<TxClientLike>;
    zRemRangeByScore(key: string, min: number, max: number): Promise<TxClientLike>;
    hget(key: string, field: string): Promise<TxClientLike>;
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<TxClientLike>;
}
/**
 * This is a subset of the overall Redis API.  You should be able to look up https://redis.io/commands
 * for more details on each command.
 *
 * For the moment, we've implemented a lot of the basic string/number commands, sorted sets, and transactions.
 * This is the most powerful subset and the safest.
 */
export declare class RedisClient implements RedisClientLike {
    #private;
    constructor(metadata: Metadata, storage?: RedisAPI | undefined);
    get storage(): RedisAPI;
    watch(...keys: string[]): Promise<TxClientLike>;
    get(key: string): Promise<string | undefined>;
    set(key: string, value: string, options?: SetOptions): Promise<string>;
    del(...keys: string[]): Promise<void>;
    incrBy(key: string, value: number): Promise<number>;
    getRange(key: string, start: number, end: number): Promise<string>;
    setRange(key: string, offset: number, value: string): Promise<number>;
    strlen(key: string): Promise<number>;
    expire(key: string, seconds: number): Promise<void>;
    expireTime(key: string): Promise<number>;
    zAdd(key: string, ...members: ZMember[]): Promise<number>;
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<{
        member: string;
        score: number;
    }[]>;
    zRem(key: string, members: string[]): Promise<number>;
    zRemRangeByLex(key: string, min: string, max: string): Promise<number>;
    zRemRangeByRank(key: string, start: number, stop: number): Promise<number>;
    zRemRangeByScore(key: string, min: number, max: number): Promise<number>;
    zScore(key: string, member: string): Promise<number>;
    mget(keys: string[]): Promise<(string | null)[]>;
    mset(keyValues: {
        [key: string]: string;
    }): Promise<void>;
    zCard(key: string): Promise<number>;
    type(key: string): Promise<string>;
    hget(key: string, field: string): Promise<string | undefined>;
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<number>;
    hgetall(key: string): Promise<Record<string, string> | undefined>;
    hdel(key: string, fields: string[]): Promise<number>;
    hscan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<HScanResponse>;
    hkeys(key: string): Promise<string[]>;
}
//# sourceMappingURL=RedisClient.d.ts.map