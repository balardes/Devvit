import { Hook, } from '../../../types/hooks.js';
export function makeUseIntervalHook(reconciler) {
    function useInterval(callback, requestedDelayMs) {
        const hookIndex = reconciler.currentHookIndex;
        const currentState = reconciler.getCurrentComponentState();
        const previousState = reconciler.getPreviousComponentState();
        // delayMs may only be a minimum of 1000ms
        const delayMs = Math.max(1000, requestedDelayMs);
        let hookState = {
            lastRun: undefined,
            running: false,
            preventCallback: false,
            type: Hook.INTERVAL,
        };
        if (hookIndex in currentState) {
            hookState = currentState[hookIndex];
        }
        else if (hookIndex in previousState) {
            hookState = previousState[hookIndex];
        }
        function start() {
            if (!currentState[hookIndex].running) {
                if (requestedDelayMs < 1000) {
                    console.error(`useInterval delay must be at least 1000ms. Your interval of ${requestedDelayMs}ms was automatically extended.`);
                }
                for (const stateItem of Object.values(currentState)) {
                    if (stateItem?.type === Hook.INTERVAL && stateItem?.running) {
                        throw new Error('Only one useInterval hook may be running at a time');
                    }
                }
                currentState[hookIndex] = {
                    running: true,
                    lastRun: Date.now(),
                    preventCallback: false,
                    type: Hook.INTERVAL,
                };
                reconciler.rerenderIn(delayMs);
            }
        }
        function stop() {
            currentState[hookIndex].running = false;
            currentState[hookIndex].lastRun = undefined;
            currentState[hookIndex].preventCallback = false;
        }
        if (reconciler.isEffectRender && hookState.running) {
            if (!hookState.preventCallback) {
                if (hookState.lastRun === undefined || hookState.lastRun + delayMs < Date.now()) {
                    reconciler.runHook(async () => {
                        const response = callback();
                        if (response && response instanceof Promise) {
                            await response;
                        }
                        hookState.lastRun = Date.now();
                    });
                }
            }
            reconciler.rerenderIn(delayMs);
        }
        hookState.preventCallback = false;
        currentState[hookIndex] = hookState;
        reconciler.currentHookIndex++;
        return {
            start,
            stop,
        };
    }
    return useInterval;
}
