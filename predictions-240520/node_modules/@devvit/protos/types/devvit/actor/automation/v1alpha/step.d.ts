/**
 * #step.ts
 *
 * @packageDocumentation
 */
import _m0 from 'protobufjs/minimal.js';
import { Metadata } from "../../../../../lib/Types.js";
import { Comment } from '../../../reddit/comment.js';
import { Post } from '../../../reddit/post.js';
import { User } from '../../../reddit/user.js';
/** A description of a single Step, to be run in a sequence in an Automation */
export interface StepDescription {
    /** The actor hostname to be invoked for the step. Must be in the format <actor_name>@<version> */
    actor: string;
    /** configuration data that is sent to the step */
    config?: {
        [key: string]: any;
    } | undefined;
}
/** Data from previous steps and config data for the step */
export interface StepInput {
    /** Configuration for the step. The shape of this struct will be dictated by the actor's config */
    config?: {
        [key: string]: any;
    } | undefined;
    /** Custom data that came from the previous step in the automation */
    prev?: {
        [key: string]: any;
    } | undefined;
}
/** Data going into an automation step with a comment */
export interface StepCommentInput {
    /** The step input */
    input?: StepInput | undefined;
    /** The Comment data from the trigger. */
    comment?: Comment | undefined;
}
/** Data going into of an automation step with a post */
export interface StepPostInput {
    /** The step input */
    input?: StepInput | undefined;
    /** The Post data from the trigger. */
    post?: Post | undefined;
}
/** Data going into of an automation step with a user */
export interface StepUserInput {
    /** The step input */
    input?: StepInput | undefined;
    /** The User data from the trigger. */
    user?: User | undefined;
}
/** The result of a step */
export interface StepResult {
    /** The output of the step. This will also be passed to the next step as prev */
    output?: {
        [key: string]: any;
    } | undefined;
    /** Whether the automation should stop or not. If false, continue on to the next step. If true, stop the automation. */
    stop: boolean;
}
/** A report of an individual step execution, to be returned from the AutomationEngine */
export interface StepReport {
    /** The actor that was invoked. Must be in the format <actor_name>@<version> */
    actor: string;
    /** Message provided by actor. If success is false, this could display output from an error, if any. */
    message: string;
    /** How long in milliseconds the step ran. This is a float to represent microseconds as well. */
    duration: number;
    /** Whether the step was a success or failure/error. If true, the next step will be executed. */
    success: boolean;
    /** The result data from the step */
    data?: StepResult | undefined;
}
export declare const StepDescription: {
    $type: "devvit.actor.automation.v1alpha.StepDescription";
    encode(message: StepDescription, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepDescription;
    fromJSON(object: any): StepDescription;
    toJSON(message: StepDescription): unknown;
    create(base?: DeepPartial<StepDescription>): StepDescription;
    fromPartial(object: DeepPartial<StepDescription>): StepDescription;
};
export declare const StepInput: {
    $type: "devvit.actor.automation.v1alpha.StepInput";
    encode(message: StepInput, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepInput;
    fromJSON(object: any): StepInput;
    toJSON(message: StepInput): unknown;
    create(base?: DeepPartial<StepInput>): StepInput;
    fromPartial(object: DeepPartial<StepInput>): StepInput;
};
export declare const StepCommentInput: {
    $type: "devvit.actor.automation.v1alpha.StepCommentInput";
    encode(message: StepCommentInput, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepCommentInput;
    fromJSON(object: any): StepCommentInput;
    toJSON(message: StepCommentInput): unknown;
    create(base?: DeepPartial<StepCommentInput>): StepCommentInput;
    fromPartial(object: DeepPartial<StepCommentInput>): StepCommentInput;
};
export declare const StepPostInput: {
    $type: "devvit.actor.automation.v1alpha.StepPostInput";
    encode(message: StepPostInput, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepPostInput;
    fromJSON(object: any): StepPostInput;
    toJSON(message: StepPostInput): unknown;
    create(base?: DeepPartial<StepPostInput>): StepPostInput;
    fromPartial(object: DeepPartial<StepPostInput>): StepPostInput;
};
export declare const StepUserInput: {
    $type: "devvit.actor.automation.v1alpha.StepUserInput";
    encode(message: StepUserInput, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepUserInput;
    fromJSON(object: any): StepUserInput;
    toJSON(message: StepUserInput): unknown;
    create(base?: DeepPartial<StepUserInput>): StepUserInput;
    fromPartial(object: DeepPartial<StepUserInput>): StepUserInput;
};
export declare const StepResult: {
    $type: "devvit.actor.automation.v1alpha.StepResult";
    encode(message: StepResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepResult;
    fromJSON(object: any): StepResult;
    toJSON(message: StepResult): unknown;
    create(base?: DeepPartial<StepResult>): StepResult;
    fromPartial(object: DeepPartial<StepResult>): StepResult;
};
export declare const StepReport: {
    $type: "devvit.actor.automation.v1alpha.StepReport";
    encode(message: StepReport, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StepReport;
    fromJSON(object: any): StepReport;
    toJSON(message: StepReport): unknown;
    create(base?: DeepPartial<StepReport>): StepReport;
    fromPartial(object: DeepPartial<StepReport>): StepReport;
};
/** Interface for an step that will receive a comment as input and be executed from the AutomationEngine. */
export interface CommentStep {
    Invoke(request: StepCommentInput, metadata?: Metadata): Promise<StepResult>;
}
export declare const CommentStepServiceName = "devvit.actor.automation.v1alpha.CommentStep";
export declare class CommentStepClientImpl implements CommentStep {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Invoke(request: StepCommentInput, metadata?: Metadata): Promise<StepResult>;
}
/** Interface for an step that will receive a comment as input and be executed from the AutomationEngine. */
export type CommentStepDefinition = typeof CommentStepDefinition;
export declare const CommentStepDefinition: {
    readonly name: "CommentStep";
    readonly fullName: "devvit.actor.automation.v1alpha.CommentStep";
    readonly methods: {
        readonly invoke: {
            readonly name: "Invoke";
            readonly requestType: {
                $type: "devvit.actor.automation.v1alpha.StepCommentInput";
                encode(message: StepCommentInput, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): StepCommentInput;
                fromJSON(object: any): StepCommentInput;
                toJSON(message: StepCommentInput): unknown;
                create(base?: DeepPartial<StepCommentInput>): StepCommentInput;
                fromPartial(object: DeepPartial<StepCommentInput>): StepCommentInput;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.StepResult";
                encode(message: StepResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): StepResult;
                fromJSON(object: any): StepResult;
                toJSON(message: StepResult): unknown;
                create(base?: DeepPartial<StepResult>): StepResult;
                fromPartial(object: DeepPartial<StepResult>): StepResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
/** Interface for an step that will receive a post as input and be executed from the AutomationEngine. */
export interface PostStep {
    Invoke(request: StepPostInput, metadata?: Metadata): Promise<StepResult>;
}
export declare const PostStepServiceName = "devvit.actor.automation.v1alpha.PostStep";
export declare class PostStepClientImpl implements PostStep {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Invoke(request: StepPostInput, metadata?: Metadata): Promise<StepResult>;
}
/** Interface for an step that will receive a post as input and be executed from the AutomationEngine. */
export type PostStepDefinition = typeof PostStepDefinition;
export declare const PostStepDefinition: {
    readonly name: "PostStep";
    readonly fullName: "devvit.actor.automation.v1alpha.PostStep";
    readonly methods: {
        readonly invoke: {
            readonly name: "Invoke";
            readonly requestType: {
                $type: "devvit.actor.automation.v1alpha.StepPostInput";
                encode(message: StepPostInput, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): StepPostInput;
                fromJSON(object: any): StepPostInput;
                toJSON(message: StepPostInput): unknown;
                create(base?: DeepPartial<StepPostInput>): StepPostInput;
                fromPartial(object: DeepPartial<StepPostInput>): StepPostInput;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.StepResult";
                encode(message: StepResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): StepResult;
                fromJSON(object: any): StepResult;
                toJSON(message: StepResult): unknown;
                create(base?: DeepPartial<StepResult>): StepResult;
                fromPartial(object: DeepPartial<StepResult>): StepResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
/** Interface for an step that will receive a user as input and be executed from the AutomationEngine. */
export interface UserStep {
    Invoke(request: StepUserInput, metadata?: Metadata): Promise<StepResult>;
}
export declare const UserStepServiceName = "devvit.actor.automation.v1alpha.UserStep";
export declare class UserStepClientImpl implements UserStep {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Invoke(request: StepUserInput, metadata?: Metadata): Promise<StepResult>;
}
/** Interface for an step that will receive a user as input and be executed from the AutomationEngine. */
export type UserStepDefinition = typeof UserStepDefinition;
export declare const UserStepDefinition: {
    readonly name: "UserStep";
    readonly fullName: "devvit.actor.automation.v1alpha.UserStep";
    readonly methods: {
        readonly invoke: {
            readonly name: "Invoke";
            readonly requestType: {
                $type: "devvit.actor.automation.v1alpha.StepUserInput";
                encode(message: StepUserInput, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): StepUserInput;
                fromJSON(object: any): StepUserInput;
                toJSON(message: StepUserInput): unknown;
                create(base?: DeepPartial<StepUserInput>): StepUserInput;
                fromPartial(object: DeepPartial<StepUserInput>): StepUserInput;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.StepResult";
                encode(message: StepResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): StepResult;
                fromJSON(object: any): StepResult;
                toJSON(message: StepResult): unknown;
                create(base?: DeepPartial<StepResult>): StepResult;
                fromPartial(object: DeepPartial<StepResult>): StepResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
interface Rpc {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=step.d.ts.map